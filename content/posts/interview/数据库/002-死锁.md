---
title: 数据库死锁以及排查
date: 2025-03-05 10:56:19
categories:
 - 面试
tags:
 - 面试
---

## 1. 导致死锁的原因

在 MySQL（尤其是 InnoDB 存储引擎）里，常见的死锁往往与行锁（Row Lock）、间隙锁（Gap Lock）、Next-Key Lock 等锁机制的细节紧密相关。要理解为什么会出现死锁，需要先明白 InnoDB 是如何在事务中为数据上锁的，以及不同类型的锁是如何导致冲突的。

- 行锁（Row Lock）：对索引记录本身加的锁（Record Lock）

- 间隙锁（Gap Lock）：对索引记录之间的间隙加的锁，用于防止幻读（Phantom Read）

- Next-Key Lock：它实际上是“记录锁 + 间隙锁”的组合锁，会锁住“当前索引记录”以及紧邻的一段间隙

MySQL InnoDB 的默认隔离级别是 **REPEATABLE READ**。在该隔离级别下，对索引进行范围查询时，为了避免幻读，InnoDB 通常会通过 Next-Key Lock 把记录本身和相邻间隙一起锁定。正是因为这种锁定方式，当多事务并发执行时，如果它们的锁定范围出现交叠或顺序不一致，就比较容易引发死锁。

### 1.1. 更新操作顺序不一致 普通行x锁

这是最直观的死锁场景之一, 也是很多人最先想到的场景, 本质原因是两个事务以不同的顺序加锁, 从而彼此等待。先来举一个简单的例子（无 Gap Lock 干扰）, 只用普通行x锁。

**场景:** 事务 A 先更新 `id=1` 的记录，再更新 `id=2` 的记录；事务 B 先更新 `id=2` 的记录，再更新 `id=1` 的记录。

如果两个事务并行执行，就可能出现这样的顺序：

1. 事务 A： `UPDATE t_user SET balance = balance - 10 WHERE id = 1;` 成功锁住 `id=1` 行
2. 事务 B： `UPDATE t_user SET balance = balance - 20 WHERE id = 2;` 成功锁住 `id=2` 行
3. 事务 A： `UPDATE t_user SET balance = balance + 10 WHERE id = 2;` 要锁 `id=2`，但是这把锁被事务 B 占用，需要等待
4. 事务 B： `UPDATE t_user SET balance = balance + 20 WHERE id = 1;` 要锁 `id=1`，但是这把锁被事务 A 占用，需要等待

此时 A 等 B 释放锁，B 等 A 释放锁，形成死锁, 由于 InnoDB 检测到死锁，会自动回滚其中一个事务, 这种多发生在批量更新的情况, 可以标准化更新顺序，例如按 id 升序更新：

```sql
-- 事务 A 和 B 都按 order_id 升序更新
UPDATE orders SET status = 'xxx' WHERE order_id IN (1, 2) ORDER BY order_id;
```

### 1.2. 间隙锁导致的死锁

下面这个场景更具代表性，也更体现出 MySQL 的“间隙锁”和“Next-Key Lock”如何导致死锁。很多开发者在进行范围查询或插入时，会因为不理解 Gap Lock 的触发条件而踩坑:

```sql
CREATE TABLE products (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50),
    price DECIMAL(10, 2),
    UNIQUE KEY (price)  -- 为了便于演示间隙锁
);
```

假设现在我们的表里有四条记录, price 分别是 1.00, 2.50, 3.00, 4.00, 

假设有两个事务，它们都使用了范围查询，并且更新了满足条件的记录。由于 MySQL 默认隔离级别是 REPEATABLE READ，所以**当前读**会触发 Next-Key Lock，导致锁住记录本身以及相邻的“间隙”

- T1 执行 `SELECT * FROM products WHERE price BETWEEN 2.00 AND 3.00 FOR UPDATE;`
  这是一个**当前读**（FOR UPDATE），会加锁, 
- 锁定范围：
  - price = 2.50：Record Lock
  - price = 3.00：Record Lock
  - 间隙：(1.00, 2.50) 和 (2.50, 3.00) 和 (3.00, 4.00)，这些会被 **Next-Key Lock** 覆盖

- T2 执行 `SELECT * FROM products WHERE price BETWEEN 3.00 AND 4.00 FOR UPDATE;`
  尝试锁住 `price=3.00`、`price=4.00` 以及与其相邻的间隙
- 由于 T1 已经锁住了 `price=3.00`，T2 在尝试加锁 `price=3.00` 时会被阻塞，等待 T1 释放
- 如果这时候 T1 在同一个事务里又做了其他操作（例如插入一条 `price=3.50` 的记录），因为它需要获取 `(3.00, 4.00)` 这个间隙锁，而这个间隙锁已经被 T2 拿到了一部分，也会等待

这样两边都在等对方释放锁, 就会出现死锁, 

> InnoDB 是基于索引的存储引擎, 所有锁都是基于索引加的, 当你执行插入操作时, InnoDB 需要确定新记录在索引中的位置, 并确保插入不会破坏数据一致性, 如果插入的列有索引, InnoDB 会扫描该索引, 找到新值应该插入的位置, 然后对相关范围加锁, 这也是为什么当 T1 插入一条 `price=3.50` 的记录时, 需要获取 `(3.00, 4.00)` 这个间隙锁, 

> 注意 InnoDB 在 “可重复读” 级别下, 常见的三种操作以及加锁情况: 
>
> **快照读**: 普通的 SELECT, 不会加锁, 只依赖快照读（MVCC）
>
> **当前读**: SELECT ... FOR UPDATE 或 SELECT ... LOCK IN SHARE MODE, 范围查询会触发 Next-Key Lock
>
> **写操作**: UPDATE/DELETE: 范围内的记录和间隙会被 Next-Key Lock 锁定

> 当列具有唯一约束时，InnoDB 在执行插入或更新操作时，会检查是否存在重复值。为保证并发环境下的一致性，InnoDB 可能会对相关记录加 Record Lock，并对插入或更新值可能影响的索引间隙加 Gap Lock 或 Next-Key Lock，具体取决于隔离级别和操作类型。



假设我们有两个表：Parent 和 Child, Child 表有一个外键引用 Parent 表的主键

**事务 A**：

- 开始事务
- 尝试删除 Parent 表中的一行, 这一行是 Child 表中某一行的外键引用
- 由于外键约束, InnoDB 必须检查 Child 表中是否存在引用该行的记录, 如果 ⁠Child 表中存在引用 ⁠Parent 表中要删除的那一行的记录, InnoDB 会阻止删除操作并返回一个错误

**事务 B**：

- 开始事务

- 尝试向 Child 表中插入一行, 该行的外键引用 Parent 表中事务 A 正在删除的那一行

- 事务 B 获得了 Child 表的行锁, 但等待 Parent 表的锁释放

> 注意 当事务 A 检查 Child 表比如 id = 001, 检查该行是否存在是, 需要先获得该行的 s锁, 但此时因为 事务B先执行了 insert xxx id = 001, InnoDB 引擎默认为插入操作获得了 x锁, 而 x 锁排斥 s 锁, 所以, 事务 A 必须等待 事务 B 释放了 id = 001 行的 x 锁, 才能检查该行是否存在, 
>
> 事务 A 在进行外键检查需要获取 Child 表中引用该 Parent 记录的共享锁（S 锁），但由于事务 B 已经对该记录加了 X 锁，而 X 锁排斥 S 锁，所以事务 A 必须等待事务 B 释放 X 锁后才能继续检查。

| 时间点 | 事务 A (删除 Parent)                           | 锁操作                                       | 事务 B (插入 Child)                            | 锁操作                       |
| ------ | ---------------------------------------------- | -------------------------------------------- | ---------------------------------------------- | ---------------------------- |
| T1     | 开始事务                                       |                                              | 开始事务                                       |                              |
| T2     | 尝试删除 Parent 表中的一行 id=01               | 请求 X 锁 (Parent 表) ✅ 获得                 |                                                |                              |
| T3     | 检查 Child 表是否存在引用                      | 请求 parentId = 01 的 S 锁 (Child 表) ⏳ 等待 |                                                |                              |
| T4     |                                                |                                              | 尝试插入一行到 Child 表                        | 请求 X 锁 (Child 表) ✅ 获得  |
| T5     |                                                |                                              | 检查 Parent 表是否存在主键                     | 请求 S 锁 (Parent 表) ⏳ 等待 |
| T6     | 事务 A 持有 Parent 表 X 锁，等待 Child 表 S 锁 | 等待 S 锁 (Child 表)                         | 事务 B 持有 Child 表 X 锁，等待 Parent 表 S 锁 | 等待 S 锁 (Parent 表)        |
| T7     | ❌ 死锁发生，InnoDB 发现循环等待                |                                              | ❌ 死锁发生，InnoDB 发现循环等待                |                              |
| T8     | InnoDB 选择回滚事务 B                          | 事务 B 失败，释放 Child 表 X 锁              | 事务 B 失败，回滚                              | 释放 Child 表 X 锁           |
| T9     | 事务 A 继续执行，删除成功                      | Parent 表 X 锁释放                           |                                                |                              |

解决办法: 如果需要删除一行 Parent 记录，应先删除或更新对应的 Child 表中的记录，再删除 Parent 表对应的记录。这样可以避免外键约束检查时因为 Child 表中的记录而引发等待或报错。

### 1.3. 范围冲突

