---
title: 数据库死锁以及排查
date: 2025-03-05 10:56:19
categories:
 - 面试
tags:
 - 面试
---

## 1. 导致死锁的原因

### 1.1. 更新操作顺序不一致

在数据库中，当多个事务同时对多行或多表的数据进行更新时，如果每个事务获取锁的顺序不一致，就可能导致死锁。所谓“锁的获取顺序未标准化”，指的是没有一个固定的规则来规定所有事务必须按照相同的顺序去锁定资源（例如，先锁表 A 再锁表 B，或者先锁 id=1 再锁 id=2）。如果事务之间锁的获取顺序随意，就会出现循环等待的情况，最终形成死锁。

比如两个事务同时试图更新相同的记录, 但它们以不同的顺序请求锁, 例如, 事务 A 锁定了记录 1 并尝试锁定记录 2, 而事务 B 锁定了记录 2 并尝试锁定记录 1。

> MySQL 进行增删改操作的时候, 会自动加上一个行级锁: x锁

多发生在批量更新的情况, 可以标准化更新顺序，例如按 id 升序更新：

```sql
-- 事务 A 和 B 都按 order_id 升序更新
UPDATE orders SET status = 'xxx' WHERE order_id IN (1, 2) ORDER BY order_id;
```

### 1.2. 外键引起

假设我们有两个表：Parent 和 Child, Child 表有一个外键引用 Parent 表的主键

**事务 A**：

- 开始事务
- 尝试删除 Parent 表中的一行, 这一行是 Child 表中某一行的外键引用
- 由于外键约束, InnoDB 必须检查 Child 表中是否存在引用该行的记录, 如果 ⁠Child 表中存在引用 ⁠Parent 表中要删除的那一行的记录, InnoDB 会阻止删除操作并返回一个错误

**事务 B**：

- 开始事务

- 尝试向 Child 表中插入一行, 该行的外键引用 Parent 表中事务 A 正在删除的那一行

- 事务 B 获得了 Child 表的行锁, 但等待 Parent 表的锁释放

> 注意 当事务 A 检查 Child 表比如 id = 001, 检查该行是否存在是, 需要先获得该行的 s锁, 但此时因为 事务B先执行了 insert xxx id = 001, InnoDB 引擎默认为插入操作获得了 x锁, 而 x 锁排斥 s 锁, 所以, 事务 A 必须等待 事务 B 释放了 id = 001 行的 x 锁, 才能检查该行是否存在, 
>
> 事务 A 在进行外键检查需要获取 Child 表中引用该 Parent 记录的共享锁（S 锁），但由于事务 B 已经对该记录加了 X 锁，而 X 锁排斥 S 锁，所以事务 A 必须等待事务 B 释放 X 锁后才能继续检查。

| 时间点 | 事务 A (删除 Parent)                           | 锁操作                          | 事务 B (插入 Child)                            | 锁操作                       |
| ------ | ---------------------------------------------- | ------------------------------- | ---------------------------------------------- | ---------------------------- |
| T1     | 开始事务                                       |                                 | 开始事务                                       |                              |
| T2     | 尝试删除 Parent 表中的一行                     | 请求 X 锁 (Parent 表) ✅ 获得    |                                                |                              |
| T3     | 检查 Child 表是否存在引用                      | 请求 S 锁 (Child 表) ⏳ 等待     |                                                |                              |
| T4     |                                                |                                 | 尝试插入一行到 Child 表                        | 请求 X 锁 (Child 表) ✅ 获得  |
| T5     |                                                |                                 | 检查 Parent 表是否存在主键                     | 请求 S 锁 (Parent 表) ⏳ 等待 |
| T6     | 事务 A 持有 Parent 表 X 锁，等待 Child 表 S 锁 | 等待 S 锁 (Child 表)            | 事务 B 持有 Child 表 X 锁，等待 Parent 表 S 锁 | 等待 S 锁 (Parent 表)        |
| T7     | ❌ 死锁发生，InnoDB 发现循环等待                |                                 | ❌ 死锁发生，InnoDB 发现循环等待                |                              |
| T8     | InnoDB 选择回滚事务 B                          | 事务 B 失败，释放 Child 表 X 锁 | 事务 B 失败，回滚                              | 释放 Child 表 X 锁           |
| T9     | 事务 A 继续执行，删除成功                      | Parent 表 X 锁释放              |                                                |                              |

解决办法: 如果需要删除一行 Parent 记录，应先删除或更新对应的 Child 表中的记录，再删除 Parent 表对应的记录。这样可以避免外键约束检查时因为 Child 表中的记录而引发等待或报错。

### 1.3. 范围冲突

