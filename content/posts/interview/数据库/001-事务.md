---
title: MySQL 事务 数据一致性 悲观锁 乐观锁
date: 2025-02-17 20:39:22
categories:
 - 面试
tags:
 - 面试
---

## 1. 脏读 脏写 幻读 - 事务隔离级别

### 1.1. 脏读 - 事务隔离级别较低

脏读是指一个事务读取到了另一个事务尚未提交的数据。若后者发生回滚，则前者读取的数据实际上并不存在。

- 事务 A 修改了一条记录，但尚未提交。

- 事务 B 读取这条记录，看到 A 的修改。

如果 A 后续回滚，那么 B 读到了不存在的数据，这就是脏读问题。

根本原因在于事务隔离级别较低，允许一个事务读取另一个事务未提交的修改数据，缺少对数据一致性的保证。

### 1.2. 脏写

脏写指的是：事务 B 在事务 A 尚未提交的更新基础上又进行了更新并提交。如果随后事务 A 回滚，但 B 已经基于 A 的“未提交更新”写入了数据库，就会导致数据库中出现了一份基于“从未真正生效的数据”所写进去的值。

- 如果 B 的更新逻辑要判断某个字段是否满足条件（例如库存是否 > 0 才扣减），而这个字段恰恰是由 A 更新的**未提交**数据。

- B 基于 A 未提交的数据做了扣减并提交，后来 A 回滚导致库存根本没增加（或者没变化），最终 B 却“凭空”把库存扣了。

这些例子都说明了：**脏写本质上是写操作基于了一份并不存在（或不确定会不会存在）的中间状态**，进而可能对数据一致性和业务逻辑造成破坏。这就是为什么数据库**禁止**脏写的原因。

> 在多数主流数据库(例如 MySQL InnoDB)的默认配置下，这种情况**通常不会发生**，因为对同一行记录的并发写操作自动会被加 x锁序列化：只有前一个写操作提交或回滚后，后一个事务才能对这行数据进行新的写。因此，脏写往往只在极其宽松/非常低的隔离级别（或人为关闭了某些并发控制）下，才可能被“模拟”或“测试”出来。

### 1.3. 不可重复读 幻读

不可重复读: 在一个事务执行过程中，读取到其它事务已提交的数据，导致两次读取的结果不一致。

幻读: 在一个事务执行过程中，读取到了其他事务新插入数据，导致两次读取的结果不一致。

### 1.4. 四种隔离级别

在`SQL`标准中设立了4种隔离级别, 用来解决上面的读一致性问题, 不同的隔离级别可以解决不同的读一致性问题

- `READ UNCOMMITTED`：未提交读
- `READ COMMITTED`：已提交读
- `REPEATABLE READ`：可重复读
- `SERIALIZABLE`：串行化

| 隔离级别 (Isolation Level)  | 脏读 (Dirty Read) | 不可重复读 (Non-repeatable Read) | 幻读 (Phantom Read)            |
| --------------------------- | ----------------- | -------------------------------- | ------------------------------ |
| 未提交读 (READ UNCOMMITTED) | 可能 (Yes)        | 可能 (Yes)                       | 可能 (Yes)                     |
| 已提交读 (READ COMMITTED)   | 不可能 (No)       | 可能 (Yes)                       | 可能 (Yes)                     |
| 可重复读 (REPEATABLE READ)  | 不可能 (No)       | 不可能 (No)                      | 可能 (Yes)（对 InnoDB 不可能） |
| 串行化 (SERIALIZABLE)       | 不可能 (No)       | 不可能 (No)                      | 不可能 (No)                    |

> 脏写的问题严重, 数据库设计上通过增删改操作默认加 x锁, 实现脏写在任何隔离级别都会避免
>
> `InnoDB`支持四个隔离级别（和`SQL`标准定义的基本一致）。隔离级别越高，事务的并发度就越低。唯一的区别就在于，`InnoDB` 在`可重复读（REPEATABLE READ）`的级别就解决了幻读的问题。这也是`InnoDB`使用`可重复读` 作为事务默认隔离级别的原因。

此节部分参考: [mysql事务和锁 - 掘金](https://juejin.cn/post/6855129007336521741)

## 2. 事务

### 2.1. 事务的概念

事务是一组要么全部成功，要么全部失败的数据库操作，保证数据的一致性。

假设你要从 A 账户转 100 元到 B 账户，这个过程涉及两个操作：

1. 从 A 账户扣 100 元
2. 给 B 账户加 100 元

如果第一步执行了，但第二步失败了，就会导致 A 的钱少了，但 B 没收到钱，这导致了数据一致性问题。事务可以防止这种情况。

```mysql
START TRANSACTION;
-- 从 A 账户扣 100 元
UPDATE accounts SET balance = balance - 100 WHERE name = 'A';
-- 给 B 账户加 100 元
UPDATE accounts SET balance = balance + 100 WHERE name = 'B';
COMMIT;
```

如果在执行过程中出现错误（比如 B 账户不存在），可以执行回滚，撤销已经执行的操作。

> **拓展:** 在 MySQL（InnoDB 存储引擎）中，单个 DML 语句（INSERT, UPDATE, DELETE）本身就是一个事务，如果 `AUTOCOMMIT` 处于默认开启状态，它会自动提交，不需要手动 `COMMIT`。
>
> 在数据修改操作（Update、Delete、Insert）中, MySQL InnoDB 会**自动**对受影响的行加上 x 锁, 事务提交的时候(语句执行完成), x锁会被自动释放。

> **后端开发:** 在 Spring Data JPA 中，事务管理是由 Spring 的事务管理器（通常是 `@Transactional` 注解）来控制的，自动回滚行为也由 Spring 决定。Spring 默认会在遇到 **运行时异常（RuntimeException 及其子类）** 或 **错误（Error）** 时自动回滚事务。
>
> 如果在事务方法内部捕获了异常，并没有将异常抛出到事务管理器，那么 Spring 不会感知到异常，从而事务不会自动回滚。
>
> ```java
> @Transactional
> public void updateSomeData() {
>     try {
>         // 一些数据库操作
>         // 可能抛出异常
>     } catch (Exception e) {
>         // 捕获异常后不重新抛出，事务将按正常流程提交
>     }
> }
> ```

### 2.2. 事务不是导致错误的原因，而是处理错误的机制

连接类错误, 语法错误, 系统资源相关错误, 数据完整性和约束错误, 事务和锁相关错误, 前几种没什么好说的, 看一下最后两种:

- 违反完整性约束的错误: 数据库自身的机制, 比如：主键重复、外键不存在、唯一约束冲突、`CHECK` 约束失败等
- 事务和锁相关错误: 在事务操作中遇到死锁或锁等待等问题
  - 两个或多个事务在等待对方持有的资源而形成循环依赖，导致系统检测到死锁。
  - 事务等待获取资源的时间超出了设定的超时时间，可能需要检查当前事务的锁竞争情况

**事务不是导致错误的原因，而是处理错误的机制:**

| **情况**                 | **数据库是否报错？** | **事务是否回滚？**   |
| ------------------------ | -------------------- | -------------------- |
| 主键冲突                 | ✅ 报错               | ✅ 回滚（事务开启时） |
| 外键约束失败             | ✅ 报错               | ✅ 回滚（事务开启时） |
| 唯一约束失败             | ✅ 报错               | ✅ 回滚（事务开启时） |
| 业务逻辑错误（如负余额） | ✅ 报错               | ✅ 回滚（事务开启时） |

1. 没开启事务时, 每条 SQL 都是独立提交的, 报错不会回滚之前的操作
2. 事务不会主动报错，报错的原因是 SQL 语句违反数据库的完整性约束
3. 事务的作用是确保错误发生时，数据不会进入不一致的状态, 事务只是处理数据库错误的工具, 并不是开启事务就万事大吉了

### 2.3. 事务的特性

**原子性（Atomicity）** 

- 事务是一个不可分割的最小操作单元，要么全部执行成功，要么全部回滚
- 以转账场景为例，一个账户的余额减少，另一个账户的余额增加，这两个操作一定是同时成功或者同时失败的

**一致性（Consistency）** 

- 事务执行前后，数据库必须保持一致性状态，即不会违反数据库的完整性约束

**隔离性（Isolation）**

- 并发事务互不影响，一个事务未提交前，其他事务无法看到其变化

**持久性（Durability）**

- 事务提交后，其修改的数据会被永久保存，即使系统崩溃也不会丢失

**一致性并不是事务本身的固有属性, 而更像是一种外在要求,** 不难发现其他三个都是实打实的特征, 唯独一致性, 无法理解, 这里的一致性更像是一种外在要求, 而不是事务本身的固有的属性, 即是一种需要依赖业务层逻辑来实现的状态,

举个不恰当的例子, 我们说一个苹果, 苹果是圆的, 苹果可以为我们提供维生素C, 这都是苹果的特征, 可是你却说, 苹果也有生吃性, 苹果必须生吃才能最大化的提供营养价值, WTF? 生不生吃苹果取决于个人啊, 这怎么能是苹果的特性呢?

同理, 数据库是不是保持一致性, 这取决于业务逻辑啊, 比如需要结合锁来实现, 什么悲观锁, 乐观锁, 这怎么能是事务的特性呢?

## 3. 数据一致性问题

### 3.1. 直接修改操作 - 隐式 x 锁

比如常见的转账例子多个人给同一个账户转 100 块钱,  系统可能会有下面的命令:

```mysql
UPDATE account SET balance = balance + 100 WHERE account_id = 002;
```

高并发状态下, A事务读取到此时账户余额为 100, B事务 也读取到账户余额为 100, 

- A 事务: 余额 = 100 + 100 = 200, 
- B 事务:  余额 = 100 + 100 = 200

最后账户余额仅为 200 而不是 300, 导致数据一致性问题, 因为 InnoDB 会在执行 UPDATE 时对目标行加上排它锁（X 锁）, 从而确保这些操作是串行化的, 

好像是告诉事务, 你想更新 `account_id = 002` 的数据? 行, 但请先获得这行数据的 X 锁, 所以不可能会有两个事务同时对同一行执行 UPDATE 操作, 也就是说使用单条 UPDATE 语句时, 不会出现多个事务都获取到相同 balance 的情况, 因为数据修改操作都是串行化的, 

> 在数据修改操作（Update、Delete、Insert）中, 事务会先尝试获得受影响行的 X 锁, 若得到, 才能进行更新, 否则只能等待, 不要忘了单个语句, 也默认属于一个事务

### 3.2. 检查 + 修改操作 -  显式 x锁 (悲观锁) 或乐观锁

这种属于多个事务中基于过时数据进行判断后再写入更新的场景, 读取数据与更新操作之间缺乏必要的锁机制保护, 导致多个事务基于同一份数据进行判断并更新, 从而引发数据不一致, 

上面的例子过于简化了, 实际系统肯定不会直接给账户加钱, 还有很多考虑, 比如检查收账人是否存在, 检查转账人的余额是不是足够, 然后进行扣款, 

**步骤 1：同时读取余额**

- 事务 A 和事务 B 同时对转账人账户执行查询操作，读取到余额都为 100 元
- 此时，如果没有加锁（如 `FOR UPDATE`），两个事务都基于相同的旧数据做判断

**步骤 2：判断余额充足**

- 事务 A 判断：100 元 >= 转账金额 80 元，认为余额足够
- 事务 B 同样判断：100 元 >= 转账金额 60 元，也认为余额足够

**步骤 3：分别执行扣款**

- 事务 A 扣款 80 元，更新余额为 20 元
- 事务 B 扣款 80 元，同样在自己的事务中基于最初读取到的 100 元执行更新，更新余额为 40 元
- 最终两个事务都成功提交，导致余额可能是40, 也可能是20, 也可能是100 - 80 - 60 = -40, 导致余额出现问题（负数或不一致）。

**解决办法1: 悲观锁**

```mysql
BEGIN;
SELECT balance FROM accounts WHERE id = ? FOR UPDATE; -- 加锁
-- 判断余额是否充足, 通过业务代码实现, SQL 无法实现逻辑判断
UPDATE accounts SET balance = balance - ? WHERE id = ?;
COMMIT;
```

这样可以确保在一个事务完成之前，其他事务必须等待，避免同时读取同一份数据进行判断。

**解决办法2: 乐观锁**

```mysql
BEGIN;
SELECT balance, version FROM accounts WHERE id = ?;
-- 判断余额是否充足, 通过业务代码实现, SQL 无法实现逻辑判断
UPDATE accounts SET balance = balance - ?, version = version + 1
WHERE id = ? AND version = ?;
-- 判断 UPDATE 是否成功, 否则重试或抛出异常返回给客户端执行失败, 通过业务代码实现
COMMIT;
```

### 3.3. 多表操作 - 事务原子性

除此之外还要确保转账人的账户 -100, 收款人的账户 +100, 不能出现后者操作失败了, 导致收款人账户余额没变, 转账人账户的钱却少了 100, 这也是属于数据不一致, 

这种很简单, 把更新两张表的语句放到同一个事务里就行了, 因为可以利用事务的回滚保证, 若有一个操作失败, 则同时都失败, 
