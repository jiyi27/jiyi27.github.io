---
title: 二叉树和堆
date: 2025-03-20 18:08:52
categories:
 - 面试
tags:
 - 面试
 - 算法面试
---

## 1. 二叉树

### 1.1. 表达式树 Expression Tree

树的叶子节点通常是操作数（例如数字或变量）, 而非叶子节点是运算符（例如 +、-、*、/）, 通过遍历表达式树（例如前序、中序或后序遍历），可以重新生成表达式或计算其结果, 表达式 (3 + 5) * 2 可以表示为：

```
    *
   / \
  +   2
 / \
3   5
```

- 计算器程序：实现复杂数学计算时，表达式树可以帮助按正确的顺序执行运算（尊重运算优先级和括号）
- 数据库查询优化：在 SQL 查询引擎中，表达式树可以表示查询条件，帮助优化执行计划

### 1.2. 决策树 Decision Tree

决策树是一种树形结构, 用于表示决策过程或分类/回归问题, 树的每个节点代表一个决策点（基于某个条件）, 分支代表可能的决策路径, 叶子节点通常表示最终的决策结果或类别:

```
       [天气]
      /      \
  [晴天]    [下雨]
  /           \
[外出]      [待在家]
```

- 机器学习：决策树是经典的监督学习算法，用于分类和回归任务。例如，判断用户是否会购买某产品（基于年龄、收入等特征）
- 游戏开发：在 AI 行为设计中，决策树用于控制 NPC（非玩家角色）的行为，例如决定是否攻击或逃跑
- 医疗诊断：基于症状、体征等条件，决策树可以帮助医生判断疾病类型

## 2. 遍历二叉树 - DFS

### 2.1. 前序遍历

参考例题: [104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)

```python
class Solution:
    def maxDepth(self, root):
        def getDepth(node, depth):
            if not node:
                return depth - 1
            # 取左右子树的最大深度
            left = getDepth(node.left, depth + 1)
            right = getDepth(node.right, depth + 1)
            return max(left, right)
        
        return getDepth(root, 0)
```

> 前序遍历使用场景: 函数处理当前节点再进行递归处理其他子节点 中左右 递归函数的单层逻辑都是处理当前节点, 一般我们通过一个状态 () 来作为参数来传递 (积累) 每次 recursion 的影响, 所以下面的例子中我们需要全局变量 `self.depth` 和 `self.result`,





```python
# 定义二叉树节点类
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val    # 节点值
        self.left = left  # 左子节点
        self.right = right # 右子节点

# 前序遍历 (根 -> 左 -> 右)
def preorderTraversal(root):
    """
    前序遍历：先访问根节点，然后遍历左子树，最后遍历右子树
    """
    result = []  # 存储遍历结果
    
    def dfs(node):
        if not node:  # 如果节点为空，返回
            return
        result.append(node.val)  # 先访问根节点
        dfs(node.left)          # 递归遍历左子树
        dfs(node.right)         # 递归遍历右子树
    
    dfs(root)
    return result

# 中序遍历 (左 -> 根 -> 右)
def inorderTraversal(root):
    """
    中序遍历：先遍历左子树，然后访问根节点，最后遍历右子树
    """
    result = []
    
    def dfs(node):
        if not node:
            return
        dfs(node.left)          # 先递归遍历左子树
        result.append(node.val)  # 然后访问根节点
        dfs(node.right)         # 最后递归遍历右子树
    
    dfs(root)
    return result

# 后序遍历 (左 -> 右 -> 根)
def postorderTraversal(root):
    """
    后序遍历：先遍历左子树，然后遍历右子树，最后访问根节点
    """
    result = []
    
    def dfs(node):
        if not node:
            return
        dfs(node.left)          # 先递归遍历左子树
        dfs(node.right)         # 然后递归遍历右子树
        result.append(node.val)  # 最后访问根节点
    
    dfs(root)
    return result

# 测试代码
if __name__ == "__main__":
    # 创建一个简单的二叉树
    #       1
    #      / \
    #     2   3
    #    / \
    #   4   5
    
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)
    root.left.left = TreeNode(4)
    root.left.right = TreeNode(5)

    # 测试三种遍历
    print("前序遍历:", preorderTraversal(root))  # 预期输出: [1, 2, 4, 5, 3]
    print("中序遍历:", inorderTraversal(root))   # 预期输出: [4, 2, 5, 1, 3]
    print("后序遍历:", postorderTraversal(root))  # 预期输出: [4, 5, 2, 3, 1]
```



