---
title: 二叉树和堆
date: 2025-03-20 18:08:52
categories:
 - 面试
tags:
 - 面试
 - 算法面试
---

## 1. 表达式树 Expression Tree

树的叶子节点通常是操作数（例如数字或变量）, 而非叶子节点是运算符（例如 +、-、*、/）, 通过遍历表达式树（例如前序、中序或后序遍历），可以重新生成表达式或计算其结果, 表达式 (3 + 5) * 2 可以表示为：

```
    *
   / \
  +   2
 / \
3   5
```

- 计算器程序：实现复杂数学计算时，表达式树可以帮助按正确的顺序执行运算（尊重运算优先级和括号）
- 数据库查询优化：在 SQL 查询引擎中，表达式树可以表示查询条件，帮助优化执行计划

## 2. 决策树 Decision Tree

决策树是一种树形结构, 用于表示决策过程或分类/回归问题, 树的每个节点代表一个决策点（基于某个条件）, 分支代表可能的决策路径, 叶子节点通常表示最终的决策结果或类别:

```
       [天气]
      /      \
  [晴天]    [下雨]
  /           \
[外出]      [待在家]
```

- 机器学习：决策树是经典的监督学习算法，用于分类和回归任务。例如，判断用户是否会购买某产品（基于年龄、收入等特征）
- 游戏开发：在 AI 行为设计中，决策树用于控制 NPC（非玩家角色）的行为，例如决定是否攻击或逃跑
- 医疗诊断：基于症状、体征等条件，决策树可以帮助医生判断疾病类型

## 3. 二叉搜索树 Binary Search Tree, BST

- 利用 BST 的性质：若目标值小于当前节点，向左子树查找；若大于，向右子树查找

- 时间复杂度：平均 O(log n)，最坏 O(n)（退化为链表时）

```python
Node find(Node root, int value) {
    if (root == null || root.value == value) return root;
    if (value < root.value) return find(root.left, value);
    return find(root.right, value);
}
```

> **延伸**：提到退化问题，并引出平衡树（如 AVL 或红黑树）

> 如何判断一棵树是否是二叉搜索树？
>
> 中序遍历检查是否升序
>
> ```python
> bool isBST(Node root, int min, int max) {
>     if (root == null) return true;
>     if (root.value <= min || root.value >= max) return false;
>     return isBST(root.left, min, root.value) && isBST(root.right, root.value, max);
> }
> ```

## 4. 遍历二叉树 - DFS

> Recursion 三步
>
> - 确定终止条件
> - 确定单层逻辑
> - 确定返回值和参数
>
> 其实**首先要确定的应该是遍历顺序**, 因为遍历顺序决定了递归的顺序, 递归的顺序决定了返回值和参数, 且听我慢慢说来

```python
class Solution104:
    def __init__(self):
        self.current_depth = 0
        self.max_depth = -1

    def maxDepth(self, root):
        def preorder(node):
            if not node:
                return
            
            # 前序遍历 中左右
            self.current_depth += 1
            if self.max_depth < self.current_depth:
                self.max_depth = self.current_depth

            if node.left:
                preorder(node.left)
                self.current_depth -= 1
            if node.right:
                preorder(node.right)
                self.current_depth -= 1

        preorder(root)
        return self.current_depth
```

> 前序遍历使用场景: 函数处理当前节点再进行递归处理其他子节点 中左右 递归函数的单层逻辑都是处理当前节点, 一般我们通过一个**全局变量** (比如上面的 `max_depth`) 来作为参数来传递 (积累) 每次 recursion 的影响

而后序遍历适合通过返回值的方式来传递信息, 因为当前节点最后处理, 通过下面的例子可以看出:

```python
def maxDepth(root):
    if not root:
        return 0
    # 后序遍历 左右中
    left = self.maxDepth(root.left)
    right = self.maxDepth(root.right)
    return max(left, right) + 1
```

> DFS 是 "Depth-First Search" 的缩写，中文翻译为“深度优先搜索”
>
> - 深度优先：指的是在搜索过程中，优先沿着一条路径尽可能深入，直到无法继续深入为止（到达尽头或满足某个条件），然后回溯到上一个节点，再探索其他路径
>
> - 搜索过程：从起点开始，选择一个方向深入探索，访问完一个节点后，继续访问它的子节点，而不是立即访问同一层的其他节点
>
> 在二叉树遍历的上下文中，DFS 通常表现为递归调用，因为递归天然具有“深入到底再回溯”的特性:
>
> - 前序遍历：先访问根节点，然后深度优先遍历左子树，再遍历右子树
>
> - 中序遍历：先深度优先遍历左子树，然后访问根节点，再遍历右子树
>
> - 后序遍历：先深度优先遍历左子树，再遍历右子树，最后访问根节点
>
> **DFS 的特点**
>
> - 可以用递归
> - 也可以用栈
> - 空间复杂度：O(h)，h 是树的高度或图的最大深度，因为需要存储递归调用栈或显式栈
> - 时间复杂度：O(n)，n 是节点数，因为每个节点都会被访问一次

> BFS（广度优先搜索，Breadth-First Search）：一层一层地探索，先访问所有同一层的节点

## 5. Max-Heap Min-Heap

**种类**

- 最大堆（Max-Heap）：每个节点的值都大于或等于其子节点的值，根节点是最大值
- 最小堆（Min-Heap）：每个节点的值都小于或等于其子节点的值，根节点是最小值

**复杂度**

- 插入：将元素加到末尾，上浮调整，O(log n)
- 删除顶部：将末尾元素移到顶部，下沉调整，O(log n)
- 通常通过数组实现

**用例** heap sort, priority queues

### 5.1.  Priority Queues

优先队列（Priority Queue）是一种特殊的队列，不同于普通的先进先出（FIFO）队列，它会**按照元素的优先级出队**：

- 每次取出的元素，不一定是最早进入队列的，而是**优先级最高**的那个

- 如果两个元素优先级一样，通常按进入队列的顺序来处理

**后端限流 / 排队服务（任务调度系统）**

开发一个 **视频转码平台**：

- 用户上传视频后，系统会排队转码（比如压缩、加字幕等）
- 有的用户是普通用户，优先级低
- 有的用户是 VIP，优先级高
- 系统同一时间只能处理有限的任务

建一个「优先队列」来排这些转码任务：

```java
import java.util.PriorityQueue;

// 转码任务类
class TranscodeTask implements Comparable<TranscodeTask> {
    private String videoId;
    private int priority; // 优先级：数字越小优先级越高
    private boolean isVip;
    
    public TranscodeTask(String videoId, boolean isVip) {
        this.videoId = videoId;
        this.isVip = isVip;
        // VIP用户优先级为1，普通用户优先级为2
        this.priority = isVip ? 1 : 2;
    }
    
    // 实现Comparable接口，用于优先队列排序
    @Override
    public int compareTo(TranscodeTask other) {
        // 按优先级排序，数字小的在前
        return Integer.compare(this.priority, other.priority);
    }
    
    @Override
    public String toString() {
        return "视频: " + videoId + " [" + (isVip ? "VIP用户" : "普通用户") + 
               ", 优先级: " + priority + "]";
    }
}

// 视频转码服务
class TranscodingService {
    private PriorityQueue<TranscodeTask> queue;
    private int maxConcurrentTasks;
    
    public TranscodingService(int maxConcurrentTasks) {
        // 创建优先队列
        this.queue = new PriorityQueue<>();
        this.maxConcurrentTasks = maxConcurrentTasks;
    }
    
    // 添加任务到队列
    public void addTask(String videoId, boolean isVip) {
        TranscodeTask task = new TranscodeTask(videoId, isVip);
        queue.offer(task); // 添加到优先队列
        System.out.println("任务已添加: " + task);
    }
    
    // 处理队列中的任务
    public void processTasks() {
        System.out.println("\n开始处理队列中的任务，最多同时处理" + maxConcurrentTasks + "个任务");
        
        // 模拟处理maxConcurrentTasks个任务
        for (int i = 0; i < maxConcurrentTasks && !queue.isEmpty(); i++) {
            TranscodeTask task = queue.poll(); // 取出优先级最高的任务
            System.out.println("正在处理: " + task);
        }
        
        System.out.println("队列中剩余任务数: " + queue.size());
    }
}

// 测试优先队列
public class VideoTranscodingDemo {
    public static void main(String[] args) {
        TranscodingService service = new TranscodingService(2); // 最多同时处理2个任务
        
        // 添加任务，普通用户和VIP用户混合
        service.addTask("video1", false); // 普通用户
        service.addTask("video2", true);  // VIP用户
        service.addTask("video3", false); // 普通用户
        service.addTask("video4", true);  // VIP用户
        service.addTask("video5", false); // 普通用户
        
        // 处理任务
        service.processTasks();
        
        // 再次处理剩余任务
        service.processTasks();
    }
}
```

**搜索推荐系统（返回前K个最优结果）Top-K 实现**

做一个电商搜索系统，用户输入关键词 “蓝牙耳机”：

- 系统会检索成千上万的商品
- 每个商品都会算一个“相关性得分”（分数越高越匹配）
- 你只想展示前 5 个最相关的商品

用一个「最小堆（优先队列）」来存当前分数最高的前 5 个结果：

```java
import java.util.PriorityQueue;
import java.util.Comparator;

// 商品类
class Product {
    private String id;
    private String name;
    private double price;
    private double relevanceScore; // 相关性得分
    
    public Product(String id, String name, double price, double relevanceScore) {
        this.id = id;
        this.name = name;
        this.price = price;
        this.relevanceScore = relevanceScore;
    }
    
    public double getRelevanceScore() {
        return relevanceScore;
    }
    
    @Override
    public String toString() {
        return "商品：" + name + " (ID: " + id + ", 价格: ¥" + price + 
               ", 相关性得分: " + relevanceScore + ")";
    }
}

// 电商搜索系统
class EcommerceSearchSystem {
    private int k; // 要保留的最高分数商品数量
    
    public EcommerceSearchSystem(int k) {
        this.k = k;
    }
    
    // 搜索方法
    public void search(String keyword, Product[] allProducts) {
        System.out.println("搜索关键词: \"" + keyword + "\"");
        
        // 创建最小堆(优先队列)，按相关性得分升序排列
        // 队首是最小元素，这样当队列满时可以移除最不相关的商品
        PriorityQueue<Product> topProducts = new PriorityQueue<>(
            Comparator.comparingDouble(Product::getRelevanceScore)
        );
        
        // 处理所有商品
        for (Product product : allProducts) {
            // 如果队列没满，直接添加
            if (topProducts.size() < k) {
                topProducts.offer(product);
            } 
            // 如果队列已满，且当前商品比队列中最低分数商品相关性更高，则替换
            else if (product.getRelevanceScore() > topProducts.peek().getRelevanceScore()) {
                topProducts.poll(); // 移除最低分数的商品
                topProducts.offer(product); // 添加当前商品
            }
        }
        
        // 输出结果（注意：这会按照优先级顺序输出，即分数从低到高）
        System.out.println("\n搜索结果 (前" + k + "名):");
        int rank = topProducts.size();
        Product[] results = new Product[rank];
        
        // 将结果从队列中取出（从分数低到高）
        while (!topProducts.isEmpty()) {
            results[--rank] = topProducts.poll();
        }
        
        // 按相关性从高到低输出
        for (int i = 0; i < results.length; i++) {
            System.out.println((i + 1) + ". " + results[i]);
        }
    }
}

// 测试电商搜索系统
public class EcommerceSearchDemo {
    public static void main(String[] args) {
        // 创建搜索系统，保留前5名商品
        EcommerceSearchSystem searchSystem = new EcommerceSearchSystem(5);
        
        // 模拟商品库（通常会有成千上万个商品）
        Product[] products = {
            new Product("101", "索尼蓝牙耳机 WH-1000XM4", 1999.00, 0.95),
            new Product("102", "苹果AirPods Pro", 1699.00, 0.89),
            new Product("103", "华为FreeBuds Pro", 999.00, 0.87),
            new Product("104", "小米蓝牙耳机Air2 Pro", 499.00, 0.82),
            new Product("105", "三星Galaxy Buds Pro", 899.00, 0.80),
            new Product("106", "蓝牙音箱JBL Flip 5", 799.00, 0.65),
            new Product("107", "BOSE QuietComfort 35 II", 2299.00, 0.92),
            new Product("108", "蓝牙耳机挂绳", 19.90, 0.60),
            new Product("109", "运动蓝牙耳机", 299.00, 0.78),
            new Product("110", "蓝牙适配器", 39.90, 0.55),
            new Product("111", "无线蓝牙键盘", 159.00, 0.50),
            new Product("112", "Beats Studio Buds蓝牙耳机", 1099.00, 0.88)
        };
        
        // 执行搜索
        searchSystem.search("蓝牙耳机", products);
    }
}
```

- 我们使用最小堆，让相关性得分最低的商品位于堆顶，这样当找到更相关的商品时，可以方便地移除最不相关的商品
- 当队列大小达到k(5)时，只有比当前堆顶元素更相关的商品才会被加入，同时移除堆顶元素

### 5.2. 游戏积分榜、直播平台礼物榜、电商热销榜

**Game Ranking List**：通常需要实时更新玩家积分并快速查询前 N 名（如 Top 100）, 积分可能频繁变化，支持动态排序

**Live Streaming Gift Leaderboard**：主播或用户收到礼物后，礼物价值累加，排行榜需实时反映最新排名，查询 Top N 或某用户排名

**E-commerce Bestsellers List**：基于商品销量排序，可能涉及复杂排序规则（如销量+时间权重），更新频率可能稍低，但查询量大

**共同特点：**

- 实时或近实时更新
- 频繁查询 Top N 或某项排名
- 数据量可能较大（几十万到数亿条）
- 排序基于单一或复合分数

## 6. 平衡二叉树 Balanced Binary Tree，如 AVL 树、红黑树

如何平衡一棵二叉搜索树？**问题变种**：AVL 树和红黑树的区别？

- AVL 树：通过旋转（左旋、右旋）保持高度差 ≤ 1，插入/删除后严格平衡，适合读多写少的场景
- 红黑树：通过颜色规则和旋转维持近似平衡，插入/删除效率更高，适合写多读少的场景（如标准库实现）
- 区别：AVL 树更严格，查找更快（O(log n) 更稳定）；红黑树更宽松，插入/删除更快
- 延伸：可以提到自底向上或自顶向下的平衡过程


