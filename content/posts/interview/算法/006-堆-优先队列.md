---
title: 优先队列
date: 2025-03-20 18:08:52
categories:
 - 面试
tags:
 - 面试
 - 算法面试
---

## 1. 堆

**种类**

- 最大堆（Max-Heap）每个节点的值都大于或等于其子节点的值，根节点是最大值
- 最小堆（Min-Heap）每个节点的值都小于或等于其子节点的值，根节点是最小值

**复杂度**

- 插入：将元素加到末尾，上浮调整，O(log n)
- 删除顶部：将末尾元素移到顶部，下沉调整，O(log n)
- 通常通过数组实现

**用例** heap sort, priority queues

## 2. Priority Queues

### 2.1. 默认排序规则（自然顺序）

默认情况下，PriorityQueue 是一个**最小堆**，即：

- 自然顺序要求元素实现 `Comparable` 接口，并在其 `compareTo` 方法中定义比较逻辑
- 队列的队首（`peek/poll` 获取的元素）始终是最小的元素（根据 `compareTo` 的结果）
- 例如，对于整数，PriorityQueue 会将最小的整数放在队首；对于字符串，会按字典序（ lexicographical order）排序

```java
import java.util.PriorityQueue;

public class Main {
    public static void main(String[] args) {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.offer(5);
        pq.offer(2);
        pq.offer(8);
        System.out.println(pq.poll()); // 输出: 2（最小值）
        System.out.println(pq.poll()); // 输出: 5
        System.out.println(pq.poll()); // 输出: 8
    }
}
```

- 这里，`Integer` 实现了 `Comparable`，`compareTo` 按数值大小比较，因此 `PriorityQueue` 按升序排列，队首是最小值

### 2.2. 自定义排序规则（使用 Comparator）

- 你可以通过在构造 `PriorityQueue` 时传入一个 `Comparator` 对象来自定义排序规则

- `Comparator` 的 compare 方法定义了元素的优先级顺序
- 如果提供了 `Comparator`，`PriorityQueue` 会根据它来决定元素的顺序，**而不是依赖 `Comparable`**
- 仍然默认是最小堆，队首是根据 `Comparator` 定义的“最小”元素

```java
import java.util.PriorityQueue;
import java.util.Comparator;

public class Main {
    public static void main(String[] args) {
        // 自定义 Comparator，按降序排序（大的值优先）
        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());
        pq.offer(5);
        pq.offer(2);
        pq.offer(8);
        System.out.println(pq.poll()); // 输出: 8（最大值）
        System.out.println(pq.poll()); // 输出: 5
        System.out.println(pq.poll()); // 输出: 2
    }
}
```

### 2.3. 排队服务 任务调度系统

- 用户上传视频后，系统会排队转码（比如压缩、加字幕等）
- 有的用户是普通用户，优先级低
- 有的用户是 VIP，优先级高

建一个「优先队列」来排这些转码任务：

```java
import java.util.PriorityQueue;

// 转码任务类
class TranscodeTask implements Comparable<TranscodeTask> {
    private String videoId;
    private int priority; // 优先级：数字越小优先级越高
    private boolean isVip;
    
    public TranscodeTask(String videoId, boolean isVip) {
        this.videoId = videoId;
        this.isVip = isVip;
        // VIP用户优先级为1，普通用户优先级为2
        this.priority = isVip ? 1 : 2;
    }
    
    // 实现Comparable接口，用于优先队列排序
    @Override
    public int compareTo(TranscodeTask other) {
        // 按优先级排序，数字小的在前
        return Integer.compare(this.priority, other.priority);
    }
    
    @Override
    public String toString() {
        return "视频: " + videoId + " [" + (isVip ? "VIP用户" : "普通用户") + 
               ", 优先级: " + priority + "]";
    }
}

// 视频转码服务
class TranscodingService {
    private PriorityQueue<TranscodeTask> queue;
    private int maxConcurrentTasks;
    
    public TranscodingService(int maxConcurrentTasks) {
        this.queue = new PriorityQueue<>();
        this.maxConcurrentTasks = maxConcurrentTasks;
    }
    
    // 添加任务到队列
    public void addTask(String videoId, boolean isVip) {
        TranscodeTask task = new TranscodeTask(videoId, isVip);
        queue.offer(task); // 添加到优先队列
        System.out.println("任务已添加: " + task);
    }
    
    // 处理队列中的任务
    public void processTasks() {
        System.out.println("\n开始处理队列中的任务，最多同时处理" + maxConcurrentTasks + "个任务");
        
        // 模拟处理maxConcurrentTasks个任务
        for (int i = 0; i < maxConcurrentTasks && !queue.isEmpty(); i++) {
            TranscodeTask task = queue.poll(); // 取出优先级最高的任务
            System.out.println("正在处理: " + task);
        }
        
        System.out.println("队列中剩余任务数: " + queue.size());
    }
}

// 测试优先队列
public class VideoTranscodingDemo {
    public static void main(String[] args) {
        TranscodingService service = new TranscodingService(2); // 最多同时处理2个任务
        
        // 添加任务，普通用户和VIP用户混合
        service.addTask("video1", false); // 普通用户
        service.addTask("video2", true);  // VIP用户
        service.addTask("video3", false); // 普通用户
        service.addTask("video4", true);  // VIP用户
        service.addTask("video5", false); // 普通用户
        
        // 处理任务
        service.processTasks();
        
        // 再次处理剩余任务
        service.processTasks();
    }
}
```

### 2.4. 搜索推荐系统（返回前K个最优结果）Top-K

用户输入关键词 “蓝牙耳机”：

- 系统会检索成千上万的商品
- 每个商品都会算一个“相关性得分”（分数越高越匹配）
- 你只想展示前 5 个最相关的商品

用一个「最小堆（优先队列）」来存当前分数最高的前 5 个结果：

```java
import java.util.PriorityQueue;
import java.util.Comparator;

// 商品类
class Product {
    private String id;
    private String name;
    private double price;
    private double relevanceScore; // 相关性得分
    
    public Product(String id, String name, double price, double relevanceScore) {
        this.id = id;
        this.name = name;
        this.price = price;
        this.relevanceScore = relevanceScore;
    }
    
    public double getRelevanceScore() {
        return relevanceScore;
    }
    
    @Override
    public String toString() {
        return "商品：" + name + " (ID: " + id + ", 价格: ¥" + price + 
               ", 相关性得分: " + relevanceScore + ")";
    }
}

// 电商搜索系统
class EcommerceSearchSystem {
    private int k; // 要保留的最高分数商品数量
    
    public EcommerceSearchSystem(int k) {
        this.k = k;
    }
    
    // 搜索方法
    public void search(String keyword, Product[] allProducts) {
        System.out.println("搜索关键词: \"" + keyword + "\"");
        
        // 创建最小堆(优先队列)，按相关性得分升序排列
        // 队首是最小元素，这样当队列满时可以移除最不相关的商品
        PriorityQueue<Product> topProducts = new PriorityQueue<>(
            Comparator.comparingDouble(Product::getRelevanceScore)
        );
        
        // 处理所有商品
        for (Product product : allProducts) {
            // 如果队列没满，直接添加
            if (topProducts.size() < k) {
                topProducts.offer(product);
            } 
            // 如果队列已满，且当前商品比队列中最低分数商品相关性更高，则替换
            else if (product.getRelevanceScore() > topProducts.peek().getRelevanceScore()) {
                topProducts.poll(); // 移除最低分数的商品
                topProducts.offer(product); // 添加当前商品
            }
        }
        
        // 输出结果（注意：这会按照优先级顺序输出，即分数从低到高）
        System.out.println("\n搜索结果 (前" + k + "名):");
        int rank = topProducts.size();
        Product[] results = new Product[rank];
        
        // 将结果从队列中取出（从分数低到高）
        while (!topProducts.isEmpty()) {
            results[--rank] = topProducts.poll();
        }
        
        // 按相关性从高到低输出
        for (int i = 0; i < results.length; i++) {
            System.out.println((i + 1) + ". " + results[i]);
        }
    }
}

// 测试电商搜索系统
public class EcommerceSearchDemo {
    public static void main(String[] args) {
        // 创建搜索系统，保留前5名商品
        EcommerceSearchSystem searchSystem = new EcommerceSearchSystem(5);
        
        // 模拟商品库（通常会有成千上万个商品）
        Product[] products = {
            new Product("101", "索尼蓝牙耳机 WH-1000XM4", 1999.00, 0.95),
            new Product("102", "苹果AirPods Pro", 1699.00, 0.89),
            new Product("103", "华为FreeBuds Pro", 999.00, 0.87),
            new Product("104", "小米蓝牙耳机Air2 Pro", 499.00, 0.82),
            new Product("105", "三星Galaxy Buds Pro", 899.00, 0.80),
            new Product("106", "蓝牙音箱JBL Flip 5", 799.00, 0.65),
            new Product("107", "BOSE QuietComfort 35 II", 2299.00, 0.92),
            new Product("108", "蓝牙耳机挂绳", 19.90, 0.60),
            new Product("109", "运动蓝牙耳机", 299.00, 0.78),
            new Product("110", "蓝牙适配器", 39.90, 0.55),
            new Product("111", "无线蓝牙键盘", 159.00, 0.50),
            new Product("112", "Beats Studio Buds蓝牙耳机", 1099.00, 0.88)
        };
        
        // 执行搜索
        searchSystem.search("蓝牙耳机", products);
    }
}
```

- 我们使用最小堆，让相关性得分最低的商品位于堆顶，这样当找到更相关的商品时，可以方便地移除最不相关的商品
- 当队列大小达到k(5)时，只有比当前堆顶元素更相关的商品才会被加入，同时移除堆顶元素

