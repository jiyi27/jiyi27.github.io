---
title: 常见的 IO 模型
date: 2025-04-22 21:35:26
categories:
 - 面试
tags:
 - 面试
 - 后端面试
---

## 1. 阻塞IO (Blocking IO)

阻塞IO是指在进行IO操作（如读写文件或网络通信）时，调用线程会一直等待直到操作完成。阻塞IO通常实现简单，但在**高并发场景下效率较低**，因为每个连接可能需要一个线程，线程切换和资源占用会成为瓶颈

- 传统的socket编程中 使用 `socket.recv()` 读取网络数据时，线程会等待直到数据到达
- MySQL客户端连接 传统数据库查询（如SELECT）通常是阻塞的，等待数据库返回结果

早期 Java 服务器为每个连接分配一个线程, 遇到高并发（如 C10K）时性能急剧下降, 促使了NIO（非阻塞IO）和 Netty 的流行

> **C10K（Concurrency 10K）问题** 指的是服务器如何高效地处理 1万个并发连接
>
> - 当并发连接数增加（例如C10K问题，即1万个并发连接），服务器需要创建大量线程（每个连接一个线程）
> - 因为线程很多, 操作系统需要处理大量**线程上下文切换**, 这会消耗大量CPU资源
>
> 因此在高并发场景下, BIO模型效率低下, 性能会急剧下降, 这也是为什么 C10K 问题推动了非阻塞 IO（NIO）和异步框架（如Netty）的流行

> **现在的 Spring MVC 不也是为每个连接分配一个线程吗？**
>
> Spring MVC 通常运行在 Servlet 容器（如Tomcat、Jetty）之上, 这些容器的线程模型决定了 Spring MVC 的并发处理方式, **现代Servlet 容器**并不为每个客户端连接分配一个专用线程，而是使用**线程池**和**事件驱动**机制: 在高并发场景下，线程池的大小远小于并发连接数, **线程可以复用**, 极大减少了线程切换和内存开销
>
> 不太懂现代 Servlet 容器的 IO 模型, 为什么是事件驱动?

## 2. 非阻塞IO (Non-blocking IO)

非阻塞IO允许线程在执行IO操作时立即返回，而不会等待操作完成。如果数据不可用，会返回一个错误或标志（如EAGAIN），调用者**需要轮询（polling）来检查状态**。

- **C语言的socket编程**：通过 `fcntl` 设置 `socket` 为 `O_NONBLOCK`, 调用 `recv` 时立即返回
- **Java NIO（New IO）**：使用 `SocketChannel` 配置为非阻塞模式，检查 `read()` 返回值

> 非阻塞IO虽然避免了线程阻塞，但**频繁轮询会消耗CPU资源**，因此单独使用非阻塞IO在高并发场景下效率也不高, **非阻塞IO常与IO复用结合使用**（如 `select` 或 `epoll`），单独使用效率低

### 2.1. 为什么非阻塞IO需要与IO复用结合？

先看看非阻塞 I/O 的使用场景 理解了非阻塞 IO 的使用场景, 才能更好的了解为什么和 IO 复用搭配使用更好:

IO 复用 如何监听的文件描述符? 比如是否可读, 可写等... 



非阻塞IO避免线程等待IO操作完成, 通过IO复用（如select、poll、epoll）高效监控多个IO描述符的状态, 从而**减少轮询开销并提升性能**



你是一个经验丰富的后端开发程序员, 请举例解释 使用 非阻塞IO 的场景

我觉得你可以通过一个实际的例子, 先不使用 IO 复用, 实现, 说出其劣势, 然后配合 IO 复用, 说出解决了什么问题, 如何提高了效率





## 3. IO复用 (IO Multiplexing)

IO复用是指一个线程监控多个IO描述符, 当某个描述符就绪时通知应用程序, 常见的实现包括 `select`、`poll` 和 `epoll`

- **Nginx**：使用 `epoll`（Linux）或 `kqueue`（BSD）处理高并发连接

- **Redis**：基于 `epoll/select` 的单线程事件循环，高效处理客户端请求

- **Python的 `selectors` 模块**：封装了 `select` 和 `epoll`，用于事件驱动编程

- **Java NIO的 `Selector` **：监控多个 `Channel` 的IO事件

- **libevent/libuv**：高性能事件循环库，广泛用于 Nginx、Node.js 等

> 是不是 事件循环 和 IO 复用的关系??
>
> 强调 epoll 相较 select 的性能优势（select的O(n) vs epoll的O(1)），并提到Nginx如何利用epoll实现高并发

> 应用总结:
>
> - **高并发Web服务器**：如Nginx，处理数千个并发连接
>
> - **单线程高性能系统**：如Redis，单线程处理大量客户端请求

## 4. 异步IO (Asynchronous IO)

异步IO是指发起IO操作后立即返回, 操作系统在后台完成IO, 完成后**通过回调、协程或事件通知应用程序**

- **Node.js**：基于 `libuv` 的事件循环，异步处理文件、网络IO
- **Python FastAPI**：依赖 `asyncio` 和 `uvicorn`，通过 `async/await` 实现异步Web服务
- **Java Netty**：异步网络框架，基于NIO和事件驱动，广泛用于高性能服务器
- **Go语言的 goroutine**：通过轻量级协程和 `select` 实现异步IO效果
- **Linux AIO**：如 `libaio`，提供内核级异步文件IO

> 应用总结:
>
> - **高并发Web服务器**：如Node.js、FastAPI，处理大量HTTP请求
> - 提到 Node.js 如何通过 libuv 和 事件循环实现单线程高并发，或 FastAPI 如何利用 asyncio 优化 Python Web 性能
>
> 异步的本质就是通过回调函数来执行, 是这样吗, 异步好像也像是同步:
>
> ```js
> const response = await fetch(....);
> ...
> ```

## 4. 



## 4. 事件驱动 和 异步IO的区别