---
title: 序列化是什么
date: 2025-04-22 10:03:38
categories:
 - 面试
tags:
 - 面试
 - 计算机基础
 - 后端面试
---

## 1. 基本定义

看看[维基百科](https://en.wikipedia.org/wiki/Serialization)的定义:

> In computing, **serialization** is process of translating a data structure or object state into a format that can be stored or transmitted. 序列化是将内存中的数据结构或对象转换为可存储或传输的格式的过程

不是很懂, 看来需要一个例子来解释, 下面是我看到的一段话, 有一些疑问:

> 一个表述说: “序列化是将内存中的数据结构或对象转换为可存储或传输的格式（如二进制数据、XML、JSON等）”
>
> - 内存中的数据结构或者对象 已经是二进制数据了  为什么不可以直接传输? 
>
> - 上面的表述说 “如二进制数据、XML、JSON等”, 网络传输不是只能传输 二进制数据吗, 为什么还有 xml 和 json 呢?

## 2. 对象在内存中的样子

表面上看, 内存中的数据确实是二进制字节（0 和 1）, 但这些字节的组织方式和语义高度依赖于程序的运行时环境, 直接传输这些字节会导致**接收端无法正确解析**:

```go
type Student struct {
	Name   string
	Age    int
	Score  float64
	Active bool
}

func main() {
	student := Student{
		Name:   "Alice",
		Age:    20,
		Score:  95.5,
		Active: true,
	}
	fmt.Printf("Student: %+v\n", student)
	fmt.Printf("Size of Student: %d bytes\n", unsafe.Sizeof(student))
}
```

运行结果 arm64 系统:

```
Student: {Name:Alice Age:20 Score:95.5 Active:true}
Size of Student: 40 bytes
```

为了理解为什么不能直接传输, 我们需要看看 `Student` 结构体在内存中的实际布局:

| 字段       | 大小   | 内存内容（示例）                                 |
| ---------- | ------ | ------------------------------------------------ |
| Name (ptr) | 8 字节 | 指针，指向 "Alice" 的内存地址（如 `0x12345678`） |
| Name (len) | 8 字节 | 字符串长度（`5`，表示 "Alice" 的长度）           |
| Age        | 8 字节 | 整数 `20`（二进制表示）                          |
| Score      | 8 字节 | 浮点数 `95.5`（IEEE 754 格式）                   |
| Active     | 1 字节 | 布尔值 `1`（true）                               |
| Padding    | 7 字节 | 填充字节（通常为 0，用于对齐）                   |

> 在 Go 中, string 是一个结构体, 包含两个字段:
>
> - 指向字符串数据的指针（`unsafe.Pointer`, 8 字节）
> - 字符串长度（`int`, 8 字节）
>
> 所以 string 总共占用 16 字节, 例如，`Name: "Alice"` 的实际数据（`"Alice"` 的字节 `[65, 108, 105, 99, 101]`）存储在内存的某个区域，`Name` 字段只保存指向该区域的指针和长度

假设 `student` 结构体存储在内存地址 `0x1000`，其二进制数据可能如下（简化表示）：
- `0x1000 - 0x1007`：`Name` 的指针（例如 `0x12345678`，指向 `"Alice"` 的实际数据的地址）
- `0x1008 - 0x100F`：`Name` 的长度（`5`）
- `0x1010 - 0x1017`：`Age` 的值（`20`，二进制 `00000014`）
- `0x1018 - 0x101F`：`Score` 的值（`95.5`，IEEE 754 格式的二进制）
- `0x1020`：`Active` 的值（`1`，表示 `true`）
- `0x1021 - 0x1027`：填充字节（`0`）

**关键点**：

- `Name` 字段的指针（`0x12345678`）指向内存中 `"Alice"` 的实际数据（`[65, 108, 105, 99, 101]`）的地址
- 这些二进制数据高度依赖 Go 的运行时环境，比如：
  - 指针地址（`0x12345678`）只在当前程序的内存空间有效
  - 内存对齐和填充字节依赖于 Go 编译器和 CPU 架构
  - `"Alice"` 的实际数据存储在堆上，由 Go 的垃圾回收器管理

## 3. 内存中的数据结构已经是二进制数据，为什么不能直接传输？

现在，假设我们将这 40 字节的二进制数据（从 `0x1000` 到 `0x1027`）直接传输到另一台机器, 接收端会遇到以下问题:

### 3.1. 指针无效

- **问题**：`Name` 字段的指针（`0x12345678`）指向当前程序的内存地址, 在接收端的机器上, 这个地址要么无效（指向不存在的内存）, 要么指向完全无关的数据
- **后果**：接收端无法访问 `"Alice"` 的实际数据（`[65, 108, 105, 99, 101]`），因为这些数据没有随结构体一起传输
- **解决方法**：序列化（如 JSON）会将 `"Alice"` 的实际内容嵌入到序列化数据中, 而不是只传输指针, 例如, JSON 会生成 `{"name":"Alice",...}`

### 3.2. 缺少类型信息

- **问题**：内存中的二进制数据没有显式的类型信息, 接收端不知道：
  - 这 32 字节代表一个 `Student` 结构体
  - 前 16 字节是 `string`，接下来的 8 字节是 `int`，等等
- **后果**：接收端无法正确解析二进制数据，除非它运行完全相同的 Go 程序（相同的结构体定义和编译器）
- **解决方法**：序列化格式（如 JSON）通过键值对显式定义字段名和值（`{"name":"Alice","age":20}`），接收端根据字段名重建数据结构

### 3.3. 内存布局不兼容

- **问题**：不同系统、编译器或 Go 版本可能有不同的内存布局：
  - 32 位 vs. 64 位系统：`int` 和指针的大小不同（4 字节 vs. 8 字节）
  - 内存对齐规则：某些系统可能不使用 8 字节对齐，填充字节不同
  - 字段顺序：编译器可能重新排列字段以优化内存访问（尽管 Go 通常按声明顺序）
- **后果**：接收端可能错误解析字段, 例如，接收端可能将 `Age` 的 8 字节解析为两个 4 字节字段，导致数据错乱
- **解决方法**：序列化格式（如 JSON）是标准化的，字段顺序和类型由格式定义（如 `{"name":"Alice","age":20}`），与内存布局无关

### 3.4. 跨语言和跨平台问题

- **问题**：如果接收端不是 Go 程序（比如 Python 或 Java），它无法理解 Go 的内存布局（指针、字符串结构体、内存对齐等）
- **后果**：非 Go 程序无法解析这 32 字节的二进制数据
- **解决方法**：序列化格式（如 JSON、XML）是语言无关的，Python 和 Java 都能解析 `{"name":"Alice","age":20}`

### 3.5. 示例：直接传输的失败场景

假设我们将 `student` 的 32 字节内存数据传输到另一台机器：
- 发送端：传输 `[0x12345678, 5, 20, 95.5, 1, 0, 0, 0, 0, 0, 0, 0]`
- 接收端：
  - 看到 `0x12345678`，但这个地址无效，无法找到 `"Alice"`
  - 不知道前 16 字节是 `string`，可能误以为是两个 `int64`
  - 内存对齐不同，可能将 `Age` 的 8 字节解析为其他类型
- 结果：数据完全不可用

> 所以我对序列化的理解是:
>
> - **序列化**是将内存中的对象转换为一种**约定好的格式**（如 Protobuf、JSON、Gob、XML 等）
>
> - 这些格式在网络传输时仍然是**二进制数据**（字节流）
>
> - 但这些二进制数据是按照**约定的格式**组织的，而不是内存中对象的**原始内存格式**

## 4. 更上一层楼 (加深理解)

### 4.1. 序列化是将内存对象转为约定格式

- 内存中的对象（比如 Go 的 `struct`）包含复杂的信息：指针、类型元数据、内存对齐填充、运行时状态等
- 序列化的目的是将这些对象转换为一种标准化的、平台无关的格式
  - 去除指针，直接嵌入实际数据（比如 `"Alice"` 的字符），**只保留数据的逻辑内容**
  - 去除了填充和运行时元数据
  - 使用标准化的结构（键值对、字段标签等），确保跨平台、跨语言可解析
- 例如：
  - JSON：`{"name":"Alice","age":20}`
  - Protobuf：紧凑的二进制格式，包含字段标签和值
  - Gob：Go 专用的二进制格式，包含类型信息和数据
  - XML：`<person><name>Alice</name><age>20</age></person>`

### 4.2. 传输时是二进制数据, 但按约定格式组织：

- 网络传输只能传输二进制字节流（0 和 1）
- 序列化后的数据（JSON、XML 等）在传输前会被编码为二进制字节流。例如：
  - JSON 字符串 `{"name":"Alice"}` 编码为 UTF-8 字节（`[123, 34, 110, 97, 109, 101, 34, ...]`）
  - Protobuf 直接生成紧凑的二进制字节，包含字段编号和值
- 这些字节流的组织方式遵循约定的格式规则（比如 JSON 的键值对结构，Protobuf 的字段标签），**接收端根据相同的规则解析**

### 4.4. 代码示例
```go
type Student struct {
	Name   string
	Age    int
	Score  float64
}

func main() {
	student := Student{Name: "Alice", Age: 20, Score: 95.5}

	// 1. 序列化为 JSON
	jsonData, err := json.Marshal(student)
	if err != nil {
		log.Fatalf("JSON 序列化失败: %v", err)
	}
	fmt.Println("JSON 数据:", string(jsonData))
	fmt.Println("JSON 字节:", jsonData)

	// 2. 序列化为 Gob
	var buf bytes.Buffer
	enc := gob.NewEncoder(&buf)
	err = enc.Encode(student)
	if err != nil {
		log.Fatalf("Gob 序列化失败: %v", err)
	}
	fmt.Println("Gob 字节:", buf.Bytes())

	// 3. 反序列化 JSON
	var jsonStudent Student
	err = json.Unmarshal(jsonData, &jsonStudent)
	if err != nil {
		log.Fatalf("JSON 反序列化失败: %v", err)
	}
	fmt.Printf("JSON 反序列化结果: %+v\n", jsonStudent)

	// 4. 反序列化 Gob
	var gobStudent Student
	dec := gob.NewDecoder(&buf)
	err = dec.Decode(&gobStudent)
	if err != nil {
		log.Fatalf("Gob 反序列化失败: %v", err)
	}
	fmt.Printf("Gob 反序列化结果: %+v\n", gobStudent)
}
```

**输出（部分简化）**

```
JSON 数据: {"Name":"Alice","Age":20,"Score":95.5}
JSON 字节: [123 34 78 97 109 101 34 58 34 65 108 105 99 101 34 44 ...]
Gob 字节: [40 255 129 3 1 1 7 83 116 117 100 101 110 116 ...]
JSON 反序列化结果: {Name:Alice Age:20 Score:95.5}
Gob 反序列化结果: {Name:Alice Age:20 Score:95.5}
```

### 4.5. 内存数据 vs. 序列化数据的对比

| 特性             | 内存中的二进制数据               | 序列化数据（JSON）                    |
| ---------------- | -------------------------------- | ------------------------------------- |
| **内容**         | 指针、长度、值、填充字节         | 实际数据（`"Alice"`、20、95.5、true） |
| **大小**         | 32 字节（固定，含指针和填充）    | 变长（约 50 字节，视数据内容）        |
| **平台依赖**     | 高度依赖（指针、内存对齐、架构） | 平台无关（标准化的文本格式）          |
| **类型信息**     | 隐式（依赖 Go 运行时）           | 显式（键值对定义字段和类型）          |
| **跨语言支持**   | 不支持（仅 Go 程序可解析）       | 支持（JSON 被广泛支持）               |
| **传输后可用性** | 不可用（指针无效，布局不同）     | 可用（接收端可直接解析）              |


