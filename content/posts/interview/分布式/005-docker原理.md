---
title: Docker 原理
date: 2025-05-01 09:56:20
categories:
 - 面试
tags:
 - 面试
 - 分布式面试
---

## 1. 容器技术是一个盒子

有次面试被问到 Docker 和 虚拟机的区别, 当时答的很不好, 就说了 Docker 是共享的, 虚拟机是独立完整的系统, 至于具体, 抱歉, 俺不知道, 今天来研究一下, Docker 到底是什么

本质上容器技术其实就是把应用隔离在一个盒子内, 因为有了盒子边界的存在, 应用于应用之间不会相互干扰, 首先应该知道这三点:

- 一个容器实例是根据一个 image 创建的
- 容器运行后, 本质上就是一个普通的 Linux 进程, 就像运行微信、Chrome 一样, 它本身也是进程
- 不同的是, Docker 在启动这个进程的时候, 给它“加上了边界”, 从而形成了一个隔离的容器 (进程运行的时候有了隔离的环境)

## 2. “边界”怎么理解？

### 2.1. “看得见”的隔离（Namespace）——容器只能看到自己的世界

举例来说, 这个容器进程:

- 看不到宿主机上的其他进程（通过 **PID Namespace** 实现）
- 有自己的文件系统视角（通过 **Mount Namespace**）
- 使用自己的 IP、网卡、路由表等（通过 **Network Namespace**）
- 拥有自己的主机名（通过 **UTS Namespace**）
- 只能访问容器内部的共享内存或消息队列（**IPC Namespace**）

这些就像是你住在一个完全隔音、封闭的房间里，你的“视野”完全被局限在这个房间内，看不到别的用户，也听不到外面的声音

### 2.2. “看不见”的限制（Cgroups）——容器不能用太多资源

Cgroups 限制容器进程能使用多少资源, 比如：

- 最多只能用 512MB 内存
- 只能用 0.5 个 CPU
- 限制磁盘和网络带宽

这就像是在你的房间里，还限制了你能用的电、水、网速

> 容器中的进程和微信、Chrome 没什么本质区别, **但它被一层“墙”包裹起来了**, 这堵墙由 Namespace 提供的“隔离视野”和 Cgroups 提供的“资源限制”共同构成, Docker 正是利用这些技术, 才实现了容器的轻量级沙盒效果

### 3. 一些基础概念

### 3.1. Image 是什么？

镜像由 Dockerfile 构建, 可以把 镜像理解为构建容器的“模板”, 就像房子的设计图, 它定义了:

- 容器里的操作系统（比如 Ubuntu、Alpine）
- 安装了哪些软件（比如 Python、Nginx、Node.js、GCC）
- 设置了哪些环境变量
- 启动时运行什么命令

一个镜像本身是**静态的**, 不能运行, 只有把它运行起来, 才变成了容器（也就是上面说的带边界的进程）

### 3.2. 镜像是分层的

每一条 Dockerfile 指令（比如 `FROM`, `RUN`, `COPY`, `ADD` 等）都会生成一层文件系统快照, 就是一个 Layer:

```docker
FROM ubuntu:22.04        # 第 1 层：Ubuntu 基础系统
RUN apt update           # 第 2 层：执行 apt update 后的状态
RUN apt install -y curl  # 第 3 层：安装了 curl 后的状态
COPY . /app              # 第 4 层：自己的代码加进来
```

每一行会创建一个新的“层”, 这些层就像叠积木一样, 一层压一层, 最终形成一个完整的镜像

> **节省空间 & 加速构建**
>
> - 比如你有两个镜像都以 `ubuntu:22.04` 为基础, 那它们会共用“第 1 层”, 不需要重复下载
>
> - 如果你改了最后一行 Dockerfile, 那么只有最后那一层会重新构建, 前面三层还是复用缓存, 加快构建速度
>
> **易于分发 & 版本控制**
>
> - 每一层都有一个唯一 ID, 相当于文件系统的快照, 这样可以追踪每一层的变动, 甚至在多个主机之间只同步有变化的层, 极大提升效率





