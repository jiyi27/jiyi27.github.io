---
title: MySQL 事务 悲观锁 乐观锁 数据一致性 
date: 2025-02-17 20:39:22
categories:
 - 数据库
tags:
 - 数据库
 - 并发编程
 - 面试
---

## 1. 事务

### 1.1. 事务的概念

事务是一组要么全部成功，要么全部失败的数据库操作，保证数据的一致性。

假设你要从 A 账户转 100 元到 B 账户，这个过程涉及两个操作：

1. 从 A 账户扣 100 元
2. 给 B 账户加 100 元

如果第一步执行了，但第二步失败了，就会导致 A 的钱少了，但 B 没收到钱，这导致了数据一致性问题。事务可以防止这种情况。

```mysql
START TRANSACTION;
-- 从 A 账户扣 100 元
UPDATE accounts SET balance = balance - 100 WHERE name = 'A';
-- 给 B 账户加 100 元
UPDATE accounts SET balance = balance + 100 WHERE name = 'B';
COMMIT;
```

如果在执行过程中出现错误（比如 B 账户不存在），可以执行回滚，撤销已经执行的操作。

> **拓展:** 在 MySQL（InnoDB 存储引擎）中，单个 DML 语句（INSERT, UPDATE, DELETE）本身就是一个事务，如果 `AUTOCOMMIT` 处于默认开启状态，它会自动提交，不需要手动 `COMMIT`。
>
> 在数据修改操作（Update、Delete、Insert）中, MySQL InnoDB 会**自动**对受影响的行加上 x 锁, 事务提交的时候(语句执行完成), x锁会被自动释放。

> **后端开发:** 在 Spring Data JPA 中，事务管理是由 Spring 的事务管理器（通常是 `@Transactional` 注解）来控制的，自动回滚行为也由 Spring 决定。Spring 默认会在遇到 **运行时异常（RuntimeException 及其子类）** 或 **错误（Error）** 时自动回滚事务。
>
> 如果在事务方法内部捕获了异常，并没有将异常抛出到事务管理器，那么 Spring 不会感知到异常，从而事务不会自动回滚。
>
> ```java
> @Transactional
> public void updateSomeData() {
>     try {
>         // 一些数据库操作
>         // 可能抛出异常
>     } catch (Exception e) {
>         // 捕获异常后不重新抛出，事务将按正常流程提交
>     }
> }
> ```

### 1.2. 事务不是导致错误的原因，而是处理错误的机制

连接类错误, 语法错误, 系统资源相关错误, 数据完整性和约束错误, 事务和锁相关错误, 前几种没什么好说的, 看一下最后两种:

- 违反完整性约束的错误: 数据库自身的机制, 比如：主键重复、外键不存在、唯一约束冲突、`CHECK` 约束失败等
- 事务和锁相关错误: 在事务操作中遇到死锁或锁等待等问题
  - 两个或多个事务在等待对方持有的资源而形成循环依赖，导致系统检测到死锁。
  - 事务等待获取资源的时间超出了设定的超时时间，可能需要检查当前事务的锁竞争情况

**事务不是导致错误的原因，而是处理错误的机制:**

| **情况**                 | **数据库是否报错？** | **事务是否回滚？**   |
| ------------------------ | -------------------- | -------------------- |
| 主键冲突                 | ✅ 报错               | ✅ 回滚（事务开启时） |
| 外键约束失败             | ✅ 报错               | ✅ 回滚（事务开启时） |
| 唯一约束失败             | ✅ 报错               | ✅ 回滚（事务开启时） |
| 业务逻辑错误（如负余额） | ✅ 报错               | ✅ 回滚（事务开启时） |

1. 没开启事务时, 每条 SQL 都是独立提交的, 报错不会回滚之前的操作
2. 事务不会主动报错，报错的原因是 SQL 语句违反数据库的完整性约束
3. 事务的作用是确保错误发生时，数据不会进入不一致的状态, 事务只是处理数据库错误的工具, 并不是开启事务就万事大吉了

### 1.3. 事务的特性

**原子性（Atomicity）** 

- 事务是一个不可分割的最小操作单元，要么全部执行成功，要么全部回滚
- 以转账场景为例，一个账户的余额减少，另一个账户的余额增加，这两个操作一定是同时成功或者同时失败的

**一致性（Consistency）** 

- 事务执行前后，数据库必须保持一致性状态，即不会违反数据库的完整性约束

**隔离性（Isolation）**

- 并发事务互不影响，一个事务未提交前，其他事务无法看到其变化

**持久性（Durability）**

- 事务提交后，其修改的数据会被永久保存，即使系统崩溃也不会丢失

**一致性并不是事务本身的固有属性, 而更像是一种外在要求,** 不难发现其他三个都是实打实的特征, 唯独一致性, 无法理解, 这里的一致性更像是一种外在要求, 而不是事务本身的固有的属性, 即是一种需要依赖业务层逻辑来实现的状态,

举个不恰当的例子, 我们说一个苹果, 苹果是圆的, 苹果可以为我们提供维生素C, 这都是苹果的特征, 可是你却说, 苹果也有生吃性, 苹果必须生吃才能最大化的提供营养价值, WTF? 生不生吃苹果取决于个人啊, 这怎么能是苹果的特性呢?

同理, 数据库是不是保持一致性, 这取决于业务逻辑啊, 比如需要结合锁来实现, 什么悲观锁, 乐观锁, 这怎么能是事务的特性呢?





## 2. 数据一致性问题

### 2.1. 直接修改操作 - 隐式 x 锁

比如常见的转账例子多个人给同一个账户转 100 块钱,  系统可能会有下面的命令:

```mysql
UPDATE account SET balance = balance + 100 WHERE account_id = 002;
```

高并发状态下, A事务读取到此时账户余额为 100, B事务 也读取到账户余额为 100, 

- A 事务: 余额 = 100 + 100 = 200, 
- B 事务:  余额 = 100 + 100 = 200

最后账户余额仅为 200 而不是 300, 导致数据一致性问题, 因为 InnoDB 会在执行 UPDATE 时对目标行加上排它锁（X 锁）, 从而确保这些操作是串行化的, 

好像是告诉事务, 你想更新 `account_id = 002` 的数据? 行, 但请先获得这行数据的 X 锁, 所以不可能会有两个事务同时对同一行执行 UPDATE 操作, 也就是说使用单条 UPDATE 语句时, 不会出现多个事务都获取到相同 balance 的情况, 因为数据修改操作都是串行化的, 

> 在数据修改操作（Update、Delete、Insert）中, 事务会先尝试获得受影响行的 X 锁, 若得到, 才能进行更新, 否则只能等待, 不要忘了单个语句, 也默认属于一个事务

### 2.2. 检查 + 修改操作 -  显式 x锁 (悲观锁) 或乐观锁

这种属于多个事务中基于过时数据进行判断后再写入更新的场景, 读取数据与更新操作之间缺乏必要的锁机制保护, 导致多个事务基于同一份数据进行判断并更新, 从而引发数据不一致, 

上面的例子过于简化了, 实际系统肯定不会直接给账户加钱, 还有很多考虑, 比如检查收账人是否存在, 检查转账人的余额是不是足够, 然后进行扣款, 

**步骤 1：同时读取余额**

- 事务 A 和事务 B 同时对转账人账户执行查询操作，读取到余额都为 100 元
- 此时，如果没有加锁（如 `FOR UPDATE`），两个事务都基于相同的旧数据做判断

**步骤 2：判断余额充足**

- 事务 A 判断：100 元 >= 转账金额 80 元，认为余额足够
- 事务 B 同样判断：100 元 >= 转账金额 60 元，也认为余额足够

**步骤 3：分别执行扣款**

- 事务 A 扣款 80 元，更新余额为 20 元
- 事务 B 扣款 80 元，同样在自己的事务中基于最初读取到的 100 元执行更新，更新余额为 40 元
- 最终两个事务都成功提交，导致余额可能是40, 也可能是20, 也可能是100 - 80 - 60 = -40, 导致余额出现问题（负数或不一致）。

**解决办法1: 悲观锁**

```mysql
BEGIN;
SELECT balance FROM accounts WHERE id = ? FOR UPDATE; -- 加锁
-- 判断余额是否充足, 通过业务代码实现, SQL 无法实现逻辑判断
UPDATE accounts SET balance = balance - ? WHERE id = ?;
COMMIT;
```

这样可以确保在一个事务完成之前，其他事务必须等待，避免同时读取同一份数据进行判断。

**解决办法2: 乐观锁**

```mysql
BEGIN;
SELECT balance, version FROM accounts WHERE id = ?;
-- 判断余额是否充足, 通过业务代码实现, SQL 无法实现逻辑判断
UPDATE accounts SET balance = balance - ?, version = version + 1
WHERE id = ? AND version = ?;
-- 判断 UPDATE 是否成功, 否则重试或抛出异常返回给客户端执行失败, 通过业务代码实现
COMMIT;
```

### 2.3. 多表操作 - 事务原子性

除此之外还要确保转账人的账户 -100, 收款人的账户 +100, 不能出现后者操作失败了, 导致收款人账户余额没变, 转账人账户的钱却少了 100, 这也是属于数据不一致, 

这种很简单, 把更新两张表的语句放到同一个事务里就行了, 因为可以利用事务的回滚保证, 若有一个操作失败, 则同时都失败, 
