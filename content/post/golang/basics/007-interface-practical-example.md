---
title: Golang Interface & Interface in Web App
date: 2023-08-22 13:03:05
categories:
 - golang
 - basics
tags:
 - golang
---

## 1. Empty Interface - Wildcard

In golang, you can treat an empty interface as a wildcard. For example, in a third part library gorilla/session:

```go
// Session stores the values and optional configuration for a session.
type Session struct {
	// The ID of the session, generated by stores. It should not be used for
	// user data.
	ID string
	// Values contains the user-data for the session.
	Values  map[interface{}]interface{}
	Options *Options
	IsNew   bool
	store   Store
	name    string
}
```

The field of Session: Values is a map whoes key can value can be any type:

```go
session.Values["name"] = "John"
session.Values["balance"] = 2000
session.Values["messages"] = []byte
session.Values[3] = "123"
```

When you take value from an empty interface, you need type asseration:

```go
messages := session.Values["messages"].([]byte)
name := session.Values["name"].(string)
// or you can write like this
str, ok := value.(string)
if ok {
    fmt.Printf("string value is: %q\n", str)
} else {
    fmt.Printf("value is not a string\n")
}
```

Because  the type of  ` session.Values[xxx] ` is `interface{}`, you can store any value in it directly but when you wnat take value form it you have let compiler know which type stored in this empty interface. 

Learn more: 

https://shaowenzhu.top/post/golang/basics/014-gob-json-encoding/#27-gobregister-method

https://shaowenzhu.top/post/golang/basics/001-syntax/#7-type-assertions

## 2. Any types can implement an interface

"Any types can implement an interface." is not accurate, I think "Any type can have its [method set](https://golang.org/ref/spec#Method_sets), and if there are all the methods of an interfacce in that type's method set, we say this type implements this interface." This type can be a function, map, struct even an int. 

>Interfaces in Go provide a way to **specify the behavior of an object**: if something can do *this*, then it can be used *here*.

Learn more: https://shaowenzhu.top/post/golang/basics/006-interfaces-golang/#3-first-try---type-admin-isnt-adimin

### 2.1. `http.HandleFunc`

I'll give you a practical example in Go web dev:

```go
func helloHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Hi there, I love %s!", r.URL.Path[1:])
}

func main() {
    http.HandleFunc("/", helloHandler)
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

`  HandleFunc()`  signature:

```go
func HandleFunc(pattern string, handler func(ResponseWriter, *Request))
```

The second parameter of `HandleFunc()` is a function type, `helloHandler` is `func(ResponseWriter, *Request)` type, therefore, we can pass it as a callback function into `HandleFunc()`

### 2.2. `http.Handle` 

There is another function called `http.Handle()` can be used to set routing info and callback, which has a different parameter compared with function `http.HandleFunc()`:

```go
func Handle(pattern string, handler Handler)
```

The second pamrameter is a `Handler` which is an interface type defined in http package:

```go
type Handler interface {
	ServeHTTP(ResponseWriter, *Request)
}
```

### 2.3. function type implement interface

Therefore, any types whose method set has `ServeHTTP(ResponseWriter, *Request)` inside, we can say this type can be used as interface `http.Handler`. 

I'll use two different types to implemet the interface `http.Handler`, first is a function type:

```go
type myWebHandler func(http.ResponseWriter, *http.Request)

func (mwh myWebHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		http.Error(w, "method not supported", http.StatusMethodNotAllowed)
		return
	}
	_, _ = fmt.Fprintf(w, "do something before custom handler mwh(w, r)")
	mwh(w, r)
}

func main() {
	callback := myWebHandler(func(w http.ResponseWriter, r *http.Request) {
		_, _ = fmt.Fprintf(w, "hello there")
	})
	
  // myWebHandler implemented interface http.Handler, so its object can passed here
	http.Handle("/hello", callback)
	log.Fatal(http.ListenAndServe(":8080", nil))
}
```

**NOTE:** for struct, when you gengerate a value ("object") you should use curly brcket `{}` as below:

```go
type Cat struct {
  name string
  age int
}

cat := Cat{name: "Kitten", age: 3}
```

for a function  type, we use parentheses to produce a value of that type:

```go
type myWebHandler func(http.ResponseWriter, *http.Request)

callback := myWebHandler(func(w http.ResponseWriter, r *http.Request) {
		_, _ = fmt.Fprintf(w, "hello there")
})
```

### 2.4. struct type implement interface

```go
type Counter struct {
	n int
}

// "_ *http.Request" can be changed to "req *http.Request", just eliminate warning
func (ctr *Counter) ServeHTTP(w http.ResponseWriter, _ *http.Request) {
	ctr.n++
	_, _ = fmt.Fprintf(w, "this page has benn visited = %d times\n", ctr.n)
}

func helloHandler(w http.ResponseWriter, r *http.Request) {
	_, _ = fmt.Fprintf(w, "Hi there, I love %s!", r.URL.Path[1:])
}

func main() {
	http.HandleFunc("/", helloHandler)
  // the pointer type of Counter implements interface Handler, not Counter, 
  // so we have to pass ""&Counter{n: 0}"" here
	http.Handle("/count", &Counter{n: 0})
	log.Fatal(http.ListenAndServe(":8080", nil))
}
```

We can achieve this feature with function type too:

```go
type WrapperFunc func(w http.ResponseWriter, r *http.Request)

func (mwh WrapperFunc) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	_, _ = fmt.Fprintf(w, "do something before call mwh(w, r) \n")
	mwh(w, r)
}

func countHandler(n *int) http.Handler {
	// type WrapperFunc implemented http.Handler
	// so we can return an instance of WrapperFunc here,
	return WrapperFunc(func(w http.ResponseWriter, r *http.Request) {
		*n++
		_, _ = fmt.Fprintf(w, fmt.Sprintf("this page has been visited %d times\n", *n))
	})
}

func main() {
	c := 0
	http.Handle("/count", countHandler(&c))
	log.Fatal(http.ListenAndServe(":8080", nil))
}
```

### 2.5. `http.HandlerFunc` 

http package has already made a function implement `http.Handler`:

```go
// The HandlerFunc type is an adapter to allow the use of
// ordinary functions as HTTP handlers. If f is a function
// with the appropriate signature, HandlerFunc(f) is a
// Handler that calls f.
type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(w, r).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
	f(w, r)
}
```

` type HandlerFunc func(ResponseWriter, *Request)`  is actually same as `type WrapperFunc func(w http.ResponseWriter, r *http.Request)` we talked before, both of them are a wrapper, 

> Don't make mistak from `http.HandleFunc`  and `HandlerFunc`, they have different name, former is just a value of a function, latter is a function. 

References:

- [HTTP Closures](https://gist.github.com/tsenart/5fc18c659814c078378d)
- [Structuring Applications in Go. How I organize my applications in Go | by Ben Johnson | Medium](https://medium.com/@benbjohnson/structuring-applications-in-go-3b04be4ff091)
