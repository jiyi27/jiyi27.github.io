---
title: Golang Interface & Interface in Web App
date: 2023-08-22 13:03:05
categories:
 - golang
 - basics
tags:
 - golang
---

## 1. Empty Interface - Wildcard

Java 中的 `Object `类是所有类的父类, 可以作为一个 Wildcard, Go 里与之对应的是个空 interface, 

如 gorilla/session 里 Session 的定义, 

```go
// Session stores the values and optional configuration for a session.
type Session struct {
	// The ID of the session, generated by stores. It should not be used for
	// user data.
	ID string
	// Values contains the user-data for the session.
	Values  map[interface{}]interface{}
	Options *Options
	IsNew   bool
	store   Store
	name    string
}
```

Values 是个 map, key可以是任何类型, key对应的值也可以是任何类型, 如在代码中可以这么写:

```go
session.Values["name"] = "John"
session.Values["balance"] = 2000
session.Values["messages"] = []byte
session.Values[3] = "123"
```

只是之后用到这些值时, 需要使用 type assertions, 

```go
messages := session.Values["messages"].([]byte)
name := session.Values["name"].(string)
```

因为 ` session.Values[xxx] ` 在编译器看来只是个空 interface, 可以用来存储任何类型的值, 但当你拿来用时, 需要告诉编译器它的类型, 

## 2. 任何类型都可以实现接口

之前的印象中, 只有类可以实现接口, 这样才有意义, 比如常见的接口 Animal, Shape, 实现这些接口的类可以是Cat, Dog, Rect, Circle, 

在 golang 里, 一个函数甚至一个 int 都可以实现接口, 

>Interfaces in Go provide a way to **specify the behavior of an object**: if something can do *this*, then it can be used *here*.

### 2.1. `http.HandleFunc`

通过例子来解释, 实现一个简单的 Go Web:

```go
func helloHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Hi there, I love %s!", r.URL.Path[1:])
}

func main() {
    http.HandleFunc("/", helloHandler)
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

`  HandleFunc`  signature:

```go
func HandleFunc(pattern string, handler func(ResponseWriter, *Request))
```

第二个参数是个function, `helloHandler` 也是 `func(ResponseWriter, *Request)` 类型, 因此可以当作 callback 传入, 

### 2.2. `http.Handle` 

` http`  package 里还有个函数可以设置 router 信息以及 callback, 类似 `http.HandleFunc`, 只是参数类型不同:

```go
func Handle(pattern string, handler Handler)
```

第二个参数 `Handler` 是个 interface, 在 `http` package 定义如下:

```go
type Handler interface {
	ServeHTTP(ResponseWriter, *Request)
}
```

也就是说, 若想使用 `http.Handle()` 来定义 routing 信息以及对应的 callback, 则需要实现 interface Handler, 前面提到不仅是 struct 可以实现 interface, function 也可以, 

### 2.3. function type implement interface

这里讨论两个 interface 的实现方法, 分别为 struct 和 function, 首先是 function type:

```go
type myWebHandler func(http.ResponseWriter, *http.Request)

func (mwh myWebHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		http.Error(w, "method not supported", http.StatusMethodNotAllowed)
		return
	}
	_, _ = fmt.Fprintf(w, "do something before custom handler mwh(w, r)")
	mwh(w, r)
}

func main() {
	callback := myWebHandler(func(w http.ResponseWriter, r *http.Request) {
		_, _ = fmt.Fprintf(w, "hello there")
	})
	
  // myWebHandler implemented interface http.Handler, so its object can passed here
	http.Handle("/hello", callback)
	log.Fatal(http.ListenAndServe(":8080", nil))
}
```

这里注意一下语法, 对于 type struct, 产生 instance 的方法为 curly bracket, 

```go
type Cat struct {
  name string
  age int
}

cat := Cat{name: "Kitten", age: 3}
```

对于 type function, 产生 instance, 需要使用 parentheses, 

```go
type myWebHandler func(http.ResponseWriter, *http.Request)

callback := myWebHandler(func(w http.ResponseWriter, r *http.Request) {
		_, _ = fmt.Fprintf(w, "hello there")
})
```

这里, callback 就是 myWebHandler 的一个对象, 

### 2.4. struct type implement interface

```go
type Counter struct {
	n int
}

// "_ *http.Request" can be changed to "req *http.Request", just eliminate warning
func (ctr *Counter) ServeHTTP(w http.ResponseWriter, _ *http.Request) {
	ctr.n++
	_, _ = fmt.Fprintf(w, "this page has benn visited = %d times\n", ctr.n)
}

func helloHandler(w http.ResponseWriter, r *http.Request) {
	_, _ = fmt.Fprintf(w, "Hi there, I love %s!", r.URL.Path[1:])
}

func main() {
	http.HandleFunc("/", helloHandler)
  // the pointer type of Counter implements interface Handler, not Counter, 
  // so we have to pass ""&Counter{n: 0}"" here
	http.Handle("/count", &Counter{n: 0})
	log.Fatal(http.ListenAndServe(":8080", nil))
}
```

此功能也可以用前面的 function type 来实现:

```go
type WrapperFunc func(w http.ResponseWriter, r *http.Request)

func (mwh WrapperFunc) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	_, _ = fmt.Fprintf(w, "do something before call mwh(w, r) \n")
	mwh(w, r)
}

func countHandler(n *int) http.Handler {
	// type WrapperFunc implemented http.Handler
	// so we can return an instance of WrapperFunc here,
	return WrapperFunc(func(w http.ResponseWriter, r *http.Request) {
		*n++
		_, _ = fmt.Fprintf(w, fmt.Sprintf("this page has been visited %d times\n", *n))
	})
}

func main() {
	c := 0
	http.Handle("/count", countHandler(&c))
	log.Fatal(http.ListenAndServe(":8080", nil))
}
```

### 2.5. `http.HandlerFunc` 

http package 已经帮我们写了一个实现了 `http.Handler` 的 function type, 如下:

```go
// The HandlerFunc type is an adapter to allow the use of
// ordinary functions as HTTP handlers. If f is a function
// with the appropriate signature, HandlerFunc(f) is a
// Handler that calls f.
type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(w, r).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
	f(w, r)
}
```

可以看出` type HandlerFunc func(ResponseWriter, *Request)` 与前面自定义的 `type WrapperFunc func(w http.ResponseWriter, r *http.Request)` 一样, 都是 wrapper, 只是  HandlerFunc 在 ` ServeHTTP` 里什么都没做, 只是简单调用callback, 

> 不要把此函数类型与上面提到的函数 `http.HandleFunc`  弄混, 不仅是名字不同, 前者是个函数类型, 后者就是个函数, 

### 2.6 conclusion

可以看到不同的 interface 实现途径, 有不同的效果, 

前者使用 function type 实现 interface http.Handler, 达到了一个 wrapper 的效果, 即在真正处理 http 相关数据之前或者之后做一些事, 比如对 http 做过滤, 直接受 POST 方法, 

而后面使用 struct 实现  interface http.Handler, 达到了记录 state 的目的, 因为 struct 可以保存变量, 从而让我们实现计数

参考:

- [HTTP Closures](https://gist.github.com/tsenart/5fc18c659814c078378d)
- [Structuring Applications in Go. How I organize my applications in Go | by Ben Johnson | Medium](https://medium.com/@benbjohnson/structuring-applications-in-go-3b04be4ff091)
