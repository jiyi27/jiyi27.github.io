<!DOCTYPE html>
<html lang="en">
<head>
  
    
    <title>零碎知识 &#43; 踩坑 - Python :: 为霜的博客</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="1. 删除列表中除前两个元素外的所有元素 def keep_first_two_del() -&gt; None: global messages if len(messages) &gt; 2: del messages[2:] # 删除从第2个索引（第3个元素）到末尾 del messages[2:]：从索引 2（第 3 个元素）开始删除到列表末尾 如果 messages = [1, 2, 3, 4, 5]，执行后变成 [1, 2] def keep_first_two_slice() -&gt; None: global messages if len(messages) &gt; 2: messages = messages[:2] # 保留从开头到第2个元素 messages[:2]：切片从开头到索引 2（不包括索引 2），即前两个元素 del messages[2:]：直接修改原始列表, del是就地操作, 更高效
messages = messages[:2]：创建新列表并重新赋值, 切片赋值创建新列表, 稍占内存
2. from xxx import xxxx vs import xxx 行为 2.1. from xxx import xxxx 在 Python 中, from data import messages 的语法会:
" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://blog.jiyi27.com/posts/python/basics/002-nuggets-python/" />





  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/buttons.min.2bc533403a27dfe0e93105a92502b42ce4587e2e4a87d9f7d349e51e16e09478.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/categories.min.3202f75cbb294747099af3850a68a09ee94b3ce505fc39e134692d90ff0a9b2a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/code.min.dd73d157e77e82a3dc1cb06ba424cf6cc6811af0bb604ad6c68e70faf2439c8a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/fonts.min.4881f0c525f3ce2a1864fb6e96676396cebe1e6fcef1933e8e1dde7041004fb5.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/footer.min.2e3eb191baee58dd05a9f0104ac1fab0827bca7c64dafe0b2579f934c33a1d69.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/header.min.b6fb4423cf82a9f9d7abc9cd010223fa3d70a6526a3f28f8e17d814c06e18f9e.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/main.min.3fb8954e26342ad3afabb4525959bfec6f9fc0d6929f0dda738ddeee30211690.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/menu.min.8cee75f73b9f9b1e40bd0dd53e6e770156b08bbfe1c579cd256c3f6cd3b6d32b.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/pagination.min.82f6400eae7c7c6dc3c866733c2ec0579e4089608fea69400ff85b3880aa0d3c.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/post.min.014a50745fbdd41d5f420a3e288730d5af4b7d90344dc6211d0e50c368b5b303.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/prism.min.b958d3d7c6c67361b945f9062d07d403422604b3d2cd33f93b88d41ed0ba634d.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/term.min.94de320c1b850e126e6d2c88a7c90acf58bb1313f0ea14a14cda2a42f2a88db2.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">


<link rel="stylesheet" href="https://blog.jiyi27.com/terminal.css">




<link rel="shortcut icon" href="https://blog.jiyi27.com/favicon.png">
<link rel="apple-touch-icon" href="https://blog.jiyi27.com/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="零碎知识 &#43; 踩坑 - Python">
<meta property="og:description" content="1. 删除列表中除前两个元素外的所有元素 def keep_first_two_del() -&gt; None: global messages if len(messages) &gt; 2: del messages[2:] # 删除从第2个索引（第3个元素）到末尾 del messages[2:]：从索引 2（第 3 个元素）开始删除到列表末尾 如果 messages = [1, 2, 3, 4, 5]，执行后变成 [1, 2] def keep_first_two_slice() -&gt; None: global messages if len(messages) &gt; 2: messages = messages[:2] # 保留从开头到第2个元素 messages[:2]：切片从开头到索引 2（不包括索引 2），即前两个元素 del messages[2:]：直接修改原始列表, del是就地操作, 更高效
messages = messages[:2]：创建新列表并重新赋值, 切片赋值创建新列表, 稍占内存
2. from xxx import xxxx vs import xxx 行为 2.1. from xxx import xxxx 在 Python 中, from data import messages 的语法会:
" />
<meta property="og:url" content="https://blog.jiyi27.com/posts/python/basics/002-nuggets-python/" />
<meta property="og:site_name" content="为霜的博客" />

  <meta property="og:image" content="https://blog.jiyi27.com/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">

  <meta property="article:section" content="python" />


  <meta property="article:published_time" content="2023-12-03 09:01:25 &#43;0000 UTC" />












</head>
<body>


<div class="container center">

  
  
  

  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://blog.jiyi27.com/posts/python/basics/002-nuggets-python/">零碎知识 + 踩坑 - Python</a>
  </h1>
  <div class="post-meta"><time class="post-date">2023-12-03</time><span class="post-reading-time">3 分钟阅读 (555 字数)</span></div>

  
    <span class="post-tags">
      
      #<a href="https://blog.jiyi27.com/tags/python/">python</a>&nbsp;
      
      #<a href="https://blog.jiyi27.com/tags/%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86/">零碎知识</a>&nbsp;
      
      #<a href="https://blog.jiyi27.com/tags/%E8%B8%A9%E5%9D%91/">踩坑</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <h2 id="1-删除列表中除前两个元素外的所有元素">1. 删除列表中除前两个元素外的所有元素<a href="#1-删除列表中除前两个元素外的所有元素" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">keep_first_two_del</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">global</span> messages
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(messages) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">2</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">del</span> messages[<span style="color:#ae81ff">2</span>:]  <span style="color:#75715e"># 删除从第2个索引（第3个元素）到末尾</span>
</span></span></code></pre></div><ul>
<li><code>del messages[2:]</code>：从索引 2（第 3 个元素）开始删除到列表末尾</li>
<li>如果 messages = [1, 2, 3, 4, 5]，执行后变成 [1, 2]</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">keep_first_two_slice</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">global</span> messages
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(messages) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">2</span>:
</span></span><span style="display:flex;"><span>        messages <span style="color:#f92672">=</span> messages[:<span style="color:#ae81ff">2</span>]  <span style="color:#75715e"># 保留从开头到第2个元素</span>
</span></span></code></pre></div><ul>
<li><code>messages[:2]</code>：切片从开头到索引 2（不包括索引 2），即前两个元素</li>
</ul>
<blockquote>
<p><code>del messages[2:]</code>：直接修改原始列表, <code>del</code>是就地操作, 更高效</p>
<p><code>messages = messages[:2]</code>：创建新列表并重新赋值, 切片赋值创建新列表, 稍占内存</p>
</blockquote>
<h2 id="2-from-xxx-import-xxxx-vs-import-xxx-行为">2. <code>from xxx import xxxx</code> vs <code>import xxx</code> 行为<a href="#2-from-xxx-import-xxxx-vs-import-xxx-行为" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<h3 id="21-from-xxx-import-xxxx">2.1. <code>from xxx import xxxx</code><a href="#21-from-xxx-import-xxxx" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>在 Python 中, <code>from data import messages</code> 的语法会:</p>
<ol>
<li>加载指定的模块（如果尚未加载）</li>
<li>从模块的命名空间中取出 <code>messages</code> 所绑定的对象</li>
<li>在当前作用域中创建一个新的名称 <code>messages</code>, 并将它绑定到从模块中取出的对象上</li>
</ol>
<p>这个新名称是一个独立的绑定, 它与模块中的原始名称（如 <code>data.messages</code>）没有动态关联, 换句话说, <code>from xxx import xxxx</code> 是“一次性拷贝引用”的操作, 而不是创建对模块属性的动态引用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># 模块 data.py</span>
</span></span><span style="display:flex;"><span>value <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">change_value</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">global</span> value
</span></span><span style="display:flex;"><span>    value <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># 然后在 main.py 中我们使用</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> data <span style="color:#f92672">import</span> value, change_value
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Before:&#34;</span>, value)  <span style="color:#75715e"># Before: 42</span>
</span></span><span style="display:flex;"><span>change_value()
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;After:&#34;</span>, value)   <span style="color:#75715e"># After: 42</span>
</span></span></code></pre></div><ul>
<li><code>from data import value</code> 将 <code>data.value</code> 的初始值（42）绑定到 <code>main.py</code> 中的 <code>value</code></li>
<li><code>change_value()</code> 修改了 <code>data.value</code>, 将其重新绑定到 100</li>
<li>但 <code>main.py</code> 中的 value 仍然绑定到原始对象 42，因为它是导入时创建的独立名称绑定，而不是对 <code>data.value</code> 的动态引用</li>
</ul>
<blockquote>
<p>如果 value 是一个对象，修改它会发生什么？</p>
<p>如果 value 是一个可变对象（如列表、字典）, 通过 from xxx import xxxx 导入后, 修改这个对象的内容（原地修改）会同时影响模块中的 xxx.xxxx 和当前作用域的 xxxx, 因为它们指向同一个对象, 但如果重新绑定 xxxx（如赋值为一个新对象）, 则会断开这种关联</p>
<p><strong>修改对象内容:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># data.py</span>
</span></span><span style="display:flex;"><span>value <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">change_value</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">global</span> value
</span></span><span style="display:flex;"><span>    value <span style="color:#f92672">=</span> value[<span style="color:#ae81ff">1</span>:] <span style="color:#75715e"># slice 会创建一个新对象, 因此 value 指向了一个不同的对象</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># main.py</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> data <span style="color:#f92672">import</span> value
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Before:&#34;</span>, value)  <span style="color:#75715e"># Before: [1, 2, 3]</span>
</span></span><span style="display:flex;"><span>value<span style="color:#f92672">.</span>append(<span style="color:#ae81ff">4</span>)          <span style="color:#75715e"># 修改对象内容</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;After append:&#34;</span>, value)  <span style="color:#75715e"># After append: [1, 2, 3, 4]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 检查 data.py 中的 value</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> data
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;data.value:&#34;</span>, data<span style="color:#f92672">.</span>value)  <span style="color:#75715e"># data.value: [1, 2, 3, 4]</span>
</span></span></code></pre></div><ul>
<li>from data import value 让 main.py 的 value 和 data.value 指向同一个列表对象</li>
<li>value.append(4) 是原地修改这个共享对象，因此 data.value 也反映了变化</li>
</ul>
<p><strong>重新绑定</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># main.py</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> data <span style="color:#f92672">import</span> value, change_value
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Before:&#34;</span>, value)  <span style="color:#75715e"># Before: [1, 2, 3]</span>
</span></span><span style="display:flex;"><span>change_value()          <span style="color:#75715e"># 模块内重新绑定</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;After change_value:&#34;</span>, value)  <span style="color:#75715e"># After change_value: [1, 2, 3]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 检查 data.py 中的 value</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> data
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;data.value:&#34;</span>, data<span style="color:#f92672">.</span>value)  <span style="color:#75715e"># data.value: [2, 3]</span>
</span></span></code></pre></div><ul>
<li>change_value() 在 data.py 中重新绑定了 data.value 到 [2, 3]</li>
<li>但 main.py 中的 value 仍然指向原来的 [1, 2, 3]，因为 from data import value 不会跟踪 data.value 的重新绑定</li>
</ul>
</blockquote>
<blockquote>
<p><strong><code>from data import messages</code> 创建的是浅拷贝吗？</strong></p>
<p>严格来说，<strong><code>from data import messages</code> 并不创建浅拷贝</strong>, 它只是将模块中 <code>messages</code> 所绑定的对象引用赋值给当前作用域中的名称 <code>messages</code>, 这不是拷贝（无论是浅拷贝还是深拷贝）, 而是直接共享同一个对象引用</p>
<ul>
<li>浅拷贝 shallow copy：会创建一个新对象, 但新对象中的元素是对原始对象元素的引用, 例如, <code>list.copy()</code> 或 <code>copy.copy()</code></li>
<li><code>from data import messages</code>: 浅拷贝创建一个新对象, from xxx import xxxx 不创建新对象, 而是共享引用</li>
</ul>
</blockquote>
<h3 id="22-import-xxx">2.2. <code>import xxx</code><a href="#22-import-xxx" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>相比之下，import xxx 的行为是：</p>
<ol>
<li>加载模块并将其作为对象引入当前作用域</li>
<li>通过 <code>xxx.name</code> 访问模块的属性时，总是动态地查询模块的命名空间</li>
<li>如果模块中的 <code>name</code> 被重新绑定，<code>xxx.name</code> 会反映最新的绑定</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># 使用相同的 data.py</span>
</span></span><span style="display:flex;"><span>value <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">change_value</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">global</span> value
</span></span><span style="display:flex;"><span>    value <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># main.py</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> data
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Before:&#34;</span>, data<span style="color:#f92672">.</span>value)  <span style="color:#75715e"># Before: 42</span>
</span></span><span style="display:flex;"><span>data<span style="color:#f92672">.</span>change_value()
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;After:&#34;</span>, data<span style="color:#f92672">.</span>value)   <span style="color:#75715e"># After: 100</span>
</span></span></code></pre></div><ul>
<li>
<p>import data 引入了模块对象 data</p>
</li>
<li>
<p>data.value 是对 data 模块命名空间中 value 属性的直接引用</p>
</li>
<li>
<p>当 change_value() 修改 data.value 时，main.py 通过 data.value 访问时会看到最新的值（100）</p>
</li>
</ul>
<h2 id="3-切片操作-浅拷贝">3. 切片操作 浅拷贝<a href="#3-切片操作-浅拷贝" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>在 Python 中，切片操作（如 list[1:3]）会创建一个新的对象，但这是一个浅拷贝（shallow copy）, 浅拷贝意味着新对象会复制原始对象的顶层元素，但如果这些元素本身是可变对象（如列表、字典等），新对象中的元素仍然是对原始对象中对应元素的引用，而不是深层次的独立副本:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># 原始列表</span>
</span></span><span style="display:flex;"><span>original <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>], [<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>]]
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 通过切片创建新列表</span>
</span></span><span style="display:flex;"><span>sliced <span style="color:#f92672">=</span> original[:]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 修改新列表中的子列表</span>
</span></span><span style="display:flex;"><span>sliced[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">99</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;原始列表:&#34;</span>, original)  <span style="color:#75715e"># [[99, 2, 3], [4, 5, 6]]</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;切片列表:&#34;</span>, sliced)    <span style="color:#75715e"># [[99, 2, 3], [4, 5, 6]]</span>
</span></span></code></pre></div><ul>
<li><code>sliced = original[:]</code> 通过切片创建了一个新列表 sliced，它是 original 的浅拷贝</li>
<li><code>sliced</code> 中的元素是对 original 中子列表 [1, 2, 3] 和 [4, 5, 6] 的引用，而不是全新的独立副本</li>
</ul>
<blockquote>
<p>This is similar to reslicing in Golang, but not same, in Gloang the new slice shares a same underlying array with it resliced from, whereas Python will create a new list object directly.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#75715e">// 原始切片</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">original</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 通过切片操作创建新切片</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">sliced</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">original</span>[<span style="color:#ae81ff">1</span>:<span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 修改新切片</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">sliced</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">99</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;原始切片:&#34;</span>, <span style="color:#a6e22e">original</span>) <span style="color:#75715e">// [1 99 3 4 5]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;新切片:&#34;</span>, <span style="color:#a6e22e">sliced</span>)     <span style="color:#75715e">// [99 3]</span>
</span></span></code></pre></div><ul>
<li>original 是一个切片，底层是一个数组 [1, 2, 3, 4, 5]</li>
<li>sliced := original[1:3] 创建了一个新切片，范围是索引 1 到 2（即 [2, 3]），但它仍然引用同一个底层数组</li>
</ul>
</blockquote>

      </div></div>

  
    
<div class="pagination">
  <div class="pagination__title">
    <span class="pagination__title-h">查看其他文章</span>
    <hr />
  </div>
  <div class="pagination__buttons">
    
      <a href="https://blog.jiyi27.com/posts/golang/basics/006-io/" class="button inline prev">
        IO in Golang
      </a>
    
    
      ::
    
    
      <a href="https://blog.jiyi27.com/posts/bugs/009-go-server-handle-large-file/" class="button inline next">
        Go File Server Cannot Handle Large Files
      </a>
    
  </div>
</div>


  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/jiyi27/jiyi27.github.io" target="_blank">Theme</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
