<!DOCTYPE html>
<html lang="en">
<head>
  
    
    <title>Methods Receivers &amp; Concurrency - Go :: 为霜的博客</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="1. Different behaviors - pointer and value receiver 修改能力:
值接收器：方法内部操作的是结构体的副本，无法修改原始数据
指针接收器：方法可以直接修改原始结构体的数据
内存效率:
type BigStruct struct { data [1024]int // 很大的数组 } // 值接收器：每次调用都会复制整个结构体 func (b BigStruct) Process() { } // 指针接收器：只复制指针（8字节） func (b *BigStruct) ProcessEfficient() { } NOTE: Generally, in practice, we seldom use pointer types whose base types are slice types, map types, channel types, function types, string types and interface types. The costs of copying values of these assumed base types are very small.
" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://blog.jiyi27.com/posts/golang/basics/004-methods-receivers/" />





  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/buttons.min.2bc533403a27dfe0e93105a92502b42ce4587e2e4a87d9f7d349e51e16e09478.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/categories.min.3202f75cbb294747099af3850a68a09ee94b3ce505fc39e134692d90ff0a9b2a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/code.min.dd73d157e77e82a3dc1cb06ba424cf6cc6811af0bb604ad6c68e70faf2439c8a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/fonts.min.4881f0c525f3ce2a1864fb6e96676396cebe1e6fcef1933e8e1dde7041004fb5.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/footer.min.2e3eb191baee58dd05a9f0104ac1fab0827bca7c64dafe0b2579f934c33a1d69.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/header.min.b6fb4423cf82a9f9d7abc9cd010223fa3d70a6526a3f28f8e17d814c06e18f9e.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/main.min.3fb8954e26342ad3afabb4525959bfec6f9fc0d6929f0dda738ddeee30211690.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/menu.min.8cee75f73b9f9b1e40bd0dd53e6e770156b08bbfe1c579cd256c3f6cd3b6d32b.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/pagination.min.82f6400eae7c7c6dc3c866733c2ec0579e4089608fea69400ff85b3880aa0d3c.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/post.min.014a50745fbdd41d5f420a3e288730d5af4b7d90344dc6211d0e50c368b5b303.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/prism.min.b958d3d7c6c67361b945f9062d07d403422604b3d2cd33f93b88d41ed0ba634d.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/term.min.94de320c1b850e126e6d2c88a7c90acf58bb1313f0ea14a14cda2a42f2a88db2.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">


<link rel="stylesheet" href="https://blog.jiyi27.com/terminal.css">




<link rel="shortcut icon" href="https://blog.jiyi27.com/favicon.png">
<link rel="apple-touch-icon" href="https://blog.jiyi27.com/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Methods Receivers &amp; Concurrency - Go">
<meta property="og:description" content="1. Different behaviors - pointer and value receiver 修改能力:
值接收器：方法内部操作的是结构体的副本，无法修改原始数据
指针接收器：方法可以直接修改原始结构体的数据
内存效率:
type BigStruct struct { data [1024]int // 很大的数组 } // 值接收器：每次调用都会复制整个结构体 func (b BigStruct) Process() { } // 指针接收器：只复制指针（8字节） func (b *BigStruct) ProcessEfficient() { } NOTE: Generally, in practice, we seldom use pointer types whose base types are slice types, map types, channel types, function types, string types and interface types. The costs of copying values of these assumed base types are very small.
" />
<meta property="og:url" content="https://blog.jiyi27.com/posts/golang/basics/004-methods-receivers/" />
<meta property="og:site_name" content="为霜的博客" />

  <meta property="og:image" content="https://blog.jiyi27.com/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">

  <meta property="article:section" content="golang" />


  <meta property="article:published_time" content="2023-09-02 22:18:20 &#43;0000 UTC" />












</head>
<body>


<div class="container center">

  
  
  

  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://blog.jiyi27.com/posts/golang/basics/004-methods-receivers/">Methods Receivers &amp; Concurrency - Go</a>
  </h1>
  <div class="post-meta"><time class="post-date">2023-09-02</time><span class="post-reading-time">3 分钟阅读 (525 字数)</span></div>

  
    <span class="post-tags">
      
      #<a href="https://blog.jiyi27.com/tags/golang/">golang</a>&nbsp;
      
      #<a href="https://blog.jiyi27.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <h2 id="1-different-behaviors---pointer-and-value-receiver">1. Different behaviors - pointer and value receiver<a href="#1-different-behaviors---pointer-and-value-receiver" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p><strong>修改能力</strong>:</p>
<p>值接收器：方法内部操作的是结构体的副本，无法修改原始数据</p>
<p>指针接收器：方法可以直接修改原始结构体的数据</p>
<p><strong>内存效率</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">BigStruct</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">data</span> [<span style="color:#ae81ff">1024</span>]<span style="color:#66d9ef">int</span>  <span style="color:#75715e">// 很大的数组</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 值接收器：每次调用都会复制整个结构体</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#a6e22e">BigStruct</span>) <span style="color:#a6e22e">Process</span>() { }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 指针接收器：只复制指针（8字节）</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">BigStruct</span>) <span style="color:#a6e22e">ProcessEfficient</span>() { }
</span></span></code></pre></div><blockquote>
<p><strong>NOTE:</strong> Generally, in practice, we seldom use pointer types whose base types are slice types, map types, channel types, function types, string types and interface types. The costs of copying values of these assumed base types are very small.</p>
<p>Source: <a href="https://go101.org/article/value-copy-cost.html">https://go101.org/article/value-copy-cost.html</a></p>
</blockquote>
<p><strong>表达意图:</strong></p>
<p>使用指针接收器更清晰地表达这是一个有状态的对象, 不需要拷贝值, 而是所有方法都访问相同的一个值.</p>
<h2 id="2-例子">2. 例子<a href="#2-例子" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>有如下接口,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">UserRepository</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Create</span>(<span style="color:#a6e22e">user</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">types</span>.<span style="color:#a6e22e">User</span>) <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">GetByID</span>(<span style="color:#a6e22e">id</span> <span style="color:#66d9ef">string</span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">types</span>.<span style="color:#a6e22e">User</span>, <span style="color:#66d9ef">error</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>即所有实现该接口的类型都可以, 比如指针:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PostgresUserRepository</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">pool</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">pgxpool</span>.<span style="color:#a6e22e">Pool</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewPostgresUserRepository</span>(<span style="color:#a6e22e">pool</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">pgxpool</span>.<span style="color:#a6e22e">Pool</span>) <span style="color:#a6e22e">repos</span>.<span style="color:#a6e22e">UserRepository</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">PostgresUserRepository</span>{<span style="color:#a6e22e">pool</span>: <span style="color:#a6e22e">pool</span>}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">PostgresUserRepository</span>) <span style="color:#a6e22e">Create</span>(<span style="color:#a6e22e">user</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">types</span>.<span style="color:#a6e22e">User</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">PostgresUserRepository</span>) <span style="color:#a6e22e">GetByID</span>(<span style="color:#a6e22e">id</span> <span style="color:#66d9ef">string</span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">types</span>.<span style="color:#a6e22e">User</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>也就是说 <code>*PostgresUserRepository</code> 实现了 <code>UserRepository</code>, 因此 可以有如下代码:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">UserHandler</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">userRepo</span> <span style="color:#a6e22e">UserRepository</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewUserHandler</span>(<span style="color:#a6e22e">us</span> <span style="color:#a6e22e">repos</span>.<span style="color:#a6e22e">UserRepository</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">UserHandler</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">UserHandler</span>{<span style="color:#a6e22e">userRepo</span>: <span style="color:#a6e22e">us</span>}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">repo</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">PostgresUserRepository</span>{} <span style="color:#75715e">// 指针</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">svc</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewUserHandler</span>(<span style="color:#a6e22e">repo</span>)       <span style="color:#75715e">// repo 是接口类型, 指针 *PostgresUserRepository 实现了该接口</span>
</span></span></code></pre></div><h2 id="3-method-receivers-in-concurrency">3. Method receivers in concurrency<a href="#3-method-receivers-in-concurrency" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>I came across a satement about when to use value receiver but forget where I found:</p>
<blockquote>
<p>You should notice that <strong><em>value receivers</em> are concurrency safe, while <em>pointer receivers</em> are not concurrency safe.</strong> So if there is no a lot copy, and you don&rsquo;t need modify any field of the value, try to use value receiver.</p>
</blockquote>
<p>Is this correct, yes it&rsquo;s correct to some extend, but things probably are more complicated when come across concurrent programming.</p>
<p>I find a good <a href="https://dave.cheney.net/2016/03/19/should-methods-be-declared-on-t-or-t">blog</a> talks about this written by <a href="https://dave.cheney.net/">Dave Cheney</a>, and I&rsquo;ll share some parts of the blog here:</p>
<p>Obviously if your method mutates its receiver, it should be declared on <code>*T</code>. However, if the method does not mutate its receiver, is it safe to declare it on <code>T</code> instead <code>*T</code>?</p>
<p>It turns out that the cases where it is safe to do so are very limited. For example, it is well known that you should not copy a <code>sync.Mutex</code> value as that breaks the invariants of the mutex. As mutexes control access to other things, they are frequently wrapped up in a <code>struct</code> with the value they control:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">counter</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Val</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mu</span>  <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">val</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">v</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Val</span>) <span style="color:#a6e22e">Get</span>() <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">val</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">v</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Val</span>) <span style="color:#a6e22e">Add</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">val</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">n</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Most Go programmers know that it is a mistake to forget to declare the <code>Get</code> or <code>Add</code> methods on the pointer receiver <code>*Val</code>. However any type that embeds a <code>Val</code> to utilise its zero value, must also only declare methods on its pointer receiver otherwise it may inadvertently copy the contents of its embedded type’s values.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Stats</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">c</span> <span style="color:#a6e22e">counter</span>.<span style="color:#a6e22e">Val</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#a6e22e">Stats</span>) <span style="color:#a6e22e">Sum</span>() <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">Get</span>() <span style="color:#f92672">+</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Get</span>() <span style="color:#f92672">+</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Get</span>() <span style="color:#75715e">// whoops</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>A similar pitfall can occur with types that maintain slices of values, and of course there is the possibility for an <a href="http://dave.cheney.net/2015/11/18/wednesday-pop-quiz-spot-the-race">unintended data race</a>.</p>
<p>In short, I think that you should prefer declaring methods on <code>*T</code> unless you have a strong reason to do otherwise.</p>

      </div></div>

  
    
<div class="pagination">
  <div class="pagination__title">
    <span class="pagination__title-h">查看其他文章</span>
    <hr />
  </div>
  <div class="pagination__buttons">
    
      <a href="https://blog.jiyi27.com/posts/golang/advance/005-unit-test-commands/" class="button inline prev">
        Unit Test Basic Commands - Go
      </a>
    
    
      ::
    
    
      <a href="https://blog.jiyi27.com/posts/git/practice/003-blog-backup/" class="button inline next">
        Backup Blogs with Git - Sovled
      </a>
    
  </div>
</div>


  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/jiyi27/jiyi27.github.io" target="_blank">Theme</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
