<!DOCTYPE html>
<html lang="en">
<head>
  
    
    <title>JVM 运行时常量池 - 动态链接 :: 为霜的博客</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="1. 前言 JVM 规范中只有 Run-Time Data Areas 的概念, 它的主要分类逻辑就是线程共享和线程私有区域, 而我们平时更倾向于站在堆栈传统角度对内存进行分类, 因为这样很容易理解,
在 JVM 类加载过程中 Run-Time Data Areas 方法区的 Runtime Constant Pool 很重要, 相当于编译中的符号表, 在动态链接的时候主要就靠它来告诉 JVM 该类用到了哪些标准库的东西, 外部的类和函数, 去哪加载等等元数据信息, 今天就来研究一下
Run-Time Data Areas └─ Method Area └─ Runtime Constant Pool 2. 每个 .class 文件都有一个常量池 在 Java 中，每一个 .class 文件里都带有一张自己的常量池。这张常量池的存在是为了在字节码里用 “符号引用” 或 “常量” 来代替真正的类、方法、字段、字符串、数值等内容，并且让它们可以在 JVM 运行时 被 “解析” 成真实的类、方法或者对象引用。
为什么每个 .class 文件都有自己的常量池？
每个 .class 文件是一个独立的编译单元，它可能引用不同的类、不同的方法、不同的字符串、不同的常量 在 Java 编译阶段，javac 会为该类所需的一切外部引用（类、字段、方法等）和字面量记录到它自己的常量池中 当这个类加载到 JVM 里时候, 需要使用其中任何符号引用或常量，就会通过它自己的常量池去做解析 3. 看个例子 public class Demo { public static void main(String[] args) { System.out.println(&#34;Hello World&#34;); } } 编译后执行 javac Demo.java，得到 Demo.class, 然后用 javap -v Demo.class 查看其常量池部分：
" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://blog.jiyi27.com/posts/java/basics/005-jvm-constant-pool/" />





  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/buttons.min.2bc533403a27dfe0e93105a92502b42ce4587e2e4a87d9f7d349e51e16e09478.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/categories.min.3202f75cbb294747099af3850a68a09ee94b3ce505fc39e134692d90ff0a9b2a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/code.min.dd73d157e77e82a3dc1cb06ba424cf6cc6811af0bb604ad6c68e70faf2439c8a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/fonts.min.4881f0c525f3ce2a1864fb6e96676396cebe1e6fcef1933e8e1dde7041004fb5.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/footer.min.2e3eb191baee58dd05a9f0104ac1fab0827bca7c64dafe0b2579f934c33a1d69.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/header.min.b6fb4423cf82a9f9d7abc9cd010223fa3d70a6526a3f28f8e17d814c06e18f9e.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/main.min.3fb8954e26342ad3afabb4525959bfec6f9fc0d6929f0dda738ddeee30211690.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/menu.min.8cee75f73b9f9b1e40bd0dd53e6e770156b08bbfe1c579cd256c3f6cd3b6d32b.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/pagination.min.82f6400eae7c7c6dc3c866733c2ec0579e4089608fea69400ff85b3880aa0d3c.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/post.min.014a50745fbdd41d5f420a3e288730d5af4b7d90344dc6211d0e50c368b5b303.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/prism.min.b958d3d7c6c67361b945f9062d07d403422604b3d2cd33f93b88d41ed0ba634d.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/term.min.94de320c1b850e126e6d2c88a7c90acf58bb1313f0ea14a14cda2a42f2a88db2.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">


<link rel="stylesheet" href="https://blog.jiyi27.com/terminal.css">




<link rel="shortcut icon" href="https://blog.jiyi27.com/favicon.png">
<link rel="apple-touch-icon" href="https://blog.jiyi27.com/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="JVM 运行时常量池 - 动态链接">
<meta property="og:description" content="1. 前言 JVM 规范中只有 Run-Time Data Areas 的概念, 它的主要分类逻辑就是线程共享和线程私有区域, 而我们平时更倾向于站在堆栈传统角度对内存进行分类, 因为这样很容易理解,
在 JVM 类加载过程中 Run-Time Data Areas 方法区的 Runtime Constant Pool 很重要, 相当于编译中的符号表, 在动态链接的时候主要就靠它来告诉 JVM 该类用到了哪些标准库的东西, 外部的类和函数, 去哪加载等等元数据信息, 今天就来研究一下
Run-Time Data Areas └─ Method Area └─ Runtime Constant Pool 2. 每个 .class 文件都有一个常量池 在 Java 中，每一个 .class 文件里都带有一张自己的常量池。这张常量池的存在是为了在字节码里用 “符号引用” 或 “常量” 来代替真正的类、方法、字段、字符串、数值等内容，并且让它们可以在 JVM 运行时 被 “解析” 成真实的类、方法或者对象引用。
为什么每个 .class 文件都有自己的常量池？
每个 .class 文件是一个独立的编译单元，它可能引用不同的类、不同的方法、不同的字符串、不同的常量 在 Java 编译阶段，javac 会为该类所需的一切外部引用（类、字段、方法等）和字面量记录到它自己的常量池中 当这个类加载到 JVM 里时候, 需要使用其中任何符号引用或常量，就会通过它自己的常量池去做解析 3. 看个例子 public class Demo { public static void main(String[] args) { System.out.println(&#34;Hello World&#34;); } } 编译后执行 javac Demo.java，得到 Demo.class, 然后用 javap -v Demo.class 查看其常量池部分：
" />
<meta property="og:url" content="https://blog.jiyi27.com/posts/java/basics/005-jvm-constant-pool/" />
<meta property="og:site_name" content="为霜的博客" />

  <meta property="og:image" content="https://blog.jiyi27.com/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">

  <meta property="article:section" content="java" />


  <meta property="article:published_time" content="2025-02-04 08:50:26 &#43;0000 UTC" />












</head>
<body>


<div class="container center">

  
  
  

  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://blog.jiyi27.com/posts/java/basics/005-jvm-constant-pool/">JVM 运行时常量池 - 动态链接</a>
  </h1>
  <div class="post-meta"><time class="post-date">2025-02-04</time><span class="post-reading-time">3 分钟阅读 (580 字数)</span></div>

  
    <span class="post-tags">
      
      #<a href="https://blog.jiyi27.com/tags/java/">java</a>&nbsp;
      
      #<a href="https://blog.jiyi27.com/tags/jvm/">jvm</a>&nbsp;
      
      #<a href="https://blog.jiyi27.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <h2 id="1-前言">1. 前言<a href="#1-前言" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>JVM 规范中只有 Run-Time Data Areas 的概念, 它的主要分类逻辑就是线程共享和线程私有区域, 而我们平时更倾向于站在堆栈传统角度对内存进行分类, 因为这样很容易理解,</p>
<p>在 JVM 类加载过程中 Run-Time Data Areas 方法区的 Runtime Constant Pool 很重要, 相当于编译中的符号表, 在动态链接的时候主要就靠它来告诉 JVM 该类用到了哪些标准库的东西, 外部的类和函数, 去哪加载等等元数据信息, 今天就来研究一下</p>
<pre tabindex="0"><code>Run-Time Data Areas
 └─ Method Area
     └─ Runtime Constant Pool
</code></pre><h2 id="2-每个-class-文件都有一个常量池">2. 每个 .class 文件都有一个常量池<a href="#2-每个-class-文件都有一个常量池" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>在 Java 中，<strong>每一个 <code>.class</code> 文件</strong>里都带有一张自己的<strong>常量池</strong>。这张常量池的存在是为了在字节码里用 “符号引用” 或 “常量” 来代替真正的类、方法、字段、字符串、数值等内容，并且让它们可以在 JVM 运行时 被 “解析” 成真实的类、方法或者对象引用。</p>
<p>为什么每个 <code>.class</code> 文件都有自己的常量池？</p>
<ul>
<li>每个 <code>.class</code> 文件是一个<strong>独立的编译单元</strong>，它可能引用不同的类、不同的方法、不同的字符串、不同的常量</li>
<li>在 Java 编译阶段，<code>javac</code> 会为<strong>该类</strong>所需的一切外部引用（类、字段、方法等）和字面量<strong>记录到它自己的常量池</strong>中</li>
<li>当这个类加载到 JVM 里时候, 需要使用其中任何符号引用或常量，就会通过它<strong>自己</strong>的常量池去做解析</li>
</ul>
<h2 id="3-看个例子">3. 看个例子<a href="#3-看个例子" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Demo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Hello World&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>编译后执行 <code>javac Demo.java</code>，得到 <code>Demo.class</code>, 然后用 <code>javap -v Demo.class</code> 查看其常量池部分：</p>
<pre tabindex="0"><code>Classfile .../Demo.class
  Last modified ...; size ...
  MD5 checksum ...
public class Demo
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #7.#22         // java/io/PrintStream.println:(Ljava/lang/String;)V
   #2 = String             #23            // Hello World
   #3 = Fieldref           #8.#24         // java/lang/System.out:Ljava/io/PrintStream;
   #4 = Class              #25            // Demo
   #5 = Class              #26            // java/io/PrintStream
   #6 = Utf8               Demo
   #7 = Utf8               java/io/PrintStream
   #8 = Utf8               java/lang/System
   #9 = Utf8               main
   #10 = Utf8              ([Ljava/lang/String;)V
   #11 = Utf8              Code
   ...
   #22 = NameAndType       #27:#28        // println:(Ljava/lang/String;)V
   #23 = Utf8              Hello World
   #24 = NameAndType       #29:#30        // out:Ljava/io/PrintStream;
   #25 = Utf8              Demo
   #26 = Utf8              java/io/PrintStream
   #27 = Utf8              println
   #28 = Utf8              (Ljava/lang/String;)V
   #29 = Utf8              out
   #30 = Utf8              Ljava/io/PrintStream;
   ...
{
  public Demo();
    ...
  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #3      // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #2      // String Hello World
         5: invokevirtual #1      // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
      ...
}
</code></pre><h2 id="4-常量池里都有啥">4. 常量池里都有啥？<a href="#4-常量池里都有啥" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p><code>#1 = Methodref #7.#22 // java/io/PrintStream.println:(Ljava/lang/String;)V</code>
表示：这是一个 <code>Methodref</code> 常量，指向“类 #7”与“NameAndType #22”的组合</p>
<ul>
<li>“类 #7” 就是 <code>java/io/PrintStream</code>（见后面 <code>#7 = Utf8 &quot;java/io/PrintStream&quot;</code>）</li>
<li>“NameAndType #22” 则表示方法名和方法描述符——在 <code>#22</code> 里你会看到 <code>&lt;println:(Ljava/lang/String;)V&gt;</code></li>
</ul>
<p><code>#2 = String #23 // Hello World</code></p>
<p>表示：这是一个 <code>String</code> 常量，对应了 “字符串 #23”；“#23” 实际是一个 <code>Utf8</code> 条目，存放 <code>&quot;Hello World&quot;</code> 的字符</p>
<p><code>#3 = Fieldref #8.#24 // java/lang/System.out:Ljava/io/PrintStream;</code>
表示：这是一个 <code>Fieldref</code> 常量，指向“类 #8”与“NameAndType #24”的组合</p>
<ul>
<li>“类 #8” -&gt; <code>java/lang/System</code></li>
<li>“NameAndType #24” -&gt; “<code>out:Ljava/io/PrintStream;</code>”</li>
</ul>
<p><code>#22 = NameAndType #27:#28 // println:(Ljava/lang/String;)V</code>
表示：这是一个 <code>NameAndType</code> 常量，<code>#27</code> 是方法名 <code>println</code>，<code>#28</code> 是方法描述符 <code>&quot;(Ljava/lang/String;)V&quot;</code></p>
<p><code>#23 = Utf8 &quot;Hello World&quot;</code>
表示：这是一个存放字符串 <code>&quot;Hello World&quot;</code> 的 <code>Utf8</code> 常量</p>
<p>可以看到，编译器把你写的代码里所有用到的类名、方法名、字段名、描述符以及字符串字面量，都以 各种类型的 cp_info（<code>Methodref</code>、<code>Fieldref</code>、<code>NameAndType</code>、<code>Utf8</code>、<code>String</code> 等）记录到了同一个常量池数组里。</p>
<h2 id="5-这些条目在运行时怎么被用到">5. 这些条目在运行时怎么被用到？<a href="#5-这些条目在运行时怎么被用到" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>在实际运行过程中，你可以从反汇编的字节码看到：</p>
<pre tabindex="0"><code>0: getstatic     #3      // Field java/lang/System.out:Ljava/io/PrintStream;
3: ldc           #2      // String Hello World
5: invokevirtual #1      // Method java/io/PrintStream.println:(Ljava/lang/String;)V
8: return
</code></pre><p><code>#3</code>、<code>#2</code>、<code>#1</code> 都是<strong>常量池索引</strong>。当 JVM 执行到这条指令时，它会到 Demo 类的常量池里找相应记录，再看看<strong>那条记录</strong>里描述了什么类、字段或方法名、描述符，然后去解析并链接到真实的 <code>System.out</code> 字段或 <code>PrintStream.println(...)</code> 方法上。</p>
<h2 id="6-类的加载验证准备解析初始化">6. 类的加载、验证、准备、解析、初始化<a href="#6-类的加载验证准备解析初始化" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>在 Java 中，类加载（Class Loading）之后，紧随其后（或在实际使用时触发）的过程，通常称为 类的链接（Linking）和 初始化（Initialization）。而链接过程里最关键的一步就是 解析（Resolution）。有时我们也把 在<strong>运行时将常量池符号引用转成直接引用</strong> 称为动态链接（Dynamic Linking），因为它跟 C/C++ 的 “编译期/链接期绑定” 不一样，而是在Java 程序执行期间由 JVM 来完成。</p>
<blockquote>
<p>第 4 步的解析（Resolution）往往就是我们所说的“动态链接”的核心：把<strong>字节码中符号形式的引用</strong>——例如 “<code>java/lang/System</code>” 、“<code>out</code>” 、“<code>println</code>”——<strong>映射到 JVM 内部真正的方法、字段、类结构</strong></p>
</blockquote>
<p>编译后字节码（通过 <code>javap -v</code>）大概是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>0: getstatic     #3      // Field java/lang/System.out:Ljava/io/PrintStream;
</span></span><span style="display:flex;"><span>3: ldc           #2      // String Hello World
</span></span><span style="display:flex;"><span>5: invokevirtual #1      // Method java/io/PrintStream.println:(Ljava/lang/String;)V
</span></span><span style="display:flex;"><span>8: return
</span></span></code></pre></div><p>这里的 <code>#3</code>, <code>#2</code>, <code>#1</code> 是常量池索引, 当 JVM 在解释或JIT 编译这些指令时，如果某个索引还没解析，就会触发解析逻辑。</p>
<p><strong>解析 <code>#3</code> (getstatic …)</strong></p>
<ul>
<li>
<p><code>#3</code> 在常量池中是一个 <code>Fieldref</code>，比如 “<code>java/lang/System.out:Ljava/io/PrintStream;</code>”</p>
</li>
<li>
<p>JVM 首先看 这个类 <code>java/lang/System</code> 加载了没？如果没有，就让 Bootstrap ClassLoader 去加载并验证、准备（以及后续可能触发解析和初始化）</p>
</li>
<li>
<p>找到它后，在 <code>java.lang.System</code> 的元数据里查找名为 <code>out</code>、描述符 <code>Ljava/io/PrintStream;</code>、并且是 <code>static</code> 的字段</p>
</li>
<li>
<p>若能找到，就把这个常量池引用标记为已解析，并存储一个指向 <code>System.out</code> 字段的内部标识（可能是一个指针/偏移量）</p>
</li>
<li>
<p>此时还要检查 <code>System</code> 类是否已经初始化过。如果没初始化，就先初始化 <code>System</code>（调用其 <code>&lt;clinit&gt;</code>）。在 <code>&lt;clinit&gt;</code> 里会将 <code>System.out</code> 赋值为一个新的 <code>PrintStream</code> 对象。</p>
</li>
<li>
<p>执行 <code>getstatic #3</code> 时，JVM 发现“已解析”，就能直接去拿 <code>System.out</code> 这个静态字段的对象引用</p>
</li>
</ul>
<p><strong>2.2 解析 <code>#2</code> (ldc …)</strong></p>
<ul>
<li><code>#2</code> 在常量池中是一个 <code>String</code> 类型常量，如 “Hello World”</li>
<li>当执行 <code>ldc #2</code> 时，如果还没解析，就去常量池里取出对应的 UTF-8 字符串，将其intern或放到字符串池，生成一个 <code>java.lang.String</code> 实例（或从已有字符串池中返回）</li>
<li>然后把这个 <code>String</code> 对象引用压栈，用于后续 <code>println</code> 调用。</li>
</ul>
<p><strong>2.3 解析 <code>#1</code> (invokevirtual …)</strong></p>
<ul>
<li><code>#1</code> 在常量池是一个 <code>Methodref</code>，如 “<code>java/io/PrintStream.println:(Ljava/lang/String;)V</code>”</li>
<li>JVM 会检查 <code>java.io.PrintStream</code> 这个类加载了吗？没的话，去加载它</li>
<li>在它的元数据里找到对应的方法表项 <code>println(String)</code></li>
<li>若找到，就把常量池条目更新为已解析，后续执行指令 <code>invokevirtual #1</code> 时，就能通过对象的类型信息 + 方法表来跳转到 <code>PrintStream.println(String)</code> 的实现</li>
</ul>
<p>以上步骤就是“解析 + 动态链接”最本质的行为：从常量池的“符号引用”（例如 “<code>Field java/lang/System.out</code>” 或 “<code>Method java/io/PrintStream.println</code>”）转成 JVM 内部可执行、可定位的实际字段或方法引用</p>
<h2 id="7-动态链接-vs-静态链接">7. 动态链接 VS. 静态链接<a href="#7-动态链接-vs-静态链接" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p><strong>静态链接（C/C++）</strong>：</p>
<ul>
<li>编译和链接器阶段就把对 <code>printf</code> 等函数的调用解析到某个符号表里，生成可执行文件，运行时再由 OS 的动态加载器做符号重定位，最终把 <code>printf</code> 的地址映射到可执行程序里。</li>
<li>也就是说，C/C++ 大部分链接工作在编译期/链接期就做好了，运行时只剩下操作系统层面的动态库装载、重定位</li>
</ul>
<p><strong>Java 的动态链接</strong>：</p>
<ul>
<li>
<p><strong><code>.class</code> 文件只保留对 <code>System.out</code>、<code>println(String)</code> 等的符号引用</strong></p>
</li>
<li>
<p>真正的解析、绑定过程在JVM 运行时发生：</p>
<ol>
<li>加载对应的类（可能还要加载该类所依赖的其他类），</li>
</ol>
</li>
</ul>
<ol start="2">
<li>验证和准备，</li>
<li>在用到这些常量池引用时触发“解析”，最终把它指向 JVM 内部的真实方法或字段对象</li>
</ol>
<ul>
<li>这使得 Java 可以做到“类的动态加载”：运行中可以从网络或别的地方得到一个 <code>.class</code>，用自定义 ClassLoader 加载并解析它。而不需要像 C++ 一样必须在编译/链接时就知道所有符号</li>
</ul>

      </div></div>

  
    
<div class="pagination">
  <div class="pagination__title">
    <span class="pagination__title-h">查看其他文章</span>
    <hr />
  </div>
  <div class="pagination__buttons">
    
      <a href="https://blog.jiyi27.com/posts/java/basics/003-jvm-memory/" class="button inline prev">
        JVM 内存结构 两种分类方式
      </a>
    
    
      ::
    
    
      <a href="https://blog.jiyi27.com/posts/reading/003-fallacies/" class="button inline next">
        常见谬误
      </a>
    
  </div>
</div>


  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/jiyi27/jiyi27.github.io" target="_blank">Theme</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
