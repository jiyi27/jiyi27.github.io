<!DOCTYPE html>
<html lang="en">
<head>
  
    
    <title>SwiftUI Modifiers :: 为霜的博客</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="1. .foregroundStyle() and .tint() .tint Targets: Works mainly on interactive controls like Button, Toggle, Picker, etc. Effect: Changes the color of text and icons within these controls, but usually doesn&rsquo;t affect plain Text views or other non-interactive elements. .foregroundStyle() More versatile, it changes the style (not just the color) of all foreground elements within a view hierarchy, including text, icons, shapes, etc. 2. Other Common Used Modifiers 2.1. Text Modifiers .font(): .largeTitle, .title, .title2, .headline, .subheadline, .body, .footnote, .font(.system(...)) 2.2. Image Modifiers .resizable(), .scaledToFit(), .scaledToFill(), aspectRatio(contentMode: .fill), imageScale()
" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://blog.jiyi27.com/posts/ios/swiftui/004-modifiers/" />





  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/buttons.min.2bc533403a27dfe0e93105a92502b42ce4587e2e4a87d9f7d349e51e16e09478.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/categories.min.3202f75cbb294747099af3850a68a09ee94b3ce505fc39e134692d90ff0a9b2a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/code.min.dd73d157e77e82a3dc1cb06ba424cf6cc6811af0bb604ad6c68e70faf2439c8a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/fonts.min.4881f0c525f3ce2a1864fb6e96676396cebe1e6fcef1933e8e1dde7041004fb5.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/footer.min.2e3eb191baee58dd05a9f0104ac1fab0827bca7c64dafe0b2579f934c33a1d69.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/header.min.b6fb4423cf82a9f9d7abc9cd010223fa3d70a6526a3f28f8e17d814c06e18f9e.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/main.min.3fb8954e26342ad3afabb4525959bfec6f9fc0d6929f0dda738ddeee30211690.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/menu.min.8cee75f73b9f9b1e40bd0dd53e6e770156b08bbfe1c579cd256c3f6cd3b6d32b.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/pagination.min.82f6400eae7c7c6dc3c866733c2ec0579e4089608fea69400ff85b3880aa0d3c.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/post.min.014a50745fbdd41d5f420a3e288730d5af4b7d90344dc6211d0e50c368b5b303.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/prism.min.b958d3d7c6c67361b945f9062d07d403422604b3d2cd33f93b88d41ed0ba634d.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/term.min.94de320c1b850e126e6d2c88a7c90acf58bb1313f0ea14a14cda2a42f2a88db2.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">


<link rel="stylesheet" href="https://blog.jiyi27.com/terminal.css">




<link rel="shortcut icon" href="https://blog.jiyi27.com/favicon.png">
<link rel="apple-touch-icon" href="https://blog.jiyi27.com/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="SwiftUI Modifiers">
<meta property="og:description" content="1. .foregroundStyle() and .tint() .tint Targets: Works mainly on interactive controls like Button, Toggle, Picker, etc. Effect: Changes the color of text and icons within these controls, but usually doesn&rsquo;t affect plain Text views or other non-interactive elements. .foregroundStyle() More versatile, it changes the style (not just the color) of all foreground elements within a view hierarchy, including text, icons, shapes, etc. 2. Other Common Used Modifiers 2.1. Text Modifiers .font(): .largeTitle, .title, .title2, .headline, .subheadline, .body, .footnote, .font(.system(...)) 2.2. Image Modifiers .resizable(), .scaledToFit(), .scaledToFill(), aspectRatio(contentMode: .fill), imageScale()
" />
<meta property="og:url" content="https://blog.jiyi27.com/posts/ios/swiftui/004-modifiers/" />
<meta property="og:site_name" content="为霜的博客" />

  <meta property="og:image" content="https://blog.jiyi27.com/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">

  <meta property="article:section" content="ios" />


  <meta property="article:published_time" content="2024-06-07 16:22:30 &#43;0000 UTC" />












</head>
<body>


<div class="container center">

  
  
  

  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://blog.jiyi27.com/posts/ios/swiftui/004-modifiers/">SwiftUI Modifiers</a>
  </h1>
  <div class="post-meta"><time class="post-date">2024-06-07</time><span class="post-reading-time">5 分钟阅读 (910 字数)</span></div>

  
    <span class="post-tags">
      
      #<a href="https://blog.jiyi27.com/tags/ios/">ios</a>&nbsp;
      
      #<a href="https://blog.jiyi27.com/tags/swiftui/">swiftui</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <h2 id="1-foregroundstyle-and-tint">1. <code>.foregroundStyle()</code> and <code>.tint()</code><a href="#1-foregroundstyle-and-tint" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<ul>
<li><code>.tint</code>
<ul>
<li>Targets: Works mainly on <strong>interactive controls</strong> like <code>Button</code>, <code>Toggle</code>, <code>Picker</code>, etc.</li>
<li>Effect: Changes the color of text and icons within these controls, but usually <strong>doesn&rsquo;t affect plain <code>Text</code> views or other non-interactive elements</strong>.</li>
</ul>
</li>
<li><code>.foregroundStyle()</code>
<ul>
<li>More versatile, it changes the style (not just the color) of all foreground elements within a view hierarchy, including text, icons, shapes, etc.</li>
</ul>
</li>
</ul>
<p><img src="https://pub-2a6758f3b2d64ef5bb71ba1601101d35.r2.dev/blogs/2024/06/b68b2b854568f35c371b5e1d22b60231.jpg" alt=""></p>
<p><img src="https://pub-2a6758f3b2d64ef5bb71ba1601101d35.r2.dev/blogs/2024/06/918b49e2021b1534f1274e732efe1522.jpg" alt=""></p>
<h2 id="2-other-common-used-modifiers">2. Other Common Used Modifiers<a href="#2-other-common-used-modifiers" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<h3 id="21-text-modifiers">2.1. Text Modifiers<a href="#21-text-modifiers" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<ul>
<li><code>.font()</code>: <code>.largeTitle</code>, <code>.title</code>, <code>.title2</code>, <code>.headline</code>, <code>.subheadline</code>, <code>.body</code>, <code>.footnote</code>, <code>.font(.system(...))</code></li>
</ul>
<h3 id="22-image-modifiers">2.2. Image Modifiers<a href="#22-image-modifiers" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p><code>.resizable()</code>, <code>.scaledToFit()</code>, <code>.scaledToFill()</code>, <code>aspectRatio(contentMode: .fill)</code>, <code>imageScale()</code></p>
<blockquote>
<p><strong>Note</strong></p>
<p><code>.frame()</code> must be used after <code>.resizable()</code>, because image is not resizable by default.</p>
<p><code>.scaledToFit()</code> and <code>.scaledToFill()</code> should be used before <code>.frame()</code>, if used after <code>.frame()</code>, it will not work.</p>
</blockquote>
<h2 id="3-padding">3. <code>padding()</code><a href="#3-padding" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>Adds an equal padding amount to specific edges of this view.</p>
<p>padding 不要理解成 css 中的 padding 内边距, 在 swiftui 中它更像是一个外边距, 应用哪个 view 上面, 就会为其产生外边距, 而不是内侧. 我们看一下 padding 的词典解释: soft material such as foam or cloth used to pad or stuff something. 填充的东西, 比如在亚马逊买的杯子, 快递盒子里面有个泡沫, 泡沫里面才是 杯子, 而这个泡沫就是被子的 padding. 所以应用 padding modifier 的顺序也是至关重要.</p>
<p>原理: The <code>padding</code> modifier adds padding to a view. It does so by taking the proposed size and subtracting the padding.</p>
<p>解释:</p>
<ul>
<li>SwiftUI布局是一个自上而下的过程, 父视图向 padding 提议一个可用的尺寸（proposed size）如 30</li>
<li><code>padding</code> 收到 proposed size: 30, 会减去 16(默认) = 14, 将 proposed size = 14 传给子视图</li>
<li>原始视图基于这个较小的建议尺寸来决定自己的大小 (可以遵从或者不遵从, 取决与 view 的类型和应用的 modifier, 如 <code>.fixedSize()</code> 就会让 view 一直 report 理想的尺寸, 而不是父视图 propose 的尺寸)</li>
</ul>
<p><img src="https://pub-2a6758f3b2d64ef5bb71ba1601101d35.r2.dev/blogs/2024/07/a882160400235c6d24501f1d7da567c0.jpg" alt=""></p>
<p><img src="https://pub-2a6758f3b2d64ef5bb71ba1601101d35.r2.dev/blogs/2024/07/5307d95b2a1819df63696dff31854401.jpg" alt=""></p>
<h2 id="4-aspectratio1-contentmode-fit-和--resizable">4. <code>.aspectRatio(1, contentMode: .fit)</code> 和  <code>.resizable()</code><a href="#4-aspectratio1-contentmode-fit-和--resizable" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p><code>.aspectRatio()</code> 最常见的就是和 <code>.resizable()</code> 一起使用.</p>
<h3 id="41-resizable">4.1. <code>.resizable()</code><a href="#41-resizable" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">resizable</span>(
</span></span><span style="display:flex;"><span>    capInsets: EdgeInsets = EdgeInsets(),
</span></span><span style="display:flex;"><span>    resizingMode: Image.ResizingMode = .stretch
</span></span><span style="display:flex;"><span>) -&gt; Image
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// stretch: A mode to enlarge or reduce the size of an image so that it fills the available space.</span>
</span></span></code></pre></div><p>所以应用了 resizable 的图片, 大小是根据可以用空间改变的, 这里的可用空间也可以理解为父视图为其 propose 的尺寸.</p>
<p>如下, 图片默认, 是不接受父视图的 propose size, 只会 report 自己的 size.</p>
<p><img src="https://pub-2a6758f3b2d64ef5bb71ba1601101d35.r2.dev/blogs/2024/07/deec310feffb04bd8358afc2160c004c.jpg" alt=""></p>
<p>加上 resizable, 图片便会接受 proposed size, 而  <code>aspectRatio(...)</code> 刚好就是修改 proposed size 的 (根据指定比例), 它俩天生一对.</p>
<p><img src="https://pub-2a6758f3b2d64ef5bb71ba1601101d35.r2.dev/blogs/2024/07/0b21372a47e485e9de0514800f46357b.jpg" alt=""></p>
<p>比如我让图片的比例显示为正方形:</p>
<p><img src="https://pub-2a6758f3b2d64ef5bb71ba1601101d35.r2.dev/blogs/2024/07/34929a01980bc6d950df3cb460b6b702.jpg" alt=""></p>
<p>虽然是正方形了, 宽高比为 1:1, 可能会问, 不是说 <code>resizable()</code> 让图片接受 propose size 吗, 为什么还是超出了 frame, 你仔细看清楚, 图片的直接上级是  <code>aspectRatio(...)</code> 而不是 <code>VStack</code> 的 <code>frame</code>, frame 给 vstack 一个 propose size, 然后 vstack 再把这个 size 传递给 <code>aspectRatio(...)</code>, 即 width: 200, height: 300, 然后我们给 <code>aspectRatio(...)</code> 的参数是 .fill, 宽高比为 1, 所以 <code>aspectRatio(...)</code> 修改 propose size 为 300 * 300 给 image, 因此呈现了现在的结果, 此时可以配合 <code>.clipShape()</code> 剪切掉图片多余的部分.</p>
<h3 id="42-aspectratio">4.2. <code>aspectRatio(...)</code><a href="#42-aspectratio" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<ul>
<li>
<p>第一个参数是宽高比（可选）, 若不提供, 则向上级 report 子视图理想的宽高比.</p>
</li>
<li>
<p>第二个参数 <code>contentMode</code>: A flag indicating whether this view should fit or fill the parent context.</p>
</li>
</ul>
<p>看个例子就明白了:</p>
<p><img src="https://pub-2a6758f3b2d64ef5bb71ba1601101d35.r2.dev/blogs/2024/07/ac21acd601632c0d4631b04101704a54.jpg" alt=""></p>
<p><img src="https://pub-2a6758f3b2d64ef5bb71ba1601101d35.r2.dev/blogs/2024/07/6030eaef9667219db109b234fc47f51b.jpg" alt=""></p>
<blockquote>
<p>Note: In the initial image example, we didn&rsquo;t specify a fixed aspect ratio. By leaving the parameter off, the underlying view&rsquo;s <a href="https://www.swiftuifieldguide.com/layout/ideal-size/">ideal size</a> is used to compute the aspect ratio. To compute the ideal size, the aspect ratio first proposes a <code> nil×nil</code> size to its child. The child&rsquo;s ideal size is used as the aspect ratio, and the aspect ratio then either fits or fills a rectangle with the computed ratio within its proposal. <a href="https://arc.net/l/quote/soiifgxm">swiftuifieldguide.com</a></p>
</blockquote>
<p><code>.fill</code> 常与<code>.clipShape()</code>搭配使用.  <strong>当你想确保 frame 被完全填满, 不留空白时使用</strong></p>
<p><code>fit</code> 适应  frame, 当打算显示整个图像, 不丢失任何部分时使用</p>
<h3 id="43-gotchas-httpswwwswiftuifieldguidecomlayoutaspect-ratiogotchas">4.3. <a href="https://www.swiftuifieldguide.com/layout/aspect-ratio/#gotchas">Gotchas </a><a href="#43-gotchas-httpswwwswiftuifieldguidecomlayoutaspect-ratiogotchas" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Perhaps surprisingly, the aspect ratio modifier only changes the <em>proposal</em>. For example, in <a href="https://www.swiftuifieldguide.com/layout/aspect-ratio/#gotchas">the view below</a>, it&rsquo;ll propose a square size to the text. However, as we can see from the border, the aspect ratio directly <em>reports</em> its child&rsquo;s size, and it doesn&rsquo;t report a square size.</p>
<p><img src="https://pub-2a6758f3b2d64ef5bb71ba1601101d35.r2.dev/blogs/2024/07/c75f7a5823677fad634f98958e21c3eb.jpg" alt=""></p>
<p>上面这句话中的 proposal 和 report 是什么?</p>
<blockquote>
<p>The essence of SwiftUI&rsquo;s layout system is very simple: a parent <strong>proposes</strong> a size to its child, and the child <strong>reports</strong> a size.</p>
<p>发现一个<a href="https://www.swiftuifieldguide.com/layout/introduction/#proposing">动画</a>很清楚的解释了这一过程, 可以去查看, 如果不是很理解可以看这个视频: <a href="https://www.youtube.com/watch?v=04fzFk367Dg&amp;t=28s">How layout works in SwiftUI </a></p>
<p>All SwiftUI layout happens in three simple steps, and understanding these steps is the key to getting great layouts every time. The steps are:</p>
<ol>
<li>A parent view proposes a size for its child.</li>
<li>Based on that information, the child then chooses its own size and the parent <em>must</em> respect that choice.</li>
<li>The parent then positions the child in its coordinate space.</li>
</ol>
</blockquote>
<p>再看最上面那句话: the aspect ratio modifier only changes the <em>proposal</em>, 显然这是在说 aspect ratio modifier 只会偷偷修改建议尺寸的大小(比例), 但是孩子上报的尺寸 他会如实上报, 即我把我的建议尺寸给你, 接不接受就看你自己了. 且 swiftui 的逻辑是, 上级视图必须无条件接受(上报)下级尺寸的报告.</p>
<p>了解更多: <a href="https://www.swiftuifieldguide.com/layout/aspect-ratio/#gotchas">Aspect Ratio - SwiftUI Field Guide</a></p>
<p>References:</p>
<p><a href="https://www.swiftuifieldguide.com/layout/aspect-ratio/">Aspect Ratio - SwiftUI Field Guide</a></p>
<p><a href="https://www.swiftuifieldguide.com/layout/introduction/">Introduction - SwiftUI Field Guide</a></p>
<h3 id="5-flexible-frames">5. Flexible Frames<a href="#5-flexible-frames" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>A flexible frame allows us to specify a minimum, ideal, and maximum value for each dimension. We can think of a frame as a “wrapper” view around its child that can <strong>both change the proposal to its child and change the reported size</strong>. One the most common usages is using <code>maxWidth: .infinity</code> to fill up the available width.</p>
<blockquote>
<p>One the most common usages is using <code>maxWidth: .infinity</code> to fill up the available width. 注意, 是 maxWidth 不是 width.</p>
</blockquote>
<p>frame 的默认宽度是其子视图的 report width,  若指定 <code>maxWidth: .infinity</code> , 则 frame 会填满父视图, 若父视图宽度小于子视图的 report width, frame 的宽度将保持在 子视图的 report width, 类似 [child&rsquo;s report width, .infinity)</p>
<p>可以使用 <code>minWidth: 0</code>, 无条件接受父视图的宽度,</p>
<blockquote>
<p>If we want to unconditionally accept the proposed width (regardless of the content&rsquo;s width), we can specify a minimum width of <code>0</code> and a maximum width of <code>.infinity</code>.</p>
</blockquote>
<p>References: <a href="https://www.swiftuifieldguide.com/layout/flexible-frames/">Flexible Frames - SwiftUI Field Guide</a></p>
<h2 id="5-实例分析">5. 实例分析<a href="#5-实例分析" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p><img src="https://pub-2a6758f3b2d64ef5bb71ba1601101d35.r2.dev/blogs/2024/07/2cbd400fbd4b67eb7cbb16d3235f2c3f.jpg" alt=""></p>
<p>前面了提到了 <code>.resizable()</code> 的默认行为: A mode to enlarge or reduce the size of an image so that it fills the available space. 宽度被 LazyVGrid 平均分配好了(两列), 图片想要填满屏幕, 就被纵向拉伸, 变成上图的样子.</p>
<p>加下来我们使用 <code>.aspectRatio(contentMode: .fill)</code>, 前面也提到了 <code>.aspectRatio()</code> 会根据比例修改 propose size, 我们没有指定比例, 所以比例就是原图的比例, 因为宽度确定了, 所以为了保持原图的比例, 图片自然就变得没那么长了. 如下图:</p>
<p><img src="https://pub-2a6758f3b2d64ef5bb71ba1601101d35.r2.dev/blogs/2024/07/33b3eaa93f02824289f4472a95509ed1.jpg" alt=""></p>
<p>可是为啥宽度不一样呢? 很简单, 左边的图比较宽, LazyVGrid 会给每行分配相同的高度,  也就是两张图的  <code>.aspectRatio()</code>  接受到的高度是相同的, 但是比例不同(各自图片的比例),   <code>.aspectRatio()</code>  会根据现在的宽度高度和比例来修改修改后的 propose size (如192*158) 肯定也不同,  <code>.resizable() </code> 会完全接受 propose size, 所以两张图的宽度不同,</p>
<p>想让宽度相同, 可以给相同的比例:</p>
<p><img src="https://pub-2a6758f3b2d64ef5bb71ba1601101d35.r2.dev/blogs/2024/07/2a6f50eb50ed95c4d5c54953f00f771e.jpg" alt=""></p>
<p><img src="https://pub-2a6758f3b2d64ef5bb71ba1601101d35.r2.dev/blogs/2024/07/4b789f645112c205d5649edeb6029025.jpg" alt=""></p>
<p>但如果我们不想让图片被拉伸,  想保持原图的比例呢, 那就使用 Flexible Frame, 提供 minWidth: 0, 意思是无条件接受上级propose width, 因为我们两列都是 flexible: <code>[.init(.flexible()), .init(.flexible())]</code>, LazyVGrid 分配的宽度自然也相同, frame 就得到了相同的宽度,  前面提到了 frame 会修改 report size from child, 也就是说无论 child 的尺寸是多少, frame 都会向上级报告自己的尺寸,</p>
<p>当然  <code>.aspectRatio()</code>  会修改 frame 传递的尺寸, 因为有比例存在, 这没关系, 我们最后在 frame 上使用 clip 就好了.</p>
<p><img src="https://pub-2a6758f3b2d64ef5bb71ba1601101d35.r2.dev/blogs/2024/07/05aacc4a64e76ac0a4216217e3d0e03f.jpg" alt=""></p>
<p><img src="https://pub-2a6758f3b2d64ef5bb71ba1601101d35.r2.dev/blogs/2024/07/dfa3cc016b54ca0f77e016dcf1de53b3.jpg" alt=""></p>

      </div></div>

  
    
<div class="pagination">
  <div class="pagination__title">
    <span class="pagination__title-h">查看其他文章</span>
    <hr />
  </div>
  <div class="pagination__buttons">
    
      <a href="https://blog.jiyi27.com/posts/ios/swiftui/005-predefined-styles/" class="button inline prev">
        Predefined Styles SwiftUI
      </a>
    
    
      ::
    
    
      <a href="https://blog.jiyi27.com/posts/ios/swiftui/006-reuse-views/" class="button inline next">
        SwiftUI Views
      </a>
    
  </div>
</div>


  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/jiyi27/jiyi27.github.io" target="_blank">Theme</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
