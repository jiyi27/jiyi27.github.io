<!DOCTYPE html>
<html lang="en">
<head>
  
    
    <title>Predefined Styles SwiftUI :: 为霜的博客</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="1. Color 1.1 Color.red vs .red background() 应该传入 Color.red 而不是直接 .red, 否则显示可能会不符合预期, 这和 Implicit Member Expression 有关系.
Swift 的类型推断能力意味着编译器能够自动理解表达式的类型而无需显式声明。在 SwiftUI 的视图中，很多属性（如 foregroundColor）期望的是一个 Color 类型。当你提供 .primary 时，Swift 知道这个上下文需要一个 Color 实例，因此它会查找 Color 类型中名为 primary 的静态属性。
如下定义所示, 调用 foregroundColor 时就可以直接使用 .red, 不必指定类型, 而 background 却不行,
func foregroundColor(_ color: Color?) -&gt; some View func background&lt;S&gt;( _ style: S, ignoresSafeAreaEdges edges: Edge.Set = .all ) -&gt; some View where S : ShapeStyle 1.2. Auto Color If you want the foregroundStyle color to adapt automatically to the system theme (such as light mode and dark mode), you can use some predefined colors like .primary, .secondary, .label, etc. These colors will automatically adjust according to different themes. However, it&rsquo;s important to note that using system colors like .label directly in foregroundStyle might encounter issues because foregroundStyle is more commonly used to define composite styles or gradients, rather than just a single color.
" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://blog.jiyi27.com/posts/ios/swiftui/005-predefined-styles/" />





  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/buttons.min.2bc533403a27dfe0e93105a92502b42ce4587e2e4a87d9f7d349e51e16e09478.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/categories.min.3202f75cbb294747099af3850a68a09ee94b3ce505fc39e134692d90ff0a9b2a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/code.min.dd73d157e77e82a3dc1cb06ba424cf6cc6811af0bb604ad6c68e70faf2439c8a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/fonts.min.4881f0c525f3ce2a1864fb6e96676396cebe1e6fcef1933e8e1dde7041004fb5.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/footer.min.2e3eb191baee58dd05a9f0104ac1fab0827bca7c64dafe0b2579f934c33a1d69.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/header.min.b6fb4423cf82a9f9d7abc9cd010223fa3d70a6526a3f28f8e17d814c06e18f9e.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/main.min.3fb8954e26342ad3afabb4525959bfec6f9fc0d6929f0dda738ddeee30211690.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/menu.min.8cee75f73b9f9b1e40bd0dd53e6e770156b08bbfe1c579cd256c3f6cd3b6d32b.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/pagination.min.82f6400eae7c7c6dc3c866733c2ec0579e4089608fea69400ff85b3880aa0d3c.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/post.min.014a50745fbdd41d5f420a3e288730d5af4b7d90344dc6211d0e50c368b5b303.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/prism.min.b958d3d7c6c67361b945f9062d07d403422604b3d2cd33f93b88d41ed0ba634d.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/term.min.94de320c1b850e126e6d2c88a7c90acf58bb1313f0ea14a14cda2a42f2a88db2.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">


<link rel="stylesheet" href="https://blog.jiyi27.com/terminal.css">




<link rel="shortcut icon" href="https://blog.jiyi27.com/favicon.png">
<link rel="apple-touch-icon" href="https://blog.jiyi27.com/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Predefined Styles SwiftUI">
<meta property="og:description" content="1. Color 1.1 Color.red vs .red background() 应该传入 Color.red 而不是直接 .red, 否则显示可能会不符合预期, 这和 Implicit Member Expression 有关系.
Swift 的类型推断能力意味着编译器能够自动理解表达式的类型而无需显式声明。在 SwiftUI 的视图中，很多属性（如 foregroundColor）期望的是一个 Color 类型。当你提供 .primary 时，Swift 知道这个上下文需要一个 Color 实例，因此它会查找 Color 类型中名为 primary 的静态属性。
如下定义所示, 调用 foregroundColor 时就可以直接使用 .red, 不必指定类型, 而 background 却不行,
func foregroundColor(_ color: Color?) -&gt; some View func background&lt;S&gt;( _ style: S, ignoresSafeAreaEdges edges: Edge.Set = .all ) -&gt; some View where S : ShapeStyle 1.2. Auto Color If you want the foregroundStyle color to adapt automatically to the system theme (such as light mode and dark mode), you can use some predefined colors like .primary, .secondary, .label, etc. These colors will automatically adjust according to different themes. However, it&rsquo;s important to note that using system colors like .label directly in foregroundStyle might encounter issues because foregroundStyle is more commonly used to define composite styles or gradients, rather than just a single color.
" />
<meta property="og:url" content="https://blog.jiyi27.com/posts/ios/swiftui/005-predefined-styles/" />
<meta property="og:site_name" content="为霜的博客" />

  <meta property="og:image" content="https://blog.jiyi27.com/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">

  <meta property="article:section" content="ios" />


  <meta property="article:published_time" content="2024-06-07 22:02:30 &#43;0000 UTC" />












</head>
<body>


<div class="container center">

  
  
  

  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://blog.jiyi27.com/posts/ios/swiftui/005-predefined-styles/">Predefined Styles SwiftUI</a>
  </h1>
  <div class="post-meta"><time class="post-date">2024-06-07</time><span class="post-reading-time">1 分钟阅读 (162 字数)</span></div>

  
    <span class="post-tags">
      
      #<a href="https://blog.jiyi27.com/tags/ios/">ios</a>&nbsp;
      
      #<a href="https://blog.jiyi27.com/tags/swiftui/">swiftui</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <h2 id="1-color">1. Color<a href="#1-color" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<h3 id="11-colorred-vs-red">1.1 <code>Color.red</code> vs <code>.red</code><a href="#11-colorred-vs-red" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p><code>background()</code> 应该传入 <code>Color.red</code> 而不是直接 <code>.red</code>, 否则显示可能会不符合预期, 这和 <a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/expressions/#Implicit-Member-Expression">Implicit Member Expression</a> 有关系.</p>
<blockquote>
<p>Swift 的类型推断能力意味着编译器能够自动理解表达式的类型而无需显式声明。在 SwiftUI 的视图中，很多属性（如 <code>foregroundColor</code>）期望的是一个 <code>Color</code> 类型。当你提供 <code>.primary</code> 时，Swift 知道这个上下文需要一个 <code>Color</code> 实例，因此它会查找 <code>Color</code> 类型中名为 <code>primary</code> 的静态属性。</p>
</blockquote>
<p>如下定义所示, 调用 foregroundColor 时就可以直接使用 <code>.red</code>, 不必指定类型, 而 background 却不行,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">foregroundColor</span>(<span style="color:#66d9ef">_</span> color: Color?) -&gt; some View
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">background</span>&lt;S&gt;(
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">_</span> style: S,
</span></span><span style="display:flex;"><span>    ignoresSafeAreaEdges edges: Edge.Set = .all
</span></span><span style="display:flex;"><span>) -&gt; some View <span style="color:#66d9ef">where</span> S : ShapeStyle
</span></span></code></pre></div><h3 id="12-auto-color">1.2. Auto Color<a href="#12-auto-color" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>If you <strong>want the <code>foregroundStyle</code> color to adapt automatically</strong> <strong>to the system theme</strong> (such as light mode and dark mode), you can use some predefined colors like <code>.primary</code>, <code>.secondary</code>, <code>.label</code>, etc. These colors will automatically adjust according to different themes. However, it&rsquo;s important to note that using system colors like <code>.label</code> directly in <code>foregroundStyle</code> might encounter issues because <code>foregroundStyle</code> is more commonly used to define composite styles or gradients, rather than just a single color.</p>
<p>考虑到 foregroundColor 已经被 foregroundStyle 替代, 有时候使用 primiary 并不能修改字体颜色, 比如 NavigationLink 默认是蓝色, 此时使用 primiary, 依然会是蓝色, 所以可以使用 label: <code>.foregroundStyle(Color(.label))</code></p>

      </div></div>

  
    
<div class="pagination">
  <div class="pagination__title">
    <span class="pagination__title-h">查看其他文章</span>
    <hr />
  </div>
  <div class="pagination__buttons">
    
      <a href="https://blog.jiyi27.com/posts/ios/swiftui/007-uikit/" class="button inline prev">
        UIKit in SwiftUI
      </a>
    
    
      ::
    
    
      <a href="https://blog.jiyi27.com/posts/ios/swiftui/004-modifiers/" class="button inline next">
        SwiftUI Modifiers
      </a>
    
  </div>
</div>


  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/jiyi27/jiyi27.github.io" target="_blank">Theme</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
