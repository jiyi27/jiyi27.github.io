<!DOCTYPE html>
<html lang="en">
<head>
  
    
    <title>Kafka vs RabbitMQ :: 为霜的博客</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="1. RabbitMQ 1.1. 优缺点 协议与消息模型灵活 RabbitMQ 基于 AMQP，可以实现多种路由策略（Direct、Fanout、Topic、Headers 等），在工作队列、发布订阅、RPC 等模式下都有成熟支持, 对编程语言、协议的兼容性好（STOMP、MQTT、AMQP 等）
低延迟 对于单条消息的快速投递、即时消费，RabbitMQ 的延迟通常可以控制在微秒到毫秒级，特别适合传统应用内的即时通信或实时响应业务
吞吐量较难达到 Kafka 的级别 RabbitMQ 也支持集群，但对于大规模数据流场景，其扩展性和稳定性往往不及 Kafka（轻量级队列系统与大数据流平台设计初衷不同）
消息持久化开销 若需要实现高可用持久化（开启镜像队列、确认机制、磁盘持久化等），在吞吐量和存储成本上会有一定牺牲
生态对于实时计算弱 相比 Kafka 自带或社区中完善的数据处理组件，RabbitMQ 主要聚焦在消息路由和队列本身，对大数据实时处理场景支持有限
AMQP Advanced Message Queuing Protocol, 是一种开放标准的应用层协议, AMQP 的核心目标是实现跨平台、跨语言的互操作性, AMQP 的主要组件包括：
交换机（Exchange）：负责接收生产者发送的消息，并根据路由规则将消息分发到合适的队列
队列（Queue）：存储消息的地方，消费者从队列中获取消息
绑定（Binding）：交换机和队列之间的关联，定义了消息的路由规则
路由键（Routing Key）：用于匹配消息和队列的标识
它支持多种工作模式, 简单模式, 工作队列模式, 发布/订阅模式, 路由模式等
1.2. 使用场景 传统应用中的异步处理
比如 Web 后端业务系统，需要快速返回请求，将后续的处理放到消息队列里异步执行 场景：下单后异步扣库存、发送通知邮件、短信等 实时通信或低延迟请求
需要消息在亚毫秒到毫秒级延迟内到达消费者进行处理 场景：实时消息推送、微服务 RPC、在线聊天系统等 多种路由策略
RabbitMQ 丰富的交换机（Exchange）类型可以满足复杂业务路由需求：如按不同 RoutingKey 分发给不同队列 2. Kafka 2.1. 优缺点 高吞吐量和可扩展性
核心功能是面向高吞吐量、可扩展性以及持久化的日志系统 Kafka 通过 Partition 进行横向扩展，可支持海量消息的高并发写入与读取 整体架构设计适合大规模分布式部署 持久化与顺序读取
" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://blog.jiyi27.com/posts/interview/%E7%BC%93%E5%AD%98%E5%92%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/001-kafka-rabbitmq/" />





  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/buttons.min.2bc533403a27dfe0e93105a92502b42ce4587e2e4a87d9f7d349e51e16e09478.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/categories.min.3202f75cbb294747099af3850a68a09ee94b3ce505fc39e134692d90ff0a9b2a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/code.min.dd73d157e77e82a3dc1cb06ba424cf6cc6811af0bb604ad6c68e70faf2439c8a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/fonts.min.4881f0c525f3ce2a1864fb6e96676396cebe1e6fcef1933e8e1dde7041004fb5.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/footer.min.2e3eb191baee58dd05a9f0104ac1fab0827bca7c64dafe0b2579f934c33a1d69.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/header.min.b6fb4423cf82a9f9d7abc9cd010223fa3d70a6526a3f28f8e17d814c06e18f9e.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/main.min.3fb8954e26342ad3afabb4525959bfec6f9fc0d6929f0dda738ddeee30211690.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/menu.min.8cee75f73b9f9b1e40bd0dd53e6e770156b08bbfe1c579cd256c3f6cd3b6d32b.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/pagination.min.82f6400eae7c7c6dc3c866733c2ec0579e4089608fea69400ff85b3880aa0d3c.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/post.min.014a50745fbdd41d5f420a3e288730d5af4b7d90344dc6211d0e50c368b5b303.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/prism.min.b958d3d7c6c67361b945f9062d07d403422604b3d2cd33f93b88d41ed0ba634d.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/term.min.94de320c1b850e126e6d2c88a7c90acf58bb1313f0ea14a14cda2a42f2a88db2.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">


<link rel="stylesheet" href="https://blog.jiyi27.com/terminal.css">




<link rel="shortcut icon" href="https://blog.jiyi27.com/favicon.png">
<link rel="apple-touch-icon" href="https://blog.jiyi27.com/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Kafka vs RabbitMQ">
<meta property="og:description" content="1. RabbitMQ 1.1. 优缺点 协议与消息模型灵活 RabbitMQ 基于 AMQP，可以实现多种路由策略（Direct、Fanout、Topic、Headers 等），在工作队列、发布订阅、RPC 等模式下都有成熟支持, 对编程语言、协议的兼容性好（STOMP、MQTT、AMQP 等）
低延迟 对于单条消息的快速投递、即时消费，RabbitMQ 的延迟通常可以控制在微秒到毫秒级，特别适合传统应用内的即时通信或实时响应业务
吞吐量较难达到 Kafka 的级别 RabbitMQ 也支持集群，但对于大规模数据流场景，其扩展性和稳定性往往不及 Kafka（轻量级队列系统与大数据流平台设计初衷不同）
消息持久化开销 若需要实现高可用持久化（开启镜像队列、确认机制、磁盘持久化等），在吞吐量和存储成本上会有一定牺牲
生态对于实时计算弱 相比 Kafka 自带或社区中完善的数据处理组件，RabbitMQ 主要聚焦在消息路由和队列本身，对大数据实时处理场景支持有限
AMQP Advanced Message Queuing Protocol, 是一种开放标准的应用层协议, AMQP 的核心目标是实现跨平台、跨语言的互操作性, AMQP 的主要组件包括：
交换机（Exchange）：负责接收生产者发送的消息，并根据路由规则将消息分发到合适的队列
队列（Queue）：存储消息的地方，消费者从队列中获取消息
绑定（Binding）：交换机和队列之间的关联，定义了消息的路由规则
路由键（Routing Key）：用于匹配消息和队列的标识
它支持多种工作模式, 简单模式, 工作队列模式, 发布/订阅模式, 路由模式等
1.2. 使用场景 传统应用中的异步处理
比如 Web 后端业务系统，需要快速返回请求，将后续的处理放到消息队列里异步执行 场景：下单后异步扣库存、发送通知邮件、短信等 实时通信或低延迟请求
需要消息在亚毫秒到毫秒级延迟内到达消费者进行处理 场景：实时消息推送、微服务 RPC、在线聊天系统等 多种路由策略
RabbitMQ 丰富的交换机（Exchange）类型可以满足复杂业务路由需求：如按不同 RoutingKey 分发给不同队列 2. Kafka 2.1. 优缺点 高吞吐量和可扩展性
核心功能是面向高吞吐量、可扩展性以及持久化的日志系统 Kafka 通过 Partition 进行横向扩展，可支持海量消息的高并发写入与读取 整体架构设计适合大规模分布式部署 持久化与顺序读取
" />
<meta property="og:url" content="https://blog.jiyi27.com/posts/interview/%E7%BC%93%E5%AD%98%E5%92%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/001-kafka-rabbitmq/" />
<meta property="og:site_name" content="为霜的博客" />

  <meta property="og:image" content="https://blog.jiyi27.com/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">

  <meta property="article:section" content="消息队列" />


  <meta property="article:published_time" content="2025-03-16 11:45:27 &#43;0000 UTC" />












</head>
<body>


<div class="container center">

  
  
  

  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://blog.jiyi27.com/posts/interview/%E7%BC%93%E5%AD%98%E5%92%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/001-kafka-rabbitmq/">Kafka vs RabbitMQ</a>
  </h1>
  <div class="post-meta"><time class="post-date">2025-03-16</time><span class="post-reading-time">1 分钟阅读 (197 字数)</span></div>

  
    <span class="post-tags">
      
      #<a href="https://blog.jiyi27.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a>&nbsp;
      
      #<a href="https://blog.jiyi27.com/tags/%E9%9D%A2%E8%AF%95/">面试</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <h2 id="1-rabbitmq">1. RabbitMQ<a href="#1-rabbitmq" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<h3 id="11-优缺点">1.1. 优缺点<a href="#11-优缺点" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<ul>
<li>
<p><strong>协议与消息模型灵活</strong> RabbitMQ 基于 AMQP，可以实现多种路由策略（Direct、Fanout、Topic、Headers 等），在工作队列、发布订阅、RPC 等模式下都有成熟支持, 对编程语言、协议的兼容性好（STOMP、MQTT、AMQP 等）</p>
</li>
<li>
<p><strong>低延迟</strong> 对于单条消息的快速投递、即时消费，RabbitMQ 的延迟通常可以控制在微秒到毫秒级，特别适合传统应用内的即时通信或实时响应业务</p>
</li>
<li>
<p><strong>吞吐量较难达到 Kafka 的级别</strong> RabbitMQ 也支持集群，但对于大规模数据流场景，其扩展性和稳定性往往不及 Kafka（轻量级队列系统与大数据流平台设计初衷不同）</p>
</li>
<li>
<p><strong>消息持久化开销</strong> 若需要实现高可用持久化（开启镜像队列、确认机制、磁盘持久化等），在吞吐量和存储成本上会有一定牺牲</p>
</li>
<li>
<p><strong>生态对于实时计算弱</strong> 相比 Kafka 自带或社区中完善的数据处理组件，RabbitMQ 主要聚焦在消息路由和队列本身，对大数据实时处理场景支持有限</p>
</li>
</ul>
<blockquote>
<p>AMQP Advanced Message Queuing Protocol, 是一种开放标准的应用层协议, AMQP 的核心目标是实现跨平台、跨语言的互操作性, AMQP 的主要组件包括：</p>
<p>交换机（Exchange）：负责接收生产者发送的消息，并根据路由规则将消息分发到合适的队列</p>
<p>队列（Queue）：存储消息的地方，消费者从队列中获取消息</p>
<p>绑定（Binding）：交换机和队列之间的关联，定义了消息的路由规则</p>
<p>路由键（Routing Key）：用于匹配消息和队列的标识</p>
<p>它支持多种工作模式, 简单模式, 工作队列模式, 发布/订阅模式, 路由模式等</p>
</blockquote>
<h2 id="12-使用场景">1.2. 使用场景<a href="#12-使用场景" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p><strong>传统应用中的异步处理</strong></p>
<ul>
<li>比如 Web 后端业务系统，需要<strong>快速返回请求</strong>，将后续的处理放到消息队列里异步执行</li>
<li>场景：下单后异步扣库存、发送通知邮件、短信等</li>
</ul>
<p><strong>实时通信或低延迟请求</strong></p>
<ul>
<li>需要消息在亚毫秒到毫秒级延迟内到达消费者进行处理</li>
<li>场景：实时消息推送、微服务 RPC、在线聊天系统等</li>
</ul>
<p><strong>多种路由策略</strong></p>
<ul>
<li>RabbitMQ 丰富的交换机（Exchange）类型可以满足<strong>复杂业务路由</strong>需求：如按不同 RoutingKey 分发给不同队列</li>
</ul>
<h2 id="2-kafka">2. Kafka<a href="#2-kafka" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<h3 id="21-优缺点">2.1. 优缺点<a href="#21-优缺点" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p><strong>高吞吐量和可扩展性</strong></p>
<ul>
<li>核心功能是面向高吞吐量、可扩展性以及持久化的日志系统</li>
<li>Kafka 通过 Partition 进行横向扩展，可支持海量消息的高并发写入与读取</li>
<li>整体架构设计适合大规模分布式部署</li>
</ul>
<p><strong>持久化与顺序读取</strong></p>
<ul>
<li>Kafka 中所有消息被持久化到磁盘，默认设置下也会进行副本（Replication）存储，故障恢复快、可靠性强</li>
<li>消费端通过 offset（偏移量）来定位消息</li>
</ul>
<p><strong>完善的生态</strong> Kafka Streams、ksqlDB、Connect 等组件支持实时计算、数据管道构建，便于与大数据体系对接（例如 Spark、Flink 等）</p>
<p><strong>消息投递不是严格的实时</strong> Kafka 侧重批量、流式吞吐量，延迟（Latency）相对于某些传统消息队列来说会稍高, 通常在毫秒到秒级，适合高吞吐场景</p>
<p><strong>消息模型相对简单</strong> Kafka 更强调分区、顺序的日志模型，在交换机/路由等维度的功能相比 RabbitMQ 等 AMQP 消息队列要简单一些</p>
<p><strong>相对复杂的运维与管理</strong> 集群依赖 ZooKeeper，对运维人员有一定要求</p>
<blockquote>
<p><strong>为什么 RabbitMQ 低延迟, 吞吐量却没 Kafka 高?</strong></p>
<p>吞吐量可以简单理解为每秒可以稳定处理 10 万条消息, 这就是高吞吐量, 延迟是指一条消息从 Producer 发送, 到 Consumer 收到并确认, 花了 5ms, 这就是“延迟”, 延迟更低意味着对单条消息来说, 响应更快, 低延迟通常意味着对每条消息采取“及时处理”的方式, 减少批量, 高吞吐量往往依赖批量发送、批量压缩、以及并行处理等技术手段</p>
<p>RabbitMQ 可能对<strong>单个消息进行直接的推送</strong>模式，没什么额外开销，特别是如果是内存队列或者轻量持久化，所以其单条消息可在很短时间内被消费</p>
<p>Kafka 在架构上着重于<strong>分区扩展</strong>、顺序写磁盘、<strong>批量 I/O</strong>，并且往往部署在多 Broker 的<strong>分布式集群</strong>上，能轻松承载数万至数十万甚至更高 TPS 的数据写入和消费, 对单条消息而言，可能有毫秒到秒级的等待时间，但在单位时间内可以处理非常庞大的消息总量（高吞吐量）</p>
</blockquote>
<h3 id="22-使用场景">2.2. 使用场景<a href="#22-使用场景" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p><strong>大数据、日志收集</strong></p>
<ul>
<li>大量日志、事件实时进入 Kafka，再对接下游 Spark、Flink、Hadoop 等进行数据分析、存储或流式处理</li>
<li>场景：电商订单流水、用户行为日志收集等</li>
</ul>
<p><strong>实时流处理与监控</strong></p>
<ul>
<li>配合 Kafka Streams、ksqlDB 或第三方流处理框架做实时数据分析、监控报警</li>
<li>场景：金融实时风控、监控数据聚合等</li>
</ul>
<p><strong>事件驱动架构</strong></p>
<ul>
<li>微服务之间通过 Kafka 进行解耦，可实现高吞吐的异步通信与事件广播</li>
<li>场景：大型互联网应用中，后端微服务之间的异步处理</li>
</ul>
<h2 id="3-总结">3. 总结<a href="#3-总结" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p><strong>高吞吐量 + 大规模数据流 + 实时/离线分析场景 → Kafka</strong></p>
<ul>
<li>如果系统需要<strong>承受海量数据</strong>的写入与消费（几十万甚至几百万级别的 TPS），并且需要对接大数据生态做后续处理，那么 Kafka 更合适</li>
<li>Kafka 提供 Partition 级别的横向扩展和日志存储模型，对历史消息也能回溯</li>
</ul>
<p><strong>轻量级任务队列 + 多种路由策略 + 低延迟场景 → RabbitMQ</strong></p>
<ul>
<li>如果你需要<strong>传统消息队列</strong>（AMQP）模型，以及在微服务中实现更灵活的<strong>路由</strong>或<strong>通信</strong>，RabbitMQ 的实现成本更低、生态成熟</li>
<li>适合相对<strong>中等规模</strong>的消息量，对延迟敏感性较高的系统</li>
</ul>
<p><strong>内部服务间的简单解耦</strong></p>
<ul>
<li>小规模场景下，RabbitMQ 足以胜任；大规模或预期未来数据量剧增，则可考虑一次性上 Kafka 以免后期大量迁移</li>
</ul>
<p><strong>从业务需求层面考虑：</strong></p>
<ul>
<li><strong>是否需要回放消息？</strong> 如果经常需要回放/重放，Kafka 的分区存储和 offset 机制十分方便</li>
<li><strong>是否需要强大的流处理生态？</strong> 如果需要针对实时数据做流计算和分析，Kafka 生态支持更完善</li>
<li><strong>是否需要复杂路由规则？</strong> RabbitMQ 的交换机模型在复杂路由上可能更具灵活性</li>
</ul>

      </div></div>

  
    
<div class="pagination">
  <div class="pagination__title">
    <span class="pagination__title-h">查看其他文章</span>
    <hr />
  </div>
  <div class="pagination__buttons">
    
      <a href="https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/007-spring-cloud-arch/" class="button inline prev">
        Spring Cloud 组件理解
      </a>
    
    
      ::
    
    
      <a href="https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/010-java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="button inline next">
        Java 多线程 并发编程
      </a>
    
  </div>
</div>


  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/jiyi27/jiyi27.github.io" target="_blank">Theme</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
