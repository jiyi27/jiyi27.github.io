<!DOCTYPE html>
<html lang="en">
<head>
  
    
    <title>游戏积分榜、直播平台礼物榜、电商热销榜 :: 为霜的博客</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="1. 游戏积分榜、直播平台礼物榜、电商热销榜 Game Ranking List：通常需要实时更新玩家积分并快速查询前 N 名（如 Top 100）, 积分可能频繁变化，支持动态排序
Live Streaming Gift Leaderboard：主播或用户收到礼物后，礼物价值累加，排行榜需实时反映最新排名，查询 Top N 或某用户排名
E-commerce Bestsellers List：基于商品销量排序，可能涉及复杂排序规则（如销量&#43;时间权重），更新频率可能稍低，但查询量大
共同特点：
实时或近实时更新 频繁查询 Top N 或某项排名 数据量可能较大（几十万到数亿条） 排序基于单一或复合分数 Priority Queues
Best when internal, performance-critical, and simple. When implementing low-level logic. Redis Sorted Sets
More frequently used in real-world, production-level systems Leaderboard systems (e.g., scores in games) Ranking systems (newsfeeds, social media) Expiring content prioritization Rate limiting 2. Bestsellers 2.1. Database Design -- Products table CREATE TABLE products ( product_id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(255) NOT NULL, description TEXT, price DECIMAL(10, 2) NOT NULL, inventory_count INT NOT NULL DEFAULT 0, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP ); -- Orders table CREATE TABLE orders ( order_id INT PRIMARY KEY AUTO_INCREMENT, user_id INT NOT NULL, total_amount DECIMAL(10, 2) NOT NULL, status VARCHAR(20) NOT NULL DEFAULT &#39;pending&#39;, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP ); -- Order Items table (for tracking individual products in orders) CREATE TABLE order_items ( order_item_id INT PRIMARY KEY AUTO_INCREMENT, order_id INT NOT NULL, product_id INT NOT NULL, quantity INT NOT NULL, unit_price DECIMAL(10, 2) NOT NULL, FOREIGN KEY (order_id) REFERENCES orders(order_id), FOREIGN KEY (product_id) REFERENCES products(product_id), created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ); -- Sales statistics table (to track sales for bestseller calculations) CREATE TABLE product_sales_stats ( stats_id INT PRIMARY KEY AUTO_INCREMENT, product_id INT NOT NULL, total_quantity_sold INT NOT NULL DEFAULT 0, total_revenue DECIMAL(15, 2) NOT NULL DEFAULT 0, last_sale_at TIMESTAMP NULL, FOREIGN KEY (product_id) REFERENCES products(product_id), created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP ); Separating orders from order items follows a common database normalization practice Reduce data redundancy One-to-Many Relationship A single order typically contains multiple products. The separation represents this one-to-many relationship accurately Performance for Order Processing Orders table can be queried quickly for order status checks without loading product details Imagine an order with 10 different products. If we combined orders and order items into a single table:
" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://blog.jiyi27.com/posts/interview/%E7%AE%97%E6%B3%95/007-%E6%B8%B8%E6%88%8F%E7%A7%AF%E5%88%86%E6%A6%9C%E5%90%84%E7%A7%8D%E6%A6%9C%E5%8D%95/" />





  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/buttons.min.2bc533403a27dfe0e93105a92502b42ce4587e2e4a87d9f7d349e51e16e09478.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/categories.min.3202f75cbb294747099af3850a68a09ee94b3ce505fc39e134692d90ff0a9b2a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/code.min.dd73d157e77e82a3dc1cb06ba424cf6cc6811af0bb604ad6c68e70faf2439c8a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/fonts.min.4881f0c525f3ce2a1864fb6e96676396cebe1e6fcef1933e8e1dde7041004fb5.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/footer.min.2e3eb191baee58dd05a9f0104ac1fab0827bca7c64dafe0b2579f934c33a1d69.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/header.min.b6fb4423cf82a9f9d7abc9cd010223fa3d70a6526a3f28f8e17d814c06e18f9e.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/main.min.3fb8954e26342ad3afabb4525959bfec6f9fc0d6929f0dda738ddeee30211690.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/menu.min.8cee75f73b9f9b1e40bd0dd53e6e770156b08bbfe1c579cd256c3f6cd3b6d32b.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/pagination.min.82f6400eae7c7c6dc3c866733c2ec0579e4089608fea69400ff85b3880aa0d3c.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/post.min.014a50745fbdd41d5f420a3e288730d5af4b7d90344dc6211d0e50c368b5b303.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/prism.min.b958d3d7c6c67361b945f9062d07d403422604b3d2cd33f93b88d41ed0ba634d.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/term.min.94de320c1b850e126e6d2c88a7c90acf58bb1313f0ea14a14cda2a42f2a88db2.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">


<link rel="stylesheet" href="https://blog.jiyi27.com/terminal.css">




<link rel="shortcut icon" href="https://blog.jiyi27.com/favicon.png">
<link rel="apple-touch-icon" href="https://blog.jiyi27.com/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="游戏积分榜、直播平台礼物榜、电商热销榜">
<meta property="og:description" content="1. 游戏积分榜、直播平台礼物榜、电商热销榜 Game Ranking List：通常需要实时更新玩家积分并快速查询前 N 名（如 Top 100）, 积分可能频繁变化，支持动态排序
Live Streaming Gift Leaderboard：主播或用户收到礼物后，礼物价值累加，排行榜需实时反映最新排名，查询 Top N 或某用户排名
E-commerce Bestsellers List：基于商品销量排序，可能涉及复杂排序规则（如销量&#43;时间权重），更新频率可能稍低，但查询量大
共同特点：
实时或近实时更新 频繁查询 Top N 或某项排名 数据量可能较大（几十万到数亿条） 排序基于单一或复合分数 Priority Queues
Best when internal, performance-critical, and simple. When implementing low-level logic. Redis Sorted Sets
More frequently used in real-world, production-level systems Leaderboard systems (e.g., scores in games) Ranking systems (newsfeeds, social media) Expiring content prioritization Rate limiting 2. Bestsellers 2.1. Database Design -- Products table CREATE TABLE products ( product_id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(255) NOT NULL, description TEXT, price DECIMAL(10, 2) NOT NULL, inventory_count INT NOT NULL DEFAULT 0, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP ); -- Orders table CREATE TABLE orders ( order_id INT PRIMARY KEY AUTO_INCREMENT, user_id INT NOT NULL, total_amount DECIMAL(10, 2) NOT NULL, status VARCHAR(20) NOT NULL DEFAULT &#39;pending&#39;, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP ); -- Order Items table (for tracking individual products in orders) CREATE TABLE order_items ( order_item_id INT PRIMARY KEY AUTO_INCREMENT, order_id INT NOT NULL, product_id INT NOT NULL, quantity INT NOT NULL, unit_price DECIMAL(10, 2) NOT NULL, FOREIGN KEY (order_id) REFERENCES orders(order_id), FOREIGN KEY (product_id) REFERENCES products(product_id), created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ); -- Sales statistics table (to track sales for bestseller calculations) CREATE TABLE product_sales_stats ( stats_id INT PRIMARY KEY AUTO_INCREMENT, product_id INT NOT NULL, total_quantity_sold INT NOT NULL DEFAULT 0, total_revenue DECIMAL(15, 2) NOT NULL DEFAULT 0, last_sale_at TIMESTAMP NULL, FOREIGN KEY (product_id) REFERENCES products(product_id), created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP ); Separating orders from order items follows a common database normalization practice Reduce data redundancy One-to-Many Relationship A single order typically contains multiple products. The separation represents this one-to-many relationship accurately Performance for Order Processing Orders table can be queried quickly for order status checks without loading product details Imagine an order with 10 different products. If we combined orders and order items into a single table:
" />
<meta property="og:url" content="https://blog.jiyi27.com/posts/interview/%E7%AE%97%E6%B3%95/007-%E6%B8%B8%E6%88%8F%E7%A7%AF%E5%88%86%E6%A6%9C%E5%90%84%E7%A7%8D%E6%A6%9C%E5%8D%95/" />
<meta property="og:site_name" content="为霜的博客" />

  <meta property="og:image" content="https://blog.jiyi27.com/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">

  <meta property="article:section" content="面试" />


  <meta property="article:published_time" content="2025-04-18 23:27:20 &#43;0000 UTC" />












</head>
<body>


<div class="container center">

  
  
  

  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://blog.jiyi27.com/posts/interview/%E7%AE%97%E6%B3%95/007-%E6%B8%B8%E6%88%8F%E7%A7%AF%E5%88%86%E6%A6%9C%E5%90%84%E7%A7%8D%E6%A6%9C%E5%8D%95/">游戏积分榜、直播平台礼物榜、电商热销榜</a>
  </h1>
  <div class="post-meta"><time class="post-date">2025-04-18</time><span class="post-reading-time">4 分钟阅读 (790 字数)</span></div>

  
    <span class="post-tags">
      
      #<a href="https://blog.jiyi27.com/tags/%E9%9D%A2%E8%AF%95/">面试</a>&nbsp;
      
      #<a href="https://blog.jiyi27.com/tags/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/">算法面试</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <h2 id="1-游戏积分榜直播平台礼物榜电商热销榜">1. 游戏积分榜、直播平台礼物榜、电商热销榜<a href="#1-游戏积分榜直播平台礼物榜电商热销榜" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p><strong>Game Ranking List</strong>：通常需要实时更新玩家积分并快速查询前 N 名（如 Top 100）, 积分可能频繁变化，支持动态排序</p>
<p><strong>Live Streaming Gift Leaderboard</strong>：主播或用户收到礼物后，礼物价值累加，排行榜需实时反映最新排名，查询 Top N 或某用户排名</p>
<p><strong>E-commerce Bestsellers List</strong>：基于商品销量排序，可能涉及复杂排序规则（如销量+时间权重），更新频率可能稍低，但查询量大</p>
<p><strong>共同特点：</strong></p>
<ul>
<li>实时或近实时更新</li>
<li>频繁查询 Top N 或某项排名</li>
<li>数据量可能较大（几十万到数亿条）</li>
<li>排序基于单一或复合分数</li>
</ul>
<blockquote>
<p><strong>Priority Queues</strong></p>
<ul>
<li>Best when internal, performance-critical, and simple.</li>
<li>When implementing low-level logic.</li>
</ul>
<p><strong>Redis Sorted Sets</strong></p>
<ul>
<li>More frequently used in <strong>real-world, production-level systems</strong></li>
<li>Leaderboard systems (e.g., scores in games)</li>
<li>Ranking systems (newsfeeds, social media)</li>
<li>Expiring content prioritization</li>
<li>Rate limiting</li>
</ul>
</blockquote>
<h2 id="2-bestsellers">2. Bestsellers<a href="#2-bestsellers" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<h3 id="21-database-design">2.1. Database Design<a href="#21-database-design" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span>-- Products table
</span></span><span style="display:flex;"><span>CREATE TABLE products (
</span></span><span style="display:flex;"><span>    product_id INT PRIMARY KEY AUTO_INCREMENT,
</span></span><span style="display:flex;"><span>    name VARCHAR(<span style="color:#ae81ff">255</span>) NOT NULL,
</span></span><span style="display:flex;"><span>    description TEXT,
</span></span><span style="display:flex;"><span>    price DECIMAL(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">2</span>) NOT NULL,
</span></span><span style="display:flex;"><span>    inventory_count INT NOT NULL DEFAULT <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
</span></span><span style="display:flex;"><span>    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>-- Orders table
</span></span><span style="display:flex;"><span>CREATE TABLE orders (
</span></span><span style="display:flex;"><span>    order_id INT PRIMARY KEY AUTO_INCREMENT,
</span></span><span style="display:flex;"><span>    user_id INT NOT NULL,
</span></span><span style="display:flex;"><span>    total_amount DECIMAL(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">2</span>) NOT NULL,
</span></span><span style="display:flex;"><span>    status VARCHAR(<span style="color:#ae81ff">20</span>) NOT NULL DEFAULT <span style="color:#960050;background-color:#1e0010">&#39;</span>pending<span style="color:#960050;background-color:#1e0010">&#39;</span>,
</span></span><span style="display:flex;"><span>    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
</span></span><span style="display:flex;"><span>    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>-- Order Items table (<span style="color:#66d9ef">for</span> tracking individual products <span style="color:#66d9ef">in</span> orders)
</span></span><span style="display:flex;"><span>CREATE TABLE order_items (
</span></span><span style="display:flex;"><span>    order_item_id INT PRIMARY KEY AUTO_INCREMENT,
</span></span><span style="display:flex;"><span>    order_id INT NOT NULL,
</span></span><span style="display:flex;"><span>    product_id INT NOT NULL,
</span></span><span style="display:flex;"><span>    quantity INT NOT NULL,
</span></span><span style="display:flex;"><span>    unit_price DECIMAL(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">2</span>) NOT NULL,
</span></span><span style="display:flex;"><span>    FOREIGN KEY (order_id) REFERENCES orders(order_id),
</span></span><span style="display:flex;"><span>    FOREIGN KEY (product_id) REFERENCES products(product_id),
</span></span><span style="display:flex;"><span>    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>-- Sales statistics table (to track sales <span style="color:#66d9ef">for</span> bestseller calculations)
</span></span><span style="display:flex;"><span>CREATE TABLE product_sales_stats (
</span></span><span style="display:flex;"><span>    stats_id INT PRIMARY KEY AUTO_INCREMENT,
</span></span><span style="display:flex;"><span>    product_id INT NOT NULL,
</span></span><span style="display:flex;"><span>    total_quantity_sold INT NOT NULL DEFAULT <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    total_revenue DECIMAL(<span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">2</span>) NOT NULL DEFAULT <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    last_sale_at TIMESTAMP NULL,
</span></span><span style="display:flex;"><span>    FOREIGN KEY (product_id) REFERENCES products(product_id),
</span></span><span style="display:flex;"><span>    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
</span></span><span style="display:flex;"><span>    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><ul>
<li>Separating orders from order items follows a common <strong>database normalization</strong> practice
<ul>
<li><strong>Reduce data redundancy</strong></li>
</ul>
</li>
<li>One-to-Many Relationship
<ul>
<li>A single order typically contains multiple products. The separation represents this one-to-many relationship accurately</li>
</ul>
</li>
<li>Performance for Order Processing
<ul>
<li>Orders table can be queried quickly for order status checks without loading product details</li>
</ul>
</li>
</ul>
<p>Imagine an order with 10 different products. If we combined orders and order items into a single table:</p>
<pre tabindex="0"><code>order_id | user_id | product_id | quantity | price | status | created_at | ...
---------|---------|------------|----------|-------|--------|------------|-----
1        | 42      | 101        | 2        | 19.99 | pending| 2023-01-01 | ...
1        | 42      | 205        | 1        | 29.99 | pending| 2023-01-01 | ...
1        | 42      | 310        | 5        | 5.99  | pending| 2023-01-01 | ...
</code></pre><p>This approach has serious problems:</p>
<ul>
<li>User information is <strong>duplicated</strong> for every product in the order</li>
<li>Status updates require updating multiple rows</li>
<li>Calculating order totals is more complex</li>
<li>Finding basic order information means sorting through product entries</li>
</ul>
<p><strong>Make sure your tables are properly indexed:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">INDEX</span> idx_order_items_product_id <span style="color:#66d9ef">ON</span> order_items(product_id);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">INDEX</span> idx_orders_status <span style="color:#66d9ef">ON</span> orders(status);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">INDEX</span> idx_orders_created_at <span style="color:#66d9ef">ON</span> orders(created_at);
</span></span></code></pre></div><h3 id="22-query-for-bestsellers">2.2. Query for Bestsellers<a href="#22-query-for-bestsellers" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#75715e">-- Basic bestsellers query (by quantity)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">SELECT</span> 
</span></span><span style="display:flex;"><span>    p.product_id,
</span></span><span style="display:flex;"><span>    p.name,
</span></span><span style="display:flex;"><span>    p.price,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">SUM</span>(oi.quantity) <span style="color:#66d9ef">as</span> total_sold
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span> 
</span></span><span style="display:flex;"><span>    products p
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">JOIN</span> 
</span></span><span style="display:flex;"><span>    order_items oi <span style="color:#66d9ef">ON</span> p.product_id <span style="color:#f92672">=</span> oi.product_id
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">JOIN</span> 
</span></span><span style="display:flex;"><span>    orders o <span style="color:#66d9ef">ON</span> oi.order_id <span style="color:#f92672">=</span> o.order_id
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">WHERE</span> 
</span></span><span style="display:flex;"><span>    o.status <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;completed&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">-- Optional: Add date range filter, e.g., for weekly bestsellers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">-- AND o.created_at &gt;= DATE_SUB(NOW(), INTERVAL 7 DAY) 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> 
</span></span><span style="display:flex;"><span>    p.product_id, p.name, p.price
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> 
</span></span><span style="display:flex;"><span>    total_sold <span style="color:#66d9ef">DESC</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">LIMIT</span> <span style="color:#ae81ff">3</span>;
</span></span></code></pre></div><p>Alternatively, if we maintain the <code>product_sales_stats</code> table through triggers or scheduled updates:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#75715e">-- Faster bestsellers query using the stats table
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">SELECT</span> 
</span></span><span style="display:flex;"><span>    p.product_id,
</span></span><span style="display:flex;"><span>    p.name,
</span></span><span style="display:flex;"><span>    p.price,
</span></span><span style="display:flex;"><span>    ps.total_quantity_sold
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span> 
</span></span><span style="display:flex;"><span>    products p
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">JOIN</span> 
</span></span><span style="display:flex;"><span>    product_sales_stats ps <span style="color:#66d9ef">ON</span> p.product_id <span style="color:#f92672">=</span> ps.product_id
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> 
</span></span><span style="display:flex;"><span>    ps.total_quantity_sold <span style="color:#66d9ef">DESC</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">LIMIT</span> <span style="color:#ae81ff">3</span>;
</span></span></code></pre></div><blockquote>
<p><strong>Multiple joins are expensive</strong> - The original query joins three tables (products, order_items, and orders), which becomes increasingly costly as these tables grow.</p>
<p>The <code>product_sales_stats</code> table is actually the better approach for performance reasons. This query <strong>performs much better</strong> as it only requires <strong>a single join</strong> and the data is already aggregated.</p>
</blockquote>
<p>Instead of updating the sales stats on every order, you could set up a scheduled job that runs periodically (e.g., every 5 minutes or hourly) to update the aggregated data:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#75715e">-- Run in a scheduled job
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">UPDATE</span> product_sales_stats ps
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">JOIN</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">SELECT</span> 
</span></span><span style="display:flex;"><span>        oi.product_id,
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">SUM</span>(oi.quantity) <span style="color:#66d9ef">AS</span> total_quantity,
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">SUM</span>(oi.quantity <span style="color:#f92672">*</span> oi.unit_price) <span style="color:#66d9ef">AS</span> total_revenue
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">FROM</span> 
</span></span><span style="display:flex;"><span>        order_items oi
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">JOIN</span> 
</span></span><span style="display:flex;"><span>        orders o <span style="color:#66d9ef">ON</span> oi.order_id <span style="color:#f92672">=</span> o.order_id
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">WHERE</span> 
</span></span><span style="display:flex;"><span>        o.status <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;completed&#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">AND</span> o.updated_at <span style="color:#f92672">&gt;</span> (<span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">MAX</span>(last_update) <span style="color:#66d9ef">FROM</span> stats_update_log)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> 
</span></span><span style="display:flex;"><span>        oi.product_id
</span></span><span style="display:flex;"><span>) new_data <span style="color:#66d9ef">ON</span> ps.product_id <span style="color:#f92672">=</span> new_data.product_id
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SET</span> 
</span></span><span style="display:flex;"><span>    ps.total_quantity_sold <span style="color:#f92672">=</span> ps.total_quantity_sold <span style="color:#f92672">+</span> new_data.total_quantity,
</span></span><span style="display:flex;"><span>    ps.total_revenue <span style="color:#f92672">=</span> ps.total_revenue <span style="color:#f92672">+</span> new_data.total_revenue,
</span></span><span style="display:flex;"><span>    ps.updated_at <span style="color:#f92672">=</span> NOW();
</span></span></code></pre></div><h3 id="23-redis-sorted-sets">2.3. Redis sorted sets<a href="#23-redis-sorted-sets" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>For even better performance, you could <strong>use Redis sorted sets to track bestsellers</strong> directly:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># When processing an order</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">update_bestseller_ranking</span>(product_id, quantity_sold):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Increment the score in a sorted set</span>
</span></span><span style="display:flex;"><span>    redis_client<span style="color:#f92672">.</span>zincrby(<span style="color:#e6db74">&#39;bestsellers:by_quantity&#39;</span>, quantity_sold, product_id)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Store product details in a hash</span>
</span></span><span style="display:flex;"><span>    redis_client<span style="color:#f92672">.</span>hset(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;product:</span><span style="color:#e6db74">{</span>product_id<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>, mapping<span style="color:#f92672">=</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;name&#39;</span>: product_name,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;price&#39;</span>: product_price
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># To get top 3 bestsellers</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_top_bestsellers</span>(count<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Get product IDs with highest scores</span>
</span></span><span style="display:flex;"><span>    top_product_ids <span style="color:#f92672">=</span> redis_client<span style="color:#f92672">.</span>zrevrange(<span style="color:#e6db74">&#39;bestsellers:by_quantity&#39;</span>, <span style="color:#ae81ff">0</span>, count<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, withscores<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    bestsellers <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> product_id, score <span style="color:#f92672">in</span> top_product_ids:
</span></span><span style="display:flex;"><span>        product_data <span style="color:#f92672">=</span> redis_client<span style="color:#f92672">.</span>hgetall(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;product:</span><span style="color:#e6db74">{</span>product_id<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>        bestsellers<span style="color:#f92672">.</span>append({
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;product_id&#39;</span>: product_id,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;name&#39;</span>: product_data[<span style="color:#e6db74">&#39;name&#39;</span>],
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;price&#39;</span>: product_data[<span style="color:#e6db74">&#39;price&#39;</span>],
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;total_quantity_sold&#39;</span>: int(score)
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> bestsellers
</span></span></code></pre></div>
      </div></div>

  
    
<div class="pagination">
  <div class="pagination__title">
    <span class="pagination__title-h">查看其他文章</span>
    <hr />
  </div>
  <div class="pagination__buttons">
    
      <a href="https://blog.jiyi27.com/posts/frontend/vue/002-vue-%E7%BB%84%E4%BB%B6%E5%AF%BC%E5%85%A5/" class="button inline prev">
        Vue 组件导入
      </a>
    
    
      ::
    
    
      <a href="https://blog.jiyi27.com/posts/csharp/basics/002-%E6%8B%93%E5%B1%95%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/" class="button inline next">
        Extension Namespaces C#
      </a>
    
  </div>
</div>


  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/jiyi27/jiyi27.github.io" target="_blank">Theme</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
