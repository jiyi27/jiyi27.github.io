<!DOCTYPE html>
<html lang="en">
<head>
  
    
    <title>Spring Cloud 组件理解 :: 为霜的博客</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="1. Spring Cloud Loadbalancer Spring Cloud Loadbalancer 并不是一个独立运行的服务 比如监听某个端口的进程, 而是一个 JAR 包, 集成到你的应用 比如 Gateway 或微服务 中, 在你的应用进程内部运行, 作为一个功能模块, Spring Cloud Loadbalancer 的工作原理是：
依赖服务注册中心: 它从服务注册中心（如 Eureka）获取服务实例列表 执行负载均衡逻辑: 在客户端本地（即你的应用进程中），根据配置的算法选择一个实例（通常是 IP &#43; 端口） 返回实例地址: 将选中的实例地址交给调用方（比如 Gateway 或 RestTemplate），由调用方发起实际请求 它不需要监听端口，因为它不是服务端，而是客户端逻辑的一部分
2. Spring Cloud Gateway 职责: Spring Cloud Gateway 是一个 API 网关, 它是整个系统的边界层, 面对外部客户端, 负责请求的分配和转发, 核心功能:
路由：将外部请求转发到对应的微服务
过滤：对请求进行预处理（如认证、限流）或响应处理（如添加头信息）
负载均衡：内置支持负载均衡 (通过调用 Spring Cloud Loadbalancer 实现)
如果 Gateway 可以负载均衡，为什么还需要 Spring Cloud Loadbalancer？
虽然 Gateway 可以做负载均衡, 但它只是“使用者”, 而 Spring Cloud Loadbalancer 是“提供者”, Loadbalancer 的存在是为了解耦负载均衡逻辑, 使其可以被多个组件复用, 而不仅仅局限于 Gateway,
" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/007-spring-cloud-arch/" />





  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/buttons.min.2bc533403a27dfe0e93105a92502b42ce4587e2e4a87d9f7d349e51e16e09478.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/categories.min.3202f75cbb294747099af3850a68a09ee94b3ce505fc39e134692d90ff0a9b2a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/code.min.dd73d157e77e82a3dc1cb06ba424cf6cc6811af0bb604ad6c68e70faf2439c8a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/fonts.min.4881f0c525f3ce2a1864fb6e96676396cebe1e6fcef1933e8e1dde7041004fb5.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/footer.min.2e3eb191baee58dd05a9f0104ac1fab0827bca7c64dafe0b2579f934c33a1d69.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/header.min.b6fb4423cf82a9f9d7abc9cd010223fa3d70a6526a3f28f8e17d814c06e18f9e.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/main.min.3fb8954e26342ad3afabb4525959bfec6f9fc0d6929f0dda738ddeee30211690.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/menu.min.8cee75f73b9f9b1e40bd0dd53e6e770156b08bbfe1c579cd256c3f6cd3b6d32b.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/pagination.min.82f6400eae7c7c6dc3c866733c2ec0579e4089608fea69400ff85b3880aa0d3c.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/post.min.014a50745fbdd41d5f420a3e288730d5af4b7d90344dc6211d0e50c368b5b303.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/prism.min.b958d3d7c6c67361b945f9062d07d403422604b3d2cd33f93b88d41ed0ba634d.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/term.min.94de320c1b850e126e6d2c88a7c90acf58bb1313f0ea14a14cda2a42f2a88db2.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">


<link rel="stylesheet" href="https://blog.jiyi27.com/terminal.css">




<link rel="shortcut icon" href="https://blog.jiyi27.com/favicon.png">
<link rel="apple-touch-icon" href="https://blog.jiyi27.com/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Spring Cloud 组件理解">
<meta property="og:description" content="1. Spring Cloud Loadbalancer Spring Cloud Loadbalancer 并不是一个独立运行的服务 比如监听某个端口的进程, 而是一个 JAR 包, 集成到你的应用 比如 Gateway 或微服务 中, 在你的应用进程内部运行, 作为一个功能模块, Spring Cloud Loadbalancer 的工作原理是：
依赖服务注册中心: 它从服务注册中心（如 Eureka）获取服务实例列表 执行负载均衡逻辑: 在客户端本地（即你的应用进程中），根据配置的算法选择一个实例（通常是 IP &#43; 端口） 返回实例地址: 将选中的实例地址交给调用方（比如 Gateway 或 RestTemplate），由调用方发起实际请求 它不需要监听端口，因为它不是服务端，而是客户端逻辑的一部分
2. Spring Cloud Gateway 职责: Spring Cloud Gateway 是一个 API 网关, 它是整个系统的边界层, 面对外部客户端, 负责请求的分配和转发, 核心功能:
路由：将外部请求转发到对应的微服务
过滤：对请求进行预处理（如认证、限流）或响应处理（如添加头信息）
负载均衡：内置支持负载均衡 (通过调用 Spring Cloud Loadbalancer 实现)
如果 Gateway 可以负载均衡，为什么还需要 Spring Cloud Loadbalancer？
虽然 Gateway 可以做负载均衡, 但它只是“使用者”, 而 Spring Cloud Loadbalancer 是“提供者”, Loadbalancer 的存在是为了解耦负载均衡逻辑, 使其可以被多个组件复用, 而不仅仅局限于 Gateway,
" />
<meta property="og:url" content="https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/007-spring-cloud-arch/" />
<meta property="og:site_name" content="为霜的博客" />

  <meta property="og:image" content="https://blog.jiyi27.com/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">

  <meta property="article:section" content="面试" />


  <meta property="article:published_time" content="2025-03-17 12:01:20 &#43;0000 UTC" />












</head>
<body>


<div class="container center">

  
  
  

  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/007-spring-cloud-arch/">Spring Cloud 组件理解</a>
  </h1>
  <div class="post-meta"><time class="post-date">2025-03-17</time><span class="post-reading-time">3 分钟阅读 (509 字数)</span></div>

  
    <span class="post-tags">
      
      #<a href="https://blog.jiyi27.com/tags/%E9%9D%A2%E8%AF%95/">面试</a>&nbsp;
      
      #<a href="https://blog.jiyi27.com/tags/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/">后端面试</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <h2 id="1-spring-cloud-loadbalancer">1. Spring Cloud Loadbalancer<a href="#1-spring-cloud-loadbalancer" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>Spring Cloud Loadbalancer 并不是一个独立运行的服务 比如监听某个端口的进程, 而是一个 JAR 包, 集成到你的应用 比如 Gateway 或微服务 中, 在你的应用进程内部运行, 作为一个功能模块, Spring Cloud Loadbalancer 的工作原理是：</p>
<ol>
<li><strong>依赖服务注册中心</strong>: 它从服务注册中心（如 Eureka）获取服务实例列表</li>
<li><strong>执行负载均衡逻辑</strong>: 在客户端本地（即你的应用进程中），根据配置的算法选择一个实例（通常是 IP + 端口）</li>
<li><strong>返回实例地址</strong>: 将选中的实例地址交给调用方（比如 Gateway 或 RestTemplate），由调用方发起实际请求</li>
</ol>
<p>它不需要监听端口，因为它不是服务端，而是客户端逻辑的一部分</p>
<h2 id="2-spring-cloud-gateway">2. Spring Cloud Gateway<a href="#2-spring-cloud-gateway" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>职责: Spring Cloud Gateway 是一个 API 网关, 它是整个系统的边界层, 面对外部客户端, 负责请求的分配和转发, 核心功能:</p>
<ul>
<li>
<p>路由：将外部请求转发到对应的微服务</p>
</li>
<li>
<p>过滤：对请求进行预处理（如认证、限流）或响应处理（如添加头信息）</p>
</li>
<li>
<p>负载均衡：内置支持负载均衡 (通过调用 Spring Cloud Loadbalancer 实现)</p>
</li>
</ul>
<blockquote>
<p>如果 Gateway 可以负载均衡，为什么还需要 Spring Cloud Loadbalancer？</p>
<p>虽然 Gateway 可以做负载均衡, 但它只是“使用者”, 而 Spring Cloud Loadbalancer 是“提供者”, Loadbalancer 的存在是为了解耦负载均衡逻辑, 使其可以被多个组件复用, 而不仅仅局限于 Gateway,</p>
</blockquote>
<h3 id="21-loadbalancer-在-gateway-中工作方式">2.1. Loadbalancer 在 Gateway 中工作方式<a href="#21-loadbalancer-在-gateway-中工作方式" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">spring</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">cloud</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">gateway</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">routes</span>:
</span></span><span style="display:flex;"><span>        - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">order-service-route</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">uri</span>: <span style="color:#ae81ff">lb://order-service</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">predicates</span>:
</span></span><span style="display:flex;"><span>            - <span style="color:#ae81ff">Path=/orders/**</span>
</span></span></code></pre></div><p>当 Spring Cloud Gateway 配置了 <code>lb://service-name</code> 时, 背后依赖 Spring Cloud Loadbalancer 来完成实例选择:</p>
<ul>
<li>客户端发送请求 GET /orders/list 到 Gateway</li>
<li>Gateway 解析 lb://order-service，识别这是一个需要负载均衡的路由</li>
<li>Gateway 调用 Spring Cloud Loadbalancer</li>
<li>Loadbalancer 从服务注册中心获取 order-service 的实例列表（比如 192.168.1.1:8081、192.168.1.2:8082、192.168.1.3:8083）</li>
<li>Loadbalancer 根据算法（默认轮询）选择一个实例，比如 192.168.1.2:8082</li>
<li>Gateway 拿到这个地址，将请求转发到 http://192.168.1.2:8082/orders/list</li>
</ul>
<h3 id="22-loadbalancer-在微服务间调用中的工作方式">2.2. Loadbalancer 在微服务间调用中的工作方式<a href="#22-loadbalancer-在微服务间调用中的工作方式" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>在微服务直接调用（不经过 Gateway）时，比如使用 <code>@LoadBalanced</code> 的 <code>RestTemplate</code> 客户端，Loadbalancer 的作用也是一样的:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@RestController</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">OrderController</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Autowired</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> RestTemplate restTemplate;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@GetMapping</span>(<span style="color:#e6db74">&#34;/pay&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">pay</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 注意这里是通过服务名称访问</span>
</span></span><span style="display:flex;"><span>        String url <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;http://payment-service/pay&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> restTemplate.<span style="color:#a6e22e">getForObject</span>(url, String.<span style="color:#a6e22e">class</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Bean</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@LoadBalanced</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> RestTemplate <span style="color:#a6e22e">restTemplate</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> RestTemplate();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>这里的 <code>&quot;http://payment-service/pay&quot;</code> 不是 具体的 IP 地址，而是一个 服务名称</li>
<li><code>@LoadBalanced</code>：启用 Spring Cloud 负载均衡功能, 让 <code>RestTemplate</code> 去注册中心查询 <code>payment-service</code> 的真实地址</li>
<li>获取所有可用实例, 可能有多个, 启动负载均衡策略, RestTemplate 发送 HTTP 请求 到选定的 <code>payment-service</code> 实例</li>
</ul>
<blockquote>
<p>Spring Cloud Gateway 的负载均衡功能（lb:// 前缀）依赖于 Spring Cloud 生态中的负载均衡机制，而这个机制默认由 Spring Cloud Loadbalancer 提供, 但这种依赖并不是 Gateway 项目直接引入的，而是通过 Spring Cloud 依赖管理间接实现的,</p>
<p>在 Spring Boot 和 Spring Cloud 项目中，依赖管理通常通过 <strong>Spring Cloud BOM（Bill of Materials）</strong> 来统一处理版本和组件集成。Spring Cloud Gateway 和 Spring Cloud Loadbalancer 都属于 Spring Cloud 生态的一部分，当你引入 spring-cloud-starter-gateway 时，负载均衡相关的依赖会通过依赖链条隐式引入</p>
</blockquote>
<h2 id="3-spring-cloud-circuit-breaker">3. Spring Cloud Circuit Breaker<a href="#3-spring-cloud-circuit-breaker" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<h3 id="31-如何使用">3.1. 如何使用<a href="#31-如何使用" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>熔断 Circuit Breaker 是一种用于提高系统稳定性和容错能力的设计模式, 当服务调用失败率过高或响应时间过长时, 熔断器会切断请求, 防止系统雪崩, 并提供降级逻辑, Resilience4j 本质上是 一个独立的熔断库, 并不属于 Spring Cloud, 但 Spring Cloud 已经将 Resilience4j 集成到 Spring Cloud Circuit Breaker 组件中, 作为 Hystrix 的替代方案,</p>
<p>添加 Spring Cloud Resilience4j 依赖:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;dependency&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;groupId&gt;</span>org.springframework.cloud<span style="color:#f92672">&lt;/groupId&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;artifactId&gt;</span>spring-cloud-starter-circuitbreaker-resilience4j<span style="color:#f92672">&lt;/artifactId&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>在 <code>application.yml</code> 配置熔断器规则：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">resilience4j</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">circuitbreaker</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">instances</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">externalService</span>: <span style="color:#75715e"># 熔断器名称，对应 @CircuitBreaker(name = &#34;externalService&#34;)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">failureRateThreshold</span>: <span style="color:#ae81ff">50</span> <span style="color:#75715e"># 失败率达到 50% 触发熔断</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">slowCallRateThreshold</span>: <span style="color:#ae81ff">100</span> <span style="color:#75715e"># 100% 慢调用视为失败</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">slowCallDurationThreshold</span>: <span style="color:#ae81ff">2s</span> <span style="color:#75715e"># 超过 2 秒的调用视为慢调用</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">waitDurationInOpenState</span>: <span style="color:#ae81ff">5s</span> <span style="color:#75715e"># 熔断后 5 秒进入半开状态</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">permittedNumberOfCallsInHalfOpenState</span>: <span style="color:#ae81ff">3</span> <span style="color:#75715e"># 半开状态下允许 3 次测试请求</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">slidingWindowSize</span>: <span style="color:#ae81ff">10</span> <span style="color:#75715e"># 统计 10 次请求</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">minimumNumberOfCalls</span>: <span style="color:#ae81ff">5</span> <span style="color:#75715e"># 至少 5 次请求后才计算熔断</span>
</span></span></code></pre></div><p>Spring Cloud 提供 <code>@CircuitBreaker</code>，但建议使用 <code>@Retryable</code> 或 <code>@TimeLimiter</code> 结合 <code>@CircuitBreaker</code> 以支持异步调用:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Service</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ExternalApiService</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> RestTemplate restTemplate <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> RestTemplate();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@CircuitBreaker</span>(name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;externalService&#34;</span>, fallbackMethod <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;fallback&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@TimeLimiter</span>(name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;externalService&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Retryable</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> CompletableFuture<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">fetchData</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> CompletableFuture.<span style="color:#a6e22e">supplyAsync</span>(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>            ResponseEntity<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> response <span style="color:#f92672">=</span> restTemplate.<span style="color:#a6e22e">getForEntity</span>(<span style="color:#e6db74">&#34;http://some-external-api.com/data&#34;</span>, String.<span style="color:#a6e22e">class</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> response.<span style="color:#a6e22e">getBody</span>();
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> CompletableFuture<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">fallback</span>(Throwable ex) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> CompletableFuture.<span style="color:#a6e22e">completedFuture</span>(<span style="color:#e6db74">&#34;Fallback response&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>
<p><code>@CircuitBreaker(name = &quot;externalService&quot;, fallbackMethod = &quot;fallback&quot;)</code> 进行熔断</p>
</li>
<li>
<p><code>@TimeLimiter(name = &quot;externalService&quot;)</code> 处理超时</p>
</li>
<li>
<p><code>@Retryable</code> 进行重试</p>
</li>
<li>
<p><code>fetchData()</code> 异步调用 API</p>
</li>
</ul>
<blockquote>
<p>Spring Cloud Circuit Breaker 是一个 抽象层, 它允许开发者使用不同的熔断实现，例如：Resilience4j, Sentinel, Hystrix（已经被废弃）</p>
</blockquote>
<h3 id="32-解决的问题">3.2. 解决的问题<a href="#32-解决的问题" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p><strong>防止雪崩效应（Cascading Failure）</strong></p>
<p>在微服务架构中，服务之间通常是链式调用，如果某个服务（比如订单服务）响应变慢或不可用，所有依赖它的服务（比如支付、推荐）都会受影响，最终可能导致整个系统瘫痪,</p>
<p>在高并发环境下，如果一个服务响应变慢，大量线程会阻塞等待返回，导致线程池被耗尽，影响其他正常请求</p>
<blockquote>
<p>**为什么大量流量会冲垮服务器? ** 答案: CPU &amp; 内存负载过高，导致崩溃</p>
<p><strong>线程池 &amp; 连接池耗尽:</strong> 现代 Web 服务器（如 Tomcat、Spring Boot 内置 Netty）在处理 HTTP 请求时，通常会使用<strong>线程池</strong>，而不是无限制创建新线程, 当请求量超出线程池或连接池的限制，服务器可能会崩溃或严重降级:</p>
<ul>
<li>由于线程池满了, 新请求只能等待，或者直接被拒绝</li>
<li>如果请求等待时间过长, 大量超时会导致请求积压, 最终服务器负载飙升, 崩溃</li>
</ul>
<p><strong>数据库 &amp; 依赖服务承受不住</strong>: 现代 Web 应用通常会依赖数据库、缓存（Redis）、第三方 API, 如果大量请求涌入, 这些依赖服务可能也会被压垮, 假设数据库可以承受 每秒 500 次查询（QPS）, 如果流量稳定, 数据库可以正常处理, 假设一秒内突然有 10,000 次查询，数据库无法处理, 数据库连接池满了，新请求需要等待连接释放, 超时 &amp; 失败请求会导致更多重试，形成恶性循环，最终数据库崩溃,</p>
</blockquote>
<h2 id="4-有了-gateway-还需要-nginx-吗">4. 有了 Gateway 还需要 Nginx 吗<a href="#4-有了-gateway-还需要-nginx-吗" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<ul>
<li>如果你的所有服务都经过 Spring Cloud Gateway 进行流量管理，并且不涉及<strong>静态资源托管</strong>，Nginx 的作用可能较小</li>
<li>通过 Nginx 实现 WAF（Web 应用防火墙）、DDoS 保护、IP 黑名单、限流等安全策略，减轻 Spring Cloud Gateway 的负担</li>
<li>如果 Spring Cloud Gateway 由于重启或崩溃导致短暂不可用，Nginx 仍能提供基本的流量调度（比如返回静态页面）</li>
</ul>

      </div></div>

  
    
<div class="pagination">
  <div class="pagination__title">
    <span class="pagination__title-h">查看其他文章</span>
    <hr />
  </div>
  <div class="pagination__buttons">
    
      <a href="https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/008-tomcat-nginx-gateway/" class="button inline prev">
        Tomcat Nginx Gateway LoadBalancer
      </a>
    
    
      ::
    
    
      <a href="https://blog.jiyi27.com/posts/interview/%E7%BC%93%E5%AD%98%E5%92%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/001-kafka-rabbitmq/" class="button inline next">
        Kafka vs RabbitMQ
      </a>
    
  </div>
</div>


  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/jiyi27/jiyi27.github.io" target="_blank">Theme</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
