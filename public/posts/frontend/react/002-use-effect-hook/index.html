<!DOCTYPE html>
<html lang="en">
<head>
  
    
    <title>useEffect Hook in React :: 为霜的博客</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="为什么 useEffect 不能是异步函数 异步函数隐式地返回一个Promise，而useEffect的设计是期望返回一个清理函数或者什么都不返回（undefined）。这个设计原则确保了React能够正确地处理副作用和它们的清理逻辑。
如果你需要在useEffect中执行异步操作，正确的做法是在useEffect的函数体内定义一个异步函数，并在该函数内执行异步操作，然后立即调用这个异步函数。例如：
useEffect(() =&gt; { async function fetchData() { // 异步操作 const data = await fetchSomeData(); // 使用数据更新状态 setState(data); } fetchData(); // 清理函数（如果需要） return () =&gt; { // 清理逻辑 }; }, [/* 依赖列表 */]); 这种模式允许在useEffect内部使用异步操作，同时遵循React的副作用处理规则。
函数组件在其主体内不应该执行有副作用的操作，比如直接进行网络请求、订阅事件、直接操作DOM等。这些操作应该放在特定的生命周期方法或钩子（如useEffect）
2. When useEffect is called What does useEffect do? By using this Hook, you tell React that your component needs to do something after render. React will remember the function setup you passed, and call it later after performing the DOM updates.
" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://blog.jiyi27.com/posts/frontend/react/002-use-effect-hook/" />





  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/buttons.min.2bc533403a27dfe0e93105a92502b42ce4587e2e4a87d9f7d349e51e16e09478.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/categories.min.3202f75cbb294747099af3850a68a09ee94b3ce505fc39e134692d90ff0a9b2a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/code.min.dd73d157e77e82a3dc1cb06ba424cf6cc6811af0bb604ad6c68e70faf2439c8a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/fonts.min.4881f0c525f3ce2a1864fb6e96676396cebe1e6fcef1933e8e1dde7041004fb5.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/footer.min.2e3eb191baee58dd05a9f0104ac1fab0827bca7c64dafe0b2579f934c33a1d69.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/header.min.b6fb4423cf82a9f9d7abc9cd010223fa3d70a6526a3f28f8e17d814c06e18f9e.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/main.min.3fb8954e26342ad3afabb4525959bfec6f9fc0d6929f0dda738ddeee30211690.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/menu.min.8cee75f73b9f9b1e40bd0dd53e6e770156b08bbfe1c579cd256c3f6cd3b6d32b.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/pagination.min.82f6400eae7c7c6dc3c866733c2ec0579e4089608fea69400ff85b3880aa0d3c.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/post.min.014a50745fbdd41d5f420a3e288730d5af4b7d90344dc6211d0e50c368b5b303.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/prism.min.b958d3d7c6c67361b945f9062d07d403422604b3d2cd33f93b88d41ed0ba634d.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/term.min.94de320c1b850e126e6d2c88a7c90acf58bb1313f0ea14a14cda2a42f2a88db2.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">


<link rel="stylesheet" href="https://blog.jiyi27.com/terminal.css">




<link rel="shortcut icon" href="https://blog.jiyi27.com/favicon.png">
<link rel="apple-touch-icon" href="https://blog.jiyi27.com/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="useEffect Hook in React">
<meta property="og:description" content="为什么 useEffect 不能是异步函数 异步函数隐式地返回一个Promise，而useEffect的设计是期望返回一个清理函数或者什么都不返回（undefined）。这个设计原则确保了React能够正确地处理副作用和它们的清理逻辑。
如果你需要在useEffect中执行异步操作，正确的做法是在useEffect的函数体内定义一个异步函数，并在该函数内执行异步操作，然后立即调用这个异步函数。例如：
useEffect(() =&gt; { async function fetchData() { // 异步操作 const data = await fetchSomeData(); // 使用数据更新状态 setState(data); } fetchData(); // 清理函数（如果需要） return () =&gt; { // 清理逻辑 }; }, [/* 依赖列表 */]); 这种模式允许在useEffect内部使用异步操作，同时遵循React的副作用处理规则。
函数组件在其主体内不应该执行有副作用的操作，比如直接进行网络请求、订阅事件、直接操作DOM等。这些操作应该放在特定的生命周期方法或钩子（如useEffect）
2. When useEffect is called What does useEffect do? By using this Hook, you tell React that your component needs to do something after render. React will remember the function setup you passed, and call it later after performing the DOM updates.
" />
<meta property="og:url" content="https://blog.jiyi27.com/posts/frontend/react/002-use-effect-hook/" />
<meta property="og:site_name" content="为霜的博客" />

  <meta property="og:image" content="https://blog.jiyi27.com/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">

  <meta property="article:section" content="前端开发" />


  <meta property="article:published_time" content="2023-12-26 19:49:22 &#43;0000 UTC" />












</head>
<body>


<div class="container center">

  
  
  

  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://blog.jiyi27.com/posts/frontend/react/002-use-effect-hook/">useEffect Hook in React</a>
  </h1>
  <div class="post-meta"><time class="post-date">2023-12-26</time><span class="post-reading-time">3 分钟阅读 (630 字数)</span></div>

  
    <span class="post-tags">
      
      #<a href="https://blog.jiyi27.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/">前端开发</a>&nbsp;
      
      #<a href="https://blog.jiyi27.com/tags/react/">react</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <h2 id="为什么-useeffect-不能是异步函数">为什么 useEffect 不能是异步函数<a href="#为什么-useeffect-不能是异步函数" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>异步函数隐式地返回一个<code>Promise</code>，而<code>useEffect</code>的设计是期望返回一个清理函数或者什么都不返回（<code>undefined</code>）。这个设计原则确保了React能够正确地处理副作用和它们的清理逻辑。</p>
<p>如果你需要在<code>useEffect</code>中执行异步操作，正确的做法是在<code>useEffect</code>的函数体内定义一个异步函数，并在该函数内执行异步操作，然后立即调用这个异步函数。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#a6e22e">useEffect</span>(() =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">fetchData</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 异步操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">data</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">fetchSomeData</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 使用数据更新状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">setState</span>(<span style="color:#a6e22e">data</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fetchData</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 清理函数（如果需要）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> () =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 清理逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  };
</span></span><span style="display:flex;"><span>}, [<span style="color:#75715e">/* 依赖列表 */</span>]);
</span></span></code></pre></div><p>这种模式允许在<code>useEffect</code>内部使用异步操作，同时遵循React的副作用处理规则。</p>
<blockquote>
<p><strong>函数组件在其主体内不应该执行有副作用的操作</strong>，比如直接进行网络请求、订阅事件、直接操作DOM等。这些操作应该放在特定的生命周期方法或钩子（如<code>useEffect</code>）</p>
</blockquote>
<h2 id="2-when-useeffect-is-called">2. When <code>useEffect</code> is called<a href="#2-when-useeffect-is-called" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p><strong>What does useEffect do?</strong> By using this Hook, you tell React that your component needs to do something <strong>after render</strong>. React will remember the function <code>setup</code> you passed, and call it later after performing the DOM updates.</p>
<p><code>useEffect</code> 是在渲染逻辑之后执行的, 是可以有副作用的. 可以看出, <code>useEffect</code> 天生就是为了解决这个问题.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#a6e22e">useEffect</span>(<span style="color:#a6e22e">setup</span>, <span style="color:#a6e22e">dependencies</span><span style="color:#f92672">?</span>)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">MyComponent</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">count</span>, <span style="color:#a6e22e">setCount</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">useState</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;1. Component function is running (render phase)&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">useEffect</span>(() =&gt; {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">setTimeout</span>(() =&gt; {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;3. useEffect is called (after DOM updates)&#34;</span>);
</span></span><span style="display:flex;"><span>        }, <span style="color:#ae81ff">2000</span>);
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (
</span></span><span style="display:flex;"><span>        &lt;<span style="color:#f92672">div</span>&gt;
</span></span><span style="display:flex;"><span>            &lt;<span style="color:#f92672">p</span>&gt;<span style="color:#a6e22e">You</span> <span style="color:#a6e22e">clicked</span> {<span style="color:#a6e22e">count</span>} <span style="color:#a6e22e">times</span>&lt;/<span style="color:#f92672">p</span>&gt;
</span></span><span style="display:flex;"><span>            &lt;<span style="color:#f92672">button</span> <span style="color:#a6e22e">onClick</span><span style="color:#f92672">=</span>{() =&gt; <span style="color:#a6e22e">setCount</span>(<span style="color:#a6e22e">count</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)}&gt;
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">Click</span> <span style="color:#a6e22e">me</span>
</span></span><span style="display:flex;"><span>            &lt;/<span style="color:#f92672">button</span>&gt;
</span></span><span style="display:flex;"><span>        &lt;/<span style="color:#f92672">div</span>&gt;
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>When you reload the page, you will see the following in the console (Don&rsquo;t use <code>StrictMode</code>):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>1. Component <span style="color:#66d9ef">function</span> is running <span style="color:#f92672">(</span>render phase<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>2. useEffect is called <span style="color:#f92672">(</span>after DOM updates<span style="color:#f92672">)</span> <span style="color:#75715e"># 2 seconds later will print</span>
</span></span></code></pre></div><p>When you click the button, you will see the following in the console:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>1. Component <span style="color:#66d9ef">function</span> is running <span style="color:#f92672">(</span>render phase<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>You clicked <span style="color:#ae81ff">1</span> times
</span></span><span style="display:flex;"><span>3. useEffect is called <span style="color:#f92672">(</span>after DOM updates<span style="color:#f92672">)</span> <span style="color:#75715e"># 2 seconds later will print</span>
</span></span></code></pre></div><p>Here&rsquo;s a simplified sequence of what happens:</p>
<ol>
<li>
<p>Component Function Executes: The function component runs. During this execution, it can render JSX and call hooks like useState. (Reload page, in example above)</p>
</li>
<li>
<p>Render to DOM: React updates the DOM and the screen based on the returned JSX from the function. (&lsquo;You click x times&rsquo;, in example above)</p>
</li>
<li>
<p>After Render: Once the rendering is complete and the DOM has been updated, useEffect is called. This is done <strong>asynchronously</strong>; it doesn&rsquo;t block the browser from updating the screen. (2 seconds later, in example above)</p>
</li>
</ol>
<h2 id="3-副作用操作实例-fetch-data">3. 副作用操作实例 fetch data<a href="#3-副作用操作实例-fetch-data" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">useState</span>, <span style="color:#a6e22e">useEffect</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;react&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">fetchBio</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;./api.js&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">default</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">Page</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">person</span>, <span style="color:#a6e22e">setPerson</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">useState</span>(<span style="color:#e6db74">&#39;Alice&#39;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">bio</span>, <span style="color:#a6e22e">setBio</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">useState</span>(<span style="color:#66d9ef">null</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">useEffect</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fetchBio</span>(<span style="color:#a6e22e">person</span>).<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">result</span> =&gt; {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">setBio</span>(<span style="color:#a6e22e">result</span>);
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>  }, [<span style="color:#a6e22e">person</span>]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (
</span></span><span style="display:flex;"><span>    &lt;&gt;
</span></span><span style="display:flex;"><span>      &lt;<span style="color:#f92672">select</span> <span style="color:#a6e22e">value</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">person</span>} <span style="color:#a6e22e">onChange</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">e</span> =&gt; {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">setPerson</span>(<span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">target</span>.<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>      }}&gt;
</span></span><span style="display:flex;"><span>        &lt;<span style="color:#f92672">option</span> <span style="color:#a6e22e">value</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Alice&#34;</span>&gt;<span style="color:#a6e22e">Alice</span>&lt;/<span style="color:#f92672">option</span>&gt;
</span></span><span style="display:flex;"><span>        &lt;<span style="color:#f92672">option</span> <span style="color:#a6e22e">value</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Bob&#34;</span>&gt;<span style="color:#a6e22e">Bob</span>&lt;/<span style="color:#f92672">option</span>&gt;
</span></span><span style="display:flex;"><span>        &lt;<span style="color:#f92672">option</span> <span style="color:#a6e22e">value</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Taylor&#34;</span>&gt;<span style="color:#a6e22e">Taylor</span>&lt;/<span style="color:#f92672">option</span>&gt;
</span></span><span style="display:flex;"><span>      &lt;/<span style="color:#f92672">select</span>&gt;
</span></span><span style="display:flex;"><span>      &lt;<span style="color:#f92672">hr</span> /&gt;
</span></span><span style="display:flex;"><span>      &lt;<span style="color:#f92672">p</span>&gt;&lt;<span style="color:#f92672">i</span>&gt;{<span style="color:#a6e22e">bio</span> <span style="color:#f92672">??</span> <span style="color:#e6db74">&#39;Loading...&#39;</span>}&lt;/<span style="color:#f92672">i</span>&gt;&lt;/<span style="color:#f92672">p</span>&gt;
</span></span><span style="display:flex;"><span>    &lt;/&gt;
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>There is a trick, <code>&lt;p&gt;&lt;i&gt;{bio ?? 'Loading...'}&lt;/i&gt;&lt;/p&gt;</code>, &lsquo;Loading&hellip;&rsquo; will be used if <code>bio</code> is null or undefined. We write it in this way because useEffect is called after the initial rendering, so <code>bio</code> will be null or undefined at the first render.</p>
<h2 id="4-race-conditions-in-useeffect">4. Race conditions in useEffect<a href="#4-race-conditions-in-useeffect" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<blockquote>
<p>You would typically notice a race condition (in React) when two slightly different requests for data have been made, and the application displays a different result <strong>depending on which request completes first.</strong></p>
</blockquote>
<p>With <code>cleanup</code> function, we can &ldquo;cancel&rdquo; the previous request (because <code>active</code> is false, <code>setData(newData);</code> in the previous  <code>useEffect</code> won&rsquo;t be called), and only use the result of the latest request.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">useEffect</span>(() =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">active</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">fetchData</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">async</span> () =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">setTimeout</span>(<span style="color:#66d9ef">async</span> () =&gt; {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">response</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">fetch</span>(<span style="color:#e6db74">`https://swapi.dev/api/people/</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">props</span>.<span style="color:#a6e22e">id</span><span style="color:#e6db74">}</span><span style="color:#e6db74">/`</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">newData</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">response</span>.<span style="color:#a6e22e">json</span>();
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">active</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">setFetchedId</span>(<span style="color:#a6e22e">props</span>.<span style="color:#a6e22e">id</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">setData</span>(<span style="color:#a6e22e">newData</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }, Math.<span style="color:#a6e22e">round</span>(Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">*</span> <span style="color:#ae81ff">12000</span>));
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fetchData</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> () =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">active</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>}, [<span style="color:#a6e22e">props</span>.<span style="color:#a6e22e">id</span>]);
</span></span></code></pre></div><ol>
<li>Your <code>setup</code> code runs when your component is added to the page (mounts), this is useEffect gets called after the render phase.</li>
<li>After every re-render of your component where the dependencies have changed:
<ul>
<li>First, your <code>cleanup</code> code runs with the old props and state.</li>
<li>Then, your <code>setup</code> code runs with the new props and state.</li>
</ul>
</li>
<li>Your <code>cleanup</code> code runs one final time after your component is removed from the page (unmounts).</li>
</ol>
<p>So, in the above example, the <code>cleanup</code> function of the previous <code>useEffect</code> call is called before the <code>setup</code> function of the current <code>useEffect</code> is called.</p>
<p>Learn more: <a href="https://maxrozen.com/race-conditions-fetching-data-react-with-useeffect">Race Condition useEffect</a></p>

      </div></div>

  
    
<div class="pagination">
  <div class="pagination__title">
    <span class="pagination__title-h">查看其他文章</span>
    <hr />
  </div>
  <div class="pagination__buttons">
    
      <a href="https://blog.jiyi27.com/posts/build-website/007-nginx/" class="button inline prev">
        Nginx
      </a>
    
    
      ::
    
    
      <a href="https://blog.jiyi27.com/posts/frontend/react/001-vite-deploy/" class="button inline next">
        Vite &amp; Deployment - React
      </a>
    
  </div>
</div>


  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/jiyi27/jiyi27.github.io" target="_blank">Theme</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
