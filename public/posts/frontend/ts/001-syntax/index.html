<!DOCTYPE html>
<html lang="en">
<head>
  
    
    <title>Basic Syntax - TypeScript :: 为霜的博客</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Types
JavaScript has three very commonly used primitives: string, number, and boolean.
TypeScript also has a special type, any, that you can use whenever you don’t want a particular value to cause typechecking errors.
Type Annotations on Variables
When you declare a variable using const, var, or let, you can optionally add a type annotation to explicitly specify the type of the variable:
let myName: string = &#34;Alice&#34;; In most cases, though, this isn’t needed. Wherever possible, TypeScript tries to automatically infer the types in your code.
" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://blog.jiyi27.com/posts/frontend/ts/001-syntax/" />





  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/buttons.min.2bc533403a27dfe0e93105a92502b42ce4587e2e4a87d9f7d349e51e16e09478.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/categories.min.3202f75cbb294747099af3850a68a09ee94b3ce505fc39e134692d90ff0a9b2a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/code.min.dd73d157e77e82a3dc1cb06ba424cf6cc6811af0bb604ad6c68e70faf2439c8a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/fonts.min.4881f0c525f3ce2a1864fb6e96676396cebe1e6fcef1933e8e1dde7041004fb5.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/footer.min.2e3eb191baee58dd05a9f0104ac1fab0827bca7c64dafe0b2579f934c33a1d69.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/header.min.b6fb4423cf82a9f9d7abc9cd010223fa3d70a6526a3f28f8e17d814c06e18f9e.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/main.min.3fb8954e26342ad3afabb4525959bfec6f9fc0d6929f0dda738ddeee30211690.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/menu.min.8cee75f73b9f9b1e40bd0dd53e6e770156b08bbfe1c579cd256c3f6cd3b6d32b.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/pagination.min.82f6400eae7c7c6dc3c866733c2ec0579e4089608fea69400ff85b3880aa0d3c.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/post.min.014a50745fbdd41d5f420a3e288730d5af4b7d90344dc6211d0e50c368b5b303.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/prism.min.b958d3d7c6c67361b945f9062d07d403422604b3d2cd33f93b88d41ed0ba634d.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/term.min.94de320c1b850e126e6d2c88a7c90acf58bb1313f0ea14a14cda2a42f2a88db2.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">


<link rel="stylesheet" href="https://blog.jiyi27.com/terminal.css">




<link rel="shortcut icon" href="https://blog.jiyi27.com/favicon.png">
<link rel="apple-touch-icon" href="https://blog.jiyi27.com/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Basic Syntax - TypeScript">
<meta property="og:description" content="Types
JavaScript has three very commonly used primitives: string, number, and boolean.
TypeScript also has a special type, any, that you can use whenever you don’t want a particular value to cause typechecking errors.
Type Annotations on Variables
When you declare a variable using const, var, or let, you can optionally add a type annotation to explicitly specify the type of the variable:
let myName: string = &#34;Alice&#34;; In most cases, though, this isn’t needed. Wherever possible, TypeScript tries to automatically infer the types in your code.
" />
<meta property="og:url" content="https://blog.jiyi27.com/posts/frontend/ts/001-syntax/" />
<meta property="og:site_name" content="为霜的博客" />

  <meta property="og:image" content="https://blog.jiyi27.com/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">

  <meta property="article:section" content="前端开发" />


  <meta property="article:published_time" content="2024-11-29 09:50:02 &#43;0000 UTC" />












</head>
<body>


<div class="container center">

  
  
  

  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://blog.jiyi27.com/posts/frontend/ts/001-syntax/">Basic Syntax - TypeScript</a>
  </h1>
  <div class="post-meta"><time class="post-date">2024-11-29</time><span class="post-reading-time">4 分钟阅读 (727 字数)</span></div>

  
    <span class="post-tags">
      
      #<a href="https://blog.jiyi27.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/">前端开发</a>&nbsp;
      
      #<a href="https://blog.jiyi27.com/tags/typescript/">typescript</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <p><strong>Types</strong></p>
<p>JavaScript has three very commonly used <a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive">primitives</a>: <code>string</code>, <code>number</code>, and <code>boolean</code>.</p>
<p>TypeScript also has a special type, <code>any</code>, that you can use whenever you don’t want a particular value to cause typechecking errors.</p>
<p><strong>Type Annotations on Variables</strong></p>
<p>When you declare a variable using <code>const</code>, <code>var</code>, or <code>let</code>, you can <strong>optionally</strong> add a type annotation to explicitly specify the type of the variable:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">myName</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Alice&#34;</span>;
</span></span></code></pre></div><blockquote>
<p>In most cases, though, this isn’t needed. Wherever possible, TypeScript tries to automatically <em>infer</em> the types in your code.</p>
</blockquote>
<p><strong>Object Types</strong></p>
<p>Apart from primitives, the most common sort of type you’ll encounter is an <em>object type</em>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// The parameter&#39;s type annotation is an object type
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">printCoord</span>(<span style="color:#a6e22e">pt</span><span style="color:#f92672">:</span> { <span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>; <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span> }) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;The coordinate&#39;s x value is &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">pt</span>.<span style="color:#a6e22e">x</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;The coordinate&#39;s y value is &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">pt</span>.<span style="color:#a6e22e">y</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">printCoord</span>({ <span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">3</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">7</span> });
</span></span></code></pre></div><blockquote>
<p>Here, we annotated the parameter with a type with two properties - <code>x</code> and <code>y</code> - which are both of type <code>number</code>. You can use <code>,</code>or <code>;</code> to separate the properties, and the last separator is optional either way.</p>
</blockquote>
<p>对象类型更常用的写法是直接结构其属性:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 使用解构语法的对象类型参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">printCoord</span>({ <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> }<span style="color:#f92672">:</span> { <span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>; <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span> }) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`x坐标是: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">x</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`y坐标是: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">y</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 或者下面这样
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Point</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">label?</span>: <span style="color:#66d9ef">string</span>; <span style="color:#75715e">// 可选属性使用 ?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">printPoint</span>({ <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">label</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;默认点&#34;</span> }<span style="color:#f92672">:</span> <span style="color:#a6e22e">Point</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">label</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> - 坐标(</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">x</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">y</span><span style="color:#e6db74">}</span><span style="color:#e6db74">)`</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>注意, 上面的例子包含两个语法, 首先是类型标注, 就像其它静态语言, 需要标注参数类型, 只不过 ts 标注参数类型的方式有很多种, 比如使用匿名对象, 其次还使用了另一个语法, 即 destructuring assignment, 直接把属性抽取出来,</p>
</blockquote>
<p><strong>Type Aliases</strong></p>
<p>We’ve been using <em><strong>object types</strong></em> and <em>union types</em> by writing them directly in <strong>type annotations</strong>. This is convenient, but it’s common to want to use the same type more than once and refer to it by a single name.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Point</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Exactly the same as the earlier example
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">printCoord</span>(<span style="color:#a6e22e">pt</span>: <span style="color:#66d9ef">Point</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;The coordinate&#39;s x value is &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">pt</span>.<span style="color:#a6e22e">x</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;The coordinate&#39;s y value is &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">pt</span>.<span style="color:#a6e22e">y</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>Interfaces</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Point</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">printCoord</span>(<span style="color:#a6e22e">pt</span>: <span style="color:#66d9ef">Point</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;The coordinate&#39;s x value is &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">pt</span>.<span style="color:#a6e22e">x</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;The coordinate&#39;s y value is &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">pt</span>.<span style="color:#a6e22e">y</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">printCoord</span>({ <span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">100</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">100</span> });
</span></span></code></pre></div><p>Just like when we used a type alias above, the example works just as if we had used an anonymous object type. TypeScript is only concerned with the <em>structure</em> of the value we passed to <code>printCoord</code> - it only cares that it has the expected properties. Being concerned only with the structure and capabilities of types is why we call TypeScript a <em>structurally typed</em> type system.</p>
<blockquote>
<p>TypeScript 使用结构类型系统(structural typing)，而大多数传统语言如 Java、C++ 使用名义类型系统(nominal typing)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// TypeScript中，两个类型的结构相同就被认为是兼容的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Person</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">age</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">age</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">age</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">name</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">age</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">age</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 虽然 Student 类并没有显式实现 Person 接口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 但因为结构相同，所以这是允许的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">person</span>: <span style="color:#66d9ef">Person</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Student</span>(<span style="color:#e6db74">&#34;张三&#34;</span>, <span style="color:#ae81ff">18</span>);
</span></span></code></pre></div></blockquote>
<hr>
<p><strong>Destructuring Assignment  &amp; Type Annotations</strong></p>
<p>基础的 Destructuring Assignment 用法:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">person</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;张三&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">age</span>: <span style="color:#66d9ef">25</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Destructuring Assignment
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// You cannot change the &#39;name&#39; and &#39;age&#39; to other world
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> { <span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">age</span> } <span style="color:#f92672">=</span> <span style="color:#a6e22e">person</span>;
</span></span></code></pre></div><p>进阶用法, 放在函数参数中,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-tsx" data-lang="tsx"><span style="display:flex;"><span><span style="color:#75715e">// 使用 对象类型 标注 参数类型, 注意这里没有使用 destructuring assignment
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// { name: string, age: number }: Object Type
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">greet</span>(<span style="color:#a6e22e">person</span><span style="color:#f92672">:</span> { <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">age</span>: <span style="color:#66d9ef">number</span> }) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`你好，</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">person</span>.<span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用 对象类型 标注 参数类型, 且使用 destructuring assignment 解构对象类型中的属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">greet</span>({ <span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">age</span> }<span style="color:#f92672">:</span> { <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">age</span>: <span style="color:#66d9ef">number</span> }) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`你好，</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>next.js 也很经常在函数参数中使用 destructuring assignment 和对象类型标注:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">default</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">Layout</span>({ <span style="color:#a6e22e">children</span> }<span style="color:#f92672">:</span> { <span style="color:#a6e22e">children</span>: <span style="color:#66d9ef">React.ReactNode</span> }) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (
</span></span><span style="display:flex;"><span>    &lt;<span style="color:#f92672">div</span>&gt;{<span style="color:#a6e22e">children</span>}&lt;/<span style="color:#f92672">div</span>&gt;
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>{ children }: { children: React.ReactNode }</code> 使用了 TypeScript 的解构赋值（Destructuring Assignment）和类型注解的组合:</p>
<ol>
<li>
<p><code>{ children }</code> 是参数解构：从传入的对象中提取 children 属性</p>
</li>
<li>
<p><code>: { children: React.ReactNode }</code> 是类型注解：定义了参数对象的类型</p>
</li>
</ol>
<p>如果使用 <code>children : { children: React.ReactNode }</code> 是不正确的, 这是因为：</p>
<ul>
<li>原始写法 <code>{ children }</code> 表示接收一个对象并解构出其 children 属性</li>
<li>如果改成 <code>children</code>，就变成了直接接收一个名为 children 的参数，其类型被声明为一个包含 children 属性的对象</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 原始写法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">Layout</span>({ <span style="color:#a6e22e">children</span> }<span style="color:#f92672">:</span> { <span style="color:#a6e22e">children</span>: <span style="color:#66d9ef">React.ReactNode</span> }) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">children</span>); <span style="color:#75715e">// 可能是 object（React元素）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> &lt;<span style="color:#f92672">div</span>&gt;{<span style="color:#a6e22e">children</span>}&lt;/<span style="color:#f92672">div</span>&gt;; <span style="color:#75715e">// 直接使用 children
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 修改后写法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">Layout</span>(<span style="color:#a6e22e">children</span><span style="color:#f92672">:</span> { <span style="color:#a6e22e">children</span>: <span style="color:#66d9ef">React.ReactNode</span> }) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">children</span>); <span style="color:#75715e">// 一定是 object
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> &lt;<span style="color:#f92672">div</span>&gt;{<span style="color:#a6e22e">children</span>.<span style="color:#a6e22e">children</span>}&lt;/<span style="color:#f92672">div</span>&gt;; <span style="color:#75715e">// 需要用 children.children
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>可是为什么要多此一举呢? 直接 <code>children: React.ReactNode</code> 当参数不行吗,</p>
<p>答案是当然可以, 但是在 React 中，我们通常使用第一种写法（对象解构），原因是：</p>
<ol>
<li>这是 React 的约定。props 总是以对象的形式传递给组件，包括 children 在内</li>
<li>如果之后需要添加其他 props，用对象解构的方式更容易扩展：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 更容易添加新的 props
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">Layout</span>({ 
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">children</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">title</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">className</span> 
</span></span><span style="display:flex;"><span>}<span style="color:#f92672">:</span> { 
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">children</span>: <span style="color:#66d9ef">React.ReactNode</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">title?</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">className?</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (
</span></span><span style="display:flex;"><span>    &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">className</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">className</span>}&gt;
</span></span><span style="display:flex;"><span>      &lt;<span style="color:#f92672">h1</span>&gt;{<span style="color:#a6e22e">title</span>}&lt;/<span style="color:#f92672">h1</span>&gt;
</span></span><span style="display:flex;"><span>      {<span style="color:#a6e22e">children</span>}
</span></span><span style="display:flex;"><span>    &lt;/<span style="color:#f92672">div</span>&gt;
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果用直接参数的方式，当需要添加新的 props 时就需要改变整个参数结构。所以虽然一开始看起来是&quot;多此一举&quot;，但从长远来看这种写法更有优势。</p>

      </div></div>

  
    
<div class="pagination">
  <div class="pagination__title">
    <span class="pagination__title-h">查看其他文章</span>
    <hr />
  </div>
  <div class="pagination__buttons">
    
      <a href="https://blog.jiyi27.com/posts/csharp/dot-net/001-nuget/" class="button inline prev">
        NuGet Package Management
      </a>
    
    
      ::
    
    
      <a href="https://blog.jiyi27.com/posts/frontend/styling-css/003-custom-styles/" class="button inline next">
        Commonly Used Flex Styles
      </a>
    
  </div>
</div>


  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/jiyi27/jiyi27.github.io" target="_blank">Theme</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
