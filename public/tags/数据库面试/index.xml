<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据库面试 on 为霜的博客</title>
    <link>https://blog.jiyi27.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95/</link>
    <description>Recent content in 数据库面试 on 为霜的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 30 Mar 2025 11:09:56 +0000</lastBuildDate><atom:link href="https://blog.jiyi27.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>窗口函数 聚合函数</title>
      <link>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/007-%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0-%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 30 Mar 2025 11:09:56 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/007-%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0-%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;h2 id=&#34;1-聚合函数&#34;&gt;1. 聚合函数&lt;/h2&gt;
&lt;p&gt;聚合函数 Aggregate Functions 用于对一组数据进行计算, 它们会将多行数据“聚合成”一个单一的结果, 常用于 SQL 查询 如 &lt;code&gt;GROUP BY&lt;/code&gt; 搭配使用:&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;函数名&lt;/th&gt;
          &lt;th&gt;功能说明&lt;/th&gt;
          &lt;th&gt;示例&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;COUNT()&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;统计数量&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;COUNT(*)&lt;/code&gt; 统计总行数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;SUM()&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;求总和&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;SUM(price)&lt;/code&gt; 计算价格总和&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;AVG()&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;求平均值&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;AVG(score)&lt;/code&gt; 计算平均分数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;MAX()&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;返回最大值&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;MAX(age)&lt;/code&gt; 查找最大年龄&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;MIN()&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;返回最小值&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;MIN(height)&lt;/code&gt; 查找最小身高&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;11-统计数据&#34;&gt;1.1. 统计数据&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;order_id&lt;/th&gt;
          &lt;th&gt;user_id&lt;/th&gt;
          &lt;th&gt;total_price&lt;/th&gt;
          &lt;th&gt;order_date&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;101&lt;/td&gt;
          &lt;td&gt;99.9&lt;/td&gt;
          &lt;td&gt;2025-03-01&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;102&lt;/td&gt;
          &lt;td&gt;149.5&lt;/td&gt;
          &lt;td&gt;2025-03-01&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;101&lt;/td&gt;
          &lt;td&gt;20.0&lt;/td&gt;
          &lt;td&gt;2025-03-02&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;统计每天的销售额&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; order_date, &lt;span style=&#34;color:#66d9ef&#34;&gt;SUM&lt;/span&gt;(total_price) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; daily_revenue
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; orders
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;GROUP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; order_date;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;第一步 扫描表 FROM, 数据库先把整个 &lt;code&gt;grades&lt;/code&gt; 表读一遍, 拿到所有原始数据&lt;/li&gt;
&lt;li&gt;第二步 分组 GROUP BY, 数据库根据 &lt;code&gt;student_id&lt;/code&gt; 把数据拆成几组
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;student_id = 1&lt;/code&gt; 的组: &lt;code&gt;(1, Math, 85)&lt;/code&gt;, &lt;code&gt;(1, English, 90)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;student_id = 2&lt;/code&gt; 的组: &lt;code&gt;(2, Math, 78)&lt;/code&gt;,  &lt;code&gt;(2, English, 92)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第三步 每组上应用聚合函数:
&lt;ul&gt;
&lt;li&gt;组1：&lt;code&gt;(85 + 90) / 2 = 87.5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;组2：&lt;code&gt;(78 + 92) / 2 = 85&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最终输出 student_id = 1, avg_score = 87.5; student_id = 2, avg_score = 85&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如果查询语句没有加 &lt;code&gt;WHERE&lt;/code&gt; 条件, 数据库&lt;strong&gt;通常会全表扫描&lt;/strong&gt;, 因为它必须读取表中所有的行才能正确地分组和聚合, 哪怕你 &lt;code&gt;student_id&lt;/code&gt; 上有索引, 它也必须读出所有行的 score 值&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-聚合函数&#34;&gt;1. 聚合函数&lt;/h2&gt;
&lt;p&gt;聚合函数 Aggregate Functions 用于对一组数据进行计算, 它们会将多行数据“聚合成”一个单一的结果, 常用于 SQL 查询 如 &lt;code&gt;GROUP BY&lt;/code&gt; 搭配使用:&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;函数名&lt;/th&gt;
          &lt;th&gt;功能说明&lt;/th&gt;
          &lt;th&gt;示例&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;COUNT()&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;统计数量&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;COUNT(*)&lt;/code&gt; 统计总行数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;SUM()&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;求总和&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;SUM(price)&lt;/code&gt; 计算价格总和&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;AVG()&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;求平均值&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;AVG(score)&lt;/code&gt; 计算平均分数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;MAX()&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;返回最大值&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;MAX(age)&lt;/code&gt; 查找最大年龄&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;MIN()&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;返回最小值&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;MIN(height)&lt;/code&gt; 查找最小身高&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;11-统计数据&#34;&gt;1.1. 统计数据&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;order_id&lt;/th&gt;
          &lt;th&gt;user_id&lt;/th&gt;
          &lt;th&gt;total_price&lt;/th&gt;
          &lt;th&gt;order_date&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;101&lt;/td&gt;
          &lt;td&gt;99.9&lt;/td&gt;
          &lt;td&gt;2025-03-01&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;102&lt;/td&gt;
          &lt;td&gt;149.5&lt;/td&gt;
          &lt;td&gt;2025-03-01&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;101&lt;/td&gt;
          &lt;td&gt;20.0&lt;/td&gt;
          &lt;td&gt;2025-03-02&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;统计每天的销售额&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; order_date, &lt;span style=&#34;color:#66d9ef&#34;&gt;SUM&lt;/span&gt;(total_price) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; daily_revenue
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; orders
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;GROUP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; order_date;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;第一步 扫描表 FROM, 数据库先把整个 &lt;code&gt;grades&lt;/code&gt; 表读一遍, 拿到所有原始数据&lt;/li&gt;
&lt;li&gt;第二步 分组 GROUP BY, 数据库根据 &lt;code&gt;student_id&lt;/code&gt; 把数据拆成几组
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;student_id = 1&lt;/code&gt; 的组: &lt;code&gt;(1, Math, 85)&lt;/code&gt;, &lt;code&gt;(1, English, 90)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;student_id = 2&lt;/code&gt; 的组: &lt;code&gt;(2, Math, 78)&lt;/code&gt;,  &lt;code&gt;(2, English, 92)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第三步 每组上应用聚合函数:
&lt;ul&gt;
&lt;li&gt;组1：&lt;code&gt;(85 + 90) / 2 = 87.5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;组2：&lt;code&gt;(78 + 92) / 2 = 85&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最终输出 student_id = 1, avg_score = 87.5; student_id = 2, avg_score = 85&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如果查询语句没有加 &lt;code&gt;WHERE&lt;/code&gt; 条件, 数据库&lt;strong&gt;通常会全表扫描&lt;/strong&gt;, 因为它必须读取表中所有的行才能正确地分组和聚合, 哪怕你 &lt;code&gt;student_id&lt;/code&gt; 上有索引, 它也必须读出所有行的 score 值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;本质上 SQL 的执行顺序差不多就是:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FROM → WHERE → GROUP BY → 聚合函数（AVG, SUM 等）→ HAVING → SELECT → ORDER BY&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;12-计算平均值&#34;&gt;1.2. 计算平均值&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;student_id&lt;/th&gt;
          &lt;th&gt;subject&lt;/th&gt;
          &lt;th&gt;score&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;Math&lt;/td&gt;
          &lt;td&gt;85&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;English&lt;/td&gt;
          &lt;td&gt;90&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;Math&lt;/td&gt;
          &lt;td&gt;78&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;English&lt;/td&gt;
          &lt;td&gt;92&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;计算每个学生所有科目的平均分&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; student_id, &lt;span style=&#34;color:#66d9ef&#34;&gt;AVG&lt;/span&gt;(score) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; avg_score
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; grades
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;GROUP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; student_id;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;13-计算最大值&#34;&gt;1.3. 计算最大值&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;id&lt;/th&gt;
          &lt;th&gt;name&lt;/th&gt;
          &lt;th&gt;department&lt;/th&gt;
          &lt;th&gt;salary&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;Alice&lt;/td&gt;
          &lt;td&gt;HR&lt;/td&gt;
          &lt;td&gt;5000&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;Bob&lt;/td&gt;
          &lt;td&gt;IT&lt;/td&gt;
          &lt;td&gt;7000&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;Tom&lt;/td&gt;
          &lt;td&gt;IT&lt;/td&gt;
          &lt;td&gt;7200&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;Lisa&lt;/td&gt;
          &lt;td&gt;HR&lt;/td&gt;
          &lt;td&gt;5200&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;查出每个部门里工资最高的员工薪资&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; department, &lt;span style=&#34;color:#66d9ef&#34;&gt;MAX&lt;/span&gt;(salary) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; max_salary
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; employees
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;GROUP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; department;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;2-窗口函数&#34;&gt;2. 窗口函数&lt;/h2&gt;
&lt;p&gt;窗口函数也是一种聚合函数的增强版, 但它不压缩多行成一行, 而是为每一行保留原始结构, 并计算“周围的一组数据”的统计值:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;函数名&lt;/span&gt;() OVER (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [PARTITION &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;列名&lt;/span&gt;]  &lt;span style=&#34;color:#75715e&#34;&gt;-- 可选，分组
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    [&lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;列名&lt;/span&gt;]      &lt;span style=&#34;color:#75715e&#34;&gt;-- 可选，排序
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    [&lt;span style=&#34;color:#66d9ef&#34;&gt;ROWS&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;或&lt;/span&gt; RANGE &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;子句&lt;/span&gt;] &lt;span style=&#34;color:#75715e&#34;&gt;-- 可选，定义窗口范围
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;21-排名&#34;&gt;2.1. 排名&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;student_id&lt;/th&gt;
          &lt;th&gt;subject&lt;/th&gt;
          &lt;th&gt;score&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;Math&lt;/td&gt;
          &lt;td&gt;85&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;Math&lt;/td&gt;
          &lt;td&gt;90&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;Math&lt;/td&gt;
          &lt;td&gt;78&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;Math&lt;/td&gt;
          &lt;td&gt;90&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;每行都有&lt;/span&gt; rank &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;字段，表示这位学生在&lt;/span&gt; Math &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;科目中的排名&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; student_id, score,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       RANK() OVER (&lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; score &lt;span style=&#34;color:#66d9ef&#34;&gt;DESC&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; rank
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; grades
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; subject &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Math&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;注意: 虽然写了 &lt;code&gt;RANK() OVER (ORDER BY score DESC)&lt;/code&gt;, 这只是窗口函数内部使用排序, 结果集本身的输出顺序还是无序的（除非你显式加上 &lt;code&gt;ORDER BY&lt;/code&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;第一步 &lt;code&gt;FROM&lt;/code&gt; + &lt;code&gt;WHERE&lt;/code&gt; 过滤筛选 &lt;code&gt;WHERE subject = &#39;Math&#39;&lt;/code&gt; 的记录&lt;/li&gt;
&lt;li&gt;第二步 窗口函数准备 &lt;code&gt;OVER()&lt;/code&gt;, 这一步, 数据库不会排序筛选出的记录, 而是&lt;strong&gt;在内存中为窗口函数排序一份数据副本&lt;/strong&gt;（根据 &lt;code&gt;score DESC&lt;/code&gt;）, 准备做排名&lt;/li&gt;
&lt;li&gt;第三步 对每行应用 &lt;code&gt;RANK()&lt;/code&gt; 排名函数, 数据库逐行执行这个函数, 这时候每一行&lt;strong&gt;都保留原始数据&lt;/strong&gt;, 并加上一列新的 rank 值&lt;/li&gt;
&lt;li&gt;第四步 结果集准备好, 但顺序可能不是你想要的, 除非你加 ORDER BY&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果想让结果集按分数顺序排序:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; student_id, score,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       RANK() OVER (&lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; score &lt;span style=&#34;color:#66d9ef&#34;&gt;DESC&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; rank
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; grades
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; subject &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Math&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; score &lt;span style=&#34;color:#66d9ef&#34;&gt;DESC&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;22-使用窗口函数计算累计总和&#34;&gt;2.2. 使用窗口函数计算累计总和&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;日期&lt;/th&gt;
          &lt;th&gt;产品&lt;/th&gt;
          &lt;th&gt;销售额&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-01&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;100&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-02&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;150&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-03&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;200&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-01&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;50&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-02&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;75&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-03&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;125&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;使用聚合函数 SUM()&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;产品&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;SUM&lt;/span&gt;(&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;销售额&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;总销售额&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;销售表&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;GROUP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;产品&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;产品&lt;/th&gt;
          &lt;th&gt;总销售额&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;450&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;250&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;使用窗口函数 SUM() OVER()&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;日期&lt;/span&gt;, &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;产品&lt;/span&gt;, &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;销售额&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       &lt;span style=&#34;color:#66d9ef&#34;&gt;SUM&lt;/span&gt;(&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;销售额&lt;/span&gt;) OVER(PARTITION &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;产品&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;产品总销售额&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;销售表&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;日期&lt;/th&gt;
          &lt;th&gt;产品&lt;/th&gt;
          &lt;th&gt;销售额&lt;/th&gt;
          &lt;th&gt;产品总销售额&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-01&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;100&lt;/td&gt;
          &lt;td&gt;450&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-02&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;150&lt;/td&gt;
          &lt;td&gt;450&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-03&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;200&lt;/td&gt;
          &lt;td&gt;450&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-01&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;50&lt;/td&gt;
          &lt;td&gt;250&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-02&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;75&lt;/td&gt;
          &lt;td&gt;250&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-03&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;125&lt;/td&gt;
          &lt;td&gt;250&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;使用窗口函数计算累计总和&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;日期&lt;/span&gt;, &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;产品&lt;/span&gt;, &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;销售额&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       &lt;span style=&#34;color:#66d9ef&#34;&gt;SUM&lt;/span&gt;(&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;销售额&lt;/span&gt;) OVER(PARTITION &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;产品&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;日期&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;累计销售额&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;销售表&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;日期&lt;/th&gt;
          &lt;th&gt;产品&lt;/th&gt;
          &lt;th&gt;销售额&lt;/th&gt;
          &lt;th&gt;累计销售额&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-01&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;100&lt;/td&gt;
          &lt;td&gt;100&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-02&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;150&lt;/td&gt;
          &lt;td&gt;250&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-03&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;200&lt;/td&gt;
          &lt;td&gt;450&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-01&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;50&lt;/td&gt;
          &lt;td&gt;50&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-02&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;75&lt;/td&gt;
          &lt;td&gt;125&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-03&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;125&lt;/td&gt;
          &lt;td&gt;250&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;23-执行过程&#34;&gt;2.3. 执行过程&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;日期&lt;/span&gt;, &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;产品&lt;/span&gt;, &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;销售额&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       &lt;span style=&#34;color:#66d9ef&#34;&gt;SUM&lt;/span&gt;(&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;销售额&lt;/span&gt;) OVER(PARTITION &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;产品&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;日期&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;累计销售额&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;销售表&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;1. 数据扫描阶段&lt;/strong&gt; 首先, 数据库引擎扫描⁠销售表中的所有行：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;日期&lt;/th&gt;
          &lt;th&gt;产品&lt;/th&gt;
          &lt;th&gt;销售额&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-01&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;100&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-02&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;150&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-03&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;200&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-01&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;50&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-02&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;75&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-03&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;125&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;2. 分区处理阶段&lt;/strong&gt; 根据⁠PARTITION BY 产品子句, 数据库将数据分成不同的分区：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;产品 A 的分区：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;日期&lt;/th&gt;
          &lt;th&gt;产品&lt;/th&gt;
          &lt;th&gt;销售额&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-01&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;100&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-02&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;150&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-03&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;200&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;产品 B 的分区：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;日期&lt;/th&gt;
          &lt;th&gt;产品&lt;/th&gt;
          &lt;th&gt;销售额&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-01&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;50&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-02&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;75&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-03&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;125&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;3. 分区内排序阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于有⁠ORDER BY 日期子句，数据库会在每个分区内按日期排序。在本例中，数据已经是按日期排序的，所以排序后的结果与原始分区相同。但这一步在逻辑上是必要的，因为它会影响窗口函数的计算方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 窗口函数计算阶段 - 累计求和&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于添加了⁠ORDER BY 日期，⁠SUM()函数不再计算整个分区的总和，而是计算&lt;strong&gt;累计总和&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于每个分区内的每一行，数据库会计算当前行及之前所有行的销售额总和：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;产品 A 的分区计算过程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	1.	第一行（2025-01-01）：累计销售额 = 100&lt;/p&gt;
&lt;p&gt;​	2.	第二行（2025-01-02）：累计销售额 = 100 + 150 = 250&lt;/p&gt;
&lt;p&gt;​	3.	第三行（2025-01-03）：累计销售额 = 100 + 150 + 200 = 450&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;产品 B 的分区计算过程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	1.	第一行（2025-01-01）：累计销售额 = 50&lt;/p&gt;
&lt;p&gt;​	2.	第二行（2025-01-02）：累计销售额 = 50 + 75 = 125&lt;/p&gt;
&lt;p&gt;​	3.	第三行（2025-01-03）：累计销售额 = 50 + 75 + 125 = 250&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 结果组装阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据库将原始行数据与计算得到的累计销售额结果组合起来：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. 返回最终结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最终返回的结果集：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;日期&lt;/th&gt;
          &lt;th&gt;产品&lt;/th&gt;
          &lt;th&gt;销售额&lt;/th&gt;
          &lt;th&gt;累计销售额&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-01&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;100&lt;/td&gt;
          &lt;td&gt;100&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-02&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;150&lt;/td&gt;
          &lt;td&gt;250&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-03&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;200&lt;/td&gt;
          &lt;td&gt;450&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-01&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;50&lt;/td&gt;
          &lt;td&gt;50&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-02&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;75&lt;/td&gt;
          &lt;td&gt;125&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-03&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;125&lt;/td&gt;
          &lt;td&gt;250&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;3-窗口函数-vs-聚合函数&#34;&gt;3. 窗口函数 vs 聚合函数&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;聚合函数&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把多行数据聚合成一行输出一个结果（比如 SUM、AVG、COUNT 等）&lt;/li&gt;
&lt;li&gt;通常与 GROUP BY 配合使用, 结果是&lt;strong&gt;每个组一个值&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;输出行数通常会减少&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;窗口函数&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在每行数据上基于一个“窗口”（由 OVER 子句定义的范围）计算结果&lt;/li&gt;
&lt;li&gt;不会减少行数，每行都会保留并附带计算结果&lt;/li&gt;
&lt;li&gt;常用于需要保留原始数据细节同时进行分析的场景&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设我们有一个 sales 表，记录销售员的销售情况：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;salesperson &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; sale_date  &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; amount
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;------------|------------|--------
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;Alice      &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2025&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;01&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;01&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;500&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Alice      &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2025&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;01&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;02&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;300&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Bob        &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2025&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;01&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;01&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;400&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Bob        &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2025&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;01&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;03&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;600&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Charlie    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2025&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;01&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;02&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;700&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Charlie    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2025&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;01&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;04&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;31-计算总销售额并排名&#34;&gt;3.1. 计算总销售额并排名&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;聚合函数方案&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; salesperson, &lt;span style=&#34;color:#66d9ef&#34;&gt;SUM&lt;/span&gt;(amount) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; total_sales
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; sales
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;GROUP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; salesperson
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; total_sales &lt;span style=&#34;color:#66d9ef&#34;&gt;DESC&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;-- 需额外处理排名
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;salesperson | total_sales
------------|-------------
Bob        | 1000
Charlie    | 900
Alice      | 800
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;聚合函数将多行聚合成一行, 适合只需要汇总结果的场景, 但无法直接生成排名, 需要额外子查询或手工处理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;窗口函数方案&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DISTINCT&lt;/span&gt; salesperson, 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       &lt;span style=&#34;color:#66d9ef&#34;&gt;SUM&lt;/span&gt;(amount) OVER (PARTITION &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; salesperson) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; total_sales,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       RANK() OVER (&lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;SUM&lt;/span&gt;(amount) &lt;span style=&#34;color:#66d9ef&#34;&gt;DESC&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; sales_rank
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; sales;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;salesperson | total_sales | sales_rank
------------|-------------|------------
Bob        | 1000        | 1
Charlie    | 900         | 2
Alice      | 800         | 3
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;窗口函数直接计算总和并排名, DISTINCT 避免重复行, 如果需要保留每笔销售记录, 只需去掉 DISTINCT, 更灵活&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-截止到某一天的累计销售额排名&#34;&gt;3.2. 截止到某一天的累计销售额排名&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;需求: 计算截止到 2025 年 1 月 2 日的累计销售额，并排名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; salesperson, &lt;span style=&#34;color:#66d9ef&#34;&gt;SUM&lt;/span&gt;(amount) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; cumulative_sales
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; sales
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; sale_date &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2025-01-02&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;GROUP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; salesperson
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; cumulative_sales &lt;span style=&#34;color:#66d9ef&#34;&gt;DESC&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;salesperson | cumulative_sales
------------|------------------
Alice      | 800
Charlie    | 700
Bob        | 400
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;聚合函数简洁地汇总截止日期的数据，Alice (500+300)、Charlie (700)、Bob (400), 但排名需额外处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;33-按日期显示每天的累计销售额排名&#34;&gt;3.3. 按日期显示每天的累计销售额排名&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; salesperson, sale_date,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       &lt;span style=&#34;color:#66d9ef&#34;&gt;SUM&lt;/span&gt;(amount) OVER (PARTITION &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; salesperson &lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; sale_date) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; cumulative_sales,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       RANK() OVER (PARTITION &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; sale_date &lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;SUM&lt;/span&gt;(amount) &lt;span style=&#34;color:#66d9ef&#34;&gt;DESC&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; daily_rank
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; sales
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; sale_date &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2025-01-02&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; sale_date, daily_rank;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;salesperson | sale_date  | cumulative_sales | daily_rank
------------|------------|------------------|------------
Alice      | 2025-01-01 | 500              | 1
Bob        | 2025-01-01 | 400              | 2
Alice      | 2025-01-02 | 800              | 1
Charlie    | 2025-01-02 | 700              | 2
Bob        | 2025-01-02 | 400              | 3
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;窗口函数轻松实现累计值和每天的排名, 保留每行数据, 逻辑清晰&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>MySQL 基础八股文</title>
      <link>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/000-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</link>
      <pubDate>Tue, 18 Mar 2025 21:03:20 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/000-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</guid>
      <description>&lt;h2 id=&#34;1-数据库设计-规范化&#34;&gt;1. 数据库设计 规范化&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;有了解过数据库设计范式吗?&lt;/p&gt;
&lt;p&gt;范式的目的是减少冗余, 确保数据的一致性和完整性, 但并不是说表的设计必须严格按照所有范式 (比如帖子点赞表), 要根据业务逻辑和性能做出取舍&lt;/p&gt;
&lt;p&gt;平时开发中如何设计数据库表?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先分析应该有的实体, 每个实体应该有哪些字段, 在考虑这些的时候其实也是进行拆表, 减少冗余或用冗余换性能的过程, 而这一过程的理论依据就是三大范式&lt;/li&gt;
&lt;li&gt;第二步考虑主键, 建立索引, 具体有单个索引 查询频率高的字段 或 或 Join 查询考虑外键, 复合索引 多条件查询, 覆盖索引 减少回表查询&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设计数据表的时候 减少数据库冗余 是如何做的?&lt;/p&gt;
&lt;p&gt;回答思路: 第二范式 消除部分依赖, 第三范式尽量减少传递依赖&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;11-第一范式&#34;&gt;1.1. 第一范式&lt;/h3&gt;
&lt;p&gt;第一范式: 数据表中的所有字段都必须是&lt;strong&gt;原子&lt;/strong&gt;的, 不能存储多个值 即每个字段只能存储单一信息&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;post
--------------------------------------
| id | title     | author | tags      |
--------------------------------------
| 1  | Golang入门 | 张三   | Go, 后端   |
| 2  | React教程  | 李四   | 前端, React|
--------------------------------------
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tags&lt;/code&gt; 字段存储了多个值, 违反了原子性, 要符合 1NF, 我们需要拆分表, 将 &lt;code&gt;tags&lt;/code&gt; 字段拆成独立的行:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;post
--------------------------------------
| id | title       | author |
--------------------------------------
| 1  | Golang入门   | 张三   |
| 2  | React教程    | 李四   |
--------------------------------------
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;post_tags
-----------------------
| post_id | tag   |
-----------------------
| 1       | Go    |
| 1       | 后端   |
| 2       | 前端   |
| 2       | React |
-----------------------
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;12-第二范式---数据冗余&#34;&gt;1.2. 第二范式 - 数据冗余&lt;/h3&gt;
&lt;p&gt;第二范式: 非主键字段必须完全依赖于整个主键, 不能只依赖于主键的一部分, 如果一个表中没有&lt;strong&gt;复合主键&lt;/strong&gt; 即只有单字段作为主键, 那么它天然符合第二范式, 因为所有非主键字段只能依赖于整个主键, 没有“部分依赖”的问题&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-数据库设计-规范化&#34;&gt;1. 数据库设计 规范化&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;有了解过数据库设计范式吗?&lt;/p&gt;
&lt;p&gt;范式的目的是减少冗余, 确保数据的一致性和完整性, 但并不是说表的设计必须严格按照所有范式 (比如帖子点赞表), 要根据业务逻辑和性能做出取舍&lt;/p&gt;
&lt;p&gt;平时开发中如何设计数据库表?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先分析应该有的实体, 每个实体应该有哪些字段, 在考虑这些的时候其实也是进行拆表, 减少冗余或用冗余换性能的过程, 而这一过程的理论依据就是三大范式&lt;/li&gt;
&lt;li&gt;第二步考虑主键, 建立索引, 具体有单个索引 查询频率高的字段 或 或 Join 查询考虑外键, 复合索引 多条件查询, 覆盖索引 减少回表查询&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设计数据表的时候 减少数据库冗余 是如何做的?&lt;/p&gt;
&lt;p&gt;回答思路: 第二范式 消除部分依赖, 第三范式尽量减少传递依赖&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;11-第一范式&#34;&gt;1.1. 第一范式&lt;/h3&gt;
&lt;p&gt;第一范式: 数据表中的所有字段都必须是&lt;strong&gt;原子&lt;/strong&gt;的, 不能存储多个值 即每个字段只能存储单一信息&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;post
--------------------------------------
| id | title     | author | tags      |
--------------------------------------
| 1  | Golang入门 | 张三   | Go, 后端   |
| 2  | React教程  | 李四   | 前端, React|
--------------------------------------
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tags&lt;/code&gt; 字段存储了多个值, 违反了原子性, 要符合 1NF, 我们需要拆分表, 将 &lt;code&gt;tags&lt;/code&gt; 字段拆成独立的行:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;post
--------------------------------------
| id | title       | author |
--------------------------------------
| 1  | Golang入门   | 张三   |
| 2  | React教程    | 李四   |
--------------------------------------
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;post_tags
-----------------------
| post_id | tag   |
-----------------------
| 1       | Go    |
| 1       | 后端   |
| 2       | 前端   |
| 2       | React |
-----------------------
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;12-第二范式---数据冗余&#34;&gt;1.2. 第二范式 - 数据冗余&lt;/h3&gt;
&lt;p&gt;第二范式: 非主键字段必须完全依赖于整个主键, 不能只依赖于主键的一部分, 如果一个表中没有&lt;strong&gt;复合主键&lt;/strong&gt; 即只有单字段作为主键, 那么它天然符合第二范式, 因为所有非主键字段只能依赖于整个主键, 没有“部分依赖”的问题&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;post_comment
-------------------------------------
| post_id | user_id | user_name    | comment |
-------------------------------------
| 1       | 101     | david12      | 很有帮助  |
| 2       | 102     | chikawa      | 学到了   |
-------------------------------------
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;该表的主键为复合主键: &lt;code&gt;(post_id, user_id)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;user_name&lt;/code&gt; 明显只依赖 &lt;code&gt;user_id&lt;/code&gt;, 而不是只依赖 &lt;code&gt;(post_id, user_id)&lt;/code&gt;, 这就违反 2NF&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;冗余数据&lt;/strong&gt;：如果david12 (&lt;code&gt;user_id = 101&lt;/code&gt;) 评论了 100 条帖子, 那 &lt;code&gt;david12&lt;/code&gt; 这个名字就会存 100 次&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据一致性问题&lt;/strong&gt;：如果王五改名字, 就得修改 100 条记录, 容易出错&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在数据库设计中, 数据冗余指的是在数据库中存储了重复或不必要的数据, 这些数据可以通过其他数据表连接查询出来, 而不是必须单独存储, 假设我们正在设计一个论坛网站的数据库, 包含以下几个表:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户表 (Users)：存储用户信息，如用户ID、用户名、邮箱&lt;/li&gt;
&lt;li&gt;帖子表 (Posts)：存储帖子内容，如帖子ID、标题、正文、作者ID&lt;/li&gt;
&lt;li&gt;评论表 (Comments)：存储评论内容，如评论ID、帖子ID、评论者ID、评论正文&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果我们在 帖子表 (Posts) 中不仅存储了 作者ID, 还额外存储了 作者用户名（如“张三”）, 这就产生了数据冗余, 因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作者用户名 已经存在于 用户表 (Users) 中, 通过 作者ID 可以关联查询到&lt;/li&gt;
&lt;li&gt;在 帖子表 中重复存储 作者用户名, 属于不必要的数据重复&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;13-第三范式---传递依赖&#34;&gt;1.3. 第三范式 - 传递依赖&lt;/h3&gt;
&lt;p&gt;传递依赖和第二范式的部分依赖很像, 因为它们都涉及到数据库中非主属性与主键之间的依赖关系问题, 第二范式要求非主属性必须完全依赖于整个主键, 而不能只依赖主键的一部分, 部分依赖通常出现在复合主键的表中, 第三范式（3NF）要求在满足 2NF 的基础上, 非主属性不能通过其他非主属性间接依赖于主键, 即不存在传递依赖:&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;UserID&lt;/th&gt;
          &lt;th&gt;Username&lt;/th&gt;
          &lt;th&gt;City&lt;/th&gt;
          &lt;th&gt;CityPopulation&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;张三&lt;/td&gt;
          &lt;td&gt;北京&lt;/td&gt;
          &lt;td&gt;2000万&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;李四&lt;/td&gt;
          &lt;td&gt;上海&lt;/td&gt;
          &lt;td&gt;2400万&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;王五&lt;/td&gt;
          &lt;td&gt;北京&lt;/td&gt;
          &lt;td&gt;2000万&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;主键：UserID&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非主属性：Username、City、CityPopulation&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传递依赖：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;UserID → City（用户决定城市）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;City → CityPopulation（城市决定人口）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因此，CityPopulation 通过 City 间接依赖 UserID，即 UserID → City → CityPopulation&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这违反了 3NF, 因为 CityPopulation 不是直接依赖主键, 而是通过非主属性 City 传递依赖, “北京” 和 “2000万” 在第1行和第3行出现了两次, 如果有更多用户住在北京, 这个信息(2000万)会重复更多次, 这种重复存储就是&lt;strong&gt;数据冗余&lt;/strong&gt;, 解决办法拆分为两个表:&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;UserID&lt;/th&gt;
          &lt;th&gt;Username&lt;/th&gt;
          &lt;th&gt;City&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;张三&lt;/td&gt;
          &lt;td&gt;北京&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;李四&lt;/td&gt;
          &lt;td&gt;上海&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;王五&lt;/td&gt;
          &lt;td&gt;北京&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;City&lt;/th&gt;
          &lt;th&gt;CityPopulation&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;北京&lt;/td&gt;
          &lt;td&gt;2000万&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;上海&lt;/td&gt;
          &lt;td&gt;2400万&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可以看出用户表中不用存储多个 2000 万 数据, 只用存个城市北京就行, 然后具体人口可以通过连表查询, 其实这个传递依赖和部分依赖很像, 引起的问题也一样, 就是数据冗余, 当然数据冗余又会造成 插入更新 麻烦, 如果北京的人口变为 2100 万, 需要修改表中所有包含“北京”的行,&lt;/p&gt;
&lt;p&gt;综上, 第二第三范式主要解决 部分依赖 和 传递依赖的问题, 这两个问题会引起数据冗余, 而数据冗余又会导致 插入 更新 效率低的问题, 当然这些问题我们可以通过拆表来解决, 但是并不是说满足三个范式一定是好的设计, 有时候在高并发场景下, 就需要一定的数据冗余来换取性能, 当然代价是更新起来麻烦, 且数据发生了冗余, 比如帖子点赞的场景, 我们一般设计 post 表:&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;字段&lt;/th&gt;
          &lt;th&gt;类型&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;PostID&lt;/td&gt;
          &lt;td&gt;INT&lt;/td&gt;
          &lt;td&gt;主键，帖子ID&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;UserID&lt;/td&gt;
          &lt;td&gt;INT&lt;/td&gt;
          &lt;td&gt;外键，作者ID&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Title&lt;/td&gt;
          &lt;td&gt;VARCHAR&lt;/td&gt;
          &lt;td&gt;帖子标题&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Content&lt;/td&gt;
          &lt;td&gt;TEXT&lt;/td&gt;
          &lt;td&gt;帖子内容&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;CreateTime&lt;/td&gt;
          &lt;td&gt;DATETIME&lt;/td&gt;
          &lt;td&gt;创建时间&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;用一个表记录点赞关系：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;字段&lt;/th&gt;
          &lt;th&gt;类型&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;LikeID&lt;/td&gt;
          &lt;td&gt;INT&lt;/td&gt;
          &lt;td&gt;主键，点赞ID&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;UserID&lt;/td&gt;
          &lt;td&gt;INT&lt;/td&gt;
          &lt;td&gt;外键，点赞者ID&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;TargetID&lt;/td&gt;
          &lt;td&gt;INT&lt;/td&gt;
          &lt;td&gt;目标ID（帖子或评论ID）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;CreateTime&lt;/td&gt;
          &lt;td&gt;CreateTime&lt;/td&gt;
          &lt;td&gt;点赞时间&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这样确实复合数据库设计的三个范式, 没有部分依赖, 没有传递依赖, 可是代价每次获取帖子信息以及其被点赞次数时, 需要关联点赞表做一个统计:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p.PostID,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p.UserID,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p.Title,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p.Content,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;COUNT&lt;/span&gt;(l.LikeID) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; LikeCount
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Posts p
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;LEFT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;JOIN&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Likes l 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p.PostID &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; l.TargetID 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; l.TargetType &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Post&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;GROUP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p.PostID, p.UserID, p.Title, p.Content;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;小网站还好, 高并发的话, 这样是不行的, 我们可以直接在 posts 表增加新字段 &lt;code&gt;LikeCount&lt;/code&gt;, 这就造成了冗余存储, 因为 LikeCount 是从 Likes 表统计得来的, 理论上可以不存储, 直接通过查询计算, 冗余就代表更新操作更麻烦, 在修改数据的时候就造成了问题, 需要多步操作:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用户点赞时，插入 Likes 表记录，同时更新对应 Post  的 LikeCount&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这时候涉及到了多表操作, 在业务逻辑层就要用事务保证数据一致性, 即要么都成功要么都失败, 回滚机制&lt;/li&gt;
&lt;li&gt;在 Redis 层面可以使用 Lua 脚本, Lua 脚本作为一个整体在 Redis 内部执行, 中间不会被打断, 是完全原子性的, Lua 脚本没有显式的“回滚”机制, 单若 Lua 脚本失败时整个脚本不生效, 因此无需回滚&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户取消点赞时，删除 Likes 表记录，同时减少 LikeCount&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从三个范式分析的话, 这样设计不符合第三范式, 造成了存储冗余和更新操作的麻烦, 但是带来了高性能:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 Posts 表中，LikeCount 表示帖子的点赞数，它依赖于 Likes 表中针对该 PostID 的记录数，而不是直接依赖 Posts 表的主键 PostID&lt;/li&gt;
&lt;li&gt;因此, LikeCount 是冗余字段，存在传递依赖: PostID → Likes 表中的记录 → LikeCount&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-数据库设计-外键-join&#34;&gt;2. 数据库设计 外键 Join&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;平时用到的查询, 如果关联表过多怎么办?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保 所有 &lt;code&gt;JOIN&lt;/code&gt; 字段上都有索引（尤其是外键）&lt;/li&gt;
&lt;li&gt;数据冗余（适度反范式化）&lt;/li&gt;
&lt;li&gt;使用 NoSQL, 比如 MongoDB 的文档嵌入&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;外键 Foreign Key 是数据库中用来建立和强化两个表之间联系的关键字段, 简单来说, 它是一个表中的某个字段, 这个字段的值来源于另一个表的主键 Primary Key, 默认不会创建外键, 需要自己指定, 当然主键也可以自己指定, 但外键更像是一个确保数据一致性约束, 比如下面两个表的结构和建表语句:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;users 表
user_id | username
--------+----------
1       | 张三
2       | 李四

orders 表
order_id | user_id | order_date
---------+---------+------------
101      | 1       | 2025-03-01
102      | 2       | 2025-03-02
103      | 1       | 2025-03-15
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;显然 orders 表中的 &lt;code&gt;user_id&lt;/code&gt; 和 &lt;code&gt;order_date&lt;/code&gt; 就是一个普通字段, 但是我们知道, 在处理用户和订单一对多的关系时 (一个用户可以拥有多个订单, 一个订单只能属于一个用户), 订单表里的外键设置为用户表里的主键就可以了, 不需要额外分表, 但是我们需要告诉订单表, 并不是说把字段设置成 &lt;code&gt;user_id&lt;/code&gt;, 订单表就知道了&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; users (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    user_id INT &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; AUTO_INCREMENT,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    username VARCHAR(&lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; orders (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    order_id INT &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; AUTO_INCREMENT,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    user_id INT &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    order_date DATE &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;FOREIGN&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; (user_id) &lt;span style=&#34;color:#66d9ef&#34;&gt;REFERENCES&lt;/span&gt; users(user_id) &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DELETE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CASCADE&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;ON DELETE CASCADE&lt;/code&gt; 是 外键约束 中的一种行为, 当 父表（即主键表）的某一行被删除时, 所有引用该行的 子表 记录也会被自动删除, 看到这不难理解, 外键就是一种约束手段, 没有什么特殊的, 和主键不一样(自动创建索引), 大部分数据库并不会为 外键 自动创建索引, 但 外键查询经常涉及 &lt;code&gt;user_id&lt;/code&gt;, 如果不加索引, 查询效率会变低:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INDEX&lt;/span&gt; idx_orders_user_id &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; orders(user_id);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样可以提高查询性能, 比如单表查询或者连接查询：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; orders &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; user_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 &lt;code&gt;JOIN&lt;/code&gt; 查询中，数据库需要在 &lt;code&gt;users&lt;/code&gt; 和 &lt;code&gt;orders&lt;/code&gt; 之间匹配 &lt;code&gt;user_id&lt;/code&gt;，如果 &lt;code&gt;orders.user_id&lt;/code&gt; 没有索引，数据库就不得不进行全表扫描（&lt;code&gt;Full Table Scan&lt;/code&gt;），从而导致查询变慢:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 查询 用户 &amp;#34;1&amp;#34; 的所有订单, 包括用户名
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; o.order_id, o.order_date, u.username
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; orders o
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;JOIN&lt;/span&gt; users u &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; o.user_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; u.user_id
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; u.user_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 查询 每个用户下的订单总数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; u.username, &lt;span style=&#34;color:#66d9ef&#34;&gt;COUNT&lt;/span&gt;(o.order_id) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; order_count
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; users u
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;LEFT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;JOIN&lt;/span&gt; orders o &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; u.user_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; o.user_id
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;GROUP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; u.username;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;拓展:&lt;/strong&gt; 除此之外, 在&lt;a href=&#34;https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/003-%E6%AD%BB%E9%94%81/#13-%E5%A4%96%E9%94%AE%E5%BC%95%E8%B5%B7&#34;&gt;数据库死锁以及排查&lt;/a&gt;文章中我们提到过, 死锁的一个原因就是外键导致的, 原因是删除主表(用户表)的一行记录时, 因为订单表的外键约束, 数据库需要去检查订单表中的外键 是不是引用的该行记录的 主键, 在检查扫表的过程会加锁, 如果有 &lt;code&gt;ON DELETE CASCADE&lt;/code&gt;, 那还会删除 订单表中 对应的记录, 这更要加锁, 这就可能导致加锁顺序不一致而造成的循环等待死锁问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;3-分库分表&#34;&gt;3. 分库分表&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;平时怎么做分表?&lt;/p&gt;
&lt;p&gt;分表是通过减少单表数据量或宽度, 提升查询性能, 例如水平分表后, 扫描的行数减少, 垂直分表后, 读取的字段减少&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于&lt;strong&gt;水平分表&lt;/strong&gt;, 选择&lt;strong&gt;合适的分片键&lt;/strong&gt;非常关键, 分片键要保证数据分布均匀, 避免某些表过热（如按时间分片可能导致最新表负载过高）, 常见的键包括ID哈希、范围（如时间、地域）等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;垂直分表&lt;/strong&gt;不需要分片键，而是基于业务逻辑拆分字段&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将一张大表拆成多张关联表 (如user和address通过外键关联), 目的是消除冗余、保持数据一致性, 这是数据库设计中的&lt;strong&gt;规范化Normalization&lt;/strong&gt;, 所以分表和数据库规范化设计不一样&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;31-垂直分库&#34;&gt;3.1. 垂直分库&lt;/h3&gt;
&lt;p&gt;“垂直分库”通常是指按照业务功能或业务模块进行数据库层面的拆分, 也可以理解为“业务维度”的拆分, 比如把用户相关的数据放在 &lt;code&gt;user_db&lt;/code&gt;, 订单相关的数据放在 &lt;code&gt;order_db&lt;/code&gt;, 支付相关的数据放在 &lt;code&gt;payment_db&lt;/code&gt; 等等, 各个库之间相互独立, 分别部署到不同的数据库实例上, 缺点也很明显 &lt;strong&gt;跨库事务复杂&lt;/strong&gt;, 可能需要分布式事务支持&lt;/p&gt;
&lt;h3 id=&#34;32-垂直分表&#34;&gt;3.2. 垂直分表&lt;/h3&gt;
&lt;p&gt;“垂直分表”指的是在同一个数据库实例内，把一张表中按列拆分成多张表，也就是把一个大而“宽”的表变成几个更“窄”的表，通常是将热点字段或常用字段与冷门或低频字段分开&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提高查询效率，减少 I/O 开销（因为主表变“窄”）&lt;/li&gt;
&lt;li&gt;需要多表关联查询，增加了复杂性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原始表：用户表 (id, name, age, address, biography, photo)&lt;/p&gt;
&lt;p&gt;拆分后：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主表：用户表 (id, name, age, address)&lt;/li&gt;
&lt;li&gt;附表：用户扩展表 (id, biography, photo)&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;查询通常依赖索引来定位数据, 垂直分表并不会减少记录行数, 为什么但垂直分表可以提高查询效率 减少 I/O 开销?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库（特别是关系型数据库，如 MySQL）将数据存储在磁盘上的&lt;strong&gt;数据页&lt;/strong&gt;（Page）中, 一个数据页的大小是固定的（比如 MySQL InnoDB 默认 16KB）&lt;/li&gt;
&lt;li&gt;每行数据（记录）占用一定空间，行的宽度（即所有字段的总字节大小）决定了单个数据页能存储多少行&lt;/li&gt;
&lt;li&gt;当执行查询时，数据库并不是只读取目标字段，而是会将包含目标行的整个数据页加载到内存中（这就是 I/O 操作）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设你经常执行的查询是 SELECT id, name, age FROM 用户表 WHERE age &amp;gt; 18，只涉及主表的部分字段&lt;/p&gt;
&lt;p&gt;未分表前:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每行数据包含所有字段（包括 biography 和 photo），行宽很大, 一个数据页存的行数少（比如 16 行），查询 1000 行可能需要加载 62 个数据页（1000 ÷ 16）&lt;/li&gt;
&lt;li&gt;加载的数据页中包含大量无关字段（biography, photo），而页数越多，磁盘 I/O 操作就越多，效率就越低&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;分表后&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主表只包含 id, name, age，行变窄&lt;/li&gt;
&lt;li&gt;一个数据页存的行数多（比如 160 行），查询 1000 行只需加载 7 个数据页（1000 ÷ 160）&lt;/li&gt;
&lt;li&gt;加载的数据页只包含需要的字段，I/O 开销显著减少&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;确实索引能快速定位到目标行, 但定位后, 数据库仍需从数据页中读取整行数据, 如果行很宽, 读取的无关数据多, I/O 效率就低, 垂直分表让主表的行变窄, 索引定位后的数据读取成本降低&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;33-水平分库-horizontal-database-sharding&#34;&gt;3.3. 水平分库 Horizontal Database Sharding&lt;/h3&gt;
&lt;p&gt;“水平分库”指的是把同一个逻辑表中的数据按行分散到多个不同的数据库实例中，每个实例上的表结构相同，但存储的数据范围（或子集）不同，比如根据订单 ID、用户 ID、时间等进行切分，每台库只负责一部分数据:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如订单数据体量巨大、访问频率非常高，此时单台数据库的扩容成本太高或已经接近物理瓶颈，需要多个数据库实例并行承担负载&lt;/li&gt;
&lt;li&gt;提高整体吞吐量，降低单库故障对全局的影响&lt;/li&gt;
&lt;li&gt;可以将不同分片布置在不同的机房或不同节点上，实现一定程度上的容灾与负载均衡&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;分片键 sharding key 的选择&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;分片键水平分库的核心, 常见的做法是选择访问量最高的查询条件作为分片键, 比如用户 ID、订单 ID、时间等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要保证分片后的数据分布尽量均匀，避免热点分片（如大量订单都集中在某几个用户）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果经常做范围查询（如时间区间），还需要考虑是否采用 Range Sharding，与 Hash Sharding 各有利弊（Range 容易出现数据倾斜，但查询方便；Hash 数据分布均匀，但跨分片查询复杂）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;跨库查询、跨库事务，需要在中间件或应用层做聚合处理，或者通过最终一致性解决事务问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;34-水平分表&#34;&gt;3.4. 水平分表&lt;/h3&gt;
&lt;p&gt;水平分表在同一个数据库实例中, 将同一逻辑大表的数据按行划分到多张结构相同的小表里, 比如 &lt;code&gt;user_001&lt;/code&gt;, &lt;code&gt;user_002&lt;/code&gt;…&lt;code&gt;user_016&lt;/code&gt;, 这些分表依旧在同一个数据库实例中, 只是物理上拆成多个表, 以减少单表容量、索引体量、DDL 风险等&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在数据库水平拆分的讨论中, 经常会出现“水平分库”与“水平分表”这两个概念, 有时也会听到“分库分表”都统称为“水平分片”或“水平切分”:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;水平分表是“拆表”，但依然在单个数据库实例内&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;水平分库是“拆库”，把数据分散到多台数据库服务器（实例）上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在大规模、高并发场景下，往往先从“水平分表”演进到“水平分库”，或者直接做“分库+分表”以获得更大的水平扩展能力&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;35-不同类型的分片键及其适用场景&#34;&gt;3.5. 不同类型的分片键及其适用场景&lt;/h3&gt;
&lt;p&gt;常见的分片策略包括 Range（区间/范围）、Hash（哈希）、Modulo（取模）、业务逻辑（地理、时间等）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Range Sharding&lt;/strong&gt; 根据分片键的值所处的区间来决定存储位置。例如常见的按“时间范围”或按“ID 范围”来切分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;按时间：每个月/每季度/每年创建一张新表或新库，比如 &lt;code&gt;orders_202301&lt;/code&gt;，&lt;code&gt;orders_202302&lt;/code&gt;…&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按 ID 范围：假如用户 ID 范围 &lt;code&gt;[0, 99999]&lt;/code&gt; 放在库/表 1，&lt;code&gt;[100000, 199999]&lt;/code&gt; 放在库/表 2，依此类推&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优点 区间查询友好&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点 易出现数据倾斜和热点, 如果大量写入发生在最新时间段, 或某些 ID 段比较热门, 就会导致某一个或少数几个分区负载极高, 而其他分区相对空闲&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Hash Sharding&lt;/strong&gt;  对分片键进行哈希计算, 然后将哈希结果映射到不同的分片中, 常见的方案是 &lt;code&gt;shard_id = hash(key) mod N&lt;/code&gt;, 其中 N 是分片数:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点 数据分布更均匀相比按范围分片，哈希分片能够平衡各个分区的存储与访问压力，避免单点或单区过热&lt;/li&gt;
&lt;li&gt;缺点 对于点查（基于主键或唯一键查询）非常友好，但对于范围扫描不太友好, 如果需要按时间区间查询或多条件查询，很可能要扫描所有分片，增加了负载和逻辑复杂度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;业务逻辑分片（地理、业务域等）&lt;/strong&gt; 根据业务属性对数据进行划分，如国家/地区、渠道、业务模块等。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;地区分片&lt;/strong&gt;：&lt;code&gt;用户(中国)&lt;/code&gt; 放在一个分片，&lt;code&gt;用户(北美)&lt;/code&gt; 放在另一个分片&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;业务域分片&lt;/strong&gt;：A 产品线所有订单进 A 库，B 产品线所有订单进 B 库&lt;/li&gt;
&lt;li&gt;缺点 数据分布不一定均匀&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>属性不固定如何设计 MySQL MongoDB -- 软件开发一面</title>
      <link>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/005-%E5%B1%9E%E6%80%A7%E4%B8%8D%E5%9B%BA%E5%AE%9A%E8%A1%A8%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Mon, 10 Mar 2025 09:50:19 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/005-%E5%B1%9E%E6%80%A7%E4%B8%8D%E5%9B%BA%E5%AE%9A%E8%A1%A8%E8%AE%BE%E8%AE%A1/</guid>
      <description>&lt;h2 id=&#34;1-mysql&#34;&gt;1. MySQL&lt;/h2&gt;
&lt;p&gt;首先来看看 MySQL 的实现, 当时没有想到这个实现方式, 只说了会用 MongoDB 来做存储, 问为什么也没能说出个所以然, 于是研究一下, 简单讨论一下, 假设我们需要设计一个系统来存储“商品信息”。商品的基本属性包括“名称”和“价格”，但不同类型的商品可能会有额外的属性（比如衣服有“尺码”和“颜色”，电子产品有“电压”和“功率”），而且这些属性可能会随着业务需求频繁增加或修改。&lt;/p&gt;
&lt;h3 id=&#34;11-eav-模型-entity-attribute-value&#34;&gt;1.1. EAV 模型 Entity-Attribute-Value&lt;/h3&gt;
&lt;p&gt;products 表：存储商品基本信息&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;id | name       | price
---|------------|-------
1  | T-shirt    | 20.00
2  | Laptop     | 999.99
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;product_attributes 表：存储动态属性&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;product_id | attribute_name | attribute_value
-----------|----------------|-----------------
1          | size          | M
1          | color         | Blue
2          | voltage       | 220V
2          | power         | 65W
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;获取 T-shirt 的所有属性：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; attribute_name, attribute_value 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; product_attributes 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; product_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-mysql&#34;&gt;1. MySQL&lt;/h2&gt;
&lt;p&gt;首先来看看 MySQL 的实现, 当时没有想到这个实现方式, 只说了会用 MongoDB 来做存储, 问为什么也没能说出个所以然, 于是研究一下, 简单讨论一下, 假设我们需要设计一个系统来存储“商品信息”。商品的基本属性包括“名称”和“价格”，但不同类型的商品可能会有额外的属性（比如衣服有“尺码”和“颜色”，电子产品有“电压”和“功率”），而且这些属性可能会随着业务需求频繁增加或修改。&lt;/p&gt;
&lt;h3 id=&#34;11-eav-模型-entity-attribute-value&#34;&gt;1.1. EAV 模型 Entity-Attribute-Value&lt;/h3&gt;
&lt;p&gt;products 表：存储商品基本信息&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;id | name       | price
---|------------|-------
1  | T-shirt    | 20.00
2  | Laptop     | 999.99
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;product_attributes 表：存储动态属性&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;product_id | attribute_name | attribute_value
-----------|----------------|-----------------
1          | size          | M
1          | color         | Blue
2          | voltage       | 220V
2          | power         | 65W
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;获取 T-shirt 的所有属性：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; attribute_name, attribute_value 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; product_attributes 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; product_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;需要通过多表连接或多次查询来获取完整信息，当数据量很大时，EAV 表的查询效率较低&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;attribute_value&lt;/code&gt; 通常是 &lt;code&gt;TEXT&lt;/code&gt; 或 &lt;code&gt;VARCHAR&lt;/code&gt;, 而不是更具体的数据类型, 原因是不同属性的数据类型可能不同:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;| user_id | attr_name  | attr_value  |
|---------|-----------|------------|
| 1       | age       | 25         |  (应为 INT)
| 1       | phone     | &amp;#34;1234567890&amp;#34; |  (应为 STRING)
| 2       | birthdate | &amp;#34;1995-10-20&amp;#34; |  (应为 DATE)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;attr_value&lt;/code&gt; 只能选择 一个 数据类型&lt;/p&gt;
&lt;h3 id=&#34;12-预留扩展列&#34;&gt;1.2. 预留扩展列&lt;/h3&gt;
&lt;p&gt;在表中预留一些通用列（如 extra1, extra2），用于存储不确定的属性&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;id &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; name       &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; price  &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; extra1 &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; extra2 &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; extra3
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;---|------------|--------|--------|--------|-------
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;shirt    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;.&lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; M      &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; Blue   &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; Laptop     &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;999&lt;/span&gt;.&lt;span style=&#34;color:#ae81ff&#34;&gt;99&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;220&lt;/span&gt;V   &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;65&lt;/span&gt;W    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;扩展性差&lt;/strong&gt;：预留列数量有限，如果属性超过预留列数，需要修改表结构&lt;/p&gt;
&lt;h3 id=&#34;13-为什么-mysql-不支持属性经常变化直接修改-schema-不就行了吗&#34;&gt;1.3. 为什么 MySQL 不支持属性经常变化？直接修改 &lt;code&gt;schema&lt;/code&gt; 不就行了吗？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果每次新属性都 &lt;code&gt;ALTER TABLE&lt;/code&gt;，很快表结构会变得难以维护，每次新增字段都要修改数据库代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MySQL 在 InnoDB 引擎下，某些 &lt;code&gt;ALTER TABLE&lt;/code&gt; 操作（如 &lt;code&gt;ADD COLUMN&lt;/code&gt;）可能会导致表锁，阻止其他写操作，特别是对 大表 影响更明显&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果表里有 百万级数据，&lt;code&gt;ALTER TABLE&lt;/code&gt; 可能需要 几秒甚至几分钟，在生产环境中这会阻塞业务操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-mongodb-文档型数据库&#34;&gt;2. MongoDB 文档型数据库&lt;/h2&gt;
&lt;p&gt;每个商品存储为一个文档, 属性以键值对的形式直接嵌入文档中, 文档结构无固定 schema，可以随时添加或删除字段&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;_id&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;T-shirt&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;price&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;20.00&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;size&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;M&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;color&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Blue&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;_id&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Laptop&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;price&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;999.99&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;voltage&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;220V&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;power&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;65W&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储空间开销：重复的字段名会增加存储成本 比如每个文档都存储 size 的键名&lt;/li&gt;
&lt;li&gt;事务支持较弱，如果需要 ACID 事务，MongoDB 不如 MySQL&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-分析优缺点&#34;&gt;3. 分析优缺点&lt;/h2&gt;
&lt;h3 id=&#34;31-mysql-分析&#34;&gt;3.1. MySQL 分析&lt;/h3&gt;
&lt;p&gt;首先对方给定的场景是大模型开发训练, 存储信息, 如果在这个场景下,&lt;/p&gt;
&lt;p&gt;EAV 显然不可以采用了, 因为其缺点就是查询效率低, 大模型训练, 应该会经常查询, 数据量也不低, 所以 EAV 不可以采用, 当然如果数据量不大, 也可以采用&lt;/p&gt;
&lt;p&gt;直接采用每次增加列也不太好, 因为每次增加列, 就要修改表的 schema, 修改表的 shcema 倒也没什么问题, 毕竟我们不是电商平台, 宕机一会维护也没什么问题, 可是表结构的频繁变化也意味着业务逻辑代码跟着变, 这就很麻烦了, 所以不能推荐,&lt;/p&gt;
&lt;p&gt;那采用预留扩展列呢, 预留列数量有限, 如果属性超过预留列数, 需要修改表结构, 另外我们也不知道预留的列的数据类型, 另外表的 shcema 一旦确定, 修改就需要修改对应的业务代码, 比如刚开始的列名 extra1, extra2, 写了就不能改了, 想改, 就得连着业务代码一起改, 还是麻烦,&lt;/p&gt;
&lt;p&gt;所以如果数据量不大, 且数据类型都相同, 可以选 EAV, 如果修改不频繁, 直接增加列也行,&lt;/p&gt;
&lt;h3 id=&#34;32-mongodb-的文档等于-mysql-中的行吗&#34;&gt;3.2. MongoDB 的文档等于 MySQL 中的行吗?&lt;/h3&gt;
&lt;p&gt;在很多常见场景下, “文档”与“行”的概念可能看起来很像——一个文档对应数据库里的一行, 但是在 MongoDB 中, 文档可以远比传统数据库的一条“行”更大、更复杂, 例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你可能把用户信息、历史订单、偏好、嵌套数组等全都存在同一个文档里&lt;/li&gt;
&lt;li&gt;在 MySQL 中，通常会拆成多张表，分别管理用户基本信息、订单信息、偏好设置等等&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;33--mongodb-的文档锁为何在冲突场景下开销更大&#34;&gt;3.3.  MongoDB 的“文档锁”为何在冲突场景下开销更大？&lt;/h3&gt;
&lt;p&gt;如果多个并发操作同时想要修改同一个文档，就会发生锁冲突——MongoDB 必须保证多字段更新的原子性和一致性，只能让一个事务/请求在同一时刻对文档进行写操作。所以它要申请&lt;strong&gt;文档锁&lt;/strong&gt;，其他请求只能等待该锁释放。假如这个文档非常大，或者更新的字段非常多，整个更新流程持续时间就会更长，导致等待的其他请求排队更久。在高并发时，这种排队/等待就会累积，拖慢响应。&lt;/p&gt;
&lt;p&gt;MongoDB 的文档锁其实对应的就是 MySQL 的行锁 x锁, 只是 InnoDB 的行通常更“轻量” 就是某张表里的一条记录, MVCC（多版本并发控制）在很多场景下可以让读和写“并行”工作：写事务锁住行在做更新时，读事务可以去读取旧版本，不被阻塞, 这就使得 InnoDB 对单行更新的“锁持有时间”通常较短, 也更容易并发执行其他事务, 换句话说, 在竞争同一个行时, MySQL 能更有效地减少彼此等待&lt;/p&gt;
&lt;h3 id=&#34;34--事务日志与回滚机制为什么-mongodb-在多文档事务下会更重&#34;&gt;3.4.  事务日志与回滚机制：为什么 MongoDB 在多文档事务下会更“重”？&lt;/h3&gt;
&lt;p&gt;当 MongoDB 开启多文档事务时, 需要在内部维护更多的事务上下文、事务标识、和分布式复制信息, 具体来讲：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;事务边界的记录&lt;/strong&gt;：开始事务时，需要标记事务 ID、会话 ID 等信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;执行过程中&lt;/strong&gt;：每次写操作，除了写入数据，还要在 oplog 中添加相应的操作（以便其他副本集节点重放），并且加上事务相关的标记&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提交/回滚时&lt;/strong&gt;：需要把事务提交的边界或回滚动作写到 oplog，其他节点才能正确得知某个事务是提交成功了还是被回滚了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;35-mongodb-事务不如-mysql&#34;&gt;3.5. MongoDB 事务不如 MySQL?&lt;/h3&gt;
&lt;p&gt;首先 MongoDB 事务不如  MySQL, MySQL 支持 ACID 事务, 事务可以跨多张表、多个行, 事务操作完成后, 可以 &lt;code&gt;COMMIT&lt;/code&gt; 提交, 也可以 &lt;code&gt;ROLLBACK&lt;/code&gt; 回滚, 当然 MongoDB 也支持这些, 但 MongoDB 的事务性能开销较大, 相比 MySQL 事务要慢,&lt;/p&gt;
&lt;p&gt;但是我们训练大模型, 又不是金融, 支付, 多文档事务好像不是那么经常发生(涉及多表操作), 当然如果多文档事务经常发生, 那可能就要选择 MySQL 了, 这里假设多文档事务不经常发生,&lt;/p&gt;
&lt;p&gt;所以虽然 MySQL 事务优于 MongoDB, 但是对于我们不是那么重要,&lt;/p&gt;
&lt;h3 id=&#34;36-mongodb-和-mysql-写入性能对比&#34;&gt;3.6. MongoDB 和 MySQL 写入性能对比&lt;/h3&gt;
&lt;p&gt;业务场景：如日志系统、埋点数据收集、IoT（物联网）设备数据上报、大量实时写入操作等&lt;/p&gt;
&lt;p&gt;需求特征：数据量增长速度快、数据结构可能较为灵活、对写入延迟较敏感但对强一致性要求相对一般&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;文档型存储，易于水平扩展：MongoDB 天生支持集群（Sharding），对高并发写入时能够通过分片策略进行分布式水平扩展，扩容相对容易，整体吞吐量可以有效提升&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模式灵活，数据模型简化：MongoDB 不需要进行严格的表结构变更操作，写入时对新字段的兼容成本较低；在开发层面减少了重复的 DDL 操作，通常能更快地进行数据落地&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;批量插入：MongoDB 提供了批量插入 API，在高并发批量写场景下也有很好的表现&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务完整性：在需要强事务、一致性写入保证时，MySQL 通常有更完善的方案。事务隔离级别控制在写入并发和一致性之间做取舍&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MySQL：适合关系复杂、需要强一致性事务、结构化并发读写的元数据场景&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;简单/灵活数据写入，大规模水平扩展，MongoDB 往往更方便；如海量日志、传感器数据写入等，MongoDB 倾向能“跑”得更快、更灵活。对强事务、高度结构化要求高的场景，或单机性能调优等，MySQL 依旧具备非常成熟的写入能力&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;37-mongodb-和-mysql-常见场景和选择建议&#34;&gt;3.7. MongoDB 和 MySQL 常见场景和选择建议&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;海量日志/传感器/埋点数据收集&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;典型特征：超大规模写入、数据结构灵活、查询方式主要以“根据 ID、时间区间”读取为主&lt;/li&gt;
&lt;li&gt;推荐：MongoDB 更方便进行水平扩展，文档模式灵活，更适合存储不固定或变动的字段。MySQL 也可用，但需要分库分表、NoSQL 化设计，运维成本相对大一些&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;内容管理系统（CMS）、电商商品信息、用户个人资料&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;典型特征：字段较灵活，如商品的规格属性不统一、用户资料字段可变；还需要快速的查询和更新&lt;/li&gt;
&lt;li&gt;推荐：MongoDB 文档化存储更省事，支持嵌套结构；若查询需要多维度或嵌套索引，一定要事先规划好索引&lt;/li&gt;
&lt;li&gt;补充：如果业务需要强事务（比如订单管理、支付流水等），则核心交易部分依旧通常采用 MySQL&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;传统的财务系统、银行、订单管理系统&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;典型特征：强事务、多表之间有严密的关系和复杂的 JOIN、对数据一致性要求极高&lt;/li&gt;
&lt;li&gt;推荐：MySQL 等关系型数据库。MongoDB 近年也在提升事务能力，但在这种极度依赖关系型操作的场景中，MySQL 的成熟度和生态更具优势&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>Redis 和 MySQL 如何实现数据一致性</title>
      <link>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/004-mysql-redis-%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/</link>
      <pubDate>Sat, 08 Mar 2025 09:50:19 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/004-mysql-redis-%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/</guid>
      <description>&lt;h2 id=&#34;1-mysql-的数据一致性&#34;&gt;1. MySQL 的数据一致性&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;事务（Transaction）&lt;/strong&gt;：MySQL 支持 ACID（原子性、一致性、隔离性、持久性）事务。通过 BEGIN、COMMIT 和 ROLLBACK，可以确保一组操作要么全部成功，要么全部回滚&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;锁机制&lt;/strong&gt;：MySQL 使用行锁、表锁或 MVCC（多版本并发控制）来处理并发访问，保证数据一致性。例如，InnoDB 引擎通过 MVCC 避免脏读和不可重复读&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主从复制&lt;/strong&gt;：在主从架构中，MySQL 通过 binlog（二进制日志）记录所有写操作，主库将 binlog 同步到从库。虽然可能存在主从延迟（异步复制），可以通过配置半同步复制或同步复制来提高一致性&lt;/p&gt;
&lt;h2 id=&#34;2-redis-的数据一致性&#34;&gt;2. Redis 的数据一致性&lt;/h2&gt;
&lt;h3 id=&#34;21-单线程模型---天然原子性&#34;&gt;2.1. 单线程模型 - 天然原子性&lt;/h3&gt;
&lt;p&gt;Redis 的核心特性之一是单线程执行命令, 所有命令按顺序执行, 不存在并发竞争问题, 天然保证了操作的原子性和一致性,&lt;/p&gt;
&lt;p&gt;假设有两个客户端同时对同一个键 counter 执行 INCR（自增）操作, 由于单线程模型，Redis 会顺序处理这两个请求，最终结果一定是 counter 增加 2，而不是出现并发覆盖导致的错误值&lt;/p&gt;
&lt;h3 id=&#34;22-超卖-秒杀系统---分布式锁--lua脚本&#34;&gt;2.2. 超卖 秒杀系统 - 分布式锁 / Lua脚本&lt;/h3&gt;
&lt;p&gt;分布式锁 如基于 Redis 的 &lt;code&gt;SETNX&lt;/code&gt; 或 ZooKeeper, &lt;code&gt;SETNX&lt;/code&gt; 是 Redis 中的一个&lt;strong&gt;字符串操作命令&lt;/strong&gt;, 全称是 &amp;ldquo;SET if Not eXists&amp;rdquo;, 常见流程:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;获取分布式锁（比如 &lt;code&gt;Redis SETNX lock_key 1&lt;/code&gt;）&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-mysql-的数据一致性&#34;&gt;1. MySQL 的数据一致性&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;事务（Transaction）&lt;/strong&gt;：MySQL 支持 ACID（原子性、一致性、隔离性、持久性）事务。通过 BEGIN、COMMIT 和 ROLLBACK，可以确保一组操作要么全部成功，要么全部回滚&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;锁机制&lt;/strong&gt;：MySQL 使用行锁、表锁或 MVCC（多版本并发控制）来处理并发访问，保证数据一致性。例如，InnoDB 引擎通过 MVCC 避免脏读和不可重复读&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主从复制&lt;/strong&gt;：在主从架构中，MySQL 通过 binlog（二进制日志）记录所有写操作，主库将 binlog 同步到从库。虽然可能存在主从延迟（异步复制），可以通过配置半同步复制或同步复制来提高一致性&lt;/p&gt;
&lt;h2 id=&#34;2-redis-的数据一致性&#34;&gt;2. Redis 的数据一致性&lt;/h2&gt;
&lt;h3 id=&#34;21-单线程模型---天然原子性&#34;&gt;2.1. 单线程模型 - 天然原子性&lt;/h3&gt;
&lt;p&gt;Redis 的核心特性之一是单线程执行命令, 所有命令按顺序执行, 不存在并发竞争问题, 天然保证了操作的原子性和一致性,&lt;/p&gt;
&lt;p&gt;假设有两个客户端同时对同一个键 counter 执行 INCR（自增）操作, 由于单线程模型，Redis 会顺序处理这两个请求，最终结果一定是 counter 增加 2，而不是出现并发覆盖导致的错误值&lt;/p&gt;
&lt;h3 id=&#34;22-超卖-秒杀系统---分布式锁--lua脚本&#34;&gt;2.2. 超卖 秒杀系统 - 分布式锁 / Lua脚本&lt;/h3&gt;
&lt;p&gt;分布式锁 如基于 Redis 的 &lt;code&gt;SETNX&lt;/code&gt; 或 ZooKeeper, &lt;code&gt;SETNX&lt;/code&gt; 是 Redis 中的一个&lt;strong&gt;字符串操作命令&lt;/strong&gt;, 全称是 &amp;ldquo;SET if Not eXists&amp;rdquo;, 常见流程:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;获取分布式锁（比如 &lt;code&gt;Redis SETNX lock_key 1&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查库存（&lt;code&gt;SELECT stock FROM inventory WHERE id = 1&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果库存足够，更新库存（&lt;code&gt;UPDATE inventory SET stock = stock - 1 WHERE id = 1 AND stock &amp;gt; 0&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;释放锁（&lt;code&gt;DEL lock_key&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设库存存储在 MySQL 中, 初始值为 10:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 线程 1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;SETNX lock_key &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;-- 获取锁成功
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; stock &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; inventory &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;-- 返回 10
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; inventory &lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; stock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; stock &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; stock &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;-- 更新为 9
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;DEL lock_key  &lt;span style=&#34;color:#75715e&#34;&gt;-- 释放锁
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 线程 2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;SETNX lock_key &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;-- 获取锁失败，等待
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 锁释放后重试上述步骤
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;分布式锁是传统解决方案, 而 Lua 脚本是一种更高效的替代方案, 需要注意的是 Lua 脚本只能在 Redis 服务器内部执行, 操作的数据必须是 Redis 中的键值对, 因此, 库存数据必须存储在 Redis 中, 更新也仅发生在 Redis 层面, 如果业务需要更新 MySQL 等持久化存储, 还需要额外的同步机制（比如将 Redis 更新结果异步写入 MySQL）, 如果宕机或数据未及时同步到 MySQL, 可能丢失更新&lt;/p&gt;
&lt;p&gt;而分布式锁的方案中, 我们只需要在业务逻辑获取分布式锁, 然后直接操作 MySQL 就行了&lt;/p&gt;
&lt;p&gt;Lua 脚本可以实现的原因是 Redis 是单线程模型, 而 Lua 脚本在 Redis 作为一个整体执行, 所以根本不存在数据竞争问题, 每个 Lua 脚本都是按顺序执行的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;23-lua-脚本---类似回滚&#34;&gt;2.3. Lua 脚本 - 类似回滚&lt;/h3&gt;
&lt;p&gt;Redis 的 Lua 脚本作为一个整体在 Redis 内部执行, 中间不会被打断, 是完全原子性的, Lua 脚本没有显式的“回滚”机制, 单若 Lua 脚本失败时整个脚本不生效, 因此无需回滚&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- Lua 脚本&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;local&lt;/span&gt; key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; KEYS[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;redis.call(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;SET&amp;#39;&lt;/span&gt;, key, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;value1&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;redis.call(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;SET&amp;#39;&lt;/span&gt;, key&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;x&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;value2&amp;#39;&lt;/span&gt;)  &lt;span style=&#34;color:#75715e&#34;&gt;-- 假设这里会失败&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;done&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果 &lt;code&gt;redis.call(&#39;SET&#39;, key..&#39;x&#39;, &#39;value2&#39;)&lt;/code&gt; 失败, 整个脚本中止, &lt;code&gt;key&lt;/code&gt; 的值不会被设置为 &lt;code&gt;value1&lt;/code&gt;, &lt;strong&gt;这不是回滚，而是脚本整体未提交&lt;/strong&gt;,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Redis 通过 MULTI 和 EXEC 提供有限的事务支持, 仅保证一组命令原子执行, 但&lt;strong&gt;不支持回滚&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;MULTI
DECRBY account:A 100
INCRBY account:B 100
EXEC
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;24-持久化-主从复制&#34;&gt;2.4. 持久化 主从复制&lt;/h3&gt;
&lt;p&gt;Redis 支持异步主从复制, 主节点将写操作异步同步到从节点, 虽然简单高效, 但可能导致&lt;strong&gt;短暂的数据不一致&lt;/strong&gt;,&lt;/p&gt;
&lt;p&gt;Redis 通过持久化（RDB 和 AOF）和主从复制来增强数据一致性和可靠性，虽然这更多是针对数据持久性而非实时一致性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;RDB&lt;/strong&gt;：通过生成数据库的快照来实现持久化, 它会将某个时间点 Redis 内存中的数据以二进制格式保存到一个 .rdb 文件中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果服务器在两次快照之间崩溃，可能会丢失部分数据（取决于快照频率）&lt;/li&gt;
&lt;li&gt;数据丢失可接受的场景&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;AOF&lt;/strong&gt;：记录每条写命令, 当 Redis 宕机并重启时, 读取 AOF 文件, 从头到尾&lt;strong&gt;重新执行这些命令&lt;/strong&gt;, 从而重建内存中的数据状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AOF 记录每条写命令，配合 appendfsync always 几乎不会丢失数据，即使是 everysec 也只可能丢失 1 秒的数据&lt;/li&gt;
&lt;li&gt;写命令需要追加到文件，同步策略（如 always）会增加磁盘 I/O，影响性能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;主从复制&lt;/strong&gt;：主节点将写操作同步到从节点，保证多副本一致性（最终一致性）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-mysql-和-redis-数据不同步&#34;&gt;3. MySQL 和 Redis 数据不同步&lt;/h2&gt;
&lt;p&gt;当 MySQL 数据更新（插入、修改、删除）时，Redis 中的缓存未及时更新或未更新，导致查询 Redis 时返回旧数据&lt;/p&gt;
&lt;h3 id=&#34;31-缓存失效策略&#34;&gt;3.1. &lt;strong&gt;缓存失效策略&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;方法&lt;/strong&gt;：在更新 MySQL 时，主动删除 Redis 中的对应缓存（而不是直接更新）&lt;/li&gt;
&lt;li&gt;步骤
&lt;ol&gt;
&lt;li&gt;更新 MySQL 数据&lt;/li&gt;
&lt;li&gt;删除 Redis 中对应的缓存键（DEL key）&lt;/li&gt;
&lt;li&gt;下次查询时，从 MySQL 重新加载数据到 Redis&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：避免了更新 Redis 的复杂逻辑，适合&lt;strong&gt;读多写少&lt;/strong&gt;的场景&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-使用事务或消息队列&#34;&gt;3.2. &lt;strong&gt;使用事务或消息队列&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;方法&lt;/strong&gt;：通过事务或消息队列（如 Kafka、RabbitMQ）确保 MySQL 和 Redis 的更新顺序一致&lt;/li&gt;
&lt;li&gt;步骤
&lt;ol&gt;
&lt;li&gt;将 MySQL 更新操作写入事务&lt;/li&gt;
&lt;li&gt;更新成功后，通过消息队列通知 Redis 更新&lt;/li&gt;
&lt;li&gt;消费消息并更新 Redis&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：解耦 MySQL 和 Redis 操作，支持分布式系统，容错性高&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;33-双写一致性cache-aside-模式&#34;&gt;3.3. 双写一致性（Cache Aside 模式）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;读数据：先查 Redis，若命中则返回；若未命中，从 MySQL 查询并写入 Redis&lt;/li&gt;
&lt;li&gt;写数据：先更新 MySQL, 再删除 Redis 缓存&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;为什么先更新 MySQL, 再删除或更新 Redis 缓存?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 MySQL 和 Redis 的组合中，MySQL 保存的是“权威数据”（source of truth），而 Redis 是缓存，用于提升性能。缓存的数据本质上是 MySQL 的副本。如果先更新 Redis 而 MySQL 更新失败（例如事务回滚、数据库宕机），会导致 Redis 中的数据是“脏数据”，与 MySQL 不一致。用户后续从缓存读取到错误数据，影响业务逻辑&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;双写一致性可能导致的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;T1&lt;/strong&gt;: 线程 A 更新 MySQL, 将 balance 改为 200&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;T2&lt;/strong&gt;: 线程 B 查询 Redis, 发现缓存中 balance 还是 100（因为线程 A 还没来得及删除缓存）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;T3&lt;/strong&gt;: 线程 B 返回旧值 100 给客户端&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;T4&lt;/strong&gt;: 线程 A 删除 Redis 缓存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 T2 到 T4 这段时间，Redis 返回的是旧值 100，而 MySQL 已经是新值 200，出现了短暂的数据不一致&lt;/li&gt;
&lt;li&gt;不一致通常只存在于“更新 MySQL”和“删除 Redis”之间的短暂时间（通常是&lt;strong&gt;毫秒级&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;根本原因: 更新 MySQL 和删除 Redis 是两个独立的操作，无法保证原子性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解决方案1：配合分布式锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;思路：通过锁机制（例如分布式锁）确保更新操作和读取操作不会同时发生，避免并发竞争&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在更新操作时，获取一个针对该数据的锁（例如 Redis 分布式锁）&lt;/li&gt;
&lt;li&gt;更新 MySQL 和删除 Redis 完成后释放锁&lt;/li&gt;
&lt;li&gt;读取操作也需要检查锁，若被占用则等待&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解决方案 2：先删除 Redis, 再更新 MySQL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以先删除 Redis, 再更新 MySQL, 但更新 MySQL 之后 需要再删一次缓存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;线程 A 删除 Redis 缓存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程 B 查询时未命中缓存, 从 MySQL 读取旧值并写回 Redis&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程 A 更新 MySQL 为新值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结果：Redis 又变成了旧值 (与 MySQL 不一致)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;延迟双删的目的正是为了在后续操作中纠正这种不一致, 确保系统最终达到一致性, 在 “先删除 Redis，再更新 MySQL” 的基础上, 更新 MySQL 后再延迟一段时间再次删除 Redis 缓存, 以清理可能被其他线程回写的脏数据:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;T1&lt;/strong&gt;: 线程 A 删除 Redis 缓存&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;T2&lt;/strong&gt;: 线程 B 查询, 未命中缓存, 从 MySQL 读取旧值 100 并写回 Redis&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;T3&lt;/strong&gt;: 线程 A 更新 MySQL 为 200&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;T4&lt;/strong&gt;: 线程 A 延迟 500ms 后再次删除 Redis 缓存&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;T5&lt;/strong&gt;: 下次查询从 MySQL 加载新值 200&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：仍然存在短暂不一致的风险（T2 到 T4 的窗口）&lt;/p&gt;
&lt;h2 id=&#34;4-综合实践-秒杀系统&#34;&gt;4. 综合实践 秒杀系统&lt;/h2&gt;
&lt;p&gt;延迟双删是为了保证缓存和数据库的一致性, 而 分布式锁机制 是为了 保证数据库的数据一致性, 在秒杀系统中, 商品库存是一个核心数据, 假设某个商品初始库存为100件, 用户通过秒杀活动购买, 每次购买会减少库存, 我们需要确保:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据库的数据一致性：库存不会超卖, 即高并发下不会出现多个线程同时扣减库存导致负值的情况&lt;/li&gt;
&lt;li&gt;缓存与数据库的一致性：Redis缓存中的库存数据与MySQL数据库中的库存数据最终一致&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;系统架构&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库（MySQL）：存储商品的实际库存&lt;/li&gt;
&lt;li&gt;缓存（Redis）：存储库存的缓存数据，用于快速查询&lt;/li&gt;
&lt;li&gt;分布式锁：通过Redis（如SETNX命令）实现分布式锁，确保高并发下对数据库的操作是串行化的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;操作流程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;线程 A&lt;/strong&gt; 尝试获取商品 1001 的分布式锁（例如 &lt;code&gt;lock_{1001}&lt;/code&gt;），抢锁成功&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程 A&lt;/strong&gt; 删除 Redis 缓存（Key = &lt;code&gt;product_stock_{1001}&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程 A&lt;/strong&gt; 从数据库查询当前库存（假设查到的是 100），进行库存检查 → 大于 0，则更新库存为 99（&lt;code&gt;UPDATE ... SET stock = 99 WHERE product_id = 1001&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程 A&lt;/strong&gt; 提交事务，数据库此时真正更新为库存 99&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程 A&lt;/strong&gt; 处理完数据库更新后，开启一个线程或通过定时任务，&lt;strong&gt;延迟&lt;/strong&gt;一段时间（比如 500ms~1000ms）后，再执行一次“删除 Redis 缓存（Key = &lt;code&gt;product_stock_{1001}&lt;/code&gt;）”的操作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程 A&lt;/strong&gt; 释放分布式锁&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此时，如果在 A 更新完数据库与“延迟删除缓存”之间，有&lt;strong&gt;线程 B&lt;/strong&gt;进来要操作库存，会发生什么呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程 B 试图抢锁，如果抢锁成功了（说明 A 已经释放了锁）：
&lt;ul&gt;
&lt;li&gt;线程 B 也会先删缓存，然后去读数据库，此时读到的已经是更新后的库存 &lt;code&gt;99&lt;/code&gt;，并做后续检查 + 更新操作&lt;/li&gt;
&lt;li&gt;同理，B 更新完也会再延迟双删，以保证缓存后续查询一定能用到最新数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于有分布式锁的存在，在“检查 + 更新”整个过程&lt;strong&gt;都是串行化&lt;/strong&gt;的，不会出现两条并发写操作抢数据库，导致超卖或脏写。同时，“延迟双删”依然起到确保“缓存最终一致”的作用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当我们使用了分布式锁, 延迟双删 还有必要吗?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为我的想法是, 线程A获取分布式锁, 然后检查 + 更新, 而更新由 (比如删除缓存 + 更新数据库)组成, 之后 A 释放锁, 为什么 线程B 会读取到缓存里的旧数据?&lt;/p&gt;
&lt;p&gt;我忽略了一个情况, 我们的分布式锁一般都是在业务逻辑上实现的, 比如某个方法, 比如用户购买, 我们为了防止 检查 + 更新 操作造成的数据不一致, 可是, 我忽略了有的方法可能只是为了读数据 (读缓存, 如不存在, 读取数据库, 然后写入缓存), 这样的情况分布式锁是避免不了的, 因为我们不可能所有操作读写都加锁, 这样会限制性能, 所以为了防止 在 线程 A 删除缓存 和 更新数据库 这个时间之间, 有其他线程因 仅读取数据造成 旧数据 又重新写会 缓存, 线程 A 在执行 删除缓存 + 庚勋数据库操作之后, 需要再进行一次删除, 即延迟双删,&lt;/p&gt;
&lt;p&gt;除此之外, 当 A 删除缓存后更新数据库 → &lt;strong&gt;与&lt;/strong&gt; → B 抢锁失败 / 等待 → &lt;strong&gt;与&lt;/strong&gt; → A 延迟再删缓存期间，假如出现一些读请求（比如线程 C），可能读到的还是旧值——如果在线程A第二次删除缓存后, 线程C才进行旧数据回写, 又出现缓存旧数据问题了, 不过这概率很小&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>数据库死锁以及排查</title>
      <link>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/003-%E6%AD%BB%E9%94%81/</link>
      <pubDate>Thu, 06 Mar 2025 12:56:19 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/003-%E6%AD%BB%E9%94%81/</guid>
      <description>&lt;h2 id=&#34;1-导致死锁的原因&#34;&gt;1. 导致死锁的原因&lt;/h2&gt;
&lt;p&gt;在 MySQL（尤其是 InnoDB 存储引擎）里，常见的死锁往往与行锁（Row Lock）、间隙锁（Gap Lock）、Next-Key Lock 等锁机制的细节紧密相关。要理解为什么会出现死锁，需要先明白 InnoDB 是如何在事务中为数据上锁的，以及不同类型的锁是如何导致冲突的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;行锁（Row Lock）：对索引记录本身加的锁（Record Lock）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;间隙锁（Gap Lock）：对索引记录之间的间隙加的锁，用于防止幻读（Phantom Read）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Next-Key Lock：它实际上是“记录锁 + 间隙锁”的组合锁，会锁住“当前索引记录”以及紧邻的一段间隙&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MySQL InnoDB 的默认隔离级别是 &lt;strong&gt;REPEATABLE READ&lt;/strong&gt;。在该隔离级别下，对索引进行范围查询时，为了避免幻读，InnoDB 通常会通过 Next-Key Lock 把记录本身和相邻间隙一起锁定。正是因为这种锁定方式，当多事务并发执行时，如果它们的锁定范围出现交叠或顺序不一致，就比较容易引发死锁。&lt;/p&gt;
&lt;h3 id=&#34;11-更新操作顺序不一致-普通行x锁&#34;&gt;1.1. 更新操作顺序不一致 普通行x锁&lt;/h3&gt;
&lt;p&gt;这是最直观的死锁场景之一, 也是很多人最先想到的场景, 本质原因是两个事务以不同的顺序加锁, 从而彼此等待。先来举一个简单的例子（无 Gap Lock 干扰）, 只用普通行x锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景:&lt;/strong&gt; 事务 A 先更新 &lt;code&gt;id=1&lt;/code&gt; 的记录，再更新 &lt;code&gt;id=2&lt;/code&gt; 的记录；事务 B 先更新 &lt;code&gt;id=2&lt;/code&gt; 的记录，再更新 &lt;code&gt;id=1&lt;/code&gt; 的记录。&lt;/p&gt;
&lt;p&gt;如果两个事务并行执行，就可能出现这样的顺序：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;事务 A： &lt;code&gt;UPDATE t_user SET balance = balance - 10 WHERE id = 1;&lt;/code&gt; 成功锁住 &lt;code&gt;id=1&lt;/code&gt; 行&lt;/li&gt;
&lt;li&gt;事务 B： &lt;code&gt;UPDATE t_user SET balance = balance - 20 WHERE id = 2;&lt;/code&gt; 成功锁住 &lt;code&gt;id=2&lt;/code&gt; 行&lt;/li&gt;
&lt;li&gt;事务 A： &lt;code&gt;UPDATE t_user SET balance = balance + 10 WHERE id = 2;&lt;/code&gt; 要锁 &lt;code&gt;id=2&lt;/code&gt;，但是这把锁被事务 B 占用，需要等待&lt;/li&gt;
&lt;li&gt;事务 B： &lt;code&gt;UPDATE t_user SET balance = balance + 20 WHERE id = 1;&lt;/code&gt; 要锁 &lt;code&gt;id=1&lt;/code&gt;，但是这把锁被事务 A 占用，需要等待&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此时 A 等 B 释放锁，B 等 A 释放锁，形成死锁, 由于 InnoDB 检测到死锁，会自动回滚其中一个事务, 这种多发生在批量更新的情况, 可以标准化更新顺序，例如按 id 升序更新：&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-导致死锁的原因&#34;&gt;1. 导致死锁的原因&lt;/h2&gt;
&lt;p&gt;在 MySQL（尤其是 InnoDB 存储引擎）里，常见的死锁往往与行锁（Row Lock）、间隙锁（Gap Lock）、Next-Key Lock 等锁机制的细节紧密相关。要理解为什么会出现死锁，需要先明白 InnoDB 是如何在事务中为数据上锁的，以及不同类型的锁是如何导致冲突的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;行锁（Row Lock）：对索引记录本身加的锁（Record Lock）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;间隙锁（Gap Lock）：对索引记录之间的间隙加的锁，用于防止幻读（Phantom Read）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Next-Key Lock：它实际上是“记录锁 + 间隙锁”的组合锁，会锁住“当前索引记录”以及紧邻的一段间隙&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MySQL InnoDB 的默认隔离级别是 &lt;strong&gt;REPEATABLE READ&lt;/strong&gt;。在该隔离级别下，对索引进行范围查询时，为了避免幻读，InnoDB 通常会通过 Next-Key Lock 把记录本身和相邻间隙一起锁定。正是因为这种锁定方式，当多事务并发执行时，如果它们的锁定范围出现交叠或顺序不一致，就比较容易引发死锁。&lt;/p&gt;
&lt;h3 id=&#34;11-更新操作顺序不一致-普通行x锁&#34;&gt;1.1. 更新操作顺序不一致 普通行x锁&lt;/h3&gt;
&lt;p&gt;这是最直观的死锁场景之一, 也是很多人最先想到的场景, 本质原因是两个事务以不同的顺序加锁, 从而彼此等待。先来举一个简单的例子（无 Gap Lock 干扰）, 只用普通行x锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景:&lt;/strong&gt; 事务 A 先更新 &lt;code&gt;id=1&lt;/code&gt; 的记录，再更新 &lt;code&gt;id=2&lt;/code&gt; 的记录；事务 B 先更新 &lt;code&gt;id=2&lt;/code&gt; 的记录，再更新 &lt;code&gt;id=1&lt;/code&gt; 的记录。&lt;/p&gt;
&lt;p&gt;如果两个事务并行执行，就可能出现这样的顺序：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;事务 A： &lt;code&gt;UPDATE t_user SET balance = balance - 10 WHERE id = 1;&lt;/code&gt; 成功锁住 &lt;code&gt;id=1&lt;/code&gt; 行&lt;/li&gt;
&lt;li&gt;事务 B： &lt;code&gt;UPDATE t_user SET balance = balance - 20 WHERE id = 2;&lt;/code&gt; 成功锁住 &lt;code&gt;id=2&lt;/code&gt; 行&lt;/li&gt;
&lt;li&gt;事务 A： &lt;code&gt;UPDATE t_user SET balance = balance + 10 WHERE id = 2;&lt;/code&gt; 要锁 &lt;code&gt;id=2&lt;/code&gt;，但是这把锁被事务 B 占用，需要等待&lt;/li&gt;
&lt;li&gt;事务 B： &lt;code&gt;UPDATE t_user SET balance = balance + 20 WHERE id = 1;&lt;/code&gt; 要锁 &lt;code&gt;id=1&lt;/code&gt;，但是这把锁被事务 A 占用，需要等待&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此时 A 等 B 释放锁，B 等 A 释放锁，形成死锁, 由于 InnoDB 检测到死锁，会自动回滚其中一个事务, 这种多发生在批量更新的情况, 可以标准化更新顺序，例如按 id 升序更新：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 事务 A 和 B 都按 order_id 升序更新
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; orders &lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; status &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;xxx&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; order_id &lt;span style=&#34;color:#66d9ef&#34;&gt;IN&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; order_id;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;12-间隙锁导致的死锁&#34;&gt;1.2. 间隙锁导致的死锁&lt;/h3&gt;
&lt;p&gt;下面这个场景更具代表性, 也更体现出 MySQL Next-Key Lock 如何导致死锁, 很多开发者在进行范围查询或插入时, 会因为不理解 Gap Lock 的触发条件而踩坑:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; products (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id INT &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; AUTO_INCREMENT,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    name VARCHAR(&lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    price DECIMAL(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;-- 间隙锁只会加在索引上, 如果不是索引则退化为全表扫描, 索引也分为唯一和不唯一索引
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;UNIQUE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; (price)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;假设现在我们的表里有四条记录, price 分别是 1.00, 2.50, 3.00, 4.00,&lt;/p&gt;
&lt;p&gt;假设有两个事务, 它们都使用了范围查询, 由于 MySQL 默认隔离级别是 REPEATABLE READ, 所以&lt;strong&gt;范围查询 当前读&lt;/strong&gt;会触发 Next-Key Lock, 导致锁住记录本身以及相邻的“间隙”:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;T1 执行 &lt;code&gt;SELECT * FROM products WHERE price BETWEEN 2.00 AND 3.00 FOR UPDATE;&lt;/code&gt;
这是一个&lt;strong&gt;当前读&lt;/strong&gt; &lt;code&gt;FOR UPDATE&lt;/code&gt;, 虽然 price 唯一, 但这是范围查询, 所以会加  Next-Key Lock&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;锁定范围：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;price = 2.50：Record Lock&lt;/li&gt;
&lt;li&gt;price = 3.00：Record Lock&lt;/li&gt;
&lt;li&gt;间隙：(1.00, 2.50) 和 (2.50, 3.00) 和 (3.00, 4.00)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;T2 执行 &lt;code&gt;SELECT * FROM products WHERE price BETWEEN 3.00 AND 4.00 FOR UPDATE;&lt;/code&gt;
尝试锁住 &lt;code&gt;price=3.00&lt;/code&gt;、&lt;code&gt;price=4.00&lt;/code&gt; 以及与其相邻的间隙&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于 T1 已经锁住了 &lt;code&gt;price=3.00&lt;/code&gt;, T2 在尝试加锁 &lt;code&gt;price=3.00&lt;/code&gt; 时会被阻塞，等待 T1 释放&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果这时候 T1 在同一个事务里又做了其他操作（例如插入一条 &lt;code&gt;price=3.50&lt;/code&gt; 的记录）, 因为插入需要先获得插入意向锁即 &lt;code&gt;(3.00, 4.00)&lt;/code&gt; 这个间隙锁，而这个间隙锁已经被 T2 拿到了一部分，也会等待&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样两边都在等对方释放锁, 就会出现死锁,&lt;/p&gt;
&lt;h3 id=&#34;13-外键引起&#34;&gt;1.3. 外键引起&lt;/h3&gt;
&lt;p&gt;假设我们有两个表：Parent 和 Child, Child 表有一个外键引用 Parent 表的主键,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;事务 A&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;启动事务后，执行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;DELETE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; Parent &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;InnoDB 对 &lt;code&gt;Parent&lt;/code&gt; 表中 &lt;code&gt;id = 1&lt;/code&gt; 这条记录加上 &lt;strong&gt;排它锁(X 锁)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为有外键约束，删除时必须确认 &lt;code&gt;Child&lt;/code&gt; 表中是否还存在引用 &lt;code&gt;Parent(id=1)&lt;/code&gt; 的行；如果存在并且外键约束是不允许删除(例如 &lt;code&gt;ON DELETE RESTRICT&lt;/code&gt;)，那就会报错阻止删除；如果是 &lt;code&gt;ON DELETE CASCADE&lt;/code&gt;，则要继续删除 &lt;code&gt;Child&lt;/code&gt; 表里相应的记录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无论哪种外键策略，InnoDB 都会去扫描 &lt;code&gt;Child&lt;/code&gt; 表是否有 &lt;code&gt;parentId = 1&lt;/code&gt; 的记录，并尝试对这些子记录（或相应索引）加锁&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;事务 B&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;事务 A 还没结束时，事务 B 执行插入：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;INSERT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INTO&lt;/span&gt; Child (id, parentId, ...) &lt;span style=&#34;color:#66d9ef&#34;&gt;VALUES&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;101&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, ...);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;InnoDB 在往 &lt;code&gt;Child&lt;/code&gt; 表里插入新行之前，会先在 &lt;code&gt;Child&lt;/code&gt; 表对应的索引上加 &lt;strong&gt;插入意向锁(或间隙锁)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接着，为了保证外键引用的有效性，需要去 &lt;code&gt;Parent&lt;/code&gt; 表里确认 &lt;code&gt;id=1&lt;/code&gt; 存在，这就要去给 &lt;code&gt;Parent(id=1)&lt;/code&gt; 这条记录请求 &lt;strong&gt;锁(通常是 S 锁或者意向锁)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但是由于事务 A 已经对 &lt;code&gt;Parent(id=1)&lt;/code&gt; 持有了 X 锁，事务 B 在此时会被阻塞&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;进入相互等待&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要注意的点是, 在现实里要形成上述场景, 往往是因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务 A 删除 &lt;code&gt;Parent&lt;/code&gt; 的时候，&lt;code&gt;ON DELETE RESTRICT&lt;/code&gt; 或者 &lt;code&gt;ON DELETE NO ACTION&lt;/code&gt; 外键策略没有立即报错, 而是先尝试获取 &lt;code&gt;Child&lt;/code&gt; 那边的锁去检查/删除，这时刚好被另一个事务 B 插入或更新冲突；或者&lt;/li&gt;
&lt;li&gt;事务 A 是 “先删父，再删子” 但中间不小心被打断，事务 B 恰好要插入/更新同样引用的父记录从而引发冲突。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-如何排查死锁&#34;&gt;2. 如何排查死锁&lt;/h2&gt;
&lt;p&gt;在 MySQL（InnoDB 引擎）中，当 InnoDB 检测到死锁时，会主动回滚其中一个事务，并将死锁相关信息记录到 &lt;code&gt;SHOW ENGINE INNODB STATUS&lt;/code&gt; 命令输出中。&lt;/p&gt;
&lt;h3 id=&#34;21-查看异常日志&#34;&gt;2.1. 查看异常日志&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Spring Boot 日志&lt;/strong&gt;：在 Spring Boot 的运行日志中，通常会看到类似 &lt;code&gt;Deadlock found when trying to get lock; try restarting transaction&lt;/code&gt; 的异常信息，这意味着某条 SQL 在执行时被 MySQL 判定发生死锁，从而回滚&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MySQL 错误日志&lt;/strong&gt;：有时还可以在 MySQL 服务器的错误日志中找到死锁相关信息（如果有开启记录）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22-使用-show-engine-innodb-status-命令&#34;&gt;2.2. 使用 &lt;code&gt;SHOW ENGINE INNODB STATUS&lt;/code&gt; 命令&lt;/h3&gt;
&lt;p&gt;在 MySQL 客户端或者其他数据库管理工具中，执行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SHOW&lt;/span&gt; ENGINE INNODB STATUS &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;\&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;G&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;------------------------
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;LATEST DETECTED DEADLOCK
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;------------------------
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2025&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;03&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;06&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;14&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;37&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;07&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;x7f9bd9513700
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;***&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;TRANSACTION&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;TRANSACTION&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;598373&lt;/span&gt;, ACTIVE &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt; sec
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;lock&lt;/span&gt; struct(s), heap &lt;span style=&#34;color:#66d9ef&#34;&gt;size&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1136&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;row&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;lock&lt;/span&gt;(s), undo log entries &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;MySQL thread id &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;, OS thread handle &lt;span style=&#34;color:#ae81ff&#34;&gt;140309172537088&lt;/span&gt;, query id &lt;span style=&#34;color:#ae81ff&#34;&gt;225&lt;/span&gt; server &lt;span style=&#34;color:#ae81ff&#34;&gt;127&lt;/span&gt;.&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;.&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;.&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;user&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;update&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;INSERT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INTO&lt;/span&gt; log_record (account_id, &lt;span style=&#34;color:#66d9ef&#34;&gt;operation&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;VALUES&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;minus 100&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;***&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) WAITING &lt;span style=&#34;color:#66d9ef&#34;&gt;FOR&lt;/span&gt; THIS &lt;span style=&#34;color:#66d9ef&#34;&gt;LOCK&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TO&lt;/span&gt; BE &lt;span style=&#34;color:#66d9ef&#34;&gt;GRANTED&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;RECORD LOCKS &lt;span style=&#34;color:#66d9ef&#34;&gt;space&lt;/span&gt; id &lt;span style=&#34;color:#ae81ff&#34;&gt;63&lt;/span&gt; page &lt;span style=&#34;color:#66d9ef&#34;&gt;no&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; n bits &lt;span style=&#34;color:#ae81ff&#34;&gt;72&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;index&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;of&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;test&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;.&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;log_record&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;trx id &lt;span style=&#34;color:#ae81ff&#34;&gt;598373&lt;/span&gt; lock_mode X locks rec but &lt;span style=&#34;color:#66d9ef&#34;&gt;not&lt;/span&gt; gap waiting
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Record &lt;span style=&#34;color:#66d9ef&#34;&gt;lock&lt;/span&gt;, heap &lt;span style=&#34;color:#66d9ef&#34;&gt;no&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; PHYSICAL RECORD: n_fields &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;; compact format; info bits &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;***&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;TRANSACTION&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;TRANSACTION&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;598374&lt;/span&gt;, ACTIVE &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; sec
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;lock&lt;/span&gt; struct(s), heap &lt;span style=&#34;color:#66d9ef&#34;&gt;size&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1136&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;row&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;lock&lt;/span&gt;(s), undo log entries &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;MySQL thread id &lt;span style=&#34;color:#ae81ff&#34;&gt;101&lt;/span&gt;, OS thread handle &lt;span style=&#34;color:#ae81ff&#34;&gt;140309172538112&lt;/span&gt;, query id &lt;span style=&#34;color:#ae81ff&#34;&gt;226&lt;/span&gt; server &lt;span style=&#34;color:#ae81ff&#34;&gt;127&lt;/span&gt;.&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;.&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;.&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;user&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;update&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; account &lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; balance &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; balance &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;***&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) HOLDS THE &lt;span style=&#34;color:#66d9ef&#34;&gt;LOCK&lt;/span&gt;(S):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;RECORD LOCKS &lt;span style=&#34;color:#66d9ef&#34;&gt;space&lt;/span&gt; id &lt;span style=&#34;color:#ae81ff&#34;&gt;62&lt;/span&gt; page &lt;span style=&#34;color:#66d9ef&#34;&gt;no&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; n bits &lt;span style=&#34;color:#ae81ff&#34;&gt;80&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;index&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;of&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;test&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;.&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;account&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;trx id &lt;span style=&#34;color:#ae81ff&#34;&gt;598374&lt;/span&gt; lock_mode X
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Record &lt;span style=&#34;color:#66d9ef&#34;&gt;lock&lt;/span&gt;, heap &lt;span style=&#34;color:#66d9ef&#34;&gt;no&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; PHYSICAL RECORD: n_fields &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;; compact format; info bits &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;***&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) WAITING &lt;span style=&#34;color:#66d9ef&#34;&gt;FOR&lt;/span&gt; THIS &lt;span style=&#34;color:#66d9ef&#34;&gt;LOCK&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TO&lt;/span&gt; BE &lt;span style=&#34;color:#66d9ef&#34;&gt;GRANTED&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;RECORD LOCKS &lt;span style=&#34;color:#66d9ef&#34;&gt;space&lt;/span&gt; id &lt;span style=&#34;color:#ae81ff&#34;&gt;63&lt;/span&gt; page &lt;span style=&#34;color:#66d9ef&#34;&gt;no&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; n bits &lt;span style=&#34;color:#ae81ff&#34;&gt;72&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;index&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;of&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;test&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;.&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;log_record&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;trx id &lt;span style=&#34;color:#ae81ff&#34;&gt;598374&lt;/span&gt; lock_mode X locks rec but &lt;span style=&#34;color:#66d9ef&#34;&gt;not&lt;/span&gt; gap waiting
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;***&lt;/span&gt; WE ROLL BACK &lt;span style=&#34;color:#66d9ef&#34;&gt;TRANSACTION&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这条命令可以查看最近一次死锁的详细信息，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;具体冲突的表、行、&lt;strong&gt;SQL 语句&lt;/strong&gt;等&lt;/li&gt;
&lt;li&gt;形成死锁的事务&lt;strong&gt;持有哪些锁&lt;/strong&gt;、在&lt;strong&gt;等待哪些锁&lt;/strong&gt;（Record lock、Gap lock、Next-key lock）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据这些信息, 我们可以判断代码中的 SQL 执行顺序, 因为多个事务以不同顺序申请锁而导致的死锁, 可以在业务层确保所有事务对资源的加锁顺序一致（例如，按主键 ID 升序加锁）&lt;/p&gt;
&lt;p&gt;也可以使用使用 &lt;code&gt;EXPLAIN&lt;/code&gt; 分析 SQL 的执行计划, 检查 SQL 是否命中索引, 因为死锁也有可能是由于缺少合适的索引可能导致锁范围扩大(整张表)进而提高死锁概率,&lt;/p&gt;
&lt;p&gt;根据上面输出:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;*** (1) TRANSACTION:
TRANSACTION 598373, ACTIVE 7 sec
3 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 1
MySQL thread id 100, OS thread handle 140309172537088, query id 225 server 127.0.0.1 user update
INSERT INTO log_record (account_id, operation) VALUES (1, &amp;#39;minus 100&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;该事务(1) 持有 3 个锁结构, 其中包括 2 个行锁: &lt;code&gt;3 lock struct(s)&lt;/code&gt;, &lt;code&gt;2 row lock(s)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;正在对表 ⁠&lt;code&gt;log_record&lt;/code&gt; 进行 INSERT 操作&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 63 page no 4 n bits 72 index `PRIMARY` of table `test`.`log_record`
trx id 598373 lock_mode X locks rec but not gap waiting
Record lock, heap no 3 PHYSICAL RECORD: n_fields 5; compact format; info bits 0
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;当前事务正在等待获取一个锁，但锁还未被授予, 换句话说，有另一个事务持有锁，导致当前事务被阻塞&lt;/li&gt;
&lt;li&gt;&lt;code&gt;index PRIMARY of table test.log_record&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;index PRIMARY: 锁的目标是表的主键索引（primary key index）&lt;/li&gt;
&lt;li&gt;table test.log_record: 锁发生在数据库 test 中的表 log_record 上&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lock_mode X locks rec but not gap waiting&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lock_mode X&lt;/code&gt;: 表示这是一个排他锁&lt;/li&gt;
&lt;li&gt;&lt;code&gt;locks rec but not gap&lt;/code&gt;: 表示这是一个记录锁 record lock, 而不是 间隙锁 gap lock, 记录锁锁定特定的行, 间隙锁锁定行之间的范围（常用于防止幻读）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;waiting&lt;/code&gt;: 当前事务正在等待, 因为另一个事务已经持有了锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-避免死锁&#34;&gt;3. 避免死锁&lt;/h2&gt;
&lt;p&gt;统一加锁顺序&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如：如果业务逻辑需要在一笔交易中更新 &lt;code&gt;A 表&lt;/code&gt; 和 &lt;code&gt;B 表&lt;/code&gt;，就应&lt;strong&gt;统一&lt;/strong&gt;先更新 &lt;code&gt;A 表&lt;/code&gt; 再更新 &lt;code&gt;B 表&lt;/code&gt;（或者反之），避免在不同事务中出现“先 A 后 B”与“先 B 后 A”的交叉&lt;/li&gt;
&lt;li&gt;这种统一顺序减少了在数据库级别发生环形等待的可能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尽量缩短事务执行时间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在事务中只放真正需要保证原子性和一致性的 SQL 操作，把其他耗时操作（如外部 HTTP 调用、文件操作）放在事务外执行&lt;/li&gt;
&lt;li&gt;事务持有锁的时间越短，发生死锁的窗口就越小&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查看执行计划并监控慢查询&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;除了使用 &lt;code&gt;EXPLAIN&lt;/code&gt; 分析单条 SQL 的执行计划外，可配合开启 MySQL 慢查询日志，关注是否存在长时间占用锁的慢 SQL&lt;/li&gt;
&lt;li&gt;如果出现大量慢查询，也意味着事务执行时间变长，更容易导致死锁和高锁等待&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>MySQL 中的事务隔离界别和各种锁</title>
      <link>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/002-%E5%90%84%E7%A7%8D%E9%94%81/</link>
      <pubDate>Thu, 06 Mar 2025 09:39:22 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/002-%E5%90%84%E7%A7%8D%E9%94%81/</guid>
      <description>&lt;h2 id=&#34;1-行级锁记录锁&#34;&gt;1. 行级锁/记录锁&lt;/h2&gt;
&lt;h3 id=&#34;11-排它锁-x-锁---解决脏写&#34;&gt;1.1. 排它锁 X 锁 - 解决脏写&lt;/h3&gt;
&lt;p&gt;相同数据行上的 X 锁会阻塞其它加共享锁或排他锁的操作&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; my_table &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FOR&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;在任何事务隔离级别下, 删改操作都需要先获得 x 锁, 目的是避免脏写, 也就是说即使没有显示使用 &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt;, 进行删改操作时, 数据库都会自动尝试获得相应行的 x锁, 然后再进行写操作, 否则阻塞等待锁释放或当作死锁处理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;12-共享锁-s-锁---解决不可重复读&#34;&gt;1.2. 共享锁 S 锁 - 解决不可重复读&lt;/h3&gt;
&lt;p&gt;允许多个事务同时读取同一数据, 但不允许修改, 也就是说与 X 锁互斥&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; my_table &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;LOCK&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;IN&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;SHARE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;MODE&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;在 所有事务隔离级别 下, s锁都不会默认添加, 只有当显式使用 &lt;code&gt;SELECT ... LOCK IN SHARE MODE&lt;/code&gt; 时才会加 s锁&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;拓展&lt;/strong&gt; 在  InnoDB 可重复读 隔离级别下, 普通的 &lt;code&gt;SELECT&lt;/code&gt; 语句不会默认加 s共享锁, 它使用的是一致性读, 即通过MVCC 机制读取数据的快照, 而不是加锁读取, 来避免不可重复读问题的, 当然你也可以显示加上 s共享锁, 使用锁来避免不可重复读问题,&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-行级锁记录锁&#34;&gt;1. 行级锁/记录锁&lt;/h2&gt;
&lt;h3 id=&#34;11-排它锁-x-锁---解决脏写&#34;&gt;1.1. 排它锁 X 锁 - 解决脏写&lt;/h3&gt;
&lt;p&gt;相同数据行上的 X 锁会阻塞其它加共享锁或排他锁的操作&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; my_table &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FOR&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;在任何事务隔离级别下, 删改操作都需要先获得 x 锁, 目的是避免脏写, 也就是说即使没有显示使用 &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt;, 进行删改操作时, 数据库都会自动尝试获得相应行的 x锁, 然后再进行写操作, 否则阻塞等待锁释放或当作死锁处理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;12-共享锁-s-锁---解决不可重复读&#34;&gt;1.2. 共享锁 S 锁 - 解决不可重复读&lt;/h3&gt;
&lt;p&gt;允许多个事务同时读取同一数据, 但不允许修改, 也就是说与 X 锁互斥&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; my_table &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;LOCK&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;IN&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;SHARE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;MODE&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;在 所有事务隔离级别 下, s锁都不会默认添加, 只有当显式使用 &lt;code&gt;SELECT ... LOCK IN SHARE MODE&lt;/code&gt; 时才会加 s锁&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;拓展&lt;/strong&gt; 在  InnoDB 可重复读 隔离级别下, 普通的 &lt;code&gt;SELECT&lt;/code&gt; 语句不会默认加 s共享锁, 它使用的是一致性读, 即通过MVCC 机制读取数据的快照, 而不是加锁读取, 来避免不可重复读问题的, 当然你也可以显示加上 s共享锁, 使用锁来避免不可重复读问题,&lt;/p&gt;
&lt;p&gt;不可重复读: 发生在同一行数据被更新, 导致同一查询多次执行返回不同的具体数值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-next-key-lock---解决幻读&#34;&gt;2. Next-Key Lock - 解决幻读&lt;/h2&gt;
&lt;p&gt;注意 InnoDB &lt;code&gt;可重复读&lt;/code&gt; 或更高隔离级别才会有 Next-Key 锁, Next-Key 锁 = 记录锁 + 间隙锁,&lt;/p&gt;
&lt;p&gt;Next-Key 锁的目的是解决幻读问题, 幻读是指事务读取一个范围的数据时, 另一个事务插入或删除行, 导致再次读取范围时结果不一致, 所以我们在进行范围查询时, 通过 &lt;code&gt;SELECT ... FOR UPDATE &lt;/code&gt; 自动添加间隙锁, 这样就可以避免在间隙锁释放之前, 其他事务在查询范围内插入新纪录, 至于如何避免的, 我们下面会讲到,&lt;/p&gt;
&lt;h3 id=&#34;21-范围查询&#34;&gt;2.1. 范围查询&lt;/h3&gt;
&lt;p&gt;当执行涉及范围条件的查询且使用 &lt;code&gt;SELECT ... FOR UPDATE &lt;/code&gt;时, InnoDB 会使用 Next-Key Lock 锁定查询范围内的记录及其间隙&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;table_name&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FOR&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;注意上面的 SQL 语句格式 &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt;, 若是普通查询 &lt;code&gt;SELECT ...&lt;/code&gt;, 无论是否是范围查询 InnoDB 采用的都是 MVCC 多版本并发控制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;22-非唯一索引上的等值查询&#34;&gt;2.2. 非唯一索引上的等值查询&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;START&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TRANSACTION&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; employees &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; salary &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4000&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FOR&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果 &lt;code&gt;salary&lt;/code&gt; 列上存在索引, 并且是&lt;strong&gt;非唯一索引&lt;/strong&gt;, InnoDB 会在查找到的记录上加锁, 同时加锁该记录与相邻记录之间的间隙, 即使这不是范围查询, 这保证了其他事务不能在锁定区间内插入新记录，从而避免幻读问题。因为若 salary 不唯一, 我们查到的结果可能是多个, 此时必须使用 Next-Key Lock 来防止其他事务插入相同的 salary 导致幻读,&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;salary&lt;/code&gt; 唯一, 通常不会触发间隙锁, 只会加记录锁, 因为等值查询可以精确定位到一条记录, 不需要保护范围,&lt;/p&gt;
&lt;p&gt;如果  &lt;code&gt;salary&lt;/code&gt;  唯一, 但若是范围查询, 则需要防止其他事务在查询范围之间插入新记录, 因此仍会触发间隙锁,&lt;/p&gt;
&lt;p&gt;如果  &lt;code&gt;salary&lt;/code&gt;   列上不存在索引（无论是唯一索引还是非唯一索引），MySQL 的 InnoDB 在执行涉及   &lt;code&gt;salary&lt;/code&gt;    的查询或修改操作时，会&lt;strong&gt;因为无法利用索引而退化为全表扫描&lt;/strong&gt;, 在这种情况下，锁的机制和范围会发生显著变化，尤其是在默认隔离级别下，可能会导致更广泛的锁范围，甚至锁住整个表。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;记录锁 Record Lock：锁定具体的索引记录, x 锁或 s 锁&lt;/p&gt;
&lt;p&gt;间隙锁 Gap Lock：锁定索引记录之间的间隙, 防止其他事务在该范围内插入新记录, 间隙锁只在 &lt;strong&gt;可重复读&lt;/strong&gt; 和 &lt;strong&gt;串行化&lt;/strong&gt; 隔离级别下生效, 且只作用于 &lt;strong&gt;索引&lt;/strong&gt;（包括主键索引和二级索引）, 如果表没有索引（例如纯堆表）, InnoDB 会退化为锁全表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;3-插入意向锁-insert-intention-lock&#34;&gt;3. 插入意向锁 Insert Intention Lock&lt;/h2&gt;
&lt;p&gt;在 InnoDB 中，插入操作本身并不会直接获取行上的 X 锁, 因为插入的目标是新记录, 尚未存在于表中, 所以没有“行”可以加锁,&lt;/p&gt;
&lt;p&gt;当执行 INSERT 操作时，InnoDB 不直接在数据行上加锁，而是先在目标 gap 上加上插入意向锁, 插入意向锁是 MySQL InnoDB 存储引擎中一种特殊的间隙锁变种, 属于意向锁的一种, 插入意向锁本身并不直接锁定具体的行, 而是表明一个事务“打算”在某个间隙中插入数据, 它会等待现有的间隙锁（如果有）释放, 从而避免冲突,&lt;/p&gt;
&lt;p&gt;插入意向锁通常出现在使用 &lt;strong&gt;可重复读 隔离级别&lt;/strong&gt;时, 因为在这个隔离级别下, MySQL 会&lt;strong&gt;使用间隙锁来防止幻读问题&lt;/strong&gt;,&lt;/p&gt;
&lt;p&gt;我们来看一下例子, 现在有两个事务同时尝试插入记录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务 A 想插入 id = 2&lt;/li&gt;
&lt;li&gt;事务 B 想插入 id = 3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设事务 C &lt;strong&gt;先执行&lt;/strong&gt;了一条查询 &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt;, 锁定了间隙 (1, 4)：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;事务 A 请求插入 id = 2, 发现间隙 (1, 4) 被间隙锁占用, 插入意向锁被阻塞&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务 A 必须等待事务 C 提交或回滚, 释放间隙锁后才能继续插入&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这就完美避免了幻读问题, 看看上面的内容, 前后呼应&lt;/p&gt;
&lt;h2 id=&#34;4-记录锁-多版本并发控制&#34;&gt;4. 记录锁 多版本并发控制&lt;/h2&gt;
&lt;p&gt;普通 &lt;code&gt;SELECT&lt;/code&gt; 语句：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 MVCC 多版本并发控制&lt;/li&gt;
&lt;li&gt;读取的是事务开始时的快照数据, 不会加 &lt;code&gt;S&lt;/code&gt; 锁, 也不会阻塞其他事务的更新或插入&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;SELECT ... LOCK IN SHARE MODE&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;会显式对读取的行加 &lt;code&gt;S&lt;/code&gt; 锁，其他事务仍可读取，但不能 &lt;code&gt;UPDATE&lt;/code&gt; 或 &lt;code&gt;DELETE&lt;/code&gt; 这些被锁的行&lt;/li&gt;
&lt;li&gt;适用于确保数据在事务执行期间不会被修改，但仍允许读取&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;会显式对读取的行加 &lt;code&gt;X&lt;/code&gt; 锁，阻止其他事务对这些行进行 &lt;code&gt;UPDATE&lt;/code&gt; 或 &lt;code&gt;DELETE&lt;/code&gt;，但仍允许读取（非锁定读）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;记录锁 Record Lock：锁定具体的索引记录, x 锁或 s 锁&lt;/li&gt;
&lt;li&gt;间隙锁 Gap Loc：锁定索引记录之间的间隙，防止其他事务在该范围内插入新记录&lt;/li&gt;
&lt;li&gt;Next-Key 锁 = 记录锁 + 间隙锁&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注意上面讨论的是在 InnoDB &lt;code&gt;可重复读&lt;/code&gt; 隔离级别下的情况, InnoDB 的默认隔离级别也是 &lt;code&gt;可重复读&lt;/code&gt;, 更低级别比如 &lt;code&gt;已提交读&lt;/code&gt;, &lt;code&gt;已提交读&lt;/code&gt; 并不支持 MVCC 快照读 或者 Next-Key 锁, 它们都是 &lt;code&gt;可重复读&lt;/code&gt; 和 &lt;code&gt;序列化&lt;/code&gt; 隔离级别下的机制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;5--快照读-vs-当前读&#34;&gt;5.  快照读 vs 当前读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;快照读&lt;/strong&gt;: 普通的 SELECT, 不会加锁, 只依赖快照读 MVCC&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当前读&lt;/strong&gt;: &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt; 或 &lt;code&gt;SELECT ... LOCK IN SHARE MODE&lt;/code&gt;, 触发 x 锁 或 s 锁, 范围查询会触发 Next-Key Lock&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无范围查询时, &lt;strong&gt;当前读&lt;/strong&gt;触发记录锁( x 锁 或 s 锁)&lt;/li&gt;
&lt;li&gt;存在范围查询, 触发 Next-Key Lock, 也就是 记录锁 + 间隙锁&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注释上面讨论的是 InnoDB  “可重复读” 隔离级别下的情况&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    </item>
    
    <item>
      <title>MySQL 事务 数据库锁 悲观锁 乐观锁</title>
      <link>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/001-%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Mon, 17 Feb 2025 20:39:22 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/001-%E4%BA%8B%E5%8A%A1/</guid>
      <description>&lt;h2 id=&#34;1-脏读-脏写-幻读---事务隔离级别&#34;&gt;1. 脏读 脏写 幻读 - 事务隔离级别&lt;/h2&gt;
&lt;h3 id=&#34;11-脏读---事务隔离级别较低&#34;&gt;1.1. 脏读 - 事务隔离级别较低&lt;/h3&gt;
&lt;p&gt;脏读是指一个事务读取到了另一个事务尚未提交的数据。若后者发生回滚，则前者读取的数据实际上并不存在。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;事务 A 修改了一条记录，但尚未提交&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务 B 读取这条记录，看到 A 的修改&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果 A 后续回滚，那么 B 读到了不存在的数据，这就是脏读问题。&lt;/p&gt;
&lt;p&gt;根本原因在于事务隔离级别较低，&lt;strong&gt;允许一个事务读取另一个事务未提交的修改数据&lt;/strong&gt;，缺少对数据一致性的保证。&lt;/p&gt;
&lt;h3 id=&#34;12-脏写&#34;&gt;1.2. 脏写&lt;/h3&gt;
&lt;p&gt;脏写指的是：事务 B 在事务 A 尚未提交的更新基础上又进行了更新并提交。如果随后事务 A 回滚，但 B 已经基于 A 的“未提交更新”写入了数据库，就会导致数据库中出现了一份基于“从未真正生效的数据”所写进去的值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果 B 的更新逻辑要判断某个字段是否满足条件（例如库存是否 &amp;gt; 0 才扣减），而这个字段恰恰是由 A 更新的未提交数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;B 基于 A 未提交的数据做了扣减并提交，后来 A 回滚导致库存根本没增加（或者没变化），最终 B 却“凭空”把库存扣了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些例子都说明了：脏写本质上是写操作基于了一份并不存在（或不确定会不会存在）的中间状态，进而可能对数据一致性和业务逻辑造成破坏, 这就是为什么数据库禁止脏写的原因。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在多数主流数据库(例如 MySQL InnoDB)的默认配置下，这种情况通常不会发生，因为对同一行记录的并发写操作自动会被加 x锁序列化：只有前一个写操作提交或回滚后，后一个事务才能对这行数据进行新的写。因此，脏写往往只在极其宽松/非常低的隔离级别（或人为关闭了某些并发控制）下，才可能被“模拟”或“测试”出来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;13-不可重复读-和-幻读&#34;&gt;1.3. 不可重复读 和 幻读&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;不可重复读&lt;/strong&gt; 发生在同一行数据被更新，导致同一查询多次执行返回不同的具体数值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;幻读&lt;/strong&gt; 则发生在范围查询中，其他事务在该范围内插入或删除数据，导致结果集的记录数发生变化&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;14-四种隔离级别&#34;&gt;1.4. 四种隔离级别&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;SQL&lt;/code&gt;标准中设立了4种隔离级别, 用来解决上面的读一致性问题, 不同的隔离级别可以解决不同的读一致性问题:&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-脏读-脏写-幻读---事务隔离级别&#34;&gt;1. 脏读 脏写 幻读 - 事务隔离级别&lt;/h2&gt;
&lt;h3 id=&#34;11-脏读---事务隔离级别较低&#34;&gt;1.1. 脏读 - 事务隔离级别较低&lt;/h3&gt;
&lt;p&gt;脏读是指一个事务读取到了另一个事务尚未提交的数据。若后者发生回滚，则前者读取的数据实际上并不存在。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;事务 A 修改了一条记录，但尚未提交&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务 B 读取这条记录，看到 A 的修改&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果 A 后续回滚，那么 B 读到了不存在的数据，这就是脏读问题。&lt;/p&gt;
&lt;p&gt;根本原因在于事务隔离级别较低，&lt;strong&gt;允许一个事务读取另一个事务未提交的修改数据&lt;/strong&gt;，缺少对数据一致性的保证。&lt;/p&gt;
&lt;h3 id=&#34;12-脏写&#34;&gt;1.2. 脏写&lt;/h3&gt;
&lt;p&gt;脏写指的是：事务 B 在事务 A 尚未提交的更新基础上又进行了更新并提交。如果随后事务 A 回滚，但 B 已经基于 A 的“未提交更新”写入了数据库，就会导致数据库中出现了一份基于“从未真正生效的数据”所写进去的值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果 B 的更新逻辑要判断某个字段是否满足条件（例如库存是否 &amp;gt; 0 才扣减），而这个字段恰恰是由 A 更新的未提交数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;B 基于 A 未提交的数据做了扣减并提交，后来 A 回滚导致库存根本没增加（或者没变化），最终 B 却“凭空”把库存扣了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些例子都说明了：脏写本质上是写操作基于了一份并不存在（或不确定会不会存在）的中间状态，进而可能对数据一致性和业务逻辑造成破坏, 这就是为什么数据库禁止脏写的原因。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在多数主流数据库(例如 MySQL InnoDB)的默认配置下，这种情况通常不会发生，因为对同一行记录的并发写操作自动会被加 x锁序列化：只有前一个写操作提交或回滚后，后一个事务才能对这行数据进行新的写。因此，脏写往往只在极其宽松/非常低的隔离级别（或人为关闭了某些并发控制）下，才可能被“模拟”或“测试”出来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;13-不可重复读-和-幻读&#34;&gt;1.3. 不可重复读 和 幻读&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;不可重复读&lt;/strong&gt; 发生在同一行数据被更新，导致同一查询多次执行返回不同的具体数值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;幻读&lt;/strong&gt; 则发生在范围查询中，其他事务在该范围内插入或删除数据，导致结果集的记录数发生变化&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;14-四种隔离级别&#34;&gt;1.4. 四种隔离级别&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;SQL&lt;/code&gt;标准中设立了4种隔离级别, 用来解决上面的读一致性问题, 不同的隔离级别可以解决不同的读一致性问题:&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;隔离级别 (Isolation Level)&lt;/th&gt;
          &lt;th&gt;脏读 (Dirty Read)&lt;/th&gt;
          &lt;th&gt;不可重复读 (Non-repeatable Read)&lt;/th&gt;
          &lt;th&gt;幻读 (Phantom Read)&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;未提交读 (READ UNCOMMITTED)&lt;/td&gt;
          &lt;td&gt;可能 (Yes)&lt;/td&gt;
          &lt;td&gt;可能 (Yes)&lt;/td&gt;
          &lt;td&gt;可能 (Yes)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;已提交读 (READ COMMITTED)&lt;/td&gt;
          &lt;td&gt;不可能 (No)&lt;/td&gt;
          &lt;td&gt;可能 (Yes)&lt;/td&gt;
          &lt;td&gt;可能 (Yes)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;可重复读 (REPEATABLE READ)&lt;/td&gt;
          &lt;td&gt;不可能 (No)&lt;/td&gt;
          &lt;td&gt;不可能 (No)&lt;/td&gt;
          &lt;td&gt;可能 (Yes)（对 InnoDB 不可能）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;串行化 (SERIALIZABLE)&lt;/td&gt;
          &lt;td&gt;不可能 (No)&lt;/td&gt;
          &lt;td&gt;不可能 (No)&lt;/td&gt;
          &lt;td&gt;不可能 (No)&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;脏写的问题严重, 数据库设计上通过删改操作默认加 x锁, 实现脏写在任何隔离级别都会避免&lt;/p&gt;
&lt;p&gt;&lt;code&gt;InnoDB&lt;/code&gt;支持四个隔离级别（和&lt;code&gt;SQL&lt;/code&gt;标准定义的基本一致）。隔离级别越高，事务的并发度就越低。唯一的区别就在于，&lt;code&gt;InnoDB&lt;/code&gt; 在&lt;code&gt;可重复读（REPEATABLE READ）&lt;/code&gt;的级别就解决了幻读的问题。这也是&lt;code&gt;InnoDB&lt;/code&gt;使用&lt;code&gt;可重复读&lt;/code&gt; 作为事务默认隔离级别的原因。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-脏读-脏写-幻读如何被解决的&#34;&gt;2. 脏读 脏写 幻读如何被解决的&lt;/h2&gt;
&lt;h3 id=&#34;21-脏读-脏写&#34;&gt;2.1. 脏读 脏写&lt;/h3&gt;
&lt;p&gt;上面提到, 数据库有四种隔离级别, 用来解决 脏读, 脏写, 不可重复读, 幻读等问题, 现在我们简单叙述一下各自的概念:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;脏读: 一个事务读取到了另一个事务尚未提交的数据, 若未提交的数据发生回滚&amp;hellip;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务隔离级别较低, 允许一个事务读取另一个事务未提交的修改数据所导致&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;脏写: 事务 B 在事务 A 尚未提交的更新基础上又进行了更新并提交&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;脏写的问题严重, 数据库设计上通过删改操作默认加 x锁, 实现脏写在任何隔离级别都会避免&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;幻读: 发生在范围查询中，其他事务在该范围内插入或删除数据，导致结果集的记录数发生变化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不可重复读: 发生在同一行数据被更新, 导致同一查询多次执行返回不同的具体数值&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中脏写在隔离级别下都被消除了, 方法是任何写操作都需要先获得 x 锁, 然后就剩脏读, 幻读, 不可重复读这三个问题,&lt;/p&gt;
&lt;p&gt;InnoDB 在第三级别 &lt;code&gt;可重复读（REPEATABLE READ）&lt;/code&gt; 就解决了所有的问题, 前两个级别分别是 &lt;code&gt;未提交读&lt;/code&gt;, &lt;code&gt;已提交读&lt;/code&gt;, 根据名字就可以看出, &lt;code&gt;未提交读&lt;/code&gt;就是允许修改的数据还没提交就允许其他事务读取, 这显然会造成脏读, &lt;code&gt;未提交读&lt;/code&gt;也是最低级别的事务隔离, 第二级别就是&lt;code&gt;已提交读&lt;/code&gt;, 显然该级别解决了脏读问题, 但是还不够, 此时还有幻读和不可重复读的问题没有解决,&lt;/p&gt;
&lt;h3 id=&#34;22-不可重复读&#34;&gt;2.2. 不可重复读&lt;/h3&gt;
&lt;p&gt;不可重复读指的是在同一个事务中，多次读取同一数据时，由于其他事务的修改并提交，导致读取结果不一致:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;事务 A：在一个事务中需要两次读取 id = 1 的余额&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务 B：在事务 A 执行两次读取期间修改并提交数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要解决“不可重复读”问题, 需要将事务隔离级别提升到 &lt;code&gt;可重复读&lt;/code&gt; 或更高的 &lt;code&gt;序列化&lt;/code&gt; 级别, 这两个级别实行默认一致性读 MVCC 来避免“不可重复读“问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;可重复读&lt;/code&gt;隔离级别下, 读取数据操作&lt;strong&gt;默认使用&lt;/strong&gt;的是一致性读, 即通过 MVCC 机制读取数据的快照, 注意默认不是加锁读取&lt;/li&gt;
&lt;li&gt;当然也可以使用 &lt;code&gt;Select ... LOCK IN SHARE MODE&lt;/code&gt; 为某行添加共享s锁, 直到当前事务结束, 这样也可以防止读取的时候数据被其他事务修改,&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;x锁和 s锁是互斥的, 也就是说 当事务 A 获得某行记录的 s锁后, 其他事务想要修改该行记录, 在尝试获取 x 锁的阶段就会阻塞&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务 A：在一个事务中需要两次读取 id = 1 的余额&lt;/li&gt;
&lt;li&gt;事务 B：在事务 A 执行期间修改并提交数据&lt;/li&gt;
&lt;li&gt;隔离级别：设置为“可重复读”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;执行过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;事务 A 开始&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行 SELECT balance FROM account WHERE id = 1;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结果：balance = 100&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据库记录事务 A 的时间点（通过 MVCC）&lt;strong&gt;或&lt;/strong&gt;对 id = 1 的行加共享锁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务 B 开始&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行 UPDATE account SET balance = 200 WHERE id = 1;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1 如果使用锁：事务 B 被阻塞，直到事务 A 结束&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2 如果使用 MVCC：事务 B 可以提交，更新 balance = 200，但事务 A 仍读取旧版本（快照）数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务 A 再次读取&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再次执行 SELECT balance FROM account WHERE id = 1;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结果：balance = 100（无论事务 B 是否提交，事务 A 读取的是一致的旧版本数据）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务 A 结束&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务 A 提交或回滚后，锁（如果有）释放，或快照失效&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后续事务读取到的可能是 balance = 200&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结果：事务 A 在整个过程中两次读取的结果都是 100, 避免了不可重复读, 但现在仍存在“幻读” 问题&lt;/p&gt;
&lt;h3 id=&#34;23-幻读&#34;&gt;2.3. 幻读&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;可重复读&lt;/code&gt; 解决了“不可重复读”, 但没有解决“幻读”问题, 幻读是指事务读取一个范围的数据时, 另一个事务插入或删除行, 导致再次读取范围时结果不一致 例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务 A：SELECT * FROM account WHERE balance &amp;gt; 50;（返回 1 行）&lt;/li&gt;
&lt;li&gt;事务 B：INSERT INTO account (id, balance) VALUES (2, 60); 并提交&lt;/li&gt;
&lt;li&gt;事务 A 再次执行相同查询，可能返回 2 行（幻读）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面我们说的是数据库上的定义, MySQL 的 InnoDB 引擎在 &lt;code&gt;可重复读&lt;/code&gt; 级别下, 通过 多版本并发控制 MVCC 和 Next-Key 锁, 在一定程度上解决了幻读问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“幻读”是指一个事务在多次读取某个范围的数据时, 由于另一个事务插入或删除了数据并提交, 导致前后两次读取的结果集不一致（多了或少了行）, 它与“不可重复读”的区别在于, &lt;strong&gt;幻读涉及范围查询的结果集变化&lt;/strong&gt;, 而&lt;strong&gt;不可重复读针对单行数据的修改&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;情况 1：事务 A 使用快照读（普通 SELECT）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事务 A 执行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;START&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TRANSACTION&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; users &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; age &lt;span style=&#34;color:#66d9ef&#34;&gt;BETWEEN&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;40&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;-- 快照读
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结果：id=1, age=20 和 id=3, age=30&lt;/p&gt;
&lt;p&gt;机制：MVCC 创建一致性读视图，事务 A 只看到开始时的快照，不加锁&lt;/p&gt;
&lt;p&gt;事务 B 插入数据, 执行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;START&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TRANSACTION&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;INSERT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INTO&lt;/span&gt; users (id, age) &lt;span style=&#34;color:#66d9ef&#34;&gt;VALUES&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;25&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;COMMIT&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结果：插入成功，表数据变为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;id | age
1  | 20
2  | 25
3  | 30
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;事务 A 再次查询, 执行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; users &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; age &lt;span style=&#34;color:#66d9ef&#34;&gt;BETWEEN&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;40&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;-- 快照读
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结果：仍是 id=1, age=20 和 id=3, age=30&lt;/p&gt;
&lt;p&gt;原因：MVCC 保证快照一致性，不受事务 B 影响，幻读被避免&lt;/p&gt;
&lt;p&gt;结论：快照读通过 MVCC 避免幻读，但不加锁，事务 B 可以插入&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;情况 2：事务 A 从一开始使用 Next-Key 锁（当前读）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事务 A 开始并使用当前读&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;START&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TRANSACTION&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; users &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; age &lt;span style=&#34;color:#66d9ef&#34;&gt;BETWEEN&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;40&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FOR&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;-- 当前读
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结果：id=1, age=20 和 id=3, age=30&lt;/p&gt;
&lt;p&gt;机制：Next-Key 锁触发，锁定 age 在 10 到 40 的范围：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;记录锁：age=20 和 age=30&lt;/li&gt;
&lt;li&gt;间隙锁：(负无穷, 20)、(20, 30)、(30, 正无穷)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事务 B 尝试插入&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;INSERT INTO users (id, age) VALUES (2, 25);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果：被阻塞，因为 age=25 落在间隙 (20, 30) 中，而该间隙已被锁定。&lt;/p&gt;
&lt;p&gt;事务 A 再次查询&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SELECT * FROM users WHERE age BETWEEN 10 AND 40 FOR UPDATE; -- 当前读
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果：仍是 id=1, age=20 和 id=3, age=30&lt;/p&gt;
&lt;p&gt;原因：事务 B 的插入被阻止，数据未改变&lt;/p&gt;
&lt;p&gt;事务 A 提交&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;COMMIT;&lt;/li&gt;
&lt;li&gt;事务 B 解除阻塞，插入成功&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结论：事务 A 从一开始使用 Next-Key 锁，完全避免了幻读，因为事务 B 无法在事务 A 执行期间插入新记录&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;情况 3：事务 A 在第二次查询时使用当前读&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事务 A 开始 执行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;START&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TRANSACTION&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; users &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; age &lt;span style=&#34;color:#66d9ef&#34;&gt;BETWEEN&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;40&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;-- 快照读
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结果：id=1, age=20 和 id=3, age=30&lt;/p&gt;
&lt;p&gt;事务 B 插入数据执行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;INSERT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INTO&lt;/span&gt; users (id, age) &lt;span style=&#34;color:#66d9ef&#34;&gt;VALUES&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;25&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;COMMIT&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;事务 A 再次查询（当前读）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; users &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; age &lt;span style=&#34;color:#66d9ef&#34;&gt;BETWEEN&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;40&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FOR&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;-- 当前读
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结果：id=1, age=20、id=2, age=25 和 id=3, age=30&lt;/p&gt;
&lt;p&gt;机制：当前读读取最新提交的数据，看到事务 B 的插入。Next-Key 锁在此触发，但因插入已完成，无法阻止已存在的数据被读取&lt;/p&gt;
&lt;p&gt;结论：当前读会看到新数据，可能出现逻辑上的幻读（与第一次快照读不一致）&lt;/p&gt;
&lt;h2 id=&#34;3-事务&#34;&gt;3. 事务&lt;/h2&gt;
&lt;h3 id=&#34;31-事务的概念&#34;&gt;3.1. 事务的概念&lt;/h3&gt;
&lt;p&gt;事务是一组要么全部成功，要么全部失败的数据库操作，保证数据的一致性。&lt;/p&gt;
&lt;p&gt;假设你要从 A 账户转 100 元到 B 账户，这个过程涉及两个操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从 A 账户扣 100 元&lt;/li&gt;
&lt;li&gt;给 B 账户加 100 元&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果第一步执行了，但第二步失败了，就会导致 A 的钱少了，但 B 没收到钱，这导致了数据一致性问题。事务可以防止这种情况。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;START TRANSACTION;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 从 A 账户扣 100 元
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; accounts &lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; balance &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; balance &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;A&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 给 B 账户加 100 元
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; accounts &lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; balance &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; balance &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;B&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;COMMIT;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果在执行过程中出现错误（比如 B 账户不存在），可以执行回滚，撤销已经执行的操作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;拓展:&lt;/strong&gt; 在 MySQL（InnoDB 存储引擎）中，单个 DML 语句（INSERT, UPDATE, DELETE）本身就是一个事务，如果 &lt;code&gt;AUTOCOMMIT&lt;/code&gt; 处于默认开启状态，它会自动提交，不需要手动 &lt;code&gt;COMMIT&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在数据修改操作（Update、Delete、Insert）中, MySQL InnoDB 会&lt;strong&gt;自动&lt;/strong&gt;对受影响的行加上 x 锁, 事务提交的时候(语句执行完成), x锁会被自动释放。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;后端开发:&lt;/strong&gt; 在 Spring Data JPA 中，事务管理是由 Spring 的事务管理器（通常是 &lt;code&gt;@Transactional&lt;/code&gt; 注解）来控制的，自动回滚行为也由 Spring 决定。Spring 默认会在遇到 &lt;strong&gt;运行时异常（RuntimeException 及其子类）&lt;/strong&gt; 或 &lt;strong&gt;错误（Error）&lt;/strong&gt; 时自动回滚事务。&lt;/p&gt;
&lt;p&gt;如果在事务方法内部捕获了异常，并没有将异常抛出到事务管理器，那么 Spring 不会感知到异常，从而事务不会自动回滚。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Transactional&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;updateSomeData&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 一些数据库操作&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 可能抛出异常&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt; (Exception e) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 捕获异常后不重新抛出，事务将按正常流程提交&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;32-事务不是导致错误的原因而是处理错误的机制&#34;&gt;3.2. 事务不是导致错误的原因，而是处理错误的机制&lt;/h3&gt;
&lt;p&gt;连接类错误, 语法错误, 系统资源相关错误, 数据完整性和约束错误, 事务和锁相关错误, 前几种没什么好说的, 看一下最后两种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;违反完整性约束的错误: 数据库自身的机制, 比如：主键重复、外键不存在、唯一约束冲突、&lt;code&gt;CHECK&lt;/code&gt; 约束失败等&lt;/li&gt;
&lt;li&gt;事务和锁相关错误: 在事务操作中遇到死锁或锁等待等问题
&lt;ul&gt;
&lt;li&gt;两个或多个事务在等待对方持有的资源而形成循环依赖，导致系统检测到死锁。&lt;/li&gt;
&lt;li&gt;事务等待获取资源的时间超出了设定的超时时间，可能需要检查当前事务的锁竞争情况&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;事务不是导致错误的原因，而是处理错误的机制:&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;strong&gt;情况&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;数据库是否报错？&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;事务是否回滚？&lt;/strong&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;主键冲突&lt;/td&gt;
          &lt;td&gt;✅ 报错&lt;/td&gt;
          &lt;td&gt;✅ 回滚（事务开启时）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;外键约束失败&lt;/td&gt;
          &lt;td&gt;✅ 报错&lt;/td&gt;
          &lt;td&gt;✅ 回滚（事务开启时）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;唯一约束失败&lt;/td&gt;
          &lt;td&gt;✅ 报错&lt;/td&gt;
          &lt;td&gt;✅ 回滚（事务开启时）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;业务逻辑错误（如负余额）&lt;/td&gt;
          &lt;td&gt;✅ 报错&lt;/td&gt;
          &lt;td&gt;✅ 回滚（事务开启时）&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ol&gt;
&lt;li&gt;没开启事务时, 每条 SQL 都是独立提交的, 报错不会回滚之前的操作&lt;/li&gt;
&lt;li&gt;事务不会主动报错，报错的原因是 SQL 语句违反数据库的完整性约束&lt;/li&gt;
&lt;li&gt;事务的作用是确保错误发生时，数据不会进入不一致的状态, 事务只是处理数据库错误的工具, 并不是开启事务就万事大吉了&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;33-事务的特性&#34;&gt;3.3. 事务的特性&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;原子性（Atomicity）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务是一个不可分割的最小操作单元，要么全部执行成功，要么全部回滚&lt;/li&gt;
&lt;li&gt;以转账场景为例，一个账户的余额减少，另一个账户的余额增加，这两个操作一定是同时成功或者同时失败的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;一致性（Consistency）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务执行前后，数据库必须保持一致性状态，即不会违反数据库的完整性约束&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;隔离性（Isolation）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并发事务互不影响，一个事务未提交前，其他事务无法看到其变化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;持久性（Durability）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务提交后，其修改的数据会被永久保存，即使系统崩溃也不会丢失&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;一致性并不是事务本身的固有属性, 而更像是一种外在要求,&lt;/strong&gt; 不难发现其他三个都是实打实的特征, 唯独一致性, 无法理解, 这里的一致性更像是一种外在要求, 而不是事务本身的固有的属性, 即是一种需要依赖业务层逻辑来实现的状态,&lt;/p&gt;
&lt;p&gt;举个不恰当的例子, 我们说一个苹果, 苹果是圆的, 苹果可以为我们提供维生素C, 这都是苹果的特征, 可是你却说, 苹果也有生吃性, 苹果必须生吃才能最大化的提供营养价值, WTF? 生不生吃苹果取决于个人啊, 这怎么能是苹果的特性呢?&lt;/p&gt;
&lt;p&gt;同理, 数据库是不是保持一致性, 这取决于业务逻辑啊, 比如需要结合锁来实现, 什么悲观锁, 乐观锁, 这怎么能是事务的特性呢?&lt;/p&gt;
&lt;h2 id=&#34;4-数据一致性问题&#34;&gt;4. 数据一致性问题&lt;/h2&gt;
&lt;h3 id=&#34;41-直接修改操作---隐式-x-锁&#34;&gt;4.1. 直接修改操作 - 隐式 x 锁&lt;/h3&gt;
&lt;p&gt;比如常见的转账例子多个人给同一个账户转 100 块钱,  系统可能会有下面的命令:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; account &lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; balance &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; balance &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; account_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;002&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;高并发状态下, A事务读取到此时账户余额为 100, B事务 也读取到账户余额为 100,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A 事务: 余额 = 100 + 100 = 200,&lt;/li&gt;
&lt;li&gt;B 事务:  余额 = 100 + 100 = 200&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后账户余额仅为 200 而不是 300, 导致数据一致性问题, 因为 InnoDB 会在执行 UPDATE 时对目标行加上排它锁（X 锁）, 从而确保这些操作是串行化的,&lt;/p&gt;
&lt;p&gt;好像是告诉事务, 你想更新 &lt;code&gt;account_id = 002&lt;/code&gt; 的数据? 行, 但请先获得这行数据的 X 锁, 所以不可能会有两个事务同时对同一行执行 UPDATE 操作, 也就是说使用单条 UPDATE 语句时, 不会出现多个事务都获取到相同 balance 的情况, 因为数据修改操作都是串行化的,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在数据修改操作（Update、Delete、Insert）中, 事务会先尝试获得受影响行的 X 锁, 若得到, 才能进行更新, 否则只能等待, 不要忘了单个语句, 也默认属于一个事务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;42-检查--修改操作----显式-x锁-悲观锁-或乐观锁&#34;&gt;4.2. 检查 + 修改操作 -  显式 x锁 (悲观锁) 或乐观锁&lt;/h3&gt;
&lt;p&gt;这种属于多个事务中基于过时数据进行判断后再写入更新的场景, 读取数据与更新操作之间缺乏必要的锁机制保护, 导致多个事务基于同一份数据进行判断并更新, 从而引发数据不一致,&lt;/p&gt;
&lt;p&gt;上面的例子过于简化了, 实际系统肯定不会直接给账户加钱, 还有很多考虑, 比如检查收账人是否存在, 检查转账人的余额是不是足够, 然后进行扣款,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤 1：同时读取余额&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务 A 和事务 B 同时对转账人账户执行查询操作，读取到余额都为 100 元&lt;/li&gt;
&lt;li&gt;此时，如果没有加锁（如 &lt;code&gt;FOR UPDATE&lt;/code&gt;），两个事务都基于相同的旧数据做判断&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;步骤 2：判断余额充足&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务 A 判断：100 元 &amp;gt;= 转账金额 80 元，认为余额足够&lt;/li&gt;
&lt;li&gt;事务 B 同样判断：100 元 &amp;gt;= 转账金额 60 元，也认为余额足够&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;步骤 3：分别执行扣款&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务 A 扣款 80 元，更新余额为 20 元&lt;/li&gt;
&lt;li&gt;事务 B 扣款 80 元，同样在自己的事务中基于最初读取到的 100 元执行更新，更新余额为 40 元&lt;/li&gt;
&lt;li&gt;最终两个事务都成功提交，导致余额可能是40, 也可能是20, 也可能是100 - 80 - 60 = -40, 导致余额出现问题（负数或不一致）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解决办法1: 悲观锁&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;BEGIN;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; balance &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; accounts &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FOR&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;-- 加锁
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 判断余额是否充足, 通过业务代码实现, SQL 无法实现逻辑判断
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; accounts &lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; balance &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; balance &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;COMMIT;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样可以确保在一个事务完成之前，其他事务必须等待，避免同时读取同一份数据进行判断。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决办法2: 乐观锁&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;BEGIN;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; balance, version &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; accounts &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 判断余额是否充足, 通过业务代码实现, SQL 无法实现逻辑判断
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; accounts &lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; balance &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; balance &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;, version &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; version &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; version &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 判断 UPDATE 是否成功, 否则重试或抛出异常返回给客户端执行失败, 通过业务代码实现
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;COMMIT;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;43-多表操作---事务原子性&#34;&gt;4.3. 多表操作 - 事务原子性&lt;/h3&gt;
&lt;p&gt;除此之外还要确保转账人的账户 -100, 收款人的账户 +100, 不能出现后者操作失败了, 导致收款人账户余额没变, 转账人账户的钱却少了 100, 这也是属于数据不一致,&lt;/p&gt;
&lt;p&gt;这种很简单, 把更新两张表的语句放到同一个事务里就行了, 因为可以利用事务的回滚保证, 若有一个操作失败, 则同时都失败,&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>数据库表设计 悲观锁/乐观锁 Redis 高并发场景实践</title>
      <link>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/006-%E9%AB%98%E5%B9%B6%E5%8F%91%E7%82%B9%E8%B5%9E/</link>
      <pubDate>Mon, 17 Feb 2025 19:20:35 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/006-%E9%AB%98%E5%B9%B6%E5%8F%91%E7%82%B9%E8%B5%9E/</guid>
      <description>&lt;h2 id=&#34;1-典型设计&#34;&gt;1. 典型设计&lt;/h2&gt;
&lt;p&gt;一个帖子系统, 用户可以发帖, 点赞帖子, 给帖子发表评论, 点赞评论, 回复评论&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 用户表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;users&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AUTO_INCREMENT&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    username &lt;span style=&#34;color:#66d9ef&#34;&gt;VARCHAR&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户名&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    email &lt;span style=&#34;color:#66d9ef&#34;&gt;VARCHAR&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;邮箱&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    password_hash &lt;span style=&#34;color:#66d9ef&#34;&gt;VARCHAR&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;255&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;密码哈希&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    created_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;创建时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    updated_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;更新时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;UNIQUE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_username&lt;/span&gt; (username),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;UNIQUE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_email&lt;/span&gt; (email)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户表&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 帖子表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;posts&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AUTO_INCREMENT&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;帖子ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    user_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;作者ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    title &lt;span style=&#34;color:#66d9ef&#34;&gt;VARCHAR&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;标题&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    content &lt;span style=&#34;color:#66d9ef&#34;&gt;TEXT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;内容&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    likes_count &lt;span style=&#34;color:#66d9ef&#34;&gt;INT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;点赞数&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    comments_count &lt;span style=&#34;color:#66d9ef&#34;&gt;INT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论数&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    status &lt;span style=&#34;color:#66d9ef&#34;&gt;TINYINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;状态:1-正常,2-已删除&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    created_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;创建时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    updated_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;更新时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    version &lt;span style=&#34;color:#66d9ef&#34;&gt;INT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;乐观锁版本号&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_user_id&lt;/span&gt; (user_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户ID索引,用于查询用户的帖子列表&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_created_at&lt;/span&gt; (created_at) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;创建时间索引,用于按时间排序&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;帖子表&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 帖子点赞表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;post_likes&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AUTO_INCREMENT&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;点赞ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    post_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;帖子ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    user_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    created_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;创建时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;UNIQUE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_post_user&lt;/span&gt; (post_id, user_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;帖子用户联合唯一索引,防止重复点赞&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_user_id&lt;/span&gt; (user_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户ID索引,用于查询用户的点赞列表&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;帖子点赞表&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 评论表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;comments&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AUTO_INCREMENT&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    post_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;帖子ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    user_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论者ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    parent_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;父评论ID,回复评论时使用&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    content &lt;span style=&#34;color:#66d9ef&#34;&gt;TEXT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论内容&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    likes_count &lt;span style=&#34;color:#66d9ef&#34;&gt;INT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;点赞数&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    replies_count &lt;span style=&#34;color:#66d9ef&#34;&gt;INT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;回复数&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    status &lt;span style=&#34;color:#66d9ef&#34;&gt;TINYINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;状态:1-正常,2-已删除&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    created_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;创建时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    updated_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;更新时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    version &lt;span style=&#34;color:#66d9ef&#34;&gt;INT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;乐观锁版本号&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_post_id&lt;/span&gt; (post_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;帖子ID索引,用于查询帖子的评论列表&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_user_id&lt;/span&gt; (user_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户ID索引,用于查询用户的评论列表&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_parent_id&lt;/span&gt; (parent_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;父评论ID索引,用于查询评论的回复列表&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论表&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 评论点赞表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;comment_likes&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AUTO_INCREMENT&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;点赞ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    comment_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    user_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    created_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;创建时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;UNIQUE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_comment_user&lt;/span&gt; (comment_id, user_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论用户联合唯一索引,防止重复点赞&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_user_id&lt;/span&gt; (user_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户ID索引,用于查询用户的点赞列表&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论点赞表&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;2-帖子中应该放点赞数和回复数吗&#34;&gt;2. 帖子中应该放点赞数和回复数吗&lt;/h2&gt;
&lt;h3 id=&#34;21-数据一致性问题---事务&#34;&gt;2.1. 数据一致性问题 - 事务&lt;/h3&gt;
&lt;p&gt;优点是读取性能好, 减少数据库压力 , 显示帖子列表时无需连表统计, 缺点是会有&lt;strong&gt;写入一致性问题和并发问题&lt;/strong&gt;, 假设用户点赞一个帖子，我们需要做两件事：&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-典型设计&#34;&gt;1. 典型设计&lt;/h2&gt;
&lt;p&gt;一个帖子系统, 用户可以发帖, 点赞帖子, 给帖子发表评论, 点赞评论, 回复评论&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 用户表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;users&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AUTO_INCREMENT&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    username &lt;span style=&#34;color:#66d9ef&#34;&gt;VARCHAR&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户名&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    email &lt;span style=&#34;color:#66d9ef&#34;&gt;VARCHAR&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;邮箱&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    password_hash &lt;span style=&#34;color:#66d9ef&#34;&gt;VARCHAR&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;255&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;密码哈希&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    created_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;创建时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    updated_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;更新时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;UNIQUE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_username&lt;/span&gt; (username),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;UNIQUE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_email&lt;/span&gt; (email)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户表&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 帖子表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;posts&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AUTO_INCREMENT&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;帖子ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    user_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;作者ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    title &lt;span style=&#34;color:#66d9ef&#34;&gt;VARCHAR&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;标题&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    content &lt;span style=&#34;color:#66d9ef&#34;&gt;TEXT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;内容&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    likes_count &lt;span style=&#34;color:#66d9ef&#34;&gt;INT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;点赞数&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    comments_count &lt;span style=&#34;color:#66d9ef&#34;&gt;INT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论数&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    status &lt;span style=&#34;color:#66d9ef&#34;&gt;TINYINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;状态:1-正常,2-已删除&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    created_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;创建时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    updated_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;更新时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    version &lt;span style=&#34;color:#66d9ef&#34;&gt;INT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;乐观锁版本号&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_user_id&lt;/span&gt; (user_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户ID索引,用于查询用户的帖子列表&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_created_at&lt;/span&gt; (created_at) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;创建时间索引,用于按时间排序&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;帖子表&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 帖子点赞表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;post_likes&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AUTO_INCREMENT&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;点赞ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    post_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;帖子ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    user_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    created_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;创建时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;UNIQUE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_post_user&lt;/span&gt; (post_id, user_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;帖子用户联合唯一索引,防止重复点赞&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_user_id&lt;/span&gt; (user_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户ID索引,用于查询用户的点赞列表&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;帖子点赞表&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 评论表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;comments&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AUTO_INCREMENT&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    post_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;帖子ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    user_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论者ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    parent_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;父评论ID,回复评论时使用&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    content &lt;span style=&#34;color:#66d9ef&#34;&gt;TEXT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论内容&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    likes_count &lt;span style=&#34;color:#66d9ef&#34;&gt;INT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;点赞数&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    replies_count &lt;span style=&#34;color:#66d9ef&#34;&gt;INT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;回复数&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    status &lt;span style=&#34;color:#66d9ef&#34;&gt;TINYINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;状态:1-正常,2-已删除&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    created_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;创建时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    updated_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;更新时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    version &lt;span style=&#34;color:#66d9ef&#34;&gt;INT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;乐观锁版本号&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_post_id&lt;/span&gt; (post_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;帖子ID索引,用于查询帖子的评论列表&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_user_id&lt;/span&gt; (user_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户ID索引,用于查询用户的评论列表&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_parent_id&lt;/span&gt; (parent_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;父评论ID索引,用于查询评论的回复列表&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论表&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 评论点赞表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;comment_likes&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AUTO_INCREMENT&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;点赞ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    comment_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    user_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    created_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;创建时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;UNIQUE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_comment_user&lt;/span&gt; (comment_id, user_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论用户联合唯一索引,防止重复点赞&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_user_id&lt;/span&gt; (user_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户ID索引,用于查询用户的点赞列表&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论点赞表&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;2-帖子中应该放点赞数和回复数吗&#34;&gt;2. 帖子中应该放点赞数和回复数吗&lt;/h2&gt;
&lt;h3 id=&#34;21-数据一致性问题---事务&#34;&gt;2.1. 数据一致性问题 - 事务&lt;/h3&gt;
&lt;p&gt;优点是读取性能好, 减少数据库压力 , 显示帖子列表时无需连表统计, 缺点是会有&lt;strong&gt;写入一致性问题和并发问题&lt;/strong&gt;, 假设用户点赞一个帖子，我们需要做两件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 post_likes 表插入一条点赞记录&lt;/li&gt;
&lt;li&gt;在 posts 表把这个帖子的 likes_count 加1&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 第一步：插入点赞记录成功
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;INSERT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INTO&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;post_likes&lt;/span&gt; (post_id, user_id) &lt;span style=&#34;color:#66d9ef&#34;&gt;VALUES&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 第二步：更新帖子点赞数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 假设在这时候数据库突然崩溃了或者网络中断了
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; posts &lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; likes_count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; likes_count &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这就导致了数据不一致: post_likes 表显示用户点赞了, 但是 posts 表的点赞数没有增加, 我们可以通过加入事务来解决:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;BEGIN&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;INSERT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INTO&lt;/span&gt; post_likes (post_id, user_id) &lt;span style=&#34;color:#66d9ef&#34;&gt;VALUES&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; posts &lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; likes_count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; likes_count &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;COMMIT&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过使用事务, 若 &lt;code&gt;BEGIN ... COMMIT&lt;/code&gt; 中的一个语句执行失败, 之前所有的操作都不会成功, 这就解决了数据一致性问题&lt;/p&gt;
&lt;h3 id=&#34;22-并发问题---x锁&#34;&gt;2.2. 并发问题 - X锁&lt;/h3&gt;
&lt;p&gt;下面先说一下一个常见的&lt;strong&gt;误解&lt;/strong&gt;, 假如帖子当前有100个赞，两个用户 A 和 B 同时点赞:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 用户A的操作
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; posts &lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; likes_count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; likes_count &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 用户B的操作(同时进行, 则都会读取到 likes_count = 100)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; posts &lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; likes_count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; likes_count &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;有人会想到可能会出现下面问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A读取到 likes_count = 100, B读取到 likes_count = 100&lt;/li&gt;
&lt;li&gt;A更新 likes_count = 101, B 更新 likes_count = 101&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最终结果是 likes_count = 101，但实际上应该是102, 其实并不会出现这个问题, 这里需要指出两个关于事务和锁事实:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 MySQL 中，默认情况下 &lt;code&gt;autocommit&lt;/code&gt; 是开启的（即 &lt;code&gt;autocommit=1&lt;/code&gt;）。在这个模式下，每条单独的 SQL 语句 (增删改, &lt;strong&gt;除了查&lt;/strong&gt;) 都会被当作一个独立的事务来执行。&lt;code&gt;SELECT&lt;/code&gt; 语句通常不涉及事务（除非是 &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt; 这种需要锁的语句）&lt;/li&gt;
&lt;li&gt;在数据修改操作（Update、Delete、Insert）中, InnoDB 会&lt;strong&gt;自动&lt;/strong&gt;对受影响的行加上行级的&lt;strong&gt;排它锁&lt;/strong&gt;（X 锁）&lt;/li&gt;
&lt;li&gt;锁只会在事务 commit 或者 rollback 的时候自动被释放, 这也是为什么锁必须配合事务使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据第二条事实, 我们知道当执行 &lt;code&gt;UPDATE posts SET likes_count = likes_count + 1 WHERE id = 1;&lt;/code&gt; 时, MySQL 会自动为 id=1 的行加上一个 x 锁, 意味着在这个锁没有被释放前, 其它任何事务都不可以修改这行数据, 因为想要修改某行数据必须要获得这行数据的 x 锁 (MySQL 默认行为), 而这行数据的 x锁还没被释放,&lt;/p&gt;
&lt;p&gt;下面使用如下表格展示用户A和用户B并发执行更新时的操作流程, 假设初始状态：&lt;code&gt;posts&lt;/code&gt; 表中 id=1 的记录 &lt;code&gt;likes_count=100&lt;/code&gt;:&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;时间 (T)&lt;/th&gt;
          &lt;th&gt;用户A的操作&lt;/th&gt;
          &lt;th&gt;用户B的操作&lt;/th&gt;
          &lt;th&gt;备注说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;T₀&lt;/td&gt;
          &lt;td&gt;——&lt;/td&gt;
          &lt;td&gt;——&lt;/td&gt;
          &lt;td&gt;初始状态：点赞数 100&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T₁&lt;/td&gt;
          &lt;td&gt;执行 &lt;code&gt;UPDATE ...&lt;/code&gt; 加排他锁并将值由 100 更新为 101&lt;/td&gt;
          &lt;td&gt;——&lt;/td&gt;
          &lt;td&gt;用户A自动获得行锁，其他事务无法修改该行&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T₂&lt;/td&gt;
          &lt;td&gt;——（等待提交或后续操作）&lt;/td&gt;
          &lt;td&gt;尝试执行相同 &lt;code&gt;UPDATE&lt;/code&gt; 语句但因行被锁，进入等待状态&lt;/td&gt;
          &lt;td&gt;用户B操作被阻塞，等待用户A释放锁&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T₃&lt;/td&gt;
          &lt;td&gt;提交事务，释放锁&lt;/td&gt;
          &lt;td&gt;——&lt;/td&gt;
          &lt;td&gt;用户A提交后，行更新为 101，释放了锁&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T₄&lt;/td&gt;
          &lt;td&gt;——&lt;/td&gt;
          &lt;td&gt;获得锁后执行 &lt;code&gt;UPDATE ...&lt;/code&gt; 将值由 101 更新为 102&lt;/td&gt;
          &lt;td&gt;用户B操作获得锁，基于最新数据进行更新&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T₅&lt;/td&gt;
          &lt;td&gt;——&lt;/td&gt;
          &lt;td&gt;提交事务&lt;/td&gt;
          &lt;td&gt;最终结果：点赞数102（累加 2）&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可以看出, 并不需要手动加x锁, 只需要使用事务保证操作的原子性就好了, 因为UPDATE 会自动获得 x 锁, 不必担心并发问题, 如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;BEGIN;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;-- 插入点赞记录
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;INSERT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INTO&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;post_likes&lt;/span&gt; (post_id, user_id) &lt;span style=&#34;color:#66d9ef&#34;&gt;VALUES&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;-- 更新点赞数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; posts &lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; likes_count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; likes_count &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;COMMIT;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;至于防止用户重复点赞, 我们可以在 &lt;code&gt;(post_id, user_id)&lt;/code&gt; 上建立索引, 若相同数据插入, &lt;code&gt;INSERT INTO post_likes (post_id, user_id) VALUES (1, 1);&lt;/code&gt; 必然失败, 导致业务逻辑抛出异常, 下面的更新操作也不会发生, 然后我们捕获异常, 告诉用户点赞重复即可,&lt;/p&gt;
&lt;h3 id=&#34;23-事务--悲观锁&#34;&gt;2.3. 事务 + 悲观锁&lt;/h3&gt;
&lt;p&gt;既然每条修改语句都会先尝试获取排它锁, 然后才能修改数据, 为什么还会有并发问题呢? 上面的情况很简单, 所以没有问题, 我们来考虑一个复杂一些的问题,&lt;/p&gt;
&lt;p&gt;假设有一个库存系统，需要先判断库存是否充足，再扣减库存。如果不使用显式加锁，可能会出现多个事务同时读取相同库存数量，然后都判断库存足够，导致库存扣减错误。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;时间 (T)&lt;/th&gt;
          &lt;th&gt;用户A的操作&lt;/th&gt;
          &lt;th&gt;用户B的操作&lt;/th&gt;
          &lt;th&gt;备注说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;T₀&lt;/td&gt;
          &lt;td&gt;——&lt;/td&gt;
          &lt;td&gt;——&lt;/td&gt;
          &lt;td&gt;初始状态：库存 &lt;code&gt;stock = 10&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T₁&lt;/td&gt;
          &lt;td&gt;查询库存,  stock = 10&lt;/td&gt;
          &lt;td&gt;——&lt;/td&gt;
          &lt;td&gt;用户A读取库存，未加锁（普通 SELECT）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T₂&lt;/td&gt;
          &lt;td&gt;——&lt;/td&gt;
          &lt;td&gt;查询库存,  &lt;code&gt;stock = 10&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;用户B也读取库存，双方看到的都是相同的初始库存&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T₃&lt;/td&gt;
          &lt;td&gt;库存足够10 ≥ 8, 加 X 锁, 更新库存 10 - 8 = 2,&lt;/td&gt;
          &lt;td&gt;——&lt;/td&gt;
          &lt;td&gt;用户A更新时加锁，库存实际变为 2&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T₄&lt;/td&gt;
          &lt;td&gt;——&lt;/td&gt;
          &lt;td&gt;库存足够10 ≥ 6, 尝试更新库存数据, 无法获取 x锁, 尝试更新失败&lt;/td&gt;
          &lt;td&gt;用户B的 UPDATE 操作因被 A 的锁阻塞，等待 A 提交&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T₅&lt;/td&gt;
          &lt;td&gt;提交事务，释放锁&lt;/td&gt;
          &lt;td&gt;——&lt;/td&gt;
          &lt;td&gt;用户A提交后，锁释放，此时数据库中库存为 2&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T₆&lt;/td&gt;
          &lt;td&gt;——&lt;/td&gt;
          &lt;td&gt;获得x锁后执行 UPDATE 操作 10 - 6 = 4,&lt;/td&gt;
          &lt;td&gt;用户B执行更新时，虽然其早先读取到库存为 10，但更新操作是基于当前实际库存（2）进行扣减，即 2 - 6 = -4&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T₇&lt;/td&gt;
          &lt;td&gt;——&lt;/td&gt;
          &lt;td&gt;提交事务&lt;/td&gt;
          &lt;td&gt;最终库存变为 -4，出现库存不足但仍被扣减的问题&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这种问题通常需要使用悲观锁（例如 &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt;）, 即使用显式加锁可以解决这个问题：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 开启事务保证多个操作的原子性(数据一致性)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;BEGIN&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;-- 手工显式加x锁，防止其他事务在判断和扣减期间修改库存
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; stock &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; products &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; product_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FOR&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;-- 根据读取的库存进行判断
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;IF&lt;/span&gt; (stock &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;THEN&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; products &lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; stock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; stock &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; product_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;END&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;IF&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;COMMIT&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里我们在事务开始前显式添加了 x锁, 这意味着若其它事务想修改 &lt;code&gt;product_id = 100&lt;/code&gt; 这行数据, &lt;strong&gt;必须先拿到这一行的 x锁&lt;/strong&gt;, 而此时若事务 A 已经显式拿到了  &lt;code&gt;product_id = 100&lt;/code&gt; 这一行数据的 x锁, 意味着事务 A 不结束, 该锁永远不会被释放, 也就是其它事务永远不可能拿到这行数据的x锁, 也就无法执行下面的流程 (比如: 查询编号为100的商品的剩余, 更新该行数据),&lt;/p&gt;
&lt;p&gt;注意这里添加事务是为了保留显式添加的锁直到整个事务结束,&lt;/p&gt;
&lt;p&gt;可以看出, 使用悲观锁（通过 &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt; 显示加 X 锁）的主要目的就是在执行更新前，确保读取到的数据是最新且不会被其他并发事务修改，从而&lt;strong&gt;保证基于该数据做出的判断是可靠的&lt;/strong&gt;。如果判断通过，再执行更新操作，而这整个过程都在同一个事务内执行，确保了原子性和隔离性，避免数据竞争和不一致的问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;小贴士&lt;/strong&gt;:  &lt;strong&gt;&lt;code&gt;X锁&lt;/code&gt; 的加锁方式有两种&lt;/strong&gt;，第一种是自动加锁，在对数据进行&lt;strong&gt;增删改&lt;/strong&gt;的时候，都会默认加上一个&lt;code&gt;X锁&lt;/code&gt;。还有一种是手工加锁，我们用一个&lt;code&gt;FOR UPDATE&lt;/code&gt;给一行数据加上一个&lt;code&gt;X锁&lt;/code&gt;, &lt;code&gt;X锁&lt;/code&gt;在同一时刻只能被一个事务持有, 其它事务想获得, 必须等待&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;最常见的数据一致性问题就是多步骤其中一个步骤失败引起的, 比如假设你在银行 A 账户有 1000 元，你想转账 200 元到银行 B 账户, 正常情况下 从 A 账户扣除 200 元（余额变成 800）, 向 B 账户增加 200 元（余额变成 1200）, 假设在步骤 1 之后（A 账户变成 800），系统崩溃或网络异常，导致步骤 2 没有执行, 这就导致 A 账户已经减少了 200 元（800），但 B 账户仍然是 1000, 这也是数据一致性问题, 这种数据一致性问题我们可以添加事务 &lt;strong&gt;利用事务的原子性&lt;/strong&gt;来解决,&lt;/p&gt;
&lt;p&gt;数据一致性问题分为好多种, 比如上面用户A, B同时点赞, 导致点赞数丢失的问题, 比如多个人给一个账户转 100 块钱,  A事务读取到此时账户余额为 100, B事务 也读取到账户余额为 100, 所以 A: 余额= 100 + 100 = 200, B事务 也是这样, 最后账户余额仅为 200 而不是 300, 导致数据一致性问题, 这种数据一致性问题可以&lt;strong&gt;通过 x 锁解决&lt;/strong&gt;, 当然 MySQL 数据库默认加上了 x 锁, 我们不必担心&lt;/p&gt;
&lt;p&gt;还有一种是需要判断再进行其他增减操作的, 比如高并发防止&lt;strong&gt;库存超卖&lt;/strong&gt;, 我们需要先判断库存是否有剩余, 再进行扣减, 这个时候就有了两个操作 判断 + 扣除, 这个时候就需要使用悲观锁直接锁定或者使用乐观锁, 需要通过锁机制来确保“判断+扣减”作为一个整体原子操作执行, 通过一个版本号标识数据的状态, 在更新时检查版本是否一致, 如果一致, 说明数据未被其他线程修改, 可以安全更新；如果不一致，说明有并发修改，需要重试或失败处理。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; quantity, &lt;span style=&#34;color:#66d9ef&#34;&gt;version&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; stock &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; product_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1001&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; stock 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; quantity &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; quantity &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;version&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;version&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; product_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1001&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;version&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;3-帖子表放点赞数-高并发点赞-redis--kafka&#34;&gt;3. 帖子表放点赞数 高并发点赞 Redis + Kafka&lt;/h2&gt;
&lt;p&gt;首先看一下易错的实现:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Transactional&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;likePost&lt;/span&gt;(Long postId, Long userId) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String likesUsersKey &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;post:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; postId &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:likes_users&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String likesCountKey &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;post:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; postId &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:likes_count&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 1. 检查是否已点赞, 检查和更新操作分离&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (Boolean.&lt;span style=&#34;color:#a6e22e&#34;&gt;TRUE&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;equals&lt;/span&gt;(redisTemplate.&lt;span style=&#34;color:#a6e22e&#34;&gt;opsForSet&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;isMember&lt;/span&gt;(likesUsersKey, userId))) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 2. Redis 操作：添加用户 ID 到点赞集合 &amp;amp; 计数+1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    redisTemplate.&lt;span style=&#34;color:#a6e22e&#34;&gt;opsForSet&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(likesUsersKey, userId);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    redisTemplate.&lt;span style=&#34;color:#a6e22e&#34;&gt;opsForValue&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;increment&lt;/span&gt;(likesCountKey, 1);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 3. 发送 Kafka 事件 (type=like)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String event &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;like,&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; postId &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; userId;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    kafkaTemplate.&lt;span style=&#34;color:#a6e22e&#34;&gt;send&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;like-topic&amp;#34;&lt;/span&gt;, event);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;初学者可能会认为Redis 服务是一个单线程进程, 所以即使一个用户同时进行两次点赞, 也不会出现数据不一致问题, 因为在:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;redisTemplate.&lt;span style=&#34;color:#a6e22e&#34;&gt;opsForSet&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(likesUsersKey, userId);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这一步就会失败(Set 集合天然唯一性), 自增1也不可能执行, 首先这么理解是不对的, &lt;code&gt;opsForSet().add(...);&lt;/code&gt; 底层调用的是 Redis 的 SADD 命令, 如果添加的成员已经存在于集合中, Redis 不会抛出异常，而是简单地&lt;strong&gt;忽略&lt;/strong&gt;该操作, 所以下面的代码(自增1)会继续执行, 那这就可能导致数据不一致问题:&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;步骤&lt;/th&gt;
          &lt;th&gt;线程A操作&lt;/th&gt;
          &lt;th&gt;线程B操作&lt;/th&gt;
          &lt;th&gt;Redis 中的实际情况&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;isMember(likes_users, 888)&lt;/code&gt; 返回 false&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;likes_users = {}&lt;/code&gt;, &lt;code&gt;likes_count = 0&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;isMember(likes_users, 888)&lt;/code&gt; 返回 false&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;likes_users = {}&lt;/code&gt;, &lt;code&gt;likes_count = 0&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;SADD(likes_users, 888)&lt;/code&gt;，返回 1&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;likes_users = {888}&lt;/code&gt;, &lt;code&gt;likes_count = 0&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;increment(likes_count)&lt;/code&gt;，加 1&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;likes_users = {888}&lt;/code&gt;, &lt;code&gt;likes_count = 1&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;SADD(likes_users, 888)&lt;/code&gt;，返回 0&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;likes_users = {888}&lt;/code&gt;, &lt;code&gt;likes_count = 1&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;6&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;increment(likes_count)&lt;/code&gt;，又加 1&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;likes_users = {888}&lt;/code&gt;, &lt;code&gt;likes_count = 2&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;从最终结果看, Set 中只有一个用户 (888), 但 &lt;code&gt;likes_count&lt;/code&gt; 变成了 2, 这就是「点赞数比实际多」的不一致情况, 要解决这个问题可以利用 Redis 命令本身返回值并在代码中加以判断:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;likePost&lt;/span&gt;(Long postId, Long userId) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String likesUsersKey &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;post:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; postId &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:likes_users&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String likesCountKey &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;post:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; postId &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:likes_count&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// sAddRet 要么是 1（成功加入，不在集合中），要么是 0（已存在，没加入）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Long sAddRet &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; redisTemplate.&lt;span style=&#34;color:#a6e22e&#34;&gt;opsForSet&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(likesUsersKey, userId);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (sAddRet &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; sAddRet &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; 0) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 只有在成功新加了用户的时候才执行加1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        redisTemplate.&lt;span style=&#34;color:#a6e22e&#34;&gt;opsForValue&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;increment&lt;/span&gt;(likesCountKey, 1);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 同时再发Kafka事件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        String event &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;like,&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; postId &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; userId;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        kafkaTemplate.&lt;span style=&#34;color:#a6e22e&#34;&gt;send&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;like-topic&amp;#34;&lt;/span&gt;, event);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样只有在成功加入到集合的时候, 才进行加1操作, 所以解决了上面的问题, 这样虽然可以解决, Redis 遇到多个操作如 检查 + 更新 这种场景的时候, 还是应该考虑&lt;strong&gt;利用分布式锁或者Lua脚本保证操作原子性&lt;/strong&gt;来解决问题,&lt;/p&gt;
&lt;p&gt;除此之外, 可以注意到上面的代码我们省略了 &lt;code&gt;isMember&lt;/code&gt; 判断, 因为我们的实现依赖 &lt;code&gt;SADD&lt;/code&gt; 的返回值来判定是否是第一次点赞,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring 的 &lt;code&gt;@Transactional&lt;/code&gt; 注解默认只对使用了关系型数据库（如 JPA / JDBC）的事务生效, 对于 RedisTemplate 的操作，除非你做了额外的配置（例如启用 Redis 事务支持，或使用了 Lua 脚本实现原子性操作），否则 Redis 并不会因为 Spring 事务回滚而自动回滚, 换句话说，一般情况下，Redis 操作默认是「非事务性」的，Spring 事务并不会对它生效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;4-高并发防止库存超卖&#34;&gt;4. 高并发防止库存超卖&lt;/h2&gt;
&lt;h3 id=&#34;41-redis--lua-脚本&#34;&gt;4.1. Redis + Lua 脚本&lt;/h3&gt;
&lt;p&gt;除了悲观锁和乐观锁, 还可以使用 Redis 来解决这个问题, 首先可能会想到的是利用 Redis 单线程特性, 伪代码如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;deductStock&lt;/span&gt;(String productId, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; amount) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;stock:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; productId;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 1. 检查库存&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Integer stock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; redis.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(key);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (stock &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; stock &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; amount) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 库存不足&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 2. 原子扣减&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Integer newStock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; redis.&lt;span style=&#34;color:#a6e22e&#34;&gt;decrBy&lt;/span&gt;(key, amount);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (newStock &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 0) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 库存不足，手动回滚&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        redis.&lt;span style=&#34;color:#a6e22e&#34;&gt;incrBy&lt;/span&gt;(key, amount);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 扣减成功&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;假设初始库存为 5, 两个线程 T1 和 T2 同时尝试扣减 3 个库存:&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;时间步&lt;/th&gt;
          &lt;th&gt;线程 T1&lt;/th&gt;
          &lt;th&gt;线程 T2&lt;/th&gt;
          &lt;th&gt;Redis 库存&lt;/th&gt;
          &lt;th&gt;备注&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;T1&lt;/td&gt;
          &lt;td&gt;GET 返回 5，检查 5 &amp;gt;= 3&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;T1 检查通过&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T2&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;GET 返回 5，检查 5 &amp;gt;= 3&lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;T2 检查通过&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T3&lt;/td&gt;
          &lt;td&gt;DECRBY 3，返回 2&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;T1 扣减成功，newStock = 2&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T4&lt;/td&gt;
          &lt;td&gt;检查 newStock = 2 &amp;gt;= 0，不回滚&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;T1 完成，库存合法&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T5&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;DECRBY 3，返回 -1&lt;/td&gt;
          &lt;td&gt;-1&lt;/td&gt;
          &lt;td&gt;T2 扣减，newStock = -1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T6&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;检查 newStock = -1 &amp;lt; 0，回滚 3&lt;/td&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;T2 回滚，库存恢复到 2&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;库存最终值：2（T1 扣了 3，T2 扣了又回滚）, 似乎问题解决了, 但实际上这只是表面现象, 问题依然存在:&lt;/p&gt;
&lt;p&gt;虽然 &lt;code&gt;decrBy&lt;/code&gt; 本身是原子的, 但前面的检查（&lt;code&gt;get&lt;/code&gt; 和判断库存是否足够）与扣减之间不是一个原子操作, 当 &lt;code&gt;decrBy&lt;/code&gt; 执行后，如果结果小于 0，则会调用 &lt;code&gt;redis.incrBy&lt;/code&gt; 补偿库存，并返回扣减失败。这样虽然能保证最终库存不会维持在负值，但&lt;strong&gt;在短时间内可能出现库存负值的状态&lt;/strong&gt;，而且多个并发请求可能都进行补偿操作:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这会导致性能问题, 大量线程尝试扣减, 最终只有少数成功, 其他回滚, 浪费资源&lt;/li&gt;
&lt;li&gt;严重的情况是由于网络延迟等原因导致补偿操作不成功, 从而引起实际上的超卖问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以你看, 即使 Redis 是单线程, 所有发送到 Redis 服务器的指令都是一个个串行执行, 依然可能会出现并发问题,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;改进建议&lt;/strong&gt; 为了解决上述问题, 可以使用 Lua 脚本将库存检查和扣减操作封装成一个原子操作, 确保整个过程在 Redis 内部一次性执行, 从而消除检查与扣减之间的时间窗口, 例如, 可以使用如下 Lua 脚本来实现:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;local&lt;/span&gt; stock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; tonumber(redis.call(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;get&amp;#39;&lt;/span&gt;, KEYS[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; stock &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; stock &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; tonumber(ARGV[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]) &lt;span style=&#34;color:#66d9ef&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; redis.call(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;decrby&amp;#39;&lt;/span&gt;, KEYS[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;], ARGV[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;伪代码:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;deductStock&lt;/span&gt;(String productId, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; amount) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;stock:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; productId;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String luaScript &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;local stock = tonumber(redis.call(&amp;#39;GET&amp;#39;, KEYS[1]))\n&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                       &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;local amount = tonumber(ARGV[1])\n&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                       &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;if stock == nil then return -1 end\n&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                       &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;if stock &amp;lt; amount then return -2 end\n&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                       &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;local newStock = stock - amount\n&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                       &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;redis.call(&amp;#39;SET&amp;#39;, KEYS[1], newStock)\n&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                       &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;return newStock&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Lua 脚本在 Redis 内部执行, 效率极高&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Long result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; redis.&lt;span style=&#34;color:#a6e22e&#34;&gt;eval&lt;/span&gt;(luaScript, Collections.&lt;span style=&#34;color:#a6e22e&#34;&gt;singletonList&lt;/span&gt;(key), Collections.&lt;span style=&#34;color:#a6e22e&#34;&gt;singletonList&lt;/span&gt;(String.&lt;span style=&#34;color:#a6e22e&#34;&gt;valueOf&lt;/span&gt;(amount)));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; 0; &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;gt;= 0 表示扣减成功&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt; 虽然这个方案通过补偿操作在逻辑上试图防止超卖，但由于库存检查与扣减操作之间不是原子性的，仍然存在在高并发场景下出现短暂负库存（即“超卖”）的风险, 使用 Lua 脚本或分布式锁来保证整个扣减过程的原子性是更为稳妥的方案&lt;/p&gt;
&lt;h3 id=&#34;42-分布式锁&#34;&gt;4.2. 分布式锁&lt;/h3&gt;
&lt;p&gt;在方案二（Lua 脚本）中, 我们将“检查库存”和“扣减库存”封装成一个原子操作, &lt;strong&gt;完全在 Redis 内部执行&lt;/strong&gt;, 效率很高, 如果业务逻辑复杂, 例如扣减库存后需要异步更新数据库, 可以用 Redis 分布式锁来控制并发&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取锁： 使用 SETNX（Set if Not Exists）加锁：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SET lock:1001 1 EX 10 NX  # 设置锁，10秒过期
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;扣减库存： 获取锁后，检查并扣减库存：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;GET stock:1001
DECRBY stock:1001 2
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;释放锁： 操作完成后删除锁&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;DEL lock:1001
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;伪代码:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;deductStock&lt;/span&gt;(String productId, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; amount) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String lockKey &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;lock:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; productId;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String stockKey &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;stock:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; productId;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 获取分布式锁&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; locked &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; redis.&lt;span style=&#34;color:#a6e22e&#34;&gt;setNX&lt;/span&gt;(lockKey, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, 10);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;locked) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 获取锁失败, 被其他线程占用&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 检查库存&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Integer stock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; redis.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(stockKey);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (stock &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; stock &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; amount) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 扣减库存&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Integer newStock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; redis.&lt;span style=&#34;color:#a6e22e&#34;&gt;decrBy&lt;/span&gt;(stockKey, amount);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (newStock &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 0) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            redis.&lt;span style=&#34;color:#a6e22e&#34;&gt;incrBy&lt;/span&gt;(stockKey, amount); &lt;span style=&#34;color:#75715e&#34;&gt;// 回滚&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 异步更新数据库&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        asyncExecutor.&lt;span style=&#34;color:#a6e22e&#34;&gt;submit&lt;/span&gt;(() &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                updateDatabase(productId, amount);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            } &lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt; (Exception e) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 数据库更新失败，回滚 Redis&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                redis.&lt;span style=&#34;color:#a6e22e&#34;&gt;incrBy&lt;/span&gt;(stockKey, amount);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                log.&lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Database update failed, rolled back stock&amp;#34;&lt;/span&gt;, e);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#66d9ef&#34;&gt;finally&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        redis.&lt;span style=&#34;color:#a6e22e&#34;&gt;del&lt;/span&gt;(lockKey); &lt;span style=&#34;color:#75715e&#34;&gt;// 释放锁&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;43-总结&#34;&gt;4.3. 总结&lt;/h3&gt;
&lt;p&gt;Lua 脚本适用场景: 业务逻辑简单，只涉及 Redis 数据操作, Lua 脚本只能操作 Redis 的数据, 无法直接与外部系统（如数据库、消息队列）交互, 分布式锁适用场景: 库存扣减后需要与外部系统（如数据库）保持一致性&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>
