<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>操作系统 on 为霜的博客</title>
    <link>https://blog.jiyi27.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
    <description>Recent content in 操作系统 on 为霜的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 22 Jan 2025 14:58:10 +0000</lastBuildDate><atom:link href="https://blog.jiyi27.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>虚拟内存</title>
      <link>https://blog.jiyi27.com/posts/cs-basics/008-virtual-memory/</link>
      <pubDate>Wed, 22 Jan 2025 14:58:10 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/cs-basics/008-virtual-memory/</guid>
      <description>&lt;h2 id=&#34;1-virtual-memory&#34;&gt;1. Virtual Memory&lt;/h2&gt;
&lt;p&gt;Virtual memory is a memory management technique that gives applications the impression that they have contiguous working memory (a continuous and complete address space), even though physical memory may be fragmented and some data may be temporarily stored on external disk storage, being swapped between them as needed.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A memory management unit (MMU) is &lt;strong&gt;a computer hardware unit&lt;/strong&gt; that examines all memory references on the memory bus, translating these requests, known as virtual memory addresses, into physical addresses in main memory. &lt;a href=&#34;https://en.wikipedia.org/wiki/Memory_management_unit&#34;&gt;Memory management unit&lt;/a&gt;&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-virtual-memory&#34;&gt;1. Virtual Memory&lt;/h2&gt;
&lt;p&gt;Virtual memory is a memory management technique that gives applications the impression that they have contiguous working memory (a continuous and complete address space), even though physical memory may be fragmented and some data may be temporarily stored on external disk storage, being swapped between them as needed.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A memory management unit (MMU) is &lt;strong&gt;a computer hardware unit&lt;/strong&gt; that examines all memory references on the memory bus, translating these requests, known as virtual memory addresses, into physical addresses in main memory. &lt;a href=&#34;https://en.wikipedia.org/wiki/Memory_management_unit&#34;&gt;Memory management unit&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-risc&#34; data-lang=&#34;risc&#34;&gt;ld r1, 400(r2)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This instruction means to load data into register r1 from the address calculated by adding an offset of 400 to the content of register r2.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Calculate the Virtual Address:
&lt;ul&gt;
&lt;li&gt;Assume the register r2 currently holds the virtual address 0x1000 (4096 in decimal).&lt;/li&gt;
&lt;li&gt;The offset 400 (0x190) is added to the content of r2.&lt;/li&gt;
&lt;li&gt;Therefore, the calculated virtual address is 0x1000 + 0x190 = 0x1190 (virtual address).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Virtual to Physical Address Translation:
&lt;ul&gt;
&lt;li&gt;The MMU receives the virtual address 0x1190 and begins to look up the page table for the current process.&lt;/li&gt;
&lt;li&gt;Suppose the page table entry shows that this virtual address maps to the physical address 0x5000.&lt;/li&gt;
&lt;li&gt;The page offset (offset within the page) remains 0x190.&lt;/li&gt;
&lt;li&gt;Thus, the complete physical address is 0x5000 + 0x190 = 0x5190.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Access Physical Memory and Execute Instruction:
&lt;ul&gt;
&lt;li&gt;Once the physical address is determined, the MMU instructs the system to load data from physical address 0x5190.&lt;/li&gt;
&lt;li&gt;The data is loaded into register r1.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-how-does-virtual-memory-work&#34;&gt;2. How Does Virtual Memory Work&lt;/h2&gt;
&lt;p&gt;RISC is a type of microprocessor design. Both MIPS and ARM are types of RISC architectures. MIPS gives each program its own 32-bit address space. Programs can only access any byte in their own address space.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;What if we don&amp;rsquo;t have enough memory?&lt;/li&gt;
&lt;li&gt;Holes in our address space?&lt;/li&gt;
&lt;li&gt;Keeping programs secure with virtual memory.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=59rEMnKWoS4&amp;amp;list=PLiwt1iVUib9s2Uo5BeYmwkDFUh70fJPxX&amp;amp;index=4&#34;&gt;Virtual Memory: 4 How Does Virtual Memory Work?&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-how-does-a-game-that-is-several-hundred-gigabytes-run-on-a-computer-with-only-a-few-gigabytes-of-memory&#34;&gt;3. How does a game that is several hundred gigabytes run on a computer with only a few gigabytes of memory?&lt;/h2&gt;
&lt;p&gt;It&amp;rsquo;s Not All Loaded at Once:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Games, even huge ones, don&amp;rsquo;t need all their data in memory at the same time. Think of a vast open-world game: you only need the data for the area immediately around your character.&lt;/li&gt;
&lt;li&gt;The game constantly loads and unloads data as you move through the world. This is called &lt;strong&gt;streaming&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;The operating system (OS) swaps data between your RAM and your storage drive (HDD or SSD). This means less frequently used game data sits on the drive until needed.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-segment-fault&#34;&gt;4. Segment Fault&lt;/h2&gt;
&lt;p&gt;A segmentation fault is a specific type of error that occurs when a program tries to access a segment of memory that it doesn’t have the permissions to access or that doesn’t exist, leading to the program’s abrupt termination by the operating system.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.percona.com/blog/segmentation-fault-a-dba-perspective/&#34;&gt;Understanding Segmentation Fault: What it is &amp;amp; How to Fix it&lt;/a&gt;&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Context Switching</title>
      <link>https://blog.jiyi27.com/posts/cs-basics/006-context-switching/</link>
      <pubDate>Sat, 27 May 2023 16:29:15 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/cs-basics/006-context-switching/</guid>
      <description>&lt;h2 id=&#34;1-context-switch&#34;&gt;1. Context switch&lt;/h2&gt;
&lt;p&gt;In a CPU, the term &amp;ldquo;context&amp;rdquo; refers to the data in the registers and program counter (PC) at a specific moment in time. A register holds the current CPU instruction. A program counter, also known as an instruction address register, is a small amount of fast memory that holds the address of the instruction to be executed immediately after the current one.&lt;/p&gt;
&lt;p&gt;In computing, a context switch is the process of storing the state of a process or thread, so that it can be restored and resume execution at a later point, and then restoring a different, previously saved, state. Two steps, the first step is to &lt;strong&gt;store the state of the thread and then restore the state of another&lt;/strong&gt;.&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-context-switch&#34;&gt;1. Context switch&lt;/h2&gt;
&lt;p&gt;In a CPU, the term &amp;ldquo;context&amp;rdquo; refers to the data in the registers and program counter (PC) at a specific moment in time. A register holds the current CPU instruction. A program counter, also known as an instruction address register, is a small amount of fast memory that holds the address of the instruction to be executed immediately after the current one.&lt;/p&gt;
&lt;p&gt;In computing, a context switch is the process of storing the state of a process or thread, so that it can be restored and resume execution at a later point, and then restoring a different, previously saved, state. Two steps, the first step is to &lt;strong&gt;store the state of the thread and then restore the state of another&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&#34;2-two-data-structure-pcb--tcb&#34;&gt;2. Two data structure: PCB &amp;amp; TCB&lt;/h2&gt;
&lt;p&gt;The &amp;lsquo;state&amp;rsquo; mentioned above is thread or process related information, stored in PCB (Process) and TCB (Thread) respectively.&lt;/p&gt;
&lt;h3 id=&#34;21-process-control-block-pcb&#34;&gt;2.1 Process control block (PCB)&lt;/h3&gt;
&lt;p&gt;A process control block (PCB) contains information about the process, i.e. registers, PID, priority, etc. The process table is an array of PCBs, that means logically contains a PCB for all of the current processes in the system.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Process State – new, ready, running, waiting, dead;&lt;/li&gt;
&lt;li&gt;Process Number (PID) – unique identification number for each process (also known as Process ID);&lt;/li&gt;
&lt;li&gt;Program Counter (PC) – a pointer to the address of the next instruction to be executed for this process;&lt;/li&gt;
&lt;li&gt;CPU Registers – register set where process needs to be stored for execution for running state;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22-thread-control-block-tcb&#34;&gt;2.2 &lt;strong&gt;Thread control block&lt;/strong&gt; (&lt;strong&gt;TCB&lt;/strong&gt;)&lt;/h3&gt;
&lt;p&gt;An example of information contained within a TCB is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Thread Identifier: Unique id (tid) is assigned to every new thread&lt;/li&gt;
&lt;li&gt;Stack pointer: Points to thread&amp;rsquo;s stack in the process&lt;/li&gt;
&lt;li&gt;Program counter (PC): Points to the current program instruction of the thread&lt;/li&gt;
&lt;li&gt;State of the thread (running, ready, waiting, start, done)&lt;/li&gt;
&lt;li&gt;Thread&amp;rsquo;s register values&lt;/li&gt;
&lt;li&gt;Pointer to the Process control block (PCB) of the process that the thread lives on&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-cost-of-context-switch&#34;&gt;3. Cost of context switch&lt;/h2&gt;
&lt;p&gt;Switching from one process to another requires a certain amount of time for doing the administration – saving and loading registers and memory maps, updating various tables and lists, etc.&lt;/p&gt;
&lt;p&gt;For example, in the Linux kernel, context switching involves &lt;em&gt;&lt;strong&gt;loading the corresponding process control block (PCB)&lt;/strong&gt;&lt;/em&gt; stored in the PCB table in the kernel stack to retrieve information about the state of the new process. &lt;em&gt;&lt;strong&gt;CPU state information&lt;/strong&gt;&lt;/em&gt; including the registers, stack pointer, and program counter as well as memory management information like segmentation tables and page tables (unless the old process shares the memory with the new) are loaded from the PCB for the new process. To avoid incorrect address translation in the case of the previous and current processes using different memory, &lt;em&gt;&lt;strong&gt;the translation lookaside buffer (TLB)&lt;/strong&gt;&lt;/em&gt; must be flushed. This negatively affects performance because every memory reference to the TLB will be a miss because it is empty after most context switches.&lt;/p&gt;
&lt;p&gt;Furthermore, analogous context switching happens between &lt;a href=&#34;https://en.wikipedia.org/wiki/User_thread&#34;&gt;user threads&lt;/a&gt;, notably &lt;a href=&#34;https://en.wikipedia.org/wiki/Green_thread&#34;&gt;green threads&lt;/a&gt;, and is often very lightweight, saving and restoring minimal context. In extreme cases, such as switching between goroutines in &lt;a href=&#34;https://en.wikipedia.org/wiki/Go_%28programming_language%29&#34;&gt;Go&lt;/a&gt;, a context switch is equivalent to a &lt;a href=&#34;https://en.wikipedia.org/wiki/Coroutine&#34;&gt;coroutine&lt;/a&gt; yield, which is only marginally more expensive than a &lt;a href=&#34;https://en.wikipedia.org/wiki/Subroutine&#34;&gt;subroutine&lt;/a&gt; call.&lt;/p&gt;
&lt;h2 id=&#34;4-when-context-switch-happens&#34;&gt;4. When context switch happens&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;System calls&lt;/strong&gt;: when a process makes any system calls, the OS switches the mode of the kernel and saves that process in context, and executes the system call.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Interrupt handling:&lt;/strong&gt; Modern architectures are &lt;a href=&#34;https://en.wikipedia.org/wiki/Interrupt&#34;&gt;interrupt&lt;/a&gt; driven. This means that if the CPU requests data from a disk, for example, it does not need to &lt;a href=&#34;https://en.wikipedia.org/wiki/Busy-wait&#34;&gt;busy-wait&lt;/a&gt; until the read is over; it can issue the request (to the I/O device) and continue with some other task. When the read is over, the CPU can be &lt;em&gt;interrupted&lt;/em&gt; (by a hardware in this case, which sends interrupt request to &lt;a href=&#34;https://en.wikipedia.org/wiki/Programmable_interrupt_controller&#34;&gt;PIC&lt;/a&gt;) and presented with the read. For interrupts, a program called an &lt;em&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Interrupt_handler&#34;&gt;interrupt handler&lt;/a&gt;&lt;/em&gt; is installed, and it is the interrupt handler that handles the interrupt from the disk.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;User and Kernel Mode switching&lt;/strong&gt;: this trigger is used when the OS needed to switch between the user mode and kernel mode.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-performance&#34;&gt;5. Performance&lt;/h2&gt;
&lt;p&gt;Context switching itself has a cost in performance, due to running the task scheduler, TLB flushes, and indirectly due to sharing the CPU cache between multiple tasks. &lt;strong&gt;Switching between threads of a single process can be faster than between two separate processes, because threads share the same virtual memory maps, so a TLB flush is not necessary&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&#34;6-conclusion&#34;&gt;6. Conclusion&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;program counter (PC): processor register, stores the address of next instruction to be executed.&lt;/li&gt;
&lt;li&gt;context switch: store state, restore state&lt;/li&gt;
&lt;li&gt;causes of context siwtch
&lt;ul&gt;
&lt;li&gt;system call&lt;/li&gt;
&lt;li&gt;interrupt handling: CPU requests data from a disk&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;References:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Context_switch&#34;&gt;Context switch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Process_control_block&#34;&gt;Process control block&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Thread_control_block&#34;&gt;Thread control block&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Program_counter&#34;&gt;Program counter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/context-switch-in-operating-system/&#34;&gt;Context Switch in Operating System - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html&#34;&gt;Scheduling In Go : Part I - OS Scheduler&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
  </channel>
</rss>
