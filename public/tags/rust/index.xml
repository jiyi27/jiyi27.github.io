<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rust on 为霜的博客</title>
    <link>https://blog.jiyi27.com/tags/rust/</link>
    <description>Recent content in Rust on 为霜的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 03 May 2024 23:30:17 +0000</lastBuildDate><atom:link href="https://blog.jiyi27.com/tags/rust/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Rust Basics - Syntax, Types</title>
      <link>https://blog.jiyi27.com/posts/rust/syntax/001-basics/</link>
      <pubDate>Fri, 03 May 2024 23:30:17 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/rust/syntax/001-basics/</guid>
      <description>&lt;h2 id=&#34;1-syntax&#34;&gt;1. Syntax&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; _x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Destructuring Tuples
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (x, y, z) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3.5&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; abc &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0.1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.3&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Destructuring Structs
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; Point { x: &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;, y: &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; } &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Point { x: &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, y: &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Ignoring Values and Partial Destructuring
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (first, _, _, last) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; Point { a, &lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt; } &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; point;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; y: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 未初始化, 不可以被使用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;2-types&#34;&gt;2. Types&lt;/h2&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;整型溢出httpscoursersbasicbase-typenumbershtml整型溢出&#34;&gt;&lt;a href=&#34;https://course.rs/basic/base-type/numbers.html#%E6%95%B4%E5%9E%8B%E6%BA%A2%E5%87%BA&#34;&gt;整型溢出&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;假设有一个 &lt;code&gt;u8&lt;/code&gt; ，它可以存放从 0 到 255 的值。那么当你将其修改为范围之外的值，比如 256，则会发生&lt;strong&gt;整型溢出&lt;/strong&gt;。关于这一行为 Rust 有一些有趣的规则：当在 debug 模式编译时，Rust 会检查整型溢出，若存在这些问题，则使程序在编译时 &lt;em&gt;panic&lt;/em&gt;(崩溃,Rust 使用这个术语来表明程序因错误而退出)。&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-syntax&#34;&gt;1. Syntax&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; _x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Destructuring Tuples
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (x, y, z) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3.5&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; abc &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0.1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.3&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Destructuring Structs
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; Point { x: &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;, y: &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; } &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Point { x: &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, y: &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Ignoring Values and Partial Destructuring
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (first, _, _, last) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; Point { a, &lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt; } &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; point;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; y: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 未初始化, 不可以被使用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;2-types&#34;&gt;2. Types&lt;/h2&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;整型溢出httpscoursersbasicbase-typenumbershtml整型溢出&#34;&gt;&lt;a href=&#34;https://course.rs/basic/base-type/numbers.html#%E6%95%B4%E5%9E%8B%E6%BA%A2%E5%87%BA&#34;&gt;整型溢出&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;假设有一个 &lt;code&gt;u8&lt;/code&gt; ，它可以存放从 0 到 255 的值。那么当你将其修改为范围之外的值，比如 256，则会发生&lt;strong&gt;整型溢出&lt;/strong&gt;。关于这一行为 Rust 有一些有趣的规则：当在 debug 模式编译时，Rust 会检查整型溢出，若存在这些问题，则使程序在编译时 &lt;em&gt;panic&lt;/em&gt;(崩溃,Rust 使用这个术语来表明程序因错误而退出)。&lt;/p&gt;
&lt;p&gt;在当使用 &lt;code&gt;--release&lt;/code&gt; 参数进行 release 模式构建时，Rust &lt;strong&gt;不&lt;/strong&gt;检测溢出。相反，当检测到整型溢出时，Rust 会按照补码循环溢出（&lt;em&gt;two’s complement wrapping&lt;/em&gt;）的规则处理。简而言之，大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值。比如在 &lt;code&gt;u8&lt;/code&gt; 的情况下，256 变成 0，257 变成 1，依此类推。程序不会 &lt;em&gt;panic&lt;/em&gt;，但是该变量的值可能不是你期望的值。依赖这种默认行为的代码都应该被认为是错误的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;浮点数陷阱httpscoursersbasicbase-typenumbershtml浮点数陷阱&#34;&gt;&lt;a href=&#34;https://course.rs/basic/base-type/numbers.html#%E6%B5%AE%E7%82%B9%E6%95%B0%E9%99%B7%E9%98%B1&#34;&gt;浮点数陷阱&lt;/a&gt;&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 断言0.1 + 0.2与0.3相等
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  assert!(&lt;span style=&#34;color:#ae81ff&#34;&gt;0.1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0.2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0.3&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你可能以为，这段代码没啥问题吧，实际上它会 &lt;em&gt;panic&lt;/em&gt;(程序崩溃，抛出异常)，因为二进制精度问题，导致了 0.1 + 0.2 并不严格等于 0.3，它们可能在小数点 N 位后存在误差。&lt;/p&gt;
&lt;p&gt;那如果非要进行比较呢？可以考虑用这种方式 &lt;code&gt;(0.1_f64 + 0.2 - 0.3).abs() &amp;lt; 0.00001&lt;/code&gt; ，具体小于多少，取决于你对精度的需求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;statement--expressionhttpscoursersbasicbase-typestatement-expressionhtml语句和表达式&#34;&gt;&lt;a href=&#34;https://course.rs/basic/base-type/statement-expression.html#%E8%AF%AD%E5%8F%A5%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F&#34;&gt;statement &amp;amp; expression&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Rust 的函数体是由一系列语句组成&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-tust&#34; data-lang=&#34;tust&#34;&gt;fn add_with_extra(x: i32, y: i32) -&amp;gt; i32 {
    let x = x + 1; // 语句
    let y = y + 5; // 语句
    x + y // 表达式
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后由一个表达式来返回值. 语句会执行一些操作但是不会返回一个值，而表达式会在求值后返回一个值，因此在上述函数体的三行代码中，前两行是语句，最后一行是表达式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;3-ownership&#34;&gt;3. Ownership&lt;/h2&gt;
&lt;p&gt;在计算机语言不断演变过程中，出现了三种流派：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;垃圾回收机制(GC)&lt;/strong&gt;，在程序运行时不断寻找不再使用的内存，典型代表：Java、Go&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;手动管理内存的分配和释放&lt;/strong&gt;, 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通过所有权来管理内存&lt;/strong&gt;，编译器在编译时会根据一系列规则进行检查&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中 Rust 选择了第三种，最妙的是，这种检查只发生在编译期，因此对于程序运行期，不会有任何性能上的损失。&lt;/p&gt;
&lt;p&gt;一段不安全的代码:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a;          &lt;span style=&#34;color:#75715e&#34;&gt;// 变量a的作用域开始
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;xyz&amp;#34;&lt;/span&gt;;   &lt;span style=&#34;color:#75715e&#34;&gt;// 变量c的作用域开始
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;a;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}                   &lt;span style=&#34;color:#75715e&#34;&gt;// 变量a和c的作用域结束
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这段代码虽然可以编译通过，但是其实非常糟糕，变量 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 都是局部变量，函数结束后将局部变量 &lt;code&gt;a&lt;/code&gt; 的地址返回，但局部变量 &lt;code&gt;a&lt;/code&gt; 存在栈中，在离开作用域后，&lt;code&gt;a&lt;/code&gt; 所申请的栈上内存都会被系统回收，从而造成了 &lt;code&gt;悬空指针(Dangling Pointer)&lt;/code&gt; 的问题。这是一个非常典型的内存安全问题，虽然编译可以通过，但是运行的时候会出现错误, 很多编程语言都存在。&lt;/p&gt;
&lt;p&gt;再来看变量 &lt;code&gt;c&lt;/code&gt;，&lt;code&gt;c&lt;/code&gt; 的值是常量字符串，存储于常量区，可能这个函数我们只调用了一次，也可能我们不再会使用这个字符串，但 &lt;code&gt;&amp;quot;xyz&amp;quot;&lt;/code&gt; 只有当整个程序结束后系统才能回收这片内存。&lt;/p&gt;
&lt;p&gt;所以内存安全问题，一直都是程序员非常头疼的问题，好在, 在 Rust 中这些问题即将成为历史，因为 Rust 在编译的时候就可以帮助我们发现内存不安全的问题.&lt;/p&gt;
&lt;h2 id=&#34;4-stack--heap&#34;&gt;4. Stack &amp;amp; Heap&lt;/h2&gt;
&lt;p&gt;因为&lt;strong&gt;栈&lt;/strong&gt;的实现方式，栈中的所有数据都必须占用已知且固定大小的内存空间，假设数据大小是未知的，那么在取出数据时，你将无法取到你想要的数据。与栈不同，对于大小未知或者可能变化的数据，我们需要将它存储在&lt;strong&gt;堆&lt;/strong&gt;上。当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的&lt;strong&gt;指针&lt;/strong&gt;, 该过程被称为&lt;strong&gt;在堆上分配内存&lt;/strong&gt;，有时简称为 “分配”(allocating)。接着，该指针会被推入&lt;strong&gt;栈&lt;/strong&gt;中，因为指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的&lt;strong&gt;指针&lt;/strong&gt;，来获取数据在堆上的实际内存位置，进而访问该数据。由上可知，堆是一种缺乏组织的数据结构。&lt;/p&gt;
&lt;p&gt;在栈上分配内存比在堆上分配内存要快，因为入栈时操作系统无需进行函数调用（或更慢的系统调用）来分配新的空间，只需要将新数据放入栈顶即可。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备，如果当前进程分配的内存页不足时，还需要进行系统调用来申请更多内存。 因此，处理器在栈上分配数据会比在堆上分配数据更加高效。&lt;/p&gt;
&lt;h2 id=&#34;5-owner-rule&#34;&gt;5. Owner Rule&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者&lt;/li&gt;
&lt;li&gt;一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者&lt;/li&gt;
&lt;li&gt;当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;References:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://course.rs/basic/base-type/index.html&#34;&gt;基本类型 - Rust语言圣经(Rust Course)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://course.rs/basic/ownership/index.html&#34;&gt;所有权和借用 - Rust语言圣经(Rust Course)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>Rust 引发的类型安全的思考</title>
      <link>https://blog.jiyi27.com/posts/cs-basics/003-type-safety/</link>
      <pubDate>Sat, 05 Aug 2023 18:32:53 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/cs-basics/003-type-safety/</guid>
      <description>&lt;p&gt;关于 type safety, 一直没有一个确切的定义, 每个语言的作者对 type safety 可能有不同的理解, 我比较喜欢的是维基百科对 type safety 的定义, 即 type safety 阻止或者使 type errors 不容易发生, 而什么是 type errors 在下面这段话里也给出了定义:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In computer science, &lt;strong&gt;type safety&lt;/strong&gt; is the extent to which a programming language discourages or prevents &lt;strong&gt;type errors&lt;/strong&gt;. The behaviors classified as type errors are usually that result from attempts to perform operations on values that are not of the appropriate data type, e.g., &lt;strong&gt;adding a string to an integer when there&amp;rsquo;s no definition on how to handle this case&lt;/strong&gt;. This classification is partly based on opinion. &lt;a href=&#34;https://en.wikipedia.org/wiki/Type_safety&#34;&gt;https://en.wikipedia.org/wiki/Type_safety&lt;/a&gt;&lt;/p&gt;</description>
      <content>&lt;p&gt;关于 type safety, 一直没有一个确切的定义, 每个语言的作者对 type safety 可能有不同的理解, 我比较喜欢的是维基百科对 type safety 的定义, 即 type safety 阻止或者使 type errors 不容易发生, 而什么是 type errors 在下面这段话里也给出了定义:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In computer science, &lt;strong&gt;type safety&lt;/strong&gt; is the extent to which a programming language discourages or prevents &lt;strong&gt;type errors&lt;/strong&gt;. The behaviors classified as type errors are usually that result from attempts to perform operations on values that are not of the appropriate data type, e.g., &lt;strong&gt;adding a string to an integer when there&amp;rsquo;s no definition on how to handle this case&lt;/strong&gt;. This classification is partly based on opinion. &lt;a href=&#34;https://en.wikipedia.org/wiki/Type_safety&#34;&gt;https://en.wikipedia.org/wiki/Type_safety&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;感觉维基百科对类型安全的定义与 Why Rust 一书的作者观点不谋而合:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If a program has been written so that no possible execution can exhibit undefined behavior, we say that program is well defined. If a language’s type system ensures that every program is well defined, we say that language is type safe.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;undefined behavior: 在 c99 的定义中, undefined behaviors 有很多: 如分母为 0, 访问超出数组大小的位置 (c 是没有越界检查的), 让一个int能表示的最大数加一,&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;argv) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; a[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  a[&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x7ffff7b36cebUL&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;According to C99, because this program accesses an element off the end of the array &lt;code&gt;a&lt;/code&gt;, its behavior is undefined, meaning that it can do anything whatsoever.&lt;/p&gt;
&lt;p&gt;A carefully written C or C++ program might be well defined, but C and C++ are not type safe: the program shown earlier has no type errors, yet exhibits undefined behavior. By contrast, Python is type safe. Python is willing to spend processor time to detect and handle out-of-range array indices in a friendlier fashion than C:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;0&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; a&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;3&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0x7ffff7b36ceb
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Traceback &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;most recent call last&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  File &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;&lt;/span&gt;, line 1, in &amp;lt;module&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;IndexError: list assignment index out of range
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Python raised an exception, which is not undefined behavior: the Python documentation specifies that the assignment to &lt;code&gt;a[3]&lt;/code&gt; should raise an &lt;code&gt;IndexError&lt;/code&gt; exception, as we saw. Certainly, a module like &lt;code&gt;ctypes&lt;/code&gt; that provides unconstrained access to the machine can introduce undefined behavior into Python, but the core language itself is type safe. Java, JavaScript, Ruby, and Haskell are similar in this way.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note that being type safe is independent of whether a language checks types at compile time or at runtime: C checks at compile time, and is not type safe; Python checks at runtime, and is type safe.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上讨论来自: &lt;a href=&#34;https://www.oreilly.com/library/view/programming-rust/9781491927274/ch01.html&#34;&gt;Why Rust Chapter 1&lt;/a&gt; , 感兴趣可以自己翻阅,&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>
