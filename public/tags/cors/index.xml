<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cors on 为霜的博客</title>
    <link>https://blog.jiyi27.com/tags/cors/</link>
    <description>Recent content in Cors on 为霜的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 26 Jan 2025 10:36:22 +0000</lastBuildDate><atom:link href="https://blog.jiyi27.com/tags/cors/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>记录 CORS Preflight Request 错误前后端排查过程</title>
      <link>https://blog.jiyi27.com/posts/bugs/012-cors-options/</link>
      <pubDate>Sun, 26 Jan 2025 10:36:22 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/bugs/012-cors-options/</guid>
      <description>&lt;p&gt;遇到的问题是, 一会有跨域请求错误, 一会没有, 真的是莫名其妙,&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Access to fetch at &amp;#39;http://localhost:8080/api/terms/suggestions?query=aaa&amp;#39; from origin &amp;#39;http://localhost:3000&amp;#39; has been blocked by CORS policy: Response to preflight request doesn&amp;#39;t pass access control check: No &amp;#39;Access-Control-Allow-Origin&amp;#39; header is present on the requested resource. If an opaque response serves your needs, set the request&amp;#39;s mode to &amp;#39;no-cors&amp;#39; to fetch the resource with CORS disabled.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当 query 字符串为长度大于 2 的时候, 浏览器就会发送 preflight request 请求, 如下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pub-2a6758f3b2d64ef5bb71ba1601101d35.r2.dev/blogs/2025/01/3a41d4bb6799ca575c2a60f333806d83.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;先不说为什么出现跨域错误, 这个肯定是我后端没处理好, 后面再分析, 我们来看为什么因为 query 不同, 导致了浏览器发送 preflight request, 首先我的所有请求都加上了 &lt;code&gt;&#39;Content-Type&#39;: &#39;application/json&#39;,&lt;/code&gt;, 也就是是说, 我的所有请求都不是简单请求, 因此触发 preflight request 很正常, 可是, 为什么 &lt;code&gt;/suggestions?query = x&lt;/code&gt;, &lt;code&gt;/suggestions?query = xx&lt;/code&gt; 没有触发呢?&lt;/p&gt;</description>
      <content>&lt;p&gt;遇到的问题是, 一会有跨域请求错误, 一会没有, 真的是莫名其妙,&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Access to fetch at &amp;#39;http://localhost:8080/api/terms/suggestions?query=aaa&amp;#39; from origin &amp;#39;http://localhost:3000&amp;#39; has been blocked by CORS policy: Response to preflight request doesn&amp;#39;t pass access control check: No &amp;#39;Access-Control-Allow-Origin&amp;#39; header is present on the requested resource. If an opaque response serves your needs, set the request&amp;#39;s mode to &amp;#39;no-cors&amp;#39; to fetch the resource with CORS disabled.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当 query 字符串为长度大于 2 的时候, 浏览器就会发送 preflight request 请求, 如下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pub-2a6758f3b2d64ef5bb71ba1601101d35.r2.dev/blogs/2025/01/3a41d4bb6799ca575c2a60f333806d83.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;先不说为什么出现跨域错误, 这个肯定是我后端没处理好, 后面再分析, 我们来看为什么因为 query 不同, 导致了浏览器发送 preflight request, 首先我的所有请求都加上了 &lt;code&gt;&#39;Content-Type&#39;: &#39;application/json&#39;,&lt;/code&gt;, 也就是是说, 我的所有请求都不是简单请求, 因此触发 preflight request 很正常, 可是, 为什么 &lt;code&gt;/suggestions?query = x&lt;/code&gt;, &lt;code&gt;/suggestions?query = xx&lt;/code&gt; 没有触发呢?&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;至于跨域错误是因为我后端没处理好, 原本代码如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-golang&#34; data-lang=&#34;golang&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mux&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;HandleFunc&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;GET /api/terms/suggestions&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;middleware&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Use&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;GetTermSuggestions&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;middleware&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Logger&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;middleware&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;CORS&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;)))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看出, 我只处理了 GET 请求, 忽略了 OPTION 请求, 这也是为什么明明使用了 CORS 中间件, 却总是不会被触发, 原来是下面这个请求根本没有对应的后端路径:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;OPTIONS http://localhost:8080/api/terms/suggestions?query=xxx
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另外还有个容易出错的地方:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-golang&#34; data-lang=&#34;golang&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mux&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;HandleFunc&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;GET /api/terms/{id}&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mux&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;HandleFunc&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;GET /api/terms/suggestions&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第一个动态路由 API 会覆盖第二个 API, 因为 &lt;code&gt;{id}&lt;/code&gt; 也是字符串, 所以不可以这么写,&lt;/p&gt;
&lt;p&gt;这么看来, 对每个 API 单独加中间件并不是一个明智的选择, 比如因为我忽略了 OPTION 请求, 导致 CORS 错误, 一直找不到原因, 所以中间件, 应该放到最开始处理的地方,&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Cross-origin Request HTTP</title>
      <link>https://blog.jiyi27.com/posts/http/003-cors-sop/</link>
      <pubDate>Fri, 06 Oct 2023 20:28:50 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/http/003-cors-sop/</guid>
      <description>&lt;h2 id=&#34;0-cors-issue-1&#34;&gt;0. CORS Issue 1&lt;/h2&gt;
&lt;p&gt;Safari shows in console:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[Error] Preflight response is not successful
[Error] XMLHttpRequest cannot load [https://xxxxxxxxxxxx](https://xxxxxxxxxxxx/) due to access control checks.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Chrome shows in console:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Access to XMLHttpRequest at &amp;#39;https://xxxxxxxxxxx&amp;#39; from origin &amp;#39;xxxx&amp;#39; has been blocked by CORS policy: Response to preflight request doesn&amp;#39;t pass access control check: No &amp;#39;Access-Control-Allow-Origin&amp;#39; header is present on the requested resource.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This means the OPTIONS calls is failing, even if all the headers (allow-origin etc&amp;hellip;.) are available server-side.&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;0-cors-issue-1&#34;&gt;0. CORS Issue 1&lt;/h2&gt;
&lt;p&gt;Safari shows in console:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[Error] Preflight response is not successful
[Error] XMLHttpRequest cannot load [https://xxxxxxxxxxxx](https://xxxxxxxxxxxx/) due to access control checks.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Chrome shows in console:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Access to XMLHttpRequest at &amp;#39;https://xxxxxxxxxxx&amp;#39; from origin &amp;#39;xxxx&amp;#39; has been blocked by CORS policy: Response to preflight request doesn&amp;#39;t pass access control check: No &amp;#39;Access-Control-Allow-Origin&amp;#39; header is present on the requested resource.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This means the OPTIONS calls is failing, even if all the headers (allow-origin etc&amp;hellip;.) are available server-side.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;说到 CORS 前，需要了解“同源”概念。同源即协议、域名和端口三者完全相同。浏览器使用同源政策，目的是为了保证用户信息的安全，防止恶意的网站窃取数据，不同源的访问会受到限制（主要是 Cookie / Local Storage 访问、iframe DOM 访问、发起 HTTP 请求）。
对于 HTML 标签的外部链接如 &lt;code&gt;&amp;lt;img&amp;gt;、&amp;lt;audio&amp;gt;、&amp;lt;video&amp;gt;、&amp;lt;script&amp;gt;&lt;/code&gt;，没有跨域问题。不过对于这样的外部链接请求不会带上 Cookie。
对于 JavaScript 发起 HTTP 请求，三要素有任何之一不匹配即是跨域，浏览器即会出于安全考虑进行限制，这时就需要使用 CORS （Cross-origin resource sharing）。CORS 主要由服务器端实现，对用户透明。
Source: &lt;a href=&#34;https://ogr.xyz/p/js-cors/&#34;&gt;https://ogr.xyz/p/js-cors/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;1-cors-issue-2&#34;&gt;1. CORS Issue 2&lt;/h2&gt;
&lt;p&gt;My frontend application is deployed on &lt;code&gt;http://localhost:5173&lt;/code&gt;, and backend application is deployed on &lt;code&gt;http://localhost:8080&lt;/code&gt;. The frontend application sends HTTP requests to the backend application through &lt;code&gt;fetch&lt;/code&gt;, but it fails with the following error:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 显然服务器没有处理 OPTIONS 请求&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Access to fetch at &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;http://localhost:8080/&amp;#39;&lt;/span&gt; from origin &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;http://localhost:5173&amp;#39;&lt;/span&gt; has been blocked by CORS policy: Response to preflight request doesn&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;t pass access control check: It does not have HTTP ok status. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Access to fetch at &amp;#39;&lt;/span&gt;http://localhost:8080/api/chat&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; from origin &amp;#39;&lt;/span&gt;http://localhost:5173&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;#39;&lt;/span&gt; has been blocked by CORS policy: Request header field content-type is not allowed by Access-Control-Allow-Headers in preflight response.
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This is the famous CORS issue, and it is caused by the &lt;strong&gt;same-origin policy&lt;/strong&gt; (SOP) enforced by web browsers.&lt;/p&gt;
&lt;p&gt;CORS is a feature built into browsers for added security. &lt;strong&gt;It prevents any random website from using your authenticated cookies&lt;/strong&gt; to send an API request to your bank&amp;rsquo;s website and do stuff like secretly withdraw money.&lt;/p&gt;
&lt;p&gt;想象一下, 如果你点进了一个恶意网站, 这个网站有个JS脚本使用比如 fetch 向你银行 /api/transfers 发送了一个请求 (origin 是恶意网站), 如果浏览器没有 same-origin policy 限制, 那么这个请求就会被发送出去, 而且会自动带上你的银行网站的 cookie (若银行后台也允许任意 cors, 这就意味着可以通过银行后台的验证), 这样恶意网站就可以做一些你不知道的事情, 比如转账, 提现等等.&lt;/p&gt;
&lt;p&gt;但是, 有了 same-origin policy 限制, 那么这个请求就不会被浏览器发送出去, 因为这个请求的 origin 和你银行网站的 origin 不一样, 所以浏览器会阻止这个请求. Origin 是浏览器自动添加的请求头, 你不能修改它. Origin 包括三部分: 协议, 域名, 端口. 上面的例子 origin 就是 &lt;code&gt;http://localhost:5173&lt;/code&gt; 和 &lt;code&gt;http://localhost:8080&lt;/code&gt;, 前端页面的 js 代码是在 &lt;code&gt;http://localhost:5173&lt;/code&gt; 运行的, 所以它的 origin 是 &lt;code&gt;http://localhost:5173&lt;/code&gt;, 而后端的 API 是在 &lt;code&gt;http://localhost:8080&lt;/code&gt; 运行的, 所以它的 origin 是 &lt;code&gt;http://localhost:8080&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;如果你的后端服务器不允许CORS, 那么除了跟你后端服务器同源(Origin)的前端页面, 其他的前端页面都不能在浏览器访问你的后端 API. 当然你可以在终端使用 curl 命令访问你的后端 API, 因为 curl 命令不是浏览器, 它不会自动添加 origin 请求头. 另外 React 的 create-react-app 也有一个 proxy 功能, 可以让你在开发环境下绕过 CORS 限制, 但是这个代理功能&lt;strong&gt;只在开发环境下有效&lt;/strong&gt;, 生产环境下还是要你自己配置后端服务器的 CORS.&lt;/p&gt;
&lt;h2 id=&#34;2-how-to-fix-cors-issue&#34;&gt;2. How to fix CORS issue&lt;/h2&gt;
&lt;h3 id=&#34;21-简单场景&#34;&gt;2.1. 简单场景&lt;/h3&gt;
&lt;p&gt;解决的办法很简单, 在后端 API 的响应头里添加 &lt;code&gt;Access-Control-Allow-Origin: *&lt;/code&gt; 就可以了. 但这仅限于一些简单的场景, 如 GET 请求. 可参考: &lt;a href=&#34;https://www.stackhawk.com/blog/golang-cors-guide-what-it-is-and-how-to-enable-it/&#34;&gt;Golang CORS Guide: What It Is and How to Enable It&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;22-复杂场景&#34;&gt;2.2. 复杂场景&lt;/h3&gt;
&lt;p&gt;如果你的 API 是 POST 请求, 并且需要带上一些请求头, 那么你可能还需要在响应头里添加 &lt;code&gt;Access-Control-Allow-Headers: *&lt;/code&gt;, 这样才能让浏览器发送 POST 请求, 并且带上你需要的请求头. (具体规定可参考: &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS&#34;&gt;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS&lt;/a&gt;) 这也是为什么在有的前端JS fetch代码里, 你后端简单设置 &lt;code&gt;Access-Control-Allow-Origin: *&lt;/code&gt; 就可以了, 但是有的并不会成功.&lt;/p&gt;
&lt;p&gt;除了设置上面两个响应头, 你还需要处理 OPTIONS 请求, 这是因为浏览器在发送跨域请求时, 会先发送一个 OPTIONS 请求, 用来询问服务器是否允许跨域请求, 如果服务器不允许, 那么浏览器就不会发送真正的请求.&lt;/p&gt;
&lt;p&gt;比如我的后端 API 需要客户端带上一个请求头 &lt;code&gt;Content-Type: application/json&lt;/code&gt; 和 &lt;code&gt;Content-Type: xxxx&lt;/code&gt;, 那么我就需要在响应头里添加 &lt;code&gt;Access-Control-Allow-Headers: Content-Type, Content-Type&lt;/code&gt;, 或者 &lt;code&gt;Access-Control-Allow-Headers: *&lt;/code&gt;, 这样浏览器发送HTTP请求时才会带上这两个请求头.&lt;/p&gt;
&lt;p&gt;使用 Golang 处理的话, 大致逻辑如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Server&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;ServeHTTP&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ResponseWriter&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Request&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;enableCors&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// Handle CORS preflighted request sent by browser.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;Method&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;OPTIONS&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 真正的处理逻辑&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;mux&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ServeHTTP&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;enableCors&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ResponseWriter&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;Header&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;Set&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Access-Control-Allow-Origin&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;Header&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;Set&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Access-Control-Allow-Methods&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;POST, GET, OPTIONS&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// We need to allow the Authorization header to be sent to the backend.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;Header&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;Set&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Access-Control-Allow-Headers&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;Header&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;Set&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Access-Control-Max-Age&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;86400&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;3-cors-vs-sop&#34;&gt;3. CORS vs SOP&lt;/h2&gt;
&lt;p&gt;The Same-Origin Policy (SOP) is a security feature &lt;strong&gt;enforced by web browsers&lt;/strong&gt; that restricts web pages (javascript) from interacting with resources (such as making requests or accessing data) from different origins.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CORS allows servers&lt;/strong&gt; to specify which origins are allowed to access their resources, even if they are from different origins. It provides a set of HTTP headers that the server includes in its responses to explicitly permit cross-origin requests from specific origins.&lt;/p&gt;
&lt;p&gt;References:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS&#34;&gt;Cross-Origin Resource Sharing (CORS) - HTTP | MDN&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&#34;&gt;Same-origin policy - Web security | MDN&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ogr.xyz/p/js-cors/&#34;&gt;JavaScript CORS 跨域请求&lt;/a&gt;&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>
