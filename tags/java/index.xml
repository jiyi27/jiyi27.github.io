<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on 为霜的博客</title>
    <link>https://blog.jiyi27.com/tags/java/</link>
    <description>Recent content in Java on 为霜的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 15 Feb 2025 15:07:57 +0000</lastBuildDate><atom:link href="https://blog.jiyi27.com/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JVM 启动时都加载了哪些类 - Java 编译原理</title>
      <link>https://blog.jiyi27.com/posts/java/basics/002-compile-java/</link>
      <pubDate>Sat, 15 Feb 2025 15:07:57 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/java/basics/002-compile-java/</guid>
      <description>&lt;h2 id=&#34;1--java-代码的执行流程&#34;&gt;1.  Java 代码的执行流程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;源代码编译：Java 源代码（&lt;code&gt;.java&lt;/code&gt; 文件）首先由 Java 编译器 (Javac) 编译成 字节码 (Bytecode), 生成二进制的 &lt;code&gt;.class&lt;/code&gt; 文件, 字节码是一种中间表示, 不是直接的机器码&lt;/li&gt;
&lt;li&gt;Java 源代码在编译后会变成 &lt;code&gt;.class&lt;/code&gt; 字节码文件, JVM 在执行时会采用 &lt;strong&gt;两种方式&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;解释执行 (Interpretation)：JVM 逐行翻译字节码, 并立即执行, 这就是“边翻译边执行”&lt;/li&gt;
&lt;li&gt;JIT (Just-In-Time Compilation)：JVM 发现高频代码（如循环、热点方法）, 会使用 JIT Compiler 将其编译成本地机器码, 避免重复翻译, 提高执行效率&lt;/li&gt;
&lt;li&gt;JIT Compiler: 如 HotSpot VM 的 C1/C2 编译器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;扩充1:&lt;/strong&gt; 类的生命周期 主要发生在 JVM 运行时, 且仅在类第一次被使用时触发, 并不是 JVM 启动时就一次性加载所有类,&lt;/p&gt;
&lt;p&gt;类的生命周期包括: 加载→验证→准备→解析→初始化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;**扩充2: ** 编译时, 每个单独的 &lt;code&gt;.java&lt;/code&gt; 源码文件被认为是一个单独的编译单元, 被单独编译成一个 .class 字节码文件, 所以在 Java 项目中, 通常会被编译成多个 &lt;code&gt;.class&lt;/code&gt; 文件, 如果直接分发 &lt;code&gt;.class&lt;/code&gt; 文件, 管理起来会很麻烦, 因此, Java 提供了 &lt;code&gt;.jar&lt;/code&gt; 这种格式, 可以把多个 &lt;code&gt;.class&lt;/code&gt; 文件打包在一起, 便于 分发、部署和加载&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1--java-代码的执行流程&#34;&gt;1.  Java 代码的执行流程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;源代码编译：Java 源代码（&lt;code&gt;.java&lt;/code&gt; 文件）首先由 Java 编译器 (Javac) 编译成 字节码 (Bytecode), 生成二进制的 &lt;code&gt;.class&lt;/code&gt; 文件, 字节码是一种中间表示, 不是直接的机器码&lt;/li&gt;
&lt;li&gt;Java 源代码在编译后会变成 &lt;code&gt;.class&lt;/code&gt; 字节码文件, JVM 在执行时会采用 &lt;strong&gt;两种方式&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;解释执行 (Interpretation)：JVM 逐行翻译字节码, 并立即执行, 这就是“边翻译边执行”&lt;/li&gt;
&lt;li&gt;JIT (Just-In-Time Compilation)：JVM 发现高频代码（如循环、热点方法）, 会使用 JIT Compiler 将其编译成本地机器码, 避免重复翻译, 提高执行效率&lt;/li&gt;
&lt;li&gt;JIT Compiler: 如 HotSpot VM 的 C1/C2 编译器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;扩充1:&lt;/strong&gt; 类的生命周期 主要发生在 JVM 运行时, 且仅在类第一次被使用时触发, 并不是 JVM 启动时就一次性加载所有类,&lt;/p&gt;
&lt;p&gt;类的生命周期包括: 加载→验证→准备→解析→初始化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;**扩充2: ** 编译时, 每个单独的 &lt;code&gt;.java&lt;/code&gt; 源码文件被认为是一个单独的编译单元, 被单独编译成一个 .class 字节码文件, 所以在 Java 项目中, 通常会被编译成多个 &lt;code&gt;.class&lt;/code&gt; 文件, 如果直接分发 &lt;code&gt;.class&lt;/code&gt; 文件, 管理起来会很麻烦, 因此, Java 提供了 &lt;code&gt;.jar&lt;/code&gt; 这种格式, 可以把多个 &lt;code&gt;.class&lt;/code&gt; 文件打包在一起, 便于 分发、部署和加载&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-手动编译并运行-java-程序&#34;&gt;2. 手动编译并运行 java 程序&lt;/h2&gt;
&lt;p&gt;目录结构:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── myproject
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│   └── src
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│       ├── Main.java
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│       └── animal
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│           └── Cat.java
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;代码内容:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Cat.java&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; animal;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Cat&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String name;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Cat&lt;/span&gt;(String name) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; name;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;mew~&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Main.java&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; animal.Cat;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Main&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(String &lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt;args){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Cat cat &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Cat(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;kitty&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在&lt;code&gt;src&lt;/code&gt;下编译:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;javac Main.java
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;编译后多出了两个字节码文件,  如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── myproject
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│   └── src
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│       ├── Main.class
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│       ├── Main.java
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│       └── animal
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│           ├── Cat.class
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│           └── Cat.java
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以发现, 我们只是编译了&lt;code&gt;Main.java&lt;/code&gt;, 被其用到的类 &lt;code&gt;Cat.java&lt;/code&gt; 也被编译了, 然后在其它文件夹下执行该程序, 用 &lt;code&gt;-cp&lt;/code&gt; 来指明 classpath, 即告诉 JVM 去哪找 user-defined class 字节码文件, &lt;code&gt;-cp&lt;/code&gt; 默认值为当前文件夹: &lt;code&gt;./&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ java -cp myproject/src Main 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mew~
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Technically, &lt;code&gt;javac&lt;/code&gt; is the program that translates Java code into bytecode (.class file). And &lt;code&gt;java&lt;/code&gt; is the program that starts the &lt;strong&gt;JVM&lt;/strong&gt;, which in turn, loads the &lt;code&gt;.class&lt;/code&gt; file, verifies the bytecode and executes it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;3-jvm-启动时都加载了哪些类&#34;&gt;3. JVM 启动时都加载了哪些类&lt;/h2&gt;
&lt;p&gt;The virtual machine searches for and loads classes in this order:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Bootstrap Classes 引导类, 加载核心库, 主要包含 Java 标准库的基础类 如 &lt;code&gt;java.lang.*&lt;/code&gt; (&lt;code&gt;String&lt;/code&gt;、&lt;code&gt;Object&lt;/code&gt;、&lt;code&gt;Math&lt;/code&gt;、&lt;code&gt;System&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Extension ClassLoader 加载扩展库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;User classes - Classes defined by developers and third parties that do not take advantage of the extension mechanism. You identify the location of these classes using the &lt;code&gt;-classpath&lt;/code&gt; option on the command line (the preferred method) or by using the CLASSPATH environment variable.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;In general, you only have to specify the location of user classes. Bootstrap classes and extension classes are found &amp;ldquo;automatically&amp;rdquo;.&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    </item>
    
    <item>
      <title>JVM 内存结构 两种分类方式</title>
      <link>https://blog.jiyi27.com/posts/java/basics/003-jvm-memory/</link>
      <pubDate>Tue, 04 Feb 2025 21:50:26 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/java/basics/003-jvm-memory/</guid>
      <description>&lt;h2 id=&#34;1-jvm-specification&#34;&gt;1. JVM Specification&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html&#34;&gt;JVM Specification&lt;/a&gt; 标准并没有提到 JVM 内存结构的概念, 只有 JVM Run-Time Data Areas, 包含以下几个主要区域：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序计数器 (PC Register)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程私有，每个线程都有一个程序计数器，用来指示下一条将要执行的字节码指令&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Java 虚拟机栈 (Java Virtual Machine Stack)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程私有，为每个 Java 方法调用创建栈帧(Stack Frame)，存放局部变量表、操作数栈、方法返回值等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;本地方法栈 (Native Method Stack)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程私有，执行 Native 方法（JNI 等）时使用的一块栈空间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;堆 (Heap)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程共享，用于存储对象实例；现代商业虚拟机通常又将堆分为年轻代 (Young) 和老年代 (Old) 等细分区域&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;方法区 (Method Area)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程共享，用于存储类信息、运行时常量池、方法元数据 (字节码、方法声明等)&lt;/li&gt;
&lt;li&gt;运行时常量池 (Runtime Constant Pool) 也是方法区的一部分&lt;/li&gt;
&lt;li&gt;HotSpot 从 Java 8 开始用 Metaspace 来实现方法区（在此之前是 PermGen）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;线程私有 (Thread Private)
 ├─ 程序计数器 (PC Register)
 ├─ Java 虚拟机栈 (Java Virtual Machine Stack)
 │   └─ 栈帧 (Stack Frame)
 │      ├─ 局部变量表 (Local Variables)
 │      ├─ 操作数栈 (Operand Stack)
 │      └─ 方法返回值等信息
 └─ 本地方法栈 (Native Method Stack)

线程共享 (Thread Shared)
 ├─ 堆 (Heap)
 │   └─ (绝大部分对象实例都在此分配)
 └─ 方法区 (Method Area)
     └─ 运行时常量池 (Runtime Constant Pool)
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：在 JVM 规范里, “运行时常量池 (Runtime Constant Pool)” 被单独列出, 但它属于方法区的一部分.&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-jvm-specification&#34;&gt;1. JVM Specification&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html&#34;&gt;JVM Specification&lt;/a&gt; 标准并没有提到 JVM 内存结构的概念, 只有 JVM Run-Time Data Areas, 包含以下几个主要区域：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序计数器 (PC Register)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程私有，每个线程都有一个程序计数器，用来指示下一条将要执行的字节码指令&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Java 虚拟机栈 (Java Virtual Machine Stack)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程私有，为每个 Java 方法调用创建栈帧(Stack Frame)，存放局部变量表、操作数栈、方法返回值等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;本地方法栈 (Native Method Stack)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程私有，执行 Native 方法（JNI 等）时使用的一块栈空间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;堆 (Heap)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程共享，用于存储对象实例；现代商业虚拟机通常又将堆分为年轻代 (Young) 和老年代 (Old) 等细分区域&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;方法区 (Method Area)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程共享，用于存储类信息、运行时常量池、方法元数据 (字节码、方法声明等)&lt;/li&gt;
&lt;li&gt;运行时常量池 (Runtime Constant Pool) 也是方法区的一部分&lt;/li&gt;
&lt;li&gt;HotSpot 从 Java 8 开始用 Metaspace 来实现方法区（在此之前是 PermGen）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;线程私有 (Thread Private)
 ├─ 程序计数器 (PC Register)
 ├─ Java 虚拟机栈 (Java Virtual Machine Stack)
 │   └─ 栈帧 (Stack Frame)
 │      ├─ 局部变量表 (Local Variables)
 │      ├─ 操作数栈 (Operand Stack)
 │      └─ 方法返回值等信息
 └─ 本地方法栈 (Native Method Stack)

线程共享 (Thread Shared)
 ├─ 堆 (Heap)
 │   └─ (绝大部分对象实例都在此分配)
 └─ 方法区 (Method Area)
     └─ 运行时常量池 (Runtime Constant Pool)
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：在 JVM 规范里, “运行时常量池 (Runtime Constant Pool)” 被单独列出, 但它属于方法区的一部分.&lt;/p&gt;
&lt;p&gt;The Run-Time Data Areas of JVM is vary from different &lt;a href=&#34;https://docs.oracle.com/javase/specs/index.html&#34;&gt;JVM specifications&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-hotspot-实现&#34;&gt;2. HotSpot 实现&lt;/h2&gt;
&lt;p&gt;在日常调优或查看监控 (比如 &lt;code&gt;jmap -heap&lt;/code&gt;、&lt;code&gt;jconsole&lt;/code&gt;) , 我们更习惯使用&lt;strong&gt;堆 / 非堆&lt;/strong&gt;来区分内存：&lt;/p&gt;
&lt;p&gt;Heap (堆内存) 用于存放 Java 对象，按年龄或回收算法又分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;年轻代 (Young Generation)：进一步细分为 Eden、Survivor0 (S0) 和 Survivor1 (S1)&lt;/li&gt;
&lt;li&gt;老年代 (Old Generation)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Non-Heap (非堆内存) 大致包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Metaspace (方法区)：存储类元数据、运行时常量池等&lt;/li&gt;
&lt;li&gt;Code Cache (代码缓存)：存放 JIT 编译后的机器码&lt;/li&gt;
&lt;li&gt;线程栈 (Thread Stack)：包括 Java 虚拟机栈和本地方法栈，在运维角度往往也被认为不是堆的一部分&lt;/li&gt;
&lt;li&gt;Direct Memory (直接内存)：通过 &lt;code&gt;Unsafe&lt;/code&gt; 或 NIO 分配的堆外内存，不在 Java 堆里，但受 &lt;code&gt;-XX:MaxDirectMemorySize&lt;/code&gt; 限制&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;线程私有 (Thread Private)
   ├─ 程序计数器 (PC Register)
   ├─ Java 虚拟机栈 (JVM Stack)
   └─ 本地方法栈 (Native Method Stack)
   
堆 (Heap)  [线程共享]
   ├─ Young Generation (年轻代)
   │   ├─ Eden
   │   ├─ Survivor 0 (S0)
   │   └─ Survivor 1 (S1)
   └─ Old Generation (老年代)

非堆 (Non-Heap) [线程共享，笼统归类为非堆]
   ├─ Metaspace (方法区的 HotSpot 实现)
   │   └─ 存储类元数据、运行时常量池等
   ├─ Code Cache (代码缓存，JIT 编译后机器码)
   ├─ Direct Memory (直接内存，通过 NIO / Unsafe 分配)
   └─ 其它 HotSpot 自身管理的结构
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;从“是否在 Java 堆中”的角度，Metaspace、线程栈、Code Cache、Direct Memory 都被放入了 “非堆 (Non-Heap)” 这个大筐里。所以**“非堆”并不对应 JVM 规范中的某个单一概念**，而是 HotSpot 实际实现或运维时的一种统称。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在讨论 JVM 内存结构时，通常会看到两种“分类视角”：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;来自 JVM 规范 (Java Virtual Machine Specification) 的“运行时数据区 (Run-Time Data Areas)”&lt;/li&gt;
&lt;li&gt;来自 HotSpot 实现/日常运维中常用的“堆 (Heap) / 非堆 (Non-Heap)”划分&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两种视角其实是同一个问题的两种不同表述方式，不同程度地抽象了底层实现。&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>JVM 运行时常量池 - 动态链接</title>
      <link>https://blog.jiyi27.com/posts/java/basics/005-jvm-constant-pool/</link>
      <pubDate>Tue, 04 Feb 2025 08:50:26 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/java/basics/005-jvm-constant-pool/</guid>
      <description>&lt;h2 id=&#34;1-前言&#34;&gt;1. 前言&lt;/h2&gt;
&lt;p&gt;JVM 规范中只有 Run-Time Data Areas 的概念, 它的主要分类逻辑就是线程共享和线程私有区域, 而我们平时更倾向于站在堆栈传统角度对内存进行分类, 因为这样很容易理解,&lt;/p&gt;
&lt;p&gt;在 JVM 类加载过程中 Run-Time Data Areas 方法区的 Runtime Constant Pool 很重要, 相当于编译中的符号表, 在动态链接的时候主要就靠它来告诉 JVM 该类用到了哪些标准库的东西, 外部的类和函数, 去哪加载等等元数据信息, 今天就来研究一下&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Run-Time Data Areas
 └─ Method Area
     └─ Runtime Constant Pool
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;2-每个-class-文件都有一个常量池&#34;&gt;2. 每个 .class 文件都有一个常量池&lt;/h2&gt;
&lt;p&gt;在 Java 中，&lt;strong&gt;每一个 &lt;code&gt;.class&lt;/code&gt; 文件&lt;/strong&gt;里都带有一张自己的&lt;strong&gt;常量池&lt;/strong&gt;。这张常量池的存在是为了在字节码里用 “符号引用” 或 “常量” 来代替真正的类、方法、字段、字符串、数值等内容，并且让它们可以在 JVM 运行时 被 “解析” 成真实的类、方法或者对象引用。&lt;/p&gt;
&lt;p&gt;为什么每个 &lt;code&gt;.class&lt;/code&gt; 文件都有自己的常量池？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个 &lt;code&gt;.class&lt;/code&gt; 文件是一个&lt;strong&gt;独立的编译单元&lt;/strong&gt;，它可能引用不同的类、不同的方法、不同的字符串、不同的常量&lt;/li&gt;
&lt;li&gt;在 Java 编译阶段，&lt;code&gt;javac&lt;/code&gt; 会为&lt;strong&gt;该类&lt;/strong&gt;所需的一切外部引用（类、字段、方法等）和字面量&lt;strong&gt;记录到它自己的常量池&lt;/strong&gt;中&lt;/li&gt;
&lt;li&gt;当这个类加载到 JVM 里时候, 需要使用其中任何符号引用或常量，就会通过它&lt;strong&gt;自己&lt;/strong&gt;的常量池去做解析&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-看个例子&#34;&gt;3. 看个例子&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Demo&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello World&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;编译后执行 &lt;code&gt;javac Demo.java&lt;/code&gt;，得到 &lt;code&gt;Demo.class&lt;/code&gt;, 然后用 &lt;code&gt;javap -v Demo.class&lt;/code&gt; 查看其常量池部分：&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-前言&#34;&gt;1. 前言&lt;/h2&gt;
&lt;p&gt;JVM 规范中只有 Run-Time Data Areas 的概念, 它的主要分类逻辑就是线程共享和线程私有区域, 而我们平时更倾向于站在堆栈传统角度对内存进行分类, 因为这样很容易理解,&lt;/p&gt;
&lt;p&gt;在 JVM 类加载过程中 Run-Time Data Areas 方法区的 Runtime Constant Pool 很重要, 相当于编译中的符号表, 在动态链接的时候主要就靠它来告诉 JVM 该类用到了哪些标准库的东西, 外部的类和函数, 去哪加载等等元数据信息, 今天就来研究一下&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Run-Time Data Areas
 └─ Method Area
     └─ Runtime Constant Pool
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;2-每个-class-文件都有一个常量池&#34;&gt;2. 每个 .class 文件都有一个常量池&lt;/h2&gt;
&lt;p&gt;在 Java 中，&lt;strong&gt;每一个 &lt;code&gt;.class&lt;/code&gt; 文件&lt;/strong&gt;里都带有一张自己的&lt;strong&gt;常量池&lt;/strong&gt;。这张常量池的存在是为了在字节码里用 “符号引用” 或 “常量” 来代替真正的类、方法、字段、字符串、数值等内容，并且让它们可以在 JVM 运行时 被 “解析” 成真实的类、方法或者对象引用。&lt;/p&gt;
&lt;p&gt;为什么每个 &lt;code&gt;.class&lt;/code&gt; 文件都有自己的常量池？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个 &lt;code&gt;.class&lt;/code&gt; 文件是一个&lt;strong&gt;独立的编译单元&lt;/strong&gt;，它可能引用不同的类、不同的方法、不同的字符串、不同的常量&lt;/li&gt;
&lt;li&gt;在 Java 编译阶段，&lt;code&gt;javac&lt;/code&gt; 会为&lt;strong&gt;该类&lt;/strong&gt;所需的一切外部引用（类、字段、方法等）和字面量&lt;strong&gt;记录到它自己的常量池&lt;/strong&gt;中&lt;/li&gt;
&lt;li&gt;当这个类加载到 JVM 里时候, 需要使用其中任何符号引用或常量，就会通过它&lt;strong&gt;自己&lt;/strong&gt;的常量池去做解析&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-看个例子&#34;&gt;3. 看个例子&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Demo&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello World&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;编译后执行 &lt;code&gt;javac Demo.java&lt;/code&gt;，得到 &lt;code&gt;Demo.class&lt;/code&gt;, 然后用 &lt;code&gt;javap -v Demo.class&lt;/code&gt; 查看其常量池部分：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Classfile .../Demo.class
  Last modified ...; size ...
  MD5 checksum ...
public class Demo
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #7.#22         // java/io/PrintStream.println:(Ljava/lang/String;)V
   #2 = String             #23            // Hello World
   #3 = Fieldref           #8.#24         // java/lang/System.out:Ljava/io/PrintStream;
   #4 = Class              #25            // Demo
   #5 = Class              #26            // java/io/PrintStream
   #6 = Utf8               Demo
   #7 = Utf8               java/io/PrintStream
   #8 = Utf8               java/lang/System
   #9 = Utf8               main
   #10 = Utf8              ([Ljava/lang/String;)V
   #11 = Utf8              Code
   ...
   #22 = NameAndType       #27:#28        // println:(Ljava/lang/String;)V
   #23 = Utf8              Hello World
   #24 = NameAndType       #29:#30        // out:Ljava/io/PrintStream;
   #25 = Utf8              Demo
   #26 = Utf8              java/io/PrintStream
   #27 = Utf8              println
   #28 = Utf8              (Ljava/lang/String;)V
   #29 = Utf8              out
   #30 = Utf8              Ljava/io/PrintStream;
   ...
{
  public Demo();
    ...
  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #3      // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #2      // String Hello World
         5: invokevirtual #1      // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
      ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;4-常量池里都有啥&#34;&gt;4. 常量池里都有啥？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;#1 = Methodref #7.#22 // java/io/PrintStream.println:(Ljava/lang/String;)V&lt;/code&gt;
表示：这是一个 &lt;code&gt;Methodref&lt;/code&gt; 常量，指向“类 #7”与“NameAndType #22”的组合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“类 #7” 就是 &lt;code&gt;java/io/PrintStream&lt;/code&gt;（见后面 &lt;code&gt;#7 = Utf8 &amp;quot;java/io/PrintStream&amp;quot;&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;“NameAndType #22” 则表示方法名和方法描述符——在 &lt;code&gt;#22&lt;/code&gt; 里你会看到 &lt;code&gt;&amp;lt;println:(Ljava/lang/String;)V&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;#2 = String #23 // Hello World&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;表示：这是一个 &lt;code&gt;String&lt;/code&gt; 常量，对应了 “字符串 #23”；“#23” 实际是一个 &lt;code&gt;Utf8&lt;/code&gt; 条目，存放 &lt;code&gt;&amp;quot;Hello World&amp;quot;&lt;/code&gt; 的字符&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#3 = Fieldref #8.#24 // java/lang/System.out:Ljava/io/PrintStream;&lt;/code&gt;
表示：这是一个 &lt;code&gt;Fieldref&lt;/code&gt; 常量，指向“类 #8”与“NameAndType #24”的组合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“类 #8” -&amp;gt; &lt;code&gt;java/lang/System&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;“NameAndType #24” -&amp;gt; “&lt;code&gt;out:Ljava/io/PrintStream;&lt;/code&gt;”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;#22 = NameAndType #27:#28 // println:(Ljava/lang/String;)V&lt;/code&gt;
表示：这是一个 &lt;code&gt;NameAndType&lt;/code&gt; 常量，&lt;code&gt;#27&lt;/code&gt; 是方法名 &lt;code&gt;println&lt;/code&gt;，&lt;code&gt;#28&lt;/code&gt; 是方法描述符 &lt;code&gt;&amp;quot;(Ljava/lang/String;)V&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#23 = Utf8 &amp;quot;Hello World&amp;quot;&lt;/code&gt;
表示：这是一个存放字符串 &lt;code&gt;&amp;quot;Hello World&amp;quot;&lt;/code&gt; 的 &lt;code&gt;Utf8&lt;/code&gt; 常量&lt;/p&gt;
&lt;p&gt;可以看到，编译器把你写的代码里所有用到的类名、方法名、字段名、描述符以及字符串字面量，都以 各种类型的 cp_info（&lt;code&gt;Methodref&lt;/code&gt;、&lt;code&gt;Fieldref&lt;/code&gt;、&lt;code&gt;NameAndType&lt;/code&gt;、&lt;code&gt;Utf8&lt;/code&gt;、&lt;code&gt;String&lt;/code&gt; 等）记录到了同一个常量池数组里。&lt;/p&gt;
&lt;h2 id=&#34;5-这些条目在运行时怎么被用到&#34;&gt;5. 这些条目在运行时怎么被用到？&lt;/h2&gt;
&lt;p&gt;在实际运行过程中，你可以从反汇编的字节码看到：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;0: getstatic     #3      // Field java/lang/System.out:Ljava/io/PrintStream;
3: ldc           #2      // String Hello World
5: invokevirtual #1      // Method java/io/PrintStream.println:(Ljava/lang/String;)V
8: return
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;#3&lt;/code&gt;、&lt;code&gt;#2&lt;/code&gt;、&lt;code&gt;#1&lt;/code&gt; 都是&lt;strong&gt;常量池索引&lt;/strong&gt;。当 JVM 执行到这条指令时，它会到 Demo 类的常量池里找相应记录，再看看&lt;strong&gt;那条记录&lt;/strong&gt;里描述了什么类、字段或方法名、描述符，然后去解析并链接到真实的 &lt;code&gt;System.out&lt;/code&gt; 字段或 &lt;code&gt;PrintStream.println(...)&lt;/code&gt; 方法上。&lt;/p&gt;
&lt;h2 id=&#34;6-类的加载验证准备解析初始化&#34;&gt;6. 类的加载、验证、准备、解析、初始化&lt;/h2&gt;
&lt;p&gt;在 Java 中，类加载（Class Loading）之后，紧随其后（或在实际使用时触发）的过程，通常称为 类的链接（Linking）和 初始化（Initialization）。而链接过程里最关键的一步就是 解析（Resolution）。有时我们也把 在&lt;strong&gt;运行时将常量池符号引用转成直接引用&lt;/strong&gt; 称为动态链接（Dynamic Linking），因为它跟 C/C++ 的 “编译期/链接期绑定” 不一样，而是在Java 程序执行期间由 JVM 来完成。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第 4 步的解析（Resolution）往往就是我们所说的“动态链接”的核心：把&lt;strong&gt;字节码中符号形式的引用&lt;/strong&gt;——例如 “&lt;code&gt;java/lang/System&lt;/code&gt;” 、“&lt;code&gt;out&lt;/code&gt;” 、“&lt;code&gt;println&lt;/code&gt;”——&lt;strong&gt;映射到 JVM 内部真正的方法、字段、类结构&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;编译后字节码（通过 &lt;code&gt;javap -v&lt;/code&gt;）大概是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0: getstatic     #3      // Field java/lang/System.out:Ljava/io/PrintStream;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;3: ldc           #2      // String Hello World
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;5: invokevirtual #1      // Method java/io/PrintStream.println:(Ljava/lang/String;)V
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;8: return
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的 &lt;code&gt;#3&lt;/code&gt;, &lt;code&gt;#2&lt;/code&gt;, &lt;code&gt;#1&lt;/code&gt; 是常量池索引, 当 JVM 在解释或JIT 编译这些指令时，如果某个索引还没解析，就会触发解析逻辑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解析 &lt;code&gt;#3&lt;/code&gt; (getstatic …)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;#3&lt;/code&gt; 在常量池中是一个 &lt;code&gt;Fieldref&lt;/code&gt;，比如 “&lt;code&gt;java/lang/System.out:Ljava/io/PrintStream;&lt;/code&gt;”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JVM 首先看 这个类 &lt;code&gt;java/lang/System&lt;/code&gt; 加载了没？如果没有，就让 Bootstrap ClassLoader 去加载并验证、准备（以及后续可能触发解析和初始化）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找到它后，在 &lt;code&gt;java.lang.System&lt;/code&gt; 的元数据里查找名为 &lt;code&gt;out&lt;/code&gt;、描述符 &lt;code&gt;Ljava/io/PrintStream;&lt;/code&gt;、并且是 &lt;code&gt;static&lt;/code&gt; 的字段&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若能找到，就把这个常量池引用标记为已解析，并存储一个指向 &lt;code&gt;System.out&lt;/code&gt; 字段的内部标识（可能是一个指针/偏移量）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;此时还要检查 &lt;code&gt;System&lt;/code&gt; 类是否已经初始化过。如果没初始化，就先初始化 &lt;code&gt;System&lt;/code&gt;（调用其 &lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt;）。在 &lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt; 里会将 &lt;code&gt;System.out&lt;/code&gt; 赋值为一个新的 &lt;code&gt;PrintStream&lt;/code&gt; 对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行 &lt;code&gt;getstatic #3&lt;/code&gt; 时，JVM 发现“已解析”，就能直接去拿 &lt;code&gt;System.out&lt;/code&gt; 这个静态字段的对象引用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2.2 解析 &lt;code&gt;#2&lt;/code&gt; (ldc …)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#2&lt;/code&gt; 在常量池中是一个 &lt;code&gt;String&lt;/code&gt; 类型常量，如 “Hello World”&lt;/li&gt;
&lt;li&gt;当执行 &lt;code&gt;ldc #2&lt;/code&gt; 时，如果还没解析，就去常量池里取出对应的 UTF-8 字符串，将其intern或放到字符串池，生成一个 &lt;code&gt;java.lang.String&lt;/code&gt; 实例（或从已有字符串池中返回）&lt;/li&gt;
&lt;li&gt;然后把这个 &lt;code&gt;String&lt;/code&gt; 对象引用压栈，用于后续 &lt;code&gt;println&lt;/code&gt; 调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2.3 解析 &lt;code&gt;#1&lt;/code&gt; (invokevirtual …)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#1&lt;/code&gt; 在常量池是一个 &lt;code&gt;Methodref&lt;/code&gt;，如 “&lt;code&gt;java/io/PrintStream.println:(Ljava/lang/String;)V&lt;/code&gt;”&lt;/li&gt;
&lt;li&gt;JVM 会检查 &lt;code&gt;java.io.PrintStream&lt;/code&gt; 这个类加载了吗？没的话，去加载它&lt;/li&gt;
&lt;li&gt;在它的元数据里找到对应的方法表项 &lt;code&gt;println(String)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;若找到，就把常量池条目更新为已解析，后续执行指令 &lt;code&gt;invokevirtual #1&lt;/code&gt; 时，就能通过对象的类型信息 + 方法表来跳转到 &lt;code&gt;PrintStream.println(String)&lt;/code&gt; 的实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上步骤就是“解析 + 动态链接”最本质的行为：从常量池的“符号引用”（例如 “&lt;code&gt;Field java/lang/System.out&lt;/code&gt;” 或 “&lt;code&gt;Method java/io/PrintStream.println&lt;/code&gt;”）转成 JVM 内部可执行、可定位的实际字段或方法引用&lt;/p&gt;
&lt;h2 id=&#34;7-动态链接-vs-静态链接&#34;&gt;7. 动态链接 VS. 静态链接&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;静态链接（C/C++）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译和链接器阶段就把对 &lt;code&gt;printf&lt;/code&gt; 等函数的调用解析到某个符号表里，生成可执行文件，运行时再由 OS 的动态加载器做符号重定位，最终把 &lt;code&gt;printf&lt;/code&gt; 的地址映射到可执行程序里。&lt;/li&gt;
&lt;li&gt;也就是说，C/C++ 大部分链接工作在编译期/链接期就做好了，运行时只剩下操作系统层面的动态库装载、重定位&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Java 的动态链接&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;.class&lt;/code&gt; 文件只保留对 &lt;code&gt;System.out&lt;/code&gt;、&lt;code&gt;println(String)&lt;/code&gt; 等的符号引用&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;真正的解析、绑定过程在JVM 运行时发生：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;加载对应的类（可能还要加载该类所依赖的其他类），&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;验证和准备，&lt;/li&gt;
&lt;li&gt;在用到这些常量池引用时触发“解析”，最终把它指向 JVM 内部的真实方法或字段对象&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;这使得 Java 可以做到“类的动态加载”：运行中可以从网络或别的地方得到一个 &lt;code&gt;.class&lt;/code&gt;，用自定义 ClassLoader 加载并解析它。而不需要像 C++ 一样必须在编译/链接时就知道所有符号&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>Pass by Value or Reference</title>
      <link>https://blog.jiyi27.com/posts/cs-basics/001-pass-by-value-reference/</link>
      <pubDate>Tue, 28 Nov 2023 23:02:06 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/cs-basics/001-pass-by-value-reference/</guid>
      <description>&lt;h2 id=&#34;1-python&#34;&gt;1. Python&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;test_function&lt;/span&gt;(x, y):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    x &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    y&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    test_function(a, b)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;a =&amp;#34;&lt;/span&gt;, a)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;b =&amp;#34;&lt;/span&gt;, b)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;main()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Output:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;If you pass a &lt;em&gt;mutable&lt;/em&gt; object into a method, the method gets a reference to that same object and you can mutate it to your heart&amp;rsquo;s delight, but if you rebind the reference in the method, the outer scope will know nothing about it, and after you&amp;rsquo;re done, the outer reference will still point at the original object.&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-python&#34;&gt;1. Python&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;test_function&lt;/span&gt;(x, y):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    x &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    y&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    test_function(a, b)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;a =&amp;#34;&lt;/span&gt;, a)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;b =&amp;#34;&lt;/span&gt;, b)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;main()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Output:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;If you pass a &lt;em&gt;mutable&lt;/em&gt; object into a method, the method gets a reference to that same object and you can mutate it to your heart&amp;rsquo;s delight, but if you rebind the reference in the method, the outer scope will know nothing about it, and after you&amp;rsquo;re done, the outer reference will still point at the original object.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;integer, str are immutable objects in Python&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If you pass an &lt;em&gt;immutable&lt;/em&gt; object to a method, you still can&amp;rsquo;t rebind the outer reference, and you can&amp;rsquo;t even mutate the object.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; def main&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...     n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;9001&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...     print&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;f&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Initial address of n: {id(n)}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...     increment&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;n&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...     print&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;f&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;  Final address of n: {id(n)}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; def increment&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;x&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...     print&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;f&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Initial address of x: {id(x)}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...     x &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...     print&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;f&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;  Final address of x: {id(x)}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; main&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Initial address of n: &lt;span style=&#34;color:#ae81ff&#34;&gt;140562586057840&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Initial address of x: &lt;span style=&#34;color:#ae81ff&#34;&gt;140562586057840&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Final address of x: &lt;span style=&#34;color:#ae81ff&#34;&gt;140562586057968&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Final address of n: &lt;span style=&#34;color:#ae81ff&#34;&gt;140562586057840&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;2-javascript&#34;&gt;2. Javascript&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;changeStuff&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;item&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;changed&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#a6e22e&#34;&gt;item&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;changed&amp;#34;&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;num&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;obj1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#a6e22e&#34;&gt;item&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;unchanged&amp;#34;&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;obj2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#a6e22e&#34;&gt;item&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;unchanged&amp;#34;&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;changeStuff&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;num&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;obj1&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;obj2&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;num&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;obj1&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;item&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;obj2&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;item&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This produces the output:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-none&#34; data-lang=&#34;none&#34;&gt;10
changed
unchanged
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;3-golang-java-c--javascript&#34;&gt;3. Golang, Java, C++ &amp;amp; Javascript&lt;/h2&gt;
&lt;p&gt;Python, Java, C++ and JS are all pass by value, but they do have references. When you assign or pass a reference-type, the copied value is still the value of the reference, namely the address, giving us the illusion of &amp;ldquo;pass by reference not value.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;C++ has another application where passing const references is preferred to enhance efficiency. However, in Java, Python, and JS, references are passed every time, but they lack the concept of const references.&lt;/p&gt;
&lt;p&gt;Actually Golang doesn&amp;rsquo;t have reference type (all are values), reference type often refers to the maps, slice, channels and strings in Golang which are pointers themselves or a struct holding a pointer to the underlying data structure.&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Data Types in Programming Languages</title>
      <link>https://blog.jiyi27.com/posts/cs-basics/001-data-types-programming-language/</link>
      <pubDate>Tue, 28 Nov 2023 20:50:06 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/cs-basics/001-data-types-programming-language/</guid>
      <description>&lt;h2 id=&#34;1-javascript&#34;&gt;1. Javascript&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;As you have know that javascript is a dynamic language from &lt;a href=&#34;https://davidzhu.xyz/post/other/000-languge-types-practice/&#34;&gt;previous post&lt;/a&gt;, which means the values have types, not variables.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Javascript value types can be categorized into two main categories: &lt;strong&gt;objects&lt;/strong&gt; and &lt;strong&gt;primitives&lt;/strong&gt;. Among these types, the &lt;strong&gt;objects are mutable&lt;/strong&gt;, which means their values can be modified or changed after they are created. On the other hand, the &lt;strong&gt;primitive types are immutable&lt;/strong&gt;, meaning their values cannot be changed once they are assigned.&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-javascript&#34;&gt;1. Javascript&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;As you have know that javascript is a dynamic language from &lt;a href=&#34;https://davidzhu.xyz/post/other/000-languge-types-practice/&#34;&gt;previous post&lt;/a&gt;, which means the values have types, not variables.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Javascript value types can be categorized into two main categories: &lt;strong&gt;objects&lt;/strong&gt; and &lt;strong&gt;primitives&lt;/strong&gt;. Among these types, the &lt;strong&gt;objects are mutable&lt;/strong&gt;, which means their values can be modified or changed after they are created. On the other hand, the &lt;strong&gt;primitive types are immutable&lt;/strong&gt;, meaning their values cannot be changed once they are assigned.&lt;/p&gt;
&lt;h3 id=&#34;11-primitive-types&#34;&gt;1.1. Primitive types&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;Type&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;&lt;code&gt;typeof&lt;/code&gt; return value&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;Object wrapper&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#null_type&#34;&gt;Null&lt;/a&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;code&gt;&amp;quot;object&amp;quot;&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;N/A&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#undefined_type&#34;&gt;Undefined&lt;/a&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;code&gt;&amp;quot;undefined&amp;quot;&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;N/A&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#boolean_type&#34;&gt;Boolean&lt;/a&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;code&gt;&amp;quot;boolean&amp;quot;&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean&#34;&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#number_type&#34;&gt;Number&lt;/a&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;code&gt;&amp;quot;number&amp;quot;&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number&#34;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#bigint_type&#34;&gt;BigInt&lt;/a&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;code&gt;&amp;quot;bigint&amp;quot;&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt&#34;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#string_type&#34;&gt;String&lt;/a&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;code&gt;&amp;quot;string&amp;quot;&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String&#34;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#symbol_type&#34;&gt;Symbol&lt;/a&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;code&gt;&amp;quot;symbol&amp;quot;&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol&#34;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;All primitive types, except &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/null&#34;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined&#34;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt;, have their corresponding object wrapper types, which provide useful methods for working with the primitive values. For example, the &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number&#34;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt; object provides methods like &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toExponential&#34;&gt;&lt;code&gt;toExponential()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;All primitive types, except &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/null&#34;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt;, can be tested by the &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof&#34;&gt;&lt;code&gt;typeof&lt;/code&gt;&lt;/a&gt; operator. &lt;code&gt;typeof null&lt;/code&gt; returns &lt;code&gt;&amp;quot;object&amp;quot;&lt;/code&gt;, so one has to use &lt;code&gt;=== null&lt;/code&gt; to test for &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;12-object-types&#34;&gt;1.2. Object types&lt;/h3&gt;
&lt;p&gt;Learn more:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://davidzhu.xyz/post/js/basics/001-javascript-basics/&#34;&gt;Objects &amp;amp; Collections in Javascript - David&amp;rsquo;s Blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures&#34;&gt;JavaScript data types and data structures - JavaScript | MDN&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-python&#34;&gt;2. Python&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Python is a dynamic language which means &lt;strong&gt;the values have types, not variables&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In Python &lt;strong&gt;all values are objects&lt;/strong&gt;, so doesn&amp;rsquo;t like Java, there is no primitives, &lt;strong&gt;all variable are references&lt;/strong&gt;. (Variables are associated with values, values have types)&lt;/p&gt;
&lt;h3 id=&#34;21-data-types&#34;&gt;2.1. Data types&lt;/h3&gt;
&lt;p&gt;Python has the following data types built-in by default, in these categories:&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;Text Type:&lt;/th&gt;
          &lt;th&gt;&lt;code&gt;str&lt;/code&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Numeric Types:&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;complex&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Sequence Types:&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;list&lt;/code&gt;, &lt;code&gt;tuple&lt;/code&gt;, &lt;code&gt;range&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Mapping Type:&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;dict&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Set Types:&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;set&lt;/code&gt;, &lt;code&gt;frozenset&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Boolean Type:&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Binary Types:&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;bytes&lt;/code&gt;, &lt;code&gt;bytearray&lt;/code&gt;, &lt;code&gt;memoryview&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;None Type:&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;NoneType&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;22-mutable-and-immutable-objects&#34;&gt;2.2. Mutable and immutable objects&lt;/h3&gt;
&lt;p&gt;Everything in Python is an object. And all objects in Python can be either &lt;strong&gt;mutable&lt;/strong&gt; or &lt;strong&gt;immutable&lt;/strong&gt;. Mutable objects are those that allow you to change their value or data in place without affecting the object’s identity. In contrast, immutable objects don’t allow this kind of operation, you have to create a new objects of the same type with different values.&lt;/p&gt;
&lt;p&gt;Objects of built-in types like (&lt;em&gt;&lt;strong&gt;int&lt;/strong&gt;, float, bool, &lt;strong&gt;str&lt;/strong&gt;, tuple, unicode&lt;/em&gt;) are immutable. Objects of built-in types like (&lt;em&gt;list, set, dict&lt;/em&gt;) are mutable. Custom classes are generally mutable.&lt;/p&gt;
&lt;p&gt;Find &lt;a href=&#34;https://stackoverflow.com/a/62177555/16317008&#34;&gt;a good explanation&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The integer is immutable. When you write x=5, x points to a memory location that holds 5. When you go on and code y=x, the variable y points to the same location as x.&lt;/p&gt;
&lt;p&gt;Then you type x+1=6, and now x points to a new location that holds 6, and not the previous location. ( Here, the integer still holds immutable because the original integer 5 still exists, but the variable x is not bound to it now. x is now bound to a new location. But y is still bound to the integer 5)&lt;/p&gt;
&lt;p&gt;But y still points to the same location that holds 5. So, integers are still immutable and this is how it works. To see it better, use id(x) or id(y) after every step.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The &lt;em&gt;variable&lt;/em&gt; is not immutable; the &lt;code&gt;int&lt;/code&gt; object &lt;em&gt;referred to&lt;/em&gt; by the variable is.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;3-java&#34;&gt;3. Java&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Java is a static language which means &lt;strong&gt;the variable have types, not values have types&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Types of variables in Java are divided into two categories—&lt;strong&gt;primitive types&lt;/strong&gt; and &lt;strong&gt;reference types&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pub-2a6758f3b2d64ef5bb71ba1601101d35.r2.dev/blogs/2025/01/abfa9bf89da62c46a77ca56b5f3cd477.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;31-primitive-types&#34;&gt;3.1. Primitive types&lt;/h3&gt;
&lt;p&gt;The primitive types are &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt;. All other types are reference types.&lt;/p&gt;
&lt;p&gt;• A primitive-type variable can store exactly one value of its declared type at a time.&lt;/p&gt;
&lt;p&gt;• Primitive-type instance variables are initialized by default. Variables of types &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; are initialized to &lt;code&gt;0&lt;/code&gt;. Variables of type &lt;code&gt;boolean&lt;/code&gt; are initialized to &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;32-reference-types&#34;&gt;3.2. Reference types&lt;/h3&gt;
&lt;p&gt;Reference types in Java are non-primitive data types. It&amp;rsquo;s called reference ecause it holds &lt;strong&gt;the memory address&lt;/strong&gt; (or reference) of the objects.&lt;/p&gt;
&lt;p&gt;In Java, &lt;strong&gt;all objects&lt;/strong&gt; are allocated on Heap. This is different from C++ where objects can be allocated memory either on Stack or on Heap.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Whenever you use &lt;code&gt;new&lt;/code&gt;, an object is created on the heap.&lt;/li&gt;
&lt;li&gt;Local variables are stored on the stack. That includes primitives (such as &lt;code&gt;int&lt;/code&gt;) and the &lt;strong&gt;references&lt;/strong&gt; to any objects created. The actual objects themselves aren&amp;rsquo;t created on the stack, as I mentioned when you use &lt;code&gt;new&lt;/code&gt; they&amp;rsquo;ll be created on the heap. &lt;a href=&#34;https://stackoverflow.com/a/8061692/16317008&#34;&gt;https://stackoverflow.com/a/8061692/16317008&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// variable age: primitive, stored on stack&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; age &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 77;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// variable person: reference, stored on stack, &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// its value is the address of the object stored on heap&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Person person &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Person();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://pub-2a6758f3b2d64ef5bb71ba1601101d35.r2.dev/blogs/2025/01/1f7623bcd0db262e0068e1a64d9699ec.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Just as men and women are fundamentally different (according to John Gray, author of Men Are from Mars, Women Are from Venus), &lt;strong&gt;primitive variables&lt;/strong&gt; and &lt;strong&gt;object reference variables&lt;/strong&gt; differ from each other in multiple ways. The basic difference is that &lt;strong&gt;primitive variables store the actual values&lt;/strong&gt;, whereas reference variables store the addresses of the objects they refer to. Let’s assume that a class Person is already defined. If you create an int variable a, and an object reference variable person, they will store their values in memory as shown in figure 2.13. &lt;a href=&#34;https://stackoverflow.com/a/32049775/16317008&#34;&gt;https://stackoverflow.com/a/32049775/16317008&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note that similar to Python, strings in Java are objects, and they are immutable.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;4-golang&#34;&gt;4. Golang&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Golang is static language,  golang has no concept of object, all are values. So you can think the variable have types or values have types, all are fine.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Golang has no refernce-type, all are values. But there is a concept of pointer, some types like &lt;code&gt;slice&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;channel&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt; which are a pointer or a struct that has a pointer element, we usually catagorize them as reference-type.&lt;/p&gt;
&lt;h2 id=&#34;5-c&#34;&gt;5. C++&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;C++ is a static language which means &lt;strong&gt;the variable have types, not values have types&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;C++ has variable, reference and object. A &lt;strong&gt;variable&lt;/strong&gt; is a named object that can hold a value of a specific data type. A &lt;strong&gt;reference&lt;/strong&gt; is an alias for a variable, which means that it refers to the same memory location as the variable it is referencing.  An &lt;strong&gt;object&lt;/strong&gt; is used to store a value in memory.&lt;/p&gt;
&lt;p&gt;A variable is an object that has a name (identifier). Naming our objects let us refer to them again later in the program. Although objects in C++ can be unnamed (anonymous), more often we name our objects using an identifier. An object with a name is called a &lt;strong&gt;variable&lt;/strong&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x; &lt;span style=&#34;color:#75715e&#34;&gt;// define a variable named x, of type int
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;In C++, we use objects to access memory. A named object is called a variable. Variables have an identifier, a type, and a value (and some other attributes that aren’t relevant here). A variable’s type is used to determine how the value in memory should be interpreted.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;You can think of RAM as a series of numbered boxes that can be used to store data while the program is running. In some older programming languages (like Applesoft BASIC), you could directly access these boxes (e.g. you could write a statement to “go get the value stored in mailbox number 7532”).  In C++, direct memory access is discouraged. Instead, we access memory indirectly through an object. An &lt;strong&gt;object&lt;/strong&gt; is a region of storage (usually memory) that can store a value, and has other associated properties.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.learncpp.com/cpp-tutorial/introduction-to-objects-and-variables/&#34;&gt;1.3 — Introduction to objects and variables – Learn C++&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;6-conclusion&#34;&gt;6. Conclusion&lt;/h2&gt;
&lt;p&gt;Variables, values, types, the concepts of these terms may a little different. Don&amp;rsquo;t need to remember what exactly these terms mean in each language, our goal is to know the behavior of the language so that we can use the language correctly and efficiently. Such as pass by value or reference, and if can return a reference of a locla variable.&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Typing in Programming Language</title>
      <link>https://blog.jiyi27.com/posts/cs-basics/000-languge-types-design/</link>
      <pubDate>Tue, 28 Nov 2023 20:30:17 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/cs-basics/000-languge-types-design/</guid>
      <description>&lt;h2 id=&#34;1-compiled-vs-interpreted-language&#34;&gt;1. Compiled vs interpreted language&lt;/h2&gt;
&lt;p&gt;Programming languages are for humans to read and understand. The program (source code) must be translated into machine language so that the computer can execute the program. &lt;strong&gt;The time when this translation occurs&lt;/strong&gt; depends on whether the programming language is a &lt;strong&gt;compiled language&lt;/strong&gt; or an &lt;strong&gt;interpreted language&lt;/strong&gt;. Instead of translating the source code into machine language before the executable file is created, an interpreter converts the source code into machine language at the same time the program runs. So you can&amp;rsquo;t say a language doesn’t have compilation step, because any language needs to be translated to machine code.&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-compiled-vs-interpreted-language&#34;&gt;1. Compiled vs interpreted language&lt;/h2&gt;
&lt;p&gt;Programming languages are for humans to read and understand. The program (source code) must be translated into machine language so that the computer can execute the program. &lt;strong&gt;The time when this translation occurs&lt;/strong&gt; depends on whether the programming language is a &lt;strong&gt;compiled language&lt;/strong&gt; or an &lt;strong&gt;interpreted language&lt;/strong&gt;. Instead of translating the source code into machine language before the executable file is created, an interpreter converts the source code into machine language at the same time the program runs. So you can&amp;rsquo;t say a language doesn’t have compilation step, because any language needs to be translated to machine code.&lt;/p&gt;
&lt;h2 id=&#34;2-statically-vs-dynamically-typing&#34;&gt;2. Statically vs dynamically typing&lt;/h2&gt;
&lt;p&gt;Also know as statically/dynamically typed, &lt;strong&gt;static/dynamic language&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Static Typing:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;In statically typed languages, the type of a variable is known at compile time.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The programmer must explicitly declare the data type of each variable.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Examples of statically typed languages include Java, C, C++, and Go.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Static typing allows for early detection of type-related errors during the compilation process.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dynamic Typing:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In dynamically typed languages, the type of a variable is determined at runtime.&lt;/li&gt;
&lt;li&gt;The programmer does not need to explicitly declare the data type of each variable.&lt;/li&gt;
&lt;li&gt;Examples of dynamically typed languages include Python, JavaScript, Ruby, and PHP.&lt;/li&gt;
&lt;li&gt;Type checking occurs during runtime, which means that type-related errors may only be discovered when the code is executed.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For example in Java:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;String str = &amp;#34;Hello&amp;#34;;  //statically typed as string
str = 5;               //would throw an error since java is statically typed
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Whereas in a &lt;strong&gt;dynamically typed language&lt;/strong&gt; the type is &lt;em&gt;dynamic&lt;/em&gt;, meaning after you set a variable to a type, you CAN change it. That is because typing is associated with the value rather than the variable. For example in Python:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;str = &amp;#34;Hello&amp;#34; # it is a string
str = 5       # now it is an integer; perfectly OK
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;3-strong-vs-weak-typing&#34;&gt;3. Strong vs weak typing&lt;/h2&gt;
&lt;p&gt;The strong/weak typing in a language is related to &lt;strong&gt;implicit type conversions&lt;/strong&gt; (partly taken from @Dario&amp;rsquo;s answer):&lt;/p&gt;
&lt;p&gt;For example in Python:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;str = 5 + &amp;#34;hello&amp;#34; 
# would throw an error since it does not want to cast one type to the other implicitly. 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;whereas in PHP:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$str = 5 + &amp;#34;hello&amp;#34;; // equals 5 because &amp;#34;hello&amp;#34; is implicitly casted to 0 
// PHP is weakly typed, thus is a very forgiving language.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Static typing allows for checking type correctness at compile time. Statically typed languages are usually compiled, and dynamically typed languages are interpreted. Therefore, dynamicly typed languages can check typing at run time.&lt;/p&gt;
&lt;p&gt;Source: &lt;a href=&#34;https://stackoverflow.com/a/34004765/16317008&#34;&gt;https://stackoverflow.com/a/34004765/16317008&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;4-conclusion&#34;&gt;4. Conclusion&lt;/h2&gt;
&lt;p&gt;Dynamically typing languages (where type checking happens at run time) can also be strongly typed (Python for example).&lt;/p&gt;
&lt;p&gt;Note that in dynamically checking languages, &lt;strong&gt;values have types&lt;/strong&gt;, not variables (have types). Whereas, in statically checking languages, variables have types.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Static/Dynamic Typing&lt;/em&gt; is about &lt;strong&gt;when&lt;/strong&gt; type information is acquired (Either at compile time or at runtime)&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Strong/Weak Typing&lt;/em&gt; is about &lt;strong&gt;how strictly&lt;/strong&gt; types are distinguished (e.g. whether the language tries to do an implicit conversion from strings to numbers).&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    </item>
    
    <item>
      <title>Typing in Programming Language - Example</title>
      <link>https://blog.jiyi27.com/posts/cs-basics/000-languge-types-practice/</link>
      <pubDate>Tue, 28 Nov 2023 19:20:17 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/cs-basics/000-languge-types-practice/</guid>
      <description>&lt;h2 id=&#34;1-javascript&#34;&gt;1. Javascript&lt;/h2&gt;
&lt;p&gt;JavaScript is a dynamic language with dynamic types. Variables in JavaScript are not directly associated with any particular value type, and any variable can be assigned (and re-assigned) values of all types:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// foo is now a number
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;bar&amp;#34;&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// foo is now a string
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// foo is now a boolean
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This is in dynamic languages (dynamically typing), values have types, not variables.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You don&amp;rsquo;t need know what is &lt;strong&gt;dynamic languages&lt;/strong&gt;, you just need know values have types, not variables.&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-javascript&#34;&gt;1. Javascript&lt;/h2&gt;
&lt;p&gt;JavaScript is a dynamic language with dynamic types. Variables in JavaScript are not directly associated with any particular value type, and any variable can be assigned (and re-assigned) values of all types:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// foo is now a number
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;bar&amp;#34;&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// foo is now a string
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// foo is now a boolean
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This is in dynamic languages (dynamically typing), values have types, not variables.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You don&amp;rsquo;t need know what is &lt;strong&gt;dynamic languages&lt;/strong&gt;, you just need know values have types, not variables.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JavaScript is also a &lt;strong&gt;weakly typed&lt;/strong&gt; language, which means it allows implicit type conversion when an operation involves mismatched types, instead of throwing type errors.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// foo is a number
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;result&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// JavaScript coerces foo to a string, so it can be concatenated with the other operand
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;result&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 421
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;As you can see, &lt;strong&gt;weakly typed&lt;/strong&gt; language means it allows implicit type conversion when an operation involves mismatched types, instead of throwing type errors.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-python&#34;&gt;2. Python&lt;/h2&gt;
&lt;p&gt;Python is dynamic language, and is strongly typed.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;bob &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;bob &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;bob&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This works because the variable does not have a type; it can name any object. After &lt;code&gt;bob=1&lt;/code&gt;, you&amp;rsquo;ll find that &lt;code&gt;type(bob)&lt;/code&gt; returns &lt;code&gt;int&lt;/code&gt;, but after &lt;code&gt;bob=&amp;quot;bob&amp;quot;&lt;/code&gt;, it returns &lt;code&gt;str&lt;/code&gt;. (Note that &lt;code&gt;type&lt;/code&gt; is a regular function, so it evaluates its argument, then returns the type of the value.)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Attempting to add a string and an integer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;string_var &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;integer_var &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# This line will result in a TypeError&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; string_var &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; integer_var
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;3-cc&#34;&gt;3. C/C++&lt;/h2&gt;
&lt;p&gt;Bbviously, they are static language, but strong or weak?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It&amp;rsquo;s hard to classify every language into &amp;lsquo;weakly&amp;rsquo; or &amp;lsquo;strongly&amp;rsquo; typed &amp;ndash; it&amp;rsquo;s more of a continuum. But, in comparison to other languages, C is fairly strongly typed. Every object has a compile-time type, and the compiler will let you know (loudly) if you&amp;rsquo;re doing something with an object that its type doesn&amp;rsquo;t let you do. For example, you can&amp;rsquo;t call functions with the wrong types of parameters, access struct/union members which don&amp;rsquo;t exist, etc.&lt;/p&gt;
&lt;p&gt;But there are a few weaknesses. One major weakness is typecasts - they essentially say that you&amp;rsquo;re going to be mucking around with the types of objects, and the compiler should be quiet (when it can). &lt;code&gt;void*&lt;/code&gt; is also another weakness &amp;ndash; it&amp;rsquo;s a generic pointer to an unknown type, and when you use them, you have to be extra careful that you&amp;rsquo;re doing the right thing. The compiler can&amp;rsquo;t statically check most uses of &lt;code&gt;void*&lt;/code&gt;. &lt;code&gt;void*&lt;/code&gt; can also be converted to a pointer to any type without a cast (only in C, not in C++), which is another weakness.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/a/430204/16317008&#34;&gt;https://stackoverflow.com/a/430204/16317008&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;4-java&#34;&gt;4. Java&lt;/h2&gt;
&lt;p&gt;Java is static and strongly typed.&lt;/p&gt;
&lt;p&gt;In Java or C/C++, every variable must have a declared type, and the type is checked at compile-time. Once a variable is declared with a specific type, it cannot be assigned a value of a different type. Here&amp;rsquo;s an example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; num &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 10; &lt;span style=&#34;color:#75715e&#34;&gt;// The variable &amp;#39;num&amp;#39; is declared as an integer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;num &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello&amp;#34;&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// This will result in a compilation error because we are trying to assign a string to an integer variable&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Strongly Typed: Java is also a strongly typed language, which means that type conversions or implicit type coercion are limited. In Java, you cannot perform operations between incompatible types without explicitly converting them. Here&amp;rsquo;s an example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; num1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 10;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;String str &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;20&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; num1 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; str; &lt;span style=&#34;color:#75715e&#34;&gt;// This will result in a compilation error because we are trying to add an integer and a string without explicit conversion&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;4-golang&#34;&gt;4. Golang&lt;/h2&gt;
&lt;p&gt;Golang is indeed a static and strongly typed language:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3.2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// invalid operation: a + b (mismatched types int and float64)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
    </item>
    
    <item>
      <title>java.lang.Object &amp; java.lang.Class</title>
      <link>https://blog.jiyi27.com/posts/java/basics/006-reflection/</link>
      <pubDate>Sat, 05 Aug 2023 19:47:51 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/java/basics/006-reflection/</guid>
      <description>&lt;h2 id=&#34;1-javalangobject&#34;&gt;1. &lt;code&gt;java.lang.Object&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;定义:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Object&lt;/span&gt; {...}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;java.lang.Object&lt;/code&gt; class is the root of the class hierarchy. Every class has &lt;code&gt;Object&lt;/code&gt; as a superclass. 所有的类(包括自定义类)都自动继承了类 &lt;code&gt;java.lang.Object&lt;/code&gt;, 你可以自己创建个类, 然后查看其对象可调用的方法, 如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.jiyi27.com/002-reflection-object-class/1.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到一些方法如 &lt;code&gt;equals()&lt;/code&gt;, &lt;code&gt;getClass()&lt;/code&gt;, 这都是 &lt;code&gt;Cat&lt;/code&gt; 继承自类 &lt;code&gt;Object&lt;/code&gt; 所得,&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; Class&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; getClass()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;了解更多: &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html&#34;&gt;Object (Java Platform SE 8 )&lt;/a&gt;,&lt;/p&gt;
&lt;h2 id=&#34;2--javalangclass&#34;&gt;2. &lt;code&gt; java.lang.Class&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Class&lt;/code&gt; 定义如下 (注意区分 &lt;code&gt;Class&lt;/code&gt; 和 &lt;code&gt;class&lt;/code&gt;, 前者是类, 后者是关键字):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; Object
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;implements&lt;/span&gt; Serializable, GenericDeclaration, Type, AnnotatedElement
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;与 &lt;code&gt;java.lang.Objetc&lt;/code&gt; 不同, &lt;code&gt;java.lang.Class&lt;/code&gt; 是 &lt;code&gt;final &lt;/code&gt;的, 所以没有类可以继承它, 而且它唯一的构造函数是私有的, 这意味着我们不能通过正常的方式来创建 &lt;code&gt;Class&lt;/code&gt; 的对象.&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-javalangobject&#34;&gt;1. &lt;code&gt;java.lang.Object&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;定义:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Object&lt;/span&gt; {...}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;java.lang.Object&lt;/code&gt; class is the root of the class hierarchy. Every class has &lt;code&gt;Object&lt;/code&gt; as a superclass. 所有的类(包括自定义类)都自动继承了类 &lt;code&gt;java.lang.Object&lt;/code&gt;, 你可以自己创建个类, 然后查看其对象可调用的方法, 如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.jiyi27.com/002-reflection-object-class/1.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到一些方法如 &lt;code&gt;equals()&lt;/code&gt;, &lt;code&gt;getClass()&lt;/code&gt;, 这都是 &lt;code&gt;Cat&lt;/code&gt; 继承自类 &lt;code&gt;Object&lt;/code&gt; 所得,&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; Class&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; getClass()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;了解更多: &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html&#34;&gt;Object (Java Platform SE 8 )&lt;/a&gt;,&lt;/p&gt;
&lt;h2 id=&#34;2--javalangclass&#34;&gt;2. &lt;code&gt; java.lang.Class&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Class&lt;/code&gt; 定义如下 (注意区分 &lt;code&gt;Class&lt;/code&gt; 和 &lt;code&gt;class&lt;/code&gt;, 前者是类, 后者是关键字):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; Object
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;implements&lt;/span&gt; Serializable, GenericDeclaration, Type, AnnotatedElement
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;与 &lt;code&gt;java.lang.Objetc&lt;/code&gt; 不同, &lt;code&gt;java.lang.Class&lt;/code&gt; 是 &lt;code&gt;final &lt;/code&gt;的, 所以没有类可以继承它, 而且它唯一的构造函数是私有的, 这意味着我们不能通过正常的方式来创建 &lt;code&gt;Class&lt;/code&gt; 的对象.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意 &lt;code&gt;java.lang.Class&lt;/code&gt;  是泛型类, 因此我们经常可以见到类似 &lt;code&gt;Class&amp;lt;?&amp;gt; xxx = cat.getClass()&lt;/code&gt;  的声明,&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;21--javalangclass-为何存在&#34;&gt;2.1. &lt;code&gt; java.lang.Class&lt;/code&gt; 为何存在&lt;/h3&gt;
&lt;p&gt;其实刚开始一直想不明白类 &lt;code&gt;java.lang.Class&lt;/code&gt; 到底是什么, 为什么存在?&lt;/p&gt;
&lt;p&gt;因为在我的印象里, 一个泛型类一般都是作为 collection 存在, 如 &lt;code&gt;ArrayList&lt;/code&gt;, &lt;code&gt;List&lt;/code&gt; 等, 他们使用泛型是为了代码的 reuse, 比如存 string, Integer, 等, 但是 &lt;code&gt;java.lang.Class&lt;/code&gt; 呢? 它又不是 collection, 为什么要用泛型呢?&lt;/p&gt;
&lt;p&gt;我现在的理解是 &lt;code&gt;java.lang.Class&lt;/code&gt;  是一个类的包装器, 也是为了代码的 reuse, 查看 &lt;code&gt;java.lang.Class&lt;/code&gt;  的方法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;getClassLoader(), getDeclaredMethods(), getFields()&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Employee&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; Person {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Main&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args) &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; NoSuchFieldException {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Class&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; myClass &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Employee.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Name: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; myClass.&lt;span style=&#34;color:#a6e22e&#34;&gt;getName&lt;/span&gt;());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Simple name: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; myClass.&lt;span style=&#34;color:#a6e22e&#34;&gt;getSimpleName&lt;/span&gt;());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Superclass: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; myClass.&lt;span style=&#34;color:#a6e22e&#34;&gt;getSuperclass&lt;/span&gt;());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Interfaces: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; Arrays.&lt;span style=&#34;color:#a6e22e&#34;&gt;toString&lt;/span&gt;(myClass.&lt;span style=&#34;color:#a6e22e&#34;&gt;getInterfaces&lt;/span&gt;()));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Methods: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; Arrays.&lt;span style=&#34;color:#a6e22e&#34;&gt;toString&lt;/span&gt;(myClass.&lt;span style=&#34;color:#a6e22e&#34;&gt;getMethods&lt;/span&gt;()));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Fields&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; Arrays.&lt;span style=&#34;color:#a6e22e&#34;&gt;toString&lt;/span&gt;(myClass.&lt;span style=&#34;color:#a6e22e&#34;&gt;getFields&lt;/span&gt;()));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;不难发现所有的类都可以用到这些方法, 这也是反射的根基, runtime 的时候用来获取某个类的信息, 在介绍 &lt;code&gt;java.lang.Object&lt;/code&gt; 的时候, &lt;code&gt;Object&lt;/code&gt; 的一个方法如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; Class&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; getClass()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个返回值 &lt;code&gt;Class&amp;lt;?&amp;gt;&lt;/code&gt; 代表什么? 代表方法可以返回 &lt;code&gt;getClass()&lt;/code&gt; 任何类型的对象, 如 &lt;code&gt;Class&amp;lt;Integer&amp;gt;&lt;/code&gt;, &lt;code&gt;Class&amp;lt;String&amp;gt;&lt;/code&gt;, or &lt;code&gt;Class&amp;lt;Object&amp;gt;&lt;/code&gt;. 你可能会反驳, 不是任何类型的对象啊, 你看你返回的是 &lt;code&gt;Class&amp;lt;Integer&amp;gt;&lt;/code&gt; 而不可以返回 &lt;code&gt;Integer&lt;/code&gt; 的对象, ummm, 别忘了前面说的, &lt;code&gt;java.klang.Class&lt;/code&gt; 是作为一个类额包装器存在的, 为什么需要这样的一个类包装器? 因为反射机制,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Every time JVM creates an object , it also creates a &lt;code&gt;java.lang.Class&lt;/code&gt; object that describes the type of the object . All instances of the same class share the same  &lt;code&gt;java.lang.Class&lt;/code&gt;  object and you can obtain the  &lt;code&gt;java.lang.Class&lt;/code&gt;  object by calling the &lt;code&gt;getClass()&lt;/code&gt; method of the object. This method is inherited from &lt;code&gt;java.lang.Object&lt;/code&gt; class . 这里说的很晕各种 object, 比如一个类 Cat, 当你第一次创建 Cat 的对象时, 如 cat_1, 此时一个  &lt;code&gt;java.lang.Class&lt;/code&gt;  的对象就会被创建, 类型是 &lt;code&gt;Class&amp;lt;Cat&amp;gt;&lt;/code&gt; 用来描述类 Cat, 之后你想获得刚被创建的这个 &lt;code&gt;java.lang.Class&lt;/code&gt;  的对象(类型为&lt;code&gt;Class&amp;lt;Cat&amp;gt;&lt;/code&gt; ) , 你可以调用 &lt;code&gt;getClass()&lt;/code&gt; 方法, 即  &lt;code&gt;cat_1.getClass()&lt;/code&gt;, 此时刚好说明了泛型 wildcard 的重要性, 即 &lt;code&gt;getClass()&lt;/code&gt; 的返回值类型只能是 &lt;code&gt;Class&amp;lt;?&amp;gt;&lt;/code&gt; , 否则当你再创建一个类的对象如 Dog 的时候, 难道还要再另重载个 &lt;code&gt;getClass()&lt;/code&gt; 函数吗?  即: &lt;code&gt;public final Class&amp;lt;Cat&amp;gt; getClass()&lt;/code&gt;, &lt;code&gt;public final Class&amp;lt;Dog&amp;gt; getClass()&lt;/code&gt;, 这也太离谱了,&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;When a class (say, &lt;code&gt;Cat&lt;/code&gt;) is accessed for the very first time (e.g., say an instance of it is created ~ new Hello()), then &lt;strong&gt;class loader&lt;/strong&gt; (a component of JVM) loads it (the bytecodes) and creates an instance of &lt;code&gt;java.lang.Class&lt;/code&gt; that represents the class in context, i.e., &lt;code&gt;Cat&lt;/code&gt;. Thereafter, when you are creating an object of that same class (&lt;code&gt;Cat&lt;/code&gt;), this &lt;code&gt;java.lang.Class&lt;/code&gt; instance would be used by JVM to create the object. This &lt;code&gt;java.lang.Class&lt;/code&gt; object is also the entry point to use reflection and it can also be used to get meta-information about the class like the class name, super-class name, etc.&lt;/p&gt;
&lt;h3 id=&#34;22-为什么需要反射&#34;&gt;2.2. 为什么需要反射&lt;/h3&gt;
&lt;p&gt;We need java.lang.Class.forName() and java.lang.Class.newInstance() because many times it happens that we don&amp;rsquo;t know the name of the class to instantiate while writing code , we may get it from config files , database , network or from any Java application . This is the reflective way of creating an object which is one of the most powerful feature of Java and which makes way for many frameworks e.g. Spring , Struts which uses Java reflection .&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Can you create an object without using new operator in Java?&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Class c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Class.&lt;span style=&#34;color:#a6e22e&#34;&gt;forName&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;java.lang.String&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;String object &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (String) c.&lt;span style=&#34;color:#a6e22e&#34;&gt;newInstance&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;3-creating-a-javalangclass-object&#34;&gt;3. Creating a &lt;code&gt;java.lang.Class&lt;/code&gt; object&lt;/h2&gt;
&lt;h3 id=&#34;31-classforname&#34;&gt;3.1. &lt;code&gt;Class.forName()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Since class &lt;code&gt;Class&lt;/code&gt; doesn’t contain any constructor, there is static factory method present in class &lt;code&gt;Class&lt;/code&gt;, which is &lt;code&gt;Class.forName()&lt;/code&gt;, used for creating object of class &lt;code&gt;Class&lt;/code&gt;. Below is the syntax :&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Main&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args) &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; ClassNotFoundException {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        String nameOfClass &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Employee&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Class&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; cls &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Class.&lt;span style=&#34;color:#a6e22e&#34;&gt;forName&lt;/span&gt;(nameOfClass);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ClassLoader cLoader &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cls.&lt;span style=&#34;color:#a6e22e&#34;&gt;getClassLoader&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(cLoader);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;32-myclassclass&#34;&gt;3.2. Myclass.class&lt;/h3&gt;
&lt;p&gt;Please note that this method is used with class name, not with class instances.&lt;/p&gt;
&lt;h3 id=&#34;33-objgetclass&#34;&gt;3.3. obj.getClass()&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;obj.getClass()&lt;/code&gt;定义在&lt;code&gt;java.lang.Object.java&lt;/code&gt;下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;native&lt;/span&gt; Class&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; getClass();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;e.&lt;span style=&#34;color:#a6e22e&#34;&gt;g&lt;/span&gt;.,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;A a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; A();   &lt;span style=&#34;color:#75715e&#34;&gt;// Any class A&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Class c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a.&lt;span style=&#34;color:#a6e22e&#34;&gt;getClass&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.hudatutorials.com/java/lang/class&#34;&gt;java lang Class Class - java.lang.Class Class in Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qr.ae/pyJqWx&#34;&gt;https://qr.ae/pyJqWx&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>JDK JRE JVM JavaSE</title>
      <link>https://blog.jiyi27.com/posts/java/basics/001-jdk-jre-jvm/</link>
      <pubDate>Wed, 26 Jul 2023 21:49:41 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/java/basics/001-jdk-jre-jvm/</guid>
      <description>&lt;h2 id=&#34;1-java-sejava-ee&#34;&gt;1. Java SE、Java EE&lt;/h2&gt;
&lt;p&gt;Java SE（Java Standard Edition，Java 标准版）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java SE 是 Java 语言的核心，包含 JVM、JDK、JRE 和标准库（如 &lt;code&gt;java.lang&lt;/code&gt;, &lt;code&gt;java.util&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;JDK 默认指的是 Java SE 的 JDK&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Java EE（Java Enterprise Edition，Java 企业版）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 Java SE 的基础上，提供 企业级开发功能，如 Servlet、JSP、JDBC&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-jdk&#34;&gt;2. JDK&lt;/h2&gt;
&lt;p&gt;JDK 是 Java 开发者需要的完整开发环境, 它包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JRE（即 JVM + Java 标准库）&lt;/li&gt;
&lt;li&gt;Java 编译器（&lt;code&gt;javac&lt;/code&gt;），用于将 &lt;code&gt;.java&lt;/code&gt; 源代码编译成 &lt;code&gt;.class&lt;/code&gt; 字节码&lt;/li&gt;
&lt;li&gt;开发工具（如 &lt;code&gt;jdb&lt;/code&gt; 调试器、&lt;code&gt;javap&lt;/code&gt; 反编译工具、&lt;code&gt;jar&lt;/code&gt; 打包工具）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同的 JDK 版本:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Oracle JDK（商业版，需要许可证）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OpenJDK（开源版，和 Oracle JDK 主要功能一致）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他厂商 JDK（如 Amazon Corretto, AdoptOpenJDK）&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-java-sejava-ee&#34;&gt;1. Java SE、Java EE&lt;/h2&gt;
&lt;p&gt;Java SE（Java Standard Edition，Java 标准版）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java SE 是 Java 语言的核心，包含 JVM、JDK、JRE 和标准库（如 &lt;code&gt;java.lang&lt;/code&gt;, &lt;code&gt;java.util&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;JDK 默认指的是 Java SE 的 JDK&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Java EE（Java Enterprise Edition，Java 企业版）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 Java SE 的基础上，提供 企业级开发功能，如 Servlet、JSP、JDBC&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-jdk&#34;&gt;2. JDK&lt;/h2&gt;
&lt;p&gt;JDK 是 Java 开发者需要的完整开发环境, 它包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JRE（即 JVM + Java 标准库）&lt;/li&gt;
&lt;li&gt;Java 编译器（&lt;code&gt;javac&lt;/code&gt;），用于将 &lt;code&gt;.java&lt;/code&gt; 源代码编译成 &lt;code&gt;.class&lt;/code&gt; 字节码&lt;/li&gt;
&lt;li&gt;开发工具（如 &lt;code&gt;jdb&lt;/code&gt; 调试器、&lt;code&gt;javap&lt;/code&gt; 反编译工具、&lt;code&gt;jar&lt;/code&gt; 打包工具）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同的 JDK 版本:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Oracle JDK（商业版，需要许可证）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OpenJDK（开源版，和 Oracle JDK 主要功能一致）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他厂商 JDK（如 Amazon Corretto, AdoptOpenJDK）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-jre-运行-java-程序的环境&#34;&gt;3. JRE 运行 Java 程序的环境&lt;/h2&gt;
&lt;p&gt;JVM +  Java 标准库 ( &lt;code&gt;java.lang&lt;/code&gt;, &lt;code&gt;java.util&lt;/code&gt;) + 运行 Java 程序的核心文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你只是运行 Java 程序, 而不进行 Java 开发, 只需要 JRE,&lt;/p&gt;
&lt;p&gt;JRE ≈ JVM + Java 标准库&lt;/p&gt;
&lt;p&gt;JDK = JRE + Java 开发工具&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;4-jre-还存在吗&#34;&gt;4. JRE 还存在吗&lt;/h2&gt;
&lt;p&gt;我的电脑有两个 jdk, 一个是我自己下载的 jdk17, 一个是电脑预安装的 jdk19:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ls /Library/Java/JavaVirtualMachines/jdk-19.jdk/Contents/Home/
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;LICENSE bin     include legal   man README  conf    jmods   lib     release
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ls ~/Downloads/Programs/jdk-17-0-3-1/Home/
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;LICENSE README  bin     conf    include jmods   legal   lib     release
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;都说 JDK 包括 JRE, JRE 里面有 JVM, 但是现在新版本的 JDK 里没有 JRE 文件夹了, JRE 被单独安装了, 那么现在对于新版本的 JDK 来说, JRE 是不是仍然属于 JDK 呢? 知道这个问题和现实就行了, 至于属不属于无所谓, 想怎么说就怎么说呗, 关键是我们得知道, 什么是 JVM, 什么是 JDK 才是重要的.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In macOS, the JDK installation path is &lt;code&gt;/Library/Java/JavaVirtualMachines/jdk-10.jdk/Contents/Home/&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;In macOS, the JRE installation path is &lt;code&gt;/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home/&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是我去找 jre 却没找到, 官方说 When you install JDK 10, the public JRE (Release 10) also gets installed automatically. 他说的这种安装是下载dmg文件, 而我下的是免安装版本的zip包, 解压出来就用了, 所以ummmm, 具体也不清楚以后再想吧&amp;hellip;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从 JDK 9 开始，Oracle 官方对 Java 进行了 模块化（Project Jigsaw） 设计，JRE 被整合进了 JDK，JDK 里 不再单独有 JRE 目录&lt;/p&gt;
&lt;p&gt;JRE 仍然存在 也可以说不再存在, 因为现在 JDK 本身就已经包含完整的运行时环境 (JVM + 标准库), 它不再是 JDK 的单独部分, 所以在不在, 有句话说的好, 心中有佛, 所见皆佛&lt;/p&gt;
&lt;p&gt;不要纠结 JRE 是不是 JDK 的一部分, 运行 Java 需要 JVM 和 标准库(动态链接时用),&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    </item>
    
    <item>
      <title>C Go Java Python内存结构及对比</title>
      <link>https://blog.jiyi27.com/posts/cs-basics/001-memory-strucutre-programming-language/</link>
      <pubDate>Sat, 27 May 2023 19:59:17 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/cs-basics/001-memory-strucutre-programming-language/</guid>
      <description>&lt;h2 id=&#34;1-javascript&#34;&gt;1. Javascript&lt;/h2&gt;
&lt;p&gt;Taken from &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_management&#34;&gt;JavaScript | MDN&lt;/a&gt; but &lt;strong&gt;this applies for all language with GC&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Low-level languages like C, have manual memory management primitives such as &lt;a href=&#34;https://pubs.opengroup.org/onlinepubs/009695399/functions/malloc.html&#34;&gt;&lt;code&gt;malloc()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://en.wikipedia.org/wiki/C_dynamic_memory_allocation#Overview_of_functions&#34;&gt;&lt;code&gt;free()&lt;/code&gt;&lt;/a&gt;. In contrast, JavaScript automatically allocates memory when objects are created and frees it when they are not used anymore (&lt;em&gt;garbage collection&lt;/em&gt;). This automaticity is a potential source of confusion: it can give developers the false impression that they don&amp;rsquo;t need to worry about memory management.&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-javascript&#34;&gt;1. Javascript&lt;/h2&gt;
&lt;p&gt;Taken from &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_management&#34;&gt;JavaScript | MDN&lt;/a&gt; but &lt;strong&gt;this applies for all language with GC&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Low-level languages like C, have manual memory management primitives such as &lt;a href=&#34;https://pubs.opengroup.org/onlinepubs/009695399/functions/malloc.html&#34;&gt;&lt;code&gt;malloc()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://en.wikipedia.org/wiki/C_dynamic_memory_allocation#Overview_of_functions&#34;&gt;&lt;code&gt;free()&lt;/code&gt;&lt;/a&gt;. In contrast, JavaScript automatically allocates memory when objects are created and frees it when they are not used anymore (&lt;em&gt;garbage collection&lt;/em&gt;). This automaticity is a potential source of confusion: it can give developers the false impression that they don&amp;rsquo;t need to worry about memory management.&lt;/p&gt;
&lt;p&gt;Regardless of the programming language, the memory life cycle is pretty much always the same:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Allocate&lt;/strong&gt; the memory you need&lt;/li&gt;
&lt;li&gt;Use the allocated memory (read, write), &lt;strong&gt;each variable exists as long as there are references to it&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Release&lt;/strong&gt; the allocated memory when it is not needed anymore (Usually done by GC)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The second part is explicit in all languages. The first and last parts are explicit in low-level languages but are mostly implicit in high-level languages like JavaScript.&lt;/p&gt;
&lt;h3 id=&#34;11-allocation&#34;&gt;1.1. Allocation&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// allocates memory for a number
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;azerty&amp;#34;&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// allocates memory for a string
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;o&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}; &lt;span style=&#34;color:#75715e&#34;&gt;// allocates memory for an object and contained values
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// (like object) allocates memory for the array and
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// contained values
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;abra&amp;#34;&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} &lt;span style=&#34;color:#75715e&#34;&gt;// allocates a function (which is a callable object)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// function expressions also allocate an object
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;someElement&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;addEventListener&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;click&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  () =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;someElement&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;style&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;backgroundColor&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;blue&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;12-using-values&#34;&gt;1.2. Using values&lt;/h3&gt;
&lt;p&gt;Using values basically means reading and writing in allocated memory. This can be done by reading or writing the value of a variable or an object property or even passing an argument to a function.&lt;/p&gt;
&lt;h3 id=&#34;13-release-when-the-memory-is-not-needed-anymore&#34;&gt;1.3. Release when the memory is not needed anymore&lt;/h3&gt;
&lt;p&gt;The majority of memory management issues occur at this phase. The most difficult aspect of this stage is determining when the allocated memory is no longer needed.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Low-level languages&lt;/strong&gt; require the developer to manually determine at which point in the program the allocated memory is no longer needed and to release it.&lt;/p&gt;
&lt;p&gt;Some &lt;strong&gt;high-level languages&lt;/strong&gt;, such as JavaScript, utilize a form of automatic memory management known as &lt;a href=&#34;https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29&#34;&gt;garbage collection&lt;/a&gt; (GC). The purpose of a garbage collector is to monitor memory allocation and determine when a block of allocated memory is no longer needed and reclaim it.&lt;/p&gt;
&lt;p&gt;Learn more: &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_management&#34;&gt;Memory management - JavaScript | MDN&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-python&#34;&gt;2. Python&lt;/h2&gt;
&lt;p&gt;Memory management in Python involves a private heap containing &lt;strong&gt;all Python objects&lt;/strong&gt; and data structures. The management of this private heap is ensured internally by the &lt;em&gt;&lt;strong&gt;Python memory manager&lt;/strong&gt;&lt;/em&gt;. The Python memory manager has different components which deal with various dynamic storage management aspects, like sharing, segmentation, preallocation or caching.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Everything is an object in Python, even types such as &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Learn more: &lt;a href=&#34;https://docs.python.org/3/c-api/memory.html&#34;&gt;Memory Management — Python 3.12.0 documentation&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-golang&#34;&gt;3. Golang&lt;/h2&gt;
&lt;p&gt;From a correctness standpoint, you don&amp;rsquo;t need to know. Each variable in Go exists as long as there are references to it. The storage location chosen by the implementation is irrelevant to the semantics of the language.&lt;/p&gt;
&lt;p&gt;The storage location does have an effect on writing efficient programs. When possible, the Go compilers will allocate variables that are local to a function in that function&amp;rsquo;s &lt;strong&gt;stack frame&lt;/strong&gt;. However, if the compiler cannot prove that the variable is not referenced after the function returns, then the compiler must allocate the variable on the &lt;strong&gt;garbage-collected heap&lt;/strong&gt; to avoid dangling pointer errors. Also, if a local variable is very large, it might make more sense to store it on the heap rather than the stack.&lt;/p&gt;
&lt;p&gt;In the current compilers, if a variable has its address taken, that variable is a candidate for allocation on the heap. However, a basic &lt;em&gt;escape analysis&lt;/em&gt; recognizes some cases when such variables will not live past the return from the function and can reside on the stack.&lt;/p&gt;
&lt;h2 id=&#34;4-java&#34;&gt;4. Java&lt;/h2&gt;
&lt;p&gt;Learn more: &lt;a href=&#34;https://davidzhu.xyz/post/java/basics/005-memory-structure/&#34;&gt;https://davidzhu.xyz/post/java/basics/005-memory-structure/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;5-cc&#34;&gt;5. C/C++&lt;/h2&gt;
&lt;p&gt;C has three different pools of memory:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;static&lt;/strong&gt;: global variable storage, permanent for the entire run of the program.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;stack&lt;/strong&gt;: local variable storage (automatic, continuous memory).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;heap&lt;/strong&gt;: dynamic storage (large pool of memory, not allocated in contiguous order).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;51-static-memory&#34;&gt;5.1. Static memory&lt;/h3&gt;
&lt;p&gt;Static memory persists throughout the entire life of the program, and is usually used to store things like &lt;em&gt;global&lt;/em&gt; variables, or variables created with the static clause. If a variable is declared &lt;em&gt;outside&lt;/em&gt; of a function, it is considered global, meaning it is accessible anywhere in the program. Global variables are static, and there is only one copy for the entire program. Inside a function the variable is allocated on the stack. It is also possible to force a variable to be static using the &lt;strong&gt;static&lt;/strong&gt; clause. For example, the same variable created inside a function using the static clause would allow it to be stored in static memory.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; theforce;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;52-stack-memory&#34;&gt;5.2. Stack memory&lt;/h3&gt;
&lt;p&gt;The &lt;em&gt;stack&lt;/em&gt; is used to store variables used on the inside of a function (including the &lt;code&gt;main()&lt;/code&gt; function). It’s a LIFO, “&lt;strong&gt;L&lt;/strong&gt;ast-&lt;strong&gt;I&lt;/strong&gt;n,-&lt;strong&gt;F&lt;/strong&gt;irst-&lt;strong&gt;O&lt;/strong&gt;ut”, structure. Every time a function declares a new variable it is “pushed” onto the stack. Then when a function finishes running, all the variables associated with that function on the stack are deleted, and the memory they use is freed up. This leads to the “local” scope of function variables.&lt;/p&gt;
&lt;p&gt;Note that there is generally a limit on the size of the stack – which can vary with the operating system (for example OSX currently has a default stack size of 8MB). If a program tries to put too much information on the stack, &lt;strong&gt;stack overflow&lt;/strong&gt; will occur. Stack overflow happens when all the memory in the stack has been allocated, and further allocations begin overflowing into other sections of memory. Stack overflow also occurs in situations where recursion is incorrectly used.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the stack grows and shrinks as variables are created and destroyed&lt;/li&gt;
&lt;li&gt;stack variables only exist whilst the function that created them exists&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;53-heap-memory&#34;&gt;5.3. Heap Memory&lt;/h3&gt;
&lt;p&gt;The &lt;em&gt;heap&lt;/em&gt; is the diametrical opposite of the stack. The &lt;em&gt;heap&lt;/em&gt; is a large pool of memory that can be used dynamically – it is also known as the “free store”. This is memory that is not automatically managed in C/C++ – you have to explicitly allocate (using functions such as malloc), and deallocate (e.g. free) the memory. Failure to free the memory when you are finished with it will result in what is known as a &lt;em&gt;memory leak&lt;/em&gt; – memory that is still “being used”, and not available to other processes. Unlike the stack, there are generally no restrictions on the size of the heap (or the variables it creates), other than the physical size of memory in the machine. Variables created on the heap are accessible anywhere in the program.&lt;/p&gt;
&lt;h2 id=&#34;6-conclusion&#34;&gt;6. Conclusion&lt;/h2&gt;
&lt;p&gt;Most of languages are designed with stack and heap, the concept of stack and heap are not mentioned in Javascript, but some concepts like the function stack frame, heap are shared among the modern languages designs. Our goal is to grab the lifetime of objects so that can write good and robust codes, not stack and heap.&lt;/p&gt;
&lt;p&gt;References:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://craftofcoding.wordpress.com/2015/12/07/memory-in-c-the-stack-the-heap-and-static/&#34;&gt;Memory in C – the stack, the heap, and static – The Craft of Coding&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/18406703/when-will-a-string-be-garbage-collected-in-java&#34;&gt;When will a string be garbage collected in java - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.baeldung.com/java-choosing-gc-algorithm&#34;&gt;Choosing a GC Algorithm in Java | Baeldung&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://segment.com/blog/allocation-efficiency-in-high-performance-go-services/&#34;&gt;Golang Memory Management: Allocation Efficiency in Go Services&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/3/c-api/memory.html&#34;&gt;Memory Management — Python 3.11.3 documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.honeybadger.io/blog/memory-management-in-python/&#34;&gt;Memory Management in Python - Honeybadger Developer Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/CPython&#34;&gt;CPython&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://deepu.tech/memory-management-in-golang/&#34;&gt;🚀 Visualizing memory management in Golang | Technorage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/a/73021/16317008&#34;&gt;methods - Is Java &amp;ldquo;pass-by-reference&amp;rdquo; or &amp;ldquo;pass-by-value&amp;rdquo;? - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/10866195/stack-vs-heap-allocation-of-structs-in-go-and-how-they-relate-to-garbage-collec&#34;&gt;Stack vs heap allocation of structs in Go, and how they relate to garbage collection - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference&#34;&gt;python - How do I pass a variable by reference? - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://devguide.python.org/internals/garbage-collector/&#34;&gt;Garbage Collector Design&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://deepu.tech/memory-management-in-programming/&#34;&gt;🚀 Demystifying memory management in modern programming languages | Technorage&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
  </channel>
</rss>
