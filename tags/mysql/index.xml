<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mysql on 为霜的博客</title>
    <link>https://blog.jiyi27.com/tags/mysql/</link>
    <description>Recent content in Mysql on 为霜的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 26 Apr 2025 17:15:56 +0000</lastBuildDate><atom:link href="https://blog.jiyi27.com/tags/mysql/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>解释大名鼎鼎的 B&#43; Tree</title>
      <link>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/009-b&#43;-tree/</link>
      <pubDate>Sat, 26 Apr 2025 17:15:56 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/009-b&#43;-tree/</guid>
      <description>&lt;h2 id=&#34;1-节点-键值-指针-是什么&#34;&gt;1. 节点 键值 指针 是什么&lt;/h2&gt;
&lt;p&gt;好奇 B+ Tree 接近 O(1) 是怎么做到的, 不应该是 像二叉搜索树那样的 就是 &lt;code&gt;lgn&lt;/code&gt; 吗, 如果高度很低, 横向数据就很多吧, 不也是需要遍历, 单是横向数据这不就是 &lt;code&gt;O(n) &lt;/code&gt;了吗?&lt;/p&gt;
&lt;p&gt;想要了解这些问题, 还是需要了解一下 B+ Tree 的结构&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;术语&lt;/th&gt;
          &lt;th&gt;含义&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;节点 (Node)&lt;/td&gt;
          &lt;td&gt;磁盘页 (默认 16 KB)，在 B+ 树层次结构中的一个元素&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;非叶子节点 (Internal / Branch page)&lt;/td&gt;
          &lt;td&gt;存放&lt;strong&gt;键值 + 子页指针&lt;/strong&gt;，负责导航&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;叶子节点 (Leaf page)&lt;/td&gt;
          &lt;td&gt;1) 聚簇索引：存放&lt;strong&gt;键值 + 整行数据&lt;/strong&gt; 2) 二级索引：存放&lt;strong&gt;键值 + 主键值&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;指针&lt;/td&gt;
          &lt;td&gt;在磁盘实现里是“页号 + 槽号”或 RowID；在逻辑图中可视作“去哪个子节点”&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;键值 (Key)&lt;/td&gt;
          &lt;td&gt;用来比较、决定走哪条路径的字段值&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;一个节点可以存多个数据, 并不是一个节点只能存一个数据, 非叶子节点, 叶子节点都是这样, 比如下面的描述:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个聚簇索引的叶子节点可以存 200 行数据&lt;/li&gt;
&lt;li&gt;一个二级索引的叶子节点可以存 200 个主键&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就是说一个节点可以存多个数据, 只是节点种类不同, 索引种类不同(聚簇索引, 二级索引), 存储的数据是不一样的:&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-节点-键值-指针-是什么&#34;&gt;1. 节点 键值 指针 是什么&lt;/h2&gt;
&lt;p&gt;好奇 B+ Tree 接近 O(1) 是怎么做到的, 不应该是 像二叉搜索树那样的 就是 &lt;code&gt;lgn&lt;/code&gt; 吗, 如果高度很低, 横向数据就很多吧, 不也是需要遍历, 单是横向数据这不就是 &lt;code&gt;O(n) &lt;/code&gt;了吗?&lt;/p&gt;
&lt;p&gt;想要了解这些问题, 还是需要了解一下 B+ Tree 的结构&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;术语&lt;/th&gt;
          &lt;th&gt;含义&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;节点 (Node)&lt;/td&gt;
          &lt;td&gt;磁盘页 (默认 16 KB)，在 B+ 树层次结构中的一个元素&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;非叶子节点 (Internal / Branch page)&lt;/td&gt;
          &lt;td&gt;存放&lt;strong&gt;键值 + 子页指针&lt;/strong&gt;，负责导航&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;叶子节点 (Leaf page)&lt;/td&gt;
          &lt;td&gt;1) 聚簇索引：存放&lt;strong&gt;键值 + 整行数据&lt;/strong&gt; 2) 二级索引：存放&lt;strong&gt;键值 + 主键值&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;指针&lt;/td&gt;
          &lt;td&gt;在磁盘实现里是“页号 + 槽号”或 RowID；在逻辑图中可视作“去哪个子节点”&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;键值 (Key)&lt;/td&gt;
          &lt;td&gt;用来比较、决定走哪条路径的字段值&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;一个节点可以存多个数据, 并不是一个节点只能存一个数据, 非叶子节点, 叶子节点都是这样, 比如下面的描述:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个聚簇索引的叶子节点可以存 200 行数据&lt;/li&gt;
&lt;li&gt;一个二级索引的叶子节点可以存 200 个主键&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就是说一个节点可以存多个数据, 只是节点种类不同, 索引种类不同(聚簇索引, 二级索引), 存储的数据是不一样的:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无论聚簇索引还是二级索引, 非叶子节点存的都是 多个指针 + 多个键值
&lt;ul&gt;
&lt;li&gt;键值用来与要查询的条件 (比如 id, name) 比较接下来 (下一层) 去哪个指针找下一个节点&lt;/li&gt;
&lt;li&gt;指针用来指向子节点 (子页) 的位置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;叶子节点就有所不同了
&lt;ul&gt;
&lt;li&gt;聚簇索引的叶子节点存储的是 &lt;strong&gt;键值 + 整行数据&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;二级索引存放&lt;strong&gt;键值 + 主键值&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意哪个列的索引, 对应的 B+ Tree 的节点的键值类型, 就是那个列的类型, 比如 &lt;code&gt;name&lt;/code&gt; 对应的索引 B+ Tree 每个节点的多个键值的类型肯定是 &lt;code&gt;name&lt;/code&gt;, 而聚簇索引是根据 id 建立的 B+ Tree, 所以每个非叶子节点 存的是很多个 id + 指针 这样的数据, 此时 id 是键值:&lt;/p&gt;
&lt;p&gt;所以上面我们说: &lt;em&gt;键值用来与要查询的条件 (比如 id, name) 比较接下来 (下一层) 去哪个指针找下一个节点&lt;/em&gt;, 现在可以理解了吧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-详细结构介绍&#34;&gt;2. 详细结构介绍&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;叶子节点&lt;/strong&gt;：存储所有键值和数据, 并通过&lt;strong&gt;双向链表&lt;/strong&gt;连接, 便于范围查询&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非叶子节点&lt;/strong&gt;：由&amp;quot;键值&amp;quot;和&amp;quot;指针&amp;quot;组成, 用于导航, &lt;strong&gt;不存储实际数据&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;键值(Key)&lt;/strong&gt;: 用于比较和决策的值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;指针(Pointer)&lt;/strong&gt;: 指向下一层节点的地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在一个非叶子节点中, 指针的数量总是比键值的数量多1个, 每个指针指向下一层的一个节点, 非叶子节点在物理结构上是一个连续的数据区域, 其中键值和指针是按特定顺序交替排列的:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[指针P1] [键值K1] [指针P2] [键值K2] [指针P3]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其实指针笔键值多一个很好理解, 比如一个节点有 3 个键值 010, 020, 030, 那数据就有四个范围:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;x &amp;lt; 010&lt;/li&gt;
&lt;li&gt;010 &amp;lt;= x &amp;lt; 020&lt;/li&gt;
&lt;li&gt;020 &amp;lt;= x &amp;lt; 030&lt;/li&gt;
&lt;li&gt;030 &amp;lt;= x&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以需要四个指针来指明 x 在哪个节点上, 通过实际例子解释一下 聚簇索引 B+ Tree 的结构&lt;/p&gt;
&lt;h3 id=&#34;22-primary-key-聚簇索引结构&#34;&gt;2.2. PRIMARY KEY 聚簇索引结构&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;id&lt;/th&gt;
          &lt;th&gt;name&lt;/th&gt;
          &lt;th&gt;age&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;Alice&lt;/td&gt;
          &lt;td&gt;23&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;Bob&lt;/td&gt;
          &lt;td&gt;31&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;Cindy&lt;/td&gt;
          &lt;td&gt;27&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;David&lt;/td&gt;
          &lt;td&gt;35&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;Emma&lt;/td&gt;
          &lt;td&gt;22&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;6&lt;/td&gt;
          &lt;td&gt;Frank&lt;/td&gt;
          &lt;td&gt;28&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;7&lt;/td&gt;
          &lt;td&gt;Grace&lt;/td&gt;
          &lt;td&gt;30&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;8&lt;/td&gt;
          &lt;td&gt;Helen&lt;/td&gt;
          &lt;td&gt;26&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;9&lt;/td&gt;
          &lt;td&gt;Iris&lt;/td&gt;
          &lt;td&gt;24&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;10&lt;/td&gt;
          &lt;td&gt;Jack&lt;/td&gt;
          &lt;td&gt;29&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;假设每个页能装 4 行记录（仅用于示意）:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;                 (Root, non-leaf page)
                 +------------------+
                 | key=5 | ptr(P2)  |
ptr(P1)----------| key=9 | ptr(P3)  |
                 +------------------+
                    /         \
         +--------------+   +--------------+
         | leaf page P1 |   | leaf page P2 |    ……
         +--------------+   +--------------+
&lt;/code&gt;&lt;/pre&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;页号&lt;/th&gt;
          &lt;th&gt;类型&lt;/th&gt;
          &lt;th&gt;内容 (简化后的顺序存储)&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;P1&lt;/td&gt;
          &lt;td&gt;叶子&lt;/td&gt;
          &lt;td&gt;(1,Alice,23) (2,Bob,31) (3,Cindy,27) (4,David,35)&lt;/td&gt;
          &lt;td&gt;键≤5&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;P2&lt;/td&gt;
          &lt;td&gt;叶子&lt;/td&gt;
          &lt;td&gt;(5,Emma,22) (6,Frank,28) (7,Grace,30) (8,Helen,26)&lt;/td&gt;
          &lt;td&gt;5&amp;lt;键≤9&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;P3&lt;/td&gt;
          &lt;td&gt;叶子&lt;/td&gt;
          &lt;td&gt;(9,Iris,24) (10,Jack,29)&lt;/td&gt;
          &lt;td&gt;键&amp;gt;9&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Root&lt;/td&gt;
          &lt;td&gt;非叶子&lt;/td&gt;
          &lt;td&gt;key=5 →P2, key=9 →P3&lt;/td&gt;
          &lt;td&gt;P1 通过最左指针隐式链接&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;解释&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;非叶子节点 Root 里只保存分隔点 key=5、key=9 以及指向子页的指针&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;叶子节点 P1/P2/P3 按主键顺序链表相连，保存 “键值 + 整行”&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查询 &lt;code&gt;SELECT * FROM users WHERE id = 7;&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;从 Root 读取, 7 &amp;gt; 5 走 ptr(P2)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;P2 里二分查找, 定位记录 (7,Grace,30)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接返回整行, 因为行数据就在叶子&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;聚簇索引和非聚簇索引的结构一样, 只是叶子节点存储的内容不一样, 前者存 键值 + 对应的一整行数据, 后者存 键值 + 主键值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;22-二级索引-idx_name-结构&#34;&gt;2.2. 二级索引 idx_name 结构&lt;/h3&gt;
&lt;p&gt;假设每个页能装 4 行记录（仅用于示意）：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;             (Root, non-leaf)
             +--------------------+
             | key=Bob | ptr(S2)  |
ptr(S1)------| key=Helen| ptr(S3) |
             +--------------------+
&lt;/code&gt;&lt;/pre&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;页号&lt;/th&gt;
          &lt;th&gt;类型&lt;/th&gt;
          &lt;th&gt;内容&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;S1&lt;/td&gt;
          &lt;td&gt;叶子&lt;/td&gt;
          &lt;td&gt;(Alice,1) (Bob,2) (Cindy,3) (David,4)&lt;/td&gt;
          &lt;td&gt;键 &amp;lt; Bob&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;S2&lt;/td&gt;
          &lt;td&gt;叶子&lt;/td&gt;
          &lt;td&gt;(Emma,5) (Frank,6) (Grace,7) (Helen,8)&lt;/td&gt;
          &lt;td&gt;Bob ≤ 键 &amp;lt; Helen&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;S3&lt;/td&gt;
          &lt;td&gt;叶子&lt;/td&gt;
          &lt;td&gt;(Iris,9) (Jack,10)&lt;/td&gt;
          &lt;td&gt;键 ≥ Helen&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Root&lt;/td&gt;
          &lt;td&gt;非叶子&lt;/td&gt;
          &lt;td&gt;key=Bob →S2, key=Helen →S3&lt;/td&gt;
          &lt;td&gt;S1 通过最左指针隐式链接&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;查询 &lt;code&gt;SELECT age FROM users WHERE name = &#39;Grace&#39;;&lt;/code&gt; 步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从 idx_name.Root 读，&amp;lsquo;Grace&amp;rsquo; &amp;gt; &amp;lsquo;Bob&amp;rsquo; 且 &amp;lt; &amp;lsquo;Helen&amp;rsquo; 走 S2&lt;/li&gt;
&lt;li&gt;在 S2 找到条目 (&amp;lsquo;Grace&amp;rsquo;, 7)&lt;/li&gt;
&lt;li&gt;拿到主键 id=7，用它去聚簇索引 Root，再走 P2，然后定位 (7,Grace,30)&lt;/li&gt;
&lt;li&gt;取出 age=30&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;23-决策流程总结&#34;&gt;2.3. 决策流程总结&lt;/h3&gt;
&lt;p&gt;优先检查能否用索引：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查询包含 WHERE id = ? → 使用聚簇索引&lt;/li&gt;
&lt;li&gt;查询 WHERE name = ? → 使用 idx_name，然后回表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;执行器根据统计信息估算成本，再选择走哪个索引（或全表扫）, 一旦选定索引，引擎从 Root 开始，逐层比较键值直到叶子, 如果是二级索引，还需拿到主键，按同样 B+ 树规则走聚簇树&lt;/p&gt;
&lt;h2 id=&#34;3-叶子节点是双向连表的优势&#34;&gt;3. 叶子节点是双向连表的优势&lt;/h2&gt;
&lt;p&gt;假设我们有一个订单表&lt;code&gt;orders&lt;/code&gt;，包含订单ID、客户名、订单日期和金额：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;orders(order_id, customer_name, order_date, amount)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中 &lt;code&gt;order_id&lt;/code&gt; 是主键，在 &lt;code&gt;order_date&lt;/code&gt; 上创建了索引:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;(1, &amp;#39;张三&amp;#39;, &amp;#39;2023-01-15&amp;#39;, 100)
(2, &amp;#39;李四&amp;#39;, &amp;#39;2023-02-20&amp;#39;, 200)
(3, &amp;#39;王五&amp;#39;, &amp;#39;2023-03-10&amp;#39;, 150)
(4, &amp;#39;赵六&amp;#39;, &amp;#39;2023-03-15&amp;#39;, 300)
(5, &amp;#39;钱七&amp;#39;, &amp;#39;2023-04-05&amp;#39;, 250)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在B+ Tree索引结构中，&lt;code&gt;order_date&lt;/code&gt; 索引的叶子节点可能如下所示:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[2023-01-15, ID=1] &amp;lt;-&amp;gt; [2023-02-20, ID=2] &amp;lt;-&amp;gt; [2023-03-10, ID=3] &amp;lt;-&amp;gt; [2023-03-15, ID=4] &amp;lt;-&amp;gt; [2023-04-05, ID=5]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这些节点通过双向链表连接, 每个节点都有指向前一个和后一个节点的指针,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;范围查询&lt;/strong&gt; 假设我们需要查询3月份的所有订单:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; orders &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; order_date &lt;span style=&#34;color:#66d9ef&#34;&gt;BETWEEN&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2023-03-01&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2023-03-31&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;数据库会：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过B+树索引结构找到第一个满足条件的叶子节点（&amp;lsquo;2023-03-10&amp;rsquo;）&lt;/li&gt;
&lt;li&gt;然后沿着链表顺序遍历，直到找到超出范围的节点&lt;/li&gt;
&lt;li&gt;无需回到树的上层节点再向下查找&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果没有双向链表, 每找到一个节点都需要&lt;strong&gt;从根节点重新遍历&lt;/strong&gt;, 效率会大大降低&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;排序查询&lt;/strong&gt; 执行如下排序查询&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; orders &lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; order_date;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由于叶子节点已经按 &lt;code&gt;order_date&lt;/code&gt; 排序并通过链表连接, 数据库只需按链表顺序读取即可, 无需额外排序步骤&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分页查询&lt;/strong&gt; 当执行分页查询时：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; orders &lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; order_date &lt;span style=&#34;color:#66d9ef&#34;&gt;LIMIT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;数据库可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到排序起始位置&lt;/li&gt;
&lt;li&gt;跳过前2条记录&lt;/li&gt;
&lt;li&gt;沿着链表读取接下来的2条记录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;全表扫描&lt;/strong&gt; 如果需要全表扫描，可以从第一个叶子节点开始，沿着链表顺序读取所有数据，这种顺序访问&lt;strong&gt;比随机访问磁盘更高效&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;4-为什么索引查询速度接近-o1&#34;&gt;4. 为什么索引查询速度接近 O(1)&lt;/h2&gt;
&lt;p&gt;有人分析说 因为 B+ Tree 树的高度很低, 一般都是 3~4, 所以 I/O 次数 只有 3 ~ 4 次, 接近常数 1, 可是我认为, B+ Tree 不像 二叉搜索树那样, 只有每个节点只有两个子节点, 有可能会有多个节点, 比如 100 个, 这没关系, 因为每个节点页都由上层 的节点 通过指针指出, 可是每个节点也就是数据页可能会有多个数据啊, 比如 100 个, 这个时候 定位数据, 复杂度不应该是 O(n) 吗?&lt;/p&gt;
&lt;h3 id=&#34;42-公式推导&#34;&gt;4.2. 公式推导&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;一次查找包含两个独立成本&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;步骤&lt;/th&gt;
          &lt;th&gt;在 B⁺Tree 中做什么&lt;/th&gt;
          &lt;th&gt;理论开销&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;A. 自根向叶走指针&lt;/td&gt;
          &lt;td&gt;需要读取「树高 h」个节点页&lt;/td&gt;
          &lt;td&gt;O(h) = O(logₘ N)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;B. 在单个节点里找分隔键&lt;/td&gt;
          &lt;td&gt;对 m-1 个键比较，可做线性查找或二分查找&lt;/td&gt;
          &lt;td&gt;O(m) 或 O(log m)&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;记号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;m = 分叉因子（一个非叶子能容纳的最大子页数）&lt;/li&gt;
&lt;li&gt;N = 总记录行数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;页大小 = 16 KB&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非叶子节点：每条索引条目 24 B（键 + 子页号）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每页可容纳 ⌊16384 / 24⌋ ≈ &lt;strong&gt;680 个分叉&lt;/strong&gt;，即 m ≈ 680&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;叶子节点：每条索引项 40 B（键 + 主键）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每页 ≈ 400 条记录&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;计算树高 h
$$
h = \lceil \log_{m}(N) \rceil
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;N (行数)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;h (向上取整)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;N (行数)&lt;/th&gt;
          &lt;th&gt;h (向上取整)&lt;/th&gt;
          &lt;th&gt;需要随机 I/O&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;100 万&lt;/td&gt;
          &lt;td&gt;⌈log₆₈₀(10⁶)⌉ = 2.4 → 3&lt;/td&gt;
          &lt;td&gt;3 次&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;1 亿&lt;/td&gt;
          &lt;td&gt;⌈log₆₈₀(10⁸)⌉ = 3.2 → 4&lt;/td&gt;
          &lt;td&gt;4 次&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;100 亿&lt;/td&gt;
          &lt;td&gt;⌈log₆₈₀(10¹⁰)⌉ = 4.0 → 4&lt;/td&gt;
          &lt;td&gt;4 次&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;N 从 10⁶ ➜ 10¹⁰ 扩大一万倍，h 只从 3 ➜ 4&lt;/li&gt;
&lt;li&gt;若页缓存命中，步骤 A 甚至是 0 次磁盘 I/O，仅 CPU 比较&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;节点内比较成本&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;线性查找：≤ 680 次比较&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二分查找：⌈log₂ 680⌉ ≈ 10 次比较&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在现代 CPU 上比较 10~680 个整数几乎可忽略, 于是&lt;strong&gt;总体壁钟时间看起来几乎不随 N 增长&lt;/strong&gt;，这就是「接近 O(1)」的直观感受&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;壁钟时间是程序运行的“真实世界时间”, 而这里强调它几乎不受 N 影响, 直观上接近常数时间复杂度,&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;42-实际数据比较&#34;&gt;4.2. 实际数据比较&lt;/h3&gt;
&lt;p&gt;我们来比较一下 做一次随机磁盘 IO + 把数据页拷贝进内存 的时间 和 CPU 比较一次的耗时做对比:&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;存储介质&lt;/th&gt;
          &lt;th&gt;一次随机 I/O 大概耗时(包括拷贝进内存的时间)&lt;/th&gt;
          &lt;th&gt;CPU 比较一次耗时&lt;/th&gt;
          &lt;th&gt;数量级差距&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;机械盘&lt;/td&gt;
          &lt;td&gt;≈ 5 ms&lt;/td&gt;
          &lt;td&gt;≈ 5 ns&lt;/td&gt;
          &lt;td&gt;≈ 1 000 000 : 1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;SATA SSD&lt;/td&gt;
          &lt;td&gt;≈ 100 µs&lt;/td&gt;
          &lt;td&gt;≈ 5 ns&lt;/td&gt;
          &lt;td&gt;≈ 20 000 : 1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;NVMe SSD&lt;/td&gt;
          &lt;td&gt;≈ 20 µs&lt;/td&gt;
          &lt;td&gt;≈ 5 ns&lt;/td&gt;
          &lt;td&gt;≈ 4 000 : 1&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;即使换成 NVMe，随机 I/O 仍比 CPU 比较慢四个数量级&lt;/li&gt;
&lt;li&gt;因此&lt;strong&gt;决定查询延迟的第一因素仍是“要做几次随机 I/O”&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;B⁺Tree 通过把分叉数 m 做到几百，使树高 h≤3–4，从而把“随机 I/O 次数”限制到 3–4 次——这远比 “&lt;strong&gt;页内要比较多少键”&lt;/strong&gt; 重要&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;为什么复杂度推导 没有包括 叶子页找目标记录的开销&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;O(log N)&lt;/code&gt; 级别推导中, 页内比较最多几百次, 比一次 I/O 快万倍, 可忽略不计&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有人可能会问 你把 在存储介质 &lt;em&gt;一次随机 I/O 耗时&lt;/em&gt; 与 &lt;em&gt;CPU 比较一次耗时&lt;/em&gt; 进行比较准确吗?&lt;/p&gt;
&lt;p&gt;&lt;em&gt;一次磁盘随机 I/O 耗时&lt;/em&gt; 不应该加上从内存读取数据的时间吗, 因为数据加载的过程, 是把该节点的整个数据页加载进内存, 然后再比较数据,&lt;/p&gt;
&lt;p&gt;下面把 &lt;em&gt;一次磁盘随机 I/O 到真正完成键值比较&lt;/em&gt; 所经历的全部路径拆开, 给出各阶段的量级, 看看 &lt;strong&gt;磁盘→内存→CPU&lt;/strong&gt; 各环节到底谁是瓶颈, 为便于对比, 以一次读取 16 KB InnoDB 页为例:&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;阶段&lt;/th&gt;
          &lt;th&gt;机械盘&lt;/th&gt;
          &lt;th&gt;SATA SSD&lt;/th&gt;
          &lt;th&gt;NVMe SSD&lt;/th&gt;
          &lt;th&gt;仅 DRAM (页已在 Buffer Pool)&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;A. 设备随机寻道/寻址&lt;/td&gt;
          &lt;td&gt;≈ 5 ms&lt;/td&gt;
          &lt;td&gt;≈ 50 µs&lt;/td&gt;
          &lt;td&gt;≈ 10 µs&lt;/td&gt;
          &lt;td&gt;0&lt;/td&gt;
          &lt;td&gt;硬盘最耗时；SSD 仍需闪存地址译码+控制器排队&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;B. 媒体读出到控制器缓存&lt;/td&gt;
          &lt;td&gt;≈ 0.2 ms&lt;/td&gt;
          &lt;td&gt;≈ 40 µs&lt;/td&gt;
          &lt;td&gt;≈ 5 µs&lt;/td&gt;
          &lt;td&gt;0&lt;/td&gt;
          &lt;td&gt;顺序传输 16 KB 原始位流&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;C. PCIe/SATA DMA 传到主机 DRAM&lt;/td&gt;
          &lt;td&gt;≈ 50 µs&lt;/td&gt;
          &lt;td&gt;≈ 10 µs&lt;/td&gt;
          &lt;td&gt;≈ 3 µs&lt;/td&gt;
          &lt;td&gt;0&lt;/td&gt;
          &lt;td&gt;含协议栈、DMA 成本&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;D. OS/Buffer Pool 拷贝 + 校验&lt;/td&gt;
          &lt;td&gt;≈ 5 µs&lt;/td&gt;
          &lt;td&gt;≈ 5 µs&lt;/td&gt;
          &lt;td&gt;≈ 5 µs&lt;/td&gt;
          &lt;td&gt;≈ 5 µs&lt;/td&gt;
          &lt;td&gt;memcpy + CRC，一次 copy≈0.8 µs，算上校验约 5 µs&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;E. InnoDB 页目录二分 + 线性扫&lt;/td&gt;
          &lt;td&gt;≈ 0.05 µs&lt;/td&gt;
          &lt;td&gt;≈ 0.05 µs&lt;/td&gt;
          &lt;td&gt;≈ 0.05 µs&lt;/td&gt;
          &lt;td&gt;≈ 0.05 µs&lt;/td&gt;
          &lt;td&gt;几十次 CPU 指令：10–100 ns&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;总耗时&lt;/td&gt;
          &lt;td&gt;≈ 5.26 ms&lt;/td&gt;
          &lt;td&gt;≈ 115 µs&lt;/td&gt;
          &lt;td&gt;≈ 18 µs&lt;/td&gt;
          &lt;td&gt;≈ 5 µs&lt;/td&gt;
          &lt;td&gt;A+B+C 占主导，D、E 几乎可忽略&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;数值按公开硬件数据取近似中位数, 偏差 1–2 倍不影响量级结论, 结论&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;随机 I/O 的主耗时就是 &lt;strong&gt;设备端寻址 + 媒体读出&lt;/strong&gt;（A+B）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对机械盘：&amp;gt; 99 % 的时间耗在磁头定位和旋转等待（A）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对 SSD：A 仍是大头，只是毫秒级→微秒级&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DMA + 内存拷贝&lt;/strong&gt;（C+D）加起来只是几个微秒，机械盘情况下占比 &amp;lt; 0.1 %&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因此前面的表格 磁盘 IO 时间 &lt;code&gt;5 ms / 100 µs / 20 µs&lt;/code&gt; 这种 “磁盘随机 I/O 耗时” 通常已经把拷贝进内存的时间统合在内；再细分也不改变大局——I/O 仍比内存-CPU 操作慢三个以上数量级&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;页内比较&lt;/strong&gt;（E）只有几十纳秒；即便连带一次 L1→L2 缓存失效也就是百纳秒量级, 和微秒～毫秒的 I/O 相比同样可以忽略&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果页已在 Buffer Pool（只需 D+E）：总耗时约 5 µs，比 NVMe 随机 I/O 快 3～4 倍，比机械盘快千倍；此时查找延迟主要是 &lt;strong&gt;CPU-DRAM&lt;/strong&gt; 以及锁、版本检查等开销&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以说 “数据库查找最贵的是随机 I/O” 是对的: 只要页不在内存，I/O 时间会压倒后续所有 CPU 计算&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在数据库查询中, &lt;strong&gt;磁盘随机 I/O 操作是最耗时的部分&lt;/strong&gt;, 而不是单纯的计算次数, B-Tree 的每一层对应一次磁盘 I/O, 而高度低意味着 I/O 次数少, 只要页不在内存, I/O 时间会压倒后续所有 CPU 计算, 因为 CPU 比较数据 &amp;amp; 内存拷贝视为“几乎免费”在数量级上是成立的, B⁺ Tree 之所以追求低树高, 就是为了把这个昂贵的随机 I/O 次数从 &lt;code&gt;O(log N)&lt;/code&gt; 压到 3–4 次, 之后&lt;strong&gt;页内二分或线性扫描&lt;/strong&gt;的优化相对只是“锦上添花”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;5-页的概念是什么意思&#34;&gt;5. 页的概念是什么意思&lt;/h2&gt;
&lt;h3 id=&#34;51-什么是页page&#34;&gt;5.1. 什么是页（Page）&lt;/h3&gt;
&lt;p&gt;在 InnoDB（MySQL 8.x 默认存储引擎）里, &lt;strong&gt;页是磁盘与内存之间读写的最小物理单元&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任何数据（表、索引、Undo、字典等）都被切成若干页来管理&lt;/li&gt;
&lt;li&gt;数据库一次随机 I/O 最多只把一个完整页搬到 Buffer Pool，随后对该页里的记录做 CPU 运算&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;页的大小&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;参数&lt;/th&gt;
          &lt;th&gt;默认值&lt;/th&gt;
          &lt;th&gt;可否修改&lt;/th&gt;
          &lt;th&gt;作用&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;innodb_page_size&lt;/td&gt;
          &lt;td&gt;16 KB (16 384 字节)&lt;/td&gt;
          &lt;td&gt;初始化实例时可改为 4 KB / 8 KB / 32 KB / 64 KB&lt;/td&gt;
          &lt;td&gt;决定所有 InnoDB 页大小&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;52-页里存放什么&#34;&gt;5.2. 页里存放什么？&lt;/h3&gt;
&lt;p&gt;以一页 “索引页（INDEX PAGE，类型 0x45BF）” 为例&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;+----------------------+  0     ← file offset
| File Header (38 B)   |
| Page Header (56 B)   |
| Infimum / Supremum   | 伪记录做边界
| User Records ...     | 按主键或二级索引键有序
| Free Space           | 插入时向中间填充
| Page Directory       | 每 128 条插一槽，向下增长
| File Trailer (8 B)   |
+----------------------+ 16384  ← 16 KB
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;User Records&lt;/strong&gt;：真正的行记录或索引条目&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Page Directory&lt;/strong&gt;：偏移量数组，用来做二分搜索&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Header&lt;/strong&gt; 包括页号、上一页/下一页指针、校验值、空闲链等元数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;53-页与-btree节点的关系&#34;&gt;5.3. 页与 B⁺Tree节点的关系&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;B⁺Tree 术语&lt;/th&gt;
          &lt;th&gt;InnoDB 对应&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Node (节点)&lt;/td&gt;
          &lt;td&gt;Page (16 KB)&lt;/td&gt;
          &lt;td&gt;一页就是一个节点&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Child Pointer&lt;/td&gt;
          &lt;td&gt;在非叶子记录中的 page_no + slot&lt;/td&gt;
          &lt;td&gt;指向子页&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Sibling Pointer&lt;/td&gt;
          &lt;td&gt;页头的 prev / next&lt;/td&gt;
          &lt;td&gt;把叶子页串成双向链表&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;所以常听到“树高 = 3～4 页深”本质上是“从根页经 3～4 次指针跳到目标叶子页”&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>数据库查询 随机 IO 的次数</title>
      <link>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/010-%E9%9A%8F%E6%9C%BAio/</link>
      <pubDate>Wed, 23 Apr 2025 20:18:45 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/010-%E9%9A%8F%E6%9C%BAio/</guid>
      <description>&lt;h2 id=&#34;1-随机磁盘-io&#34;&gt;1. 随机磁盘 I/O&lt;/h2&gt;
&lt;h3 id=&#34;11-随机磁盘-io-的定义&#34;&gt;1.1. 随机磁盘 I/O 的定义&lt;/h3&gt;
&lt;p&gt;B + Tree 索引的时候总是提到 随机磁盘 IO, 这是什么意思呢?&lt;/p&gt;
&lt;p&gt;既然查询的主要事件就是 随机 IO 的时间, 一次查询怎么估算进行的随机 IO 的次数呢?&lt;/p&gt;
&lt;p&gt;读取或写入&lt;strong&gt;彼此不连续、位置不可预测&lt;/strong&gt;的物理块（页、扇区）时，就叫随机（Random）I/O&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;访问顺序跳来跳去 → 每次都要重新定位磁头或重新建立闪存地址映射&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在数据库语境里，随机 I/O 通常指 “把单个 4 KB/8 KB/16 KB 页从持久化介质搬进内存” 这一原子动作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与之对立的是&lt;strong&gt;顺序（Sequential）I/O&lt;/strong&gt;：按连续 LBA 逐块读写，一次“拉”大量数据，&lt;strong&gt;定位成本只付一次&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12-为什么随机比顺序慢得多&#34;&gt;1.2. 为什么“随机”比“顺序”慢得多？&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;介质&lt;/th&gt;
          &lt;th&gt;顺序 I/O 吞吐&lt;/th&gt;
          &lt;th&gt;随机 I/O 吞吐&lt;/th&gt;
          &lt;th&gt;随机单次延迟主要来源&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;机械硬盘 (HDD)&lt;/td&gt;
          &lt;td&gt;200 MB/s&lt;/td&gt;
          &lt;td&gt;≈ 1 MB/s (≈ 200×差)&lt;/td&gt;
          &lt;td&gt;寻道 + 旋转等待 (ms)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;SATA SSD&lt;/td&gt;
          &lt;td&gt;550 MB/s&lt;/td&gt;
          &lt;td&gt;40 MB/s&lt;/td&gt;
          &lt;td&gt;闪存块映射、队列对齐 (µs)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;NVMe SSD&lt;/td&gt;
          &lt;td&gt;3 GB/s&lt;/td&gt;
          &lt;td&gt;500 MB/s&lt;/td&gt;
          &lt;td&gt;同上，但控制器更快 (µs)&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;随机 I/O 把&lt;strong&gt;定位成本&lt;/strong&gt;均摊到 16 KB 这种很小的 payload 上, 顺序 I/O 则把定位成本摊到数百 KB ～数 MB, 故单位数据成本悬殊&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-随机磁盘-io&#34;&gt;1. 随机磁盘 I/O&lt;/h2&gt;
&lt;h3 id=&#34;11-随机磁盘-io-的定义&#34;&gt;1.1. 随机磁盘 I/O 的定义&lt;/h3&gt;
&lt;p&gt;B + Tree 索引的时候总是提到 随机磁盘 IO, 这是什么意思呢?&lt;/p&gt;
&lt;p&gt;既然查询的主要事件就是 随机 IO 的时间, 一次查询怎么估算进行的随机 IO 的次数呢?&lt;/p&gt;
&lt;p&gt;读取或写入&lt;strong&gt;彼此不连续、位置不可预测&lt;/strong&gt;的物理块（页、扇区）时，就叫随机（Random）I/O&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;访问顺序跳来跳去 → 每次都要重新定位磁头或重新建立闪存地址映射&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在数据库语境里，随机 I/O 通常指 “把单个 4 KB/8 KB/16 KB 页从持久化介质搬进内存” 这一原子动作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与之对立的是&lt;strong&gt;顺序（Sequential）I/O&lt;/strong&gt;：按连续 LBA 逐块读写，一次“拉”大量数据，&lt;strong&gt;定位成本只付一次&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12-为什么随机比顺序慢得多&#34;&gt;1.2. 为什么“随机”比“顺序”慢得多？&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;介质&lt;/th&gt;
          &lt;th&gt;顺序 I/O 吞吐&lt;/th&gt;
          &lt;th&gt;随机 I/O 吞吐&lt;/th&gt;
          &lt;th&gt;随机单次延迟主要来源&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;机械硬盘 (HDD)&lt;/td&gt;
          &lt;td&gt;200 MB/s&lt;/td&gt;
          &lt;td&gt;≈ 1 MB/s (≈ 200×差)&lt;/td&gt;
          &lt;td&gt;寻道 + 旋转等待 (ms)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;SATA SSD&lt;/td&gt;
          &lt;td&gt;550 MB/s&lt;/td&gt;
          &lt;td&gt;40 MB/s&lt;/td&gt;
          &lt;td&gt;闪存块映射、队列对齐 (µs)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;NVMe SSD&lt;/td&gt;
          &lt;td&gt;3 GB/s&lt;/td&gt;
          &lt;td&gt;500 MB/s&lt;/td&gt;
          &lt;td&gt;同上，但控制器更快 (µs)&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;随机 I/O 把&lt;strong&gt;定位成本&lt;/strong&gt;均摊到 16 KB 这种很小的 payload 上, 顺序 I/O 则把定位成本摊到数百 KB ～数 MB, 故单位数据成本悬殊&lt;/p&gt;
&lt;h3 id=&#34;13-数据库为何经常出现随机-io&#34;&gt;1.3. 数据库为何经常出现随机 I/O？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;B⁺Tree 把整张表拆成很多 16 KB 页, 键值排序后&lt;strong&gt;物理位置不再按主键连续&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一次查询只需要极少量行 ⇒ 只读几个离散页&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并发事务各跑各的语句 ⇒ 访问模式高度交错&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;14-随机-io-在执行计划中的角色&#34;&gt;1.4. 随机 I/O 在执行计划中的角色&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Optimizer 估算“若某条索引路径需 n 个&lt;strong&gt;未命中的页&lt;/strong&gt;” ⇒ 代价 = n × (随机 I/O 单价)&lt;/li&gt;
&lt;li&gt;高度 h = 3 的 B⁺Tree：理论最坏 3 次随机读即可命中目标叶子 ⇒ 成本大幅低于全表顺序扫（需读很多页）&lt;/li&gt;
&lt;li&gt;Buffer Pool 命中 ⇒ 把“随机 I/O”降为“逻辑读”，代价由毫秒/微秒→纳秒级&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;15-典型日志指标中如何看到随机-io&#34;&gt;1.5. 典型日志/指标中如何看到随机 I/O&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;SHOW STATUS LIKE &#39;Innodb_buffer_pool_reads&#39;;&lt;/code&gt; → 物理随机读次数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Performance Schema 表 ⁠file_summary_by_instance.*&lt;/code&gt; → 按文件统计随机 I/O 次数与平均延迟&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;16-一次二级索引等值查找&#34;&gt;1.6. 一次二级索引等值查找&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;索引根页不在缓存 → 随机读取 16 KB&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内部页 miss → 再随机读取 16 KB&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;叶子页 miss → 第三次随机读取&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果页面已缓存, 上述步骤变成 0 次随机 I/O, 仅逻辑读&lt;/p&gt;
&lt;p&gt;取到主键 → 去聚簇索引重走 1～3 步 ⇒ 最多再 3 次随机 I/O&lt;/p&gt;
&lt;p&gt;因此常说 “随机 I/O 次数 ≈ 树高（+回表）”&lt;/p&gt;
&lt;h2 id=&#34;2-磁盘随机-io-次数怎么计算的&#34;&gt;2. 磁盘随机 IO 次数怎么计算的&lt;/h2&gt;
&lt;p&gt;下面只讨论 &lt;strong&gt;InnoDB&lt;/strong&gt;（8.x）+ &lt;strong&gt;B⁺Tree&lt;/strong&gt; 的情形, 重点说明&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;随机 I/O “怎么数”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;影响它的典型因素与估算方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;21-概念对齐&#34;&gt;2.1. 概念对齐&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;名词&lt;/th&gt;
          &lt;th&gt;含义&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;随机 I/O 次数&lt;/td&gt;
          &lt;td&gt;查询执行过程中&lt;strong&gt;不得不从磁盘把某个页读取进 Buffer Pool 的次数&lt;/strong&gt;（若页已命中缓冲，则记作逻辑读，不计入随机 I/O）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;树高 h&lt;/td&gt;
          &lt;td&gt;自根页 → 目标叶子页所需经过的层数；根也算 1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;回表 (bookmark lookup)&lt;/td&gt;
          &lt;td&gt;二级索引命中后, 再去聚簇索引找整行所触发的额外路径&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;22-单条记录查询时的估算公式&#34;&gt;2.2. 单条记录查询时的估算公式&lt;/h3&gt;
&lt;p&gt;假设页都不在缓冲区（最坏情形）&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;查询类型&lt;/th&gt;
          &lt;th&gt;随机 I/O 估算&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;PRIMARY KEY 等值&lt;/td&gt;
          &lt;td&gt;h(PK)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;二级索引等值（唯一）&lt;/td&gt;
          &lt;td&gt;h(Secondary) + h(PK)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;二级索引非唯一，匹配 k 条&lt;/td&gt;
          &lt;td&gt;h(Secondary) + k × h(PK) + (k – 1)（额外叶子页）&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;说明&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根页通常常驻内存，可把最顶层减 1；但在“最坏估算”里仍按 h 计算&lt;/li&gt;
&lt;li&gt;如果同一叶子页内包含多条目标记录，只算 1 次随机 I/O&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;23-range-scan--全表扫描&#34;&gt;2.3. Range-Scan / 全表扫描&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;场景&lt;/th&gt;
          &lt;th&gt;随机 I/O 估算&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;主键顺序扫整表&lt;/td&gt;
          &lt;td&gt;页数 = &lt;strong&gt;⌈行数 ÷ 每页行数⌉&lt;/strong&gt; → 近似顺序 I/O，成本常按“顺序读”估算而非随机&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;二级索引范围 (l ≈ r)&lt;/td&gt;
          &lt;td&gt;h(Secondary) + #命中叶子页 + 回表成本（同上）&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;24-多表-join-时如何累加&#34;&gt;2.4. 多表 JOIN 时如何累加&lt;/h3&gt;
&lt;p&gt;优化器使用**块嵌套循环（BNL）或索引嵌套循环（BKA）**等模型；以下给最常见的“嵌套循环 + 内表走索引”场景：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;随机 I/O ≈ outer_rows_not_in_cache × outer_row_cost + outer_rows × (inner_index_height + inner_pk_height)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;outer_row_cost 指外表行本身的读取成本（可能为 0，若外表已全缓冲）&lt;/li&gt;
&lt;li&gt;inner_index_height 与 inner_pk_height 计算规则同上&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;25-optimizer-如何拿到这些数字&#34;&gt;2.5. Optimizer 如何拿到这些数字&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;统计信息 (⁠ANALYZE TABLE) 告诉它行数、基数、平均每页记录数&lt;/li&gt;
&lt;li&gt;⁠innodb_page_size 决定页大小；结合记录长度可推算每页能放几条&lt;/li&gt;
&lt;li&gt;根页、最热的几层常常假设缓存命中 → 物理 I/O 被扣掉&lt;/li&gt;
&lt;li&gt;剩余部分按一次访问 &lt;em&gt;=&lt;/em&gt; 一次随机 &lt;em&gt;I/O&lt;/em&gt;的假设累加&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;⁠&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SHOW&lt;/span&gt; STATUS &lt;span style=&#34;color:#66d9ef&#34;&gt;LIKE&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;InnoDB_buffer_pool_read%&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;变量&lt;/th&gt;
          &lt;th&gt;含义&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Innodb_buffer_pool_read_requests&lt;/td&gt;
          &lt;td&gt;逻辑读（包括命中）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Innodb_buffer_pool_reads&lt;/td&gt;
          &lt;td&gt;物理随机读（未命中）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Innodb_buffer_pool_pages_flushed&lt;/td&gt;
          &lt;td&gt;物理写&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;26-例子-二级索引等值查询&#34;&gt;2.6. 例子 二级索引等值查询&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; age 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt;   users 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt;  name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Grace&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;已知&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;h(Secondary)=3&lt;/code&gt;，&lt;code&gt;h(PK)=3&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&#39;Grace&#39;&lt;/code&gt; 唯一&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;随机 I/O 估算&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;二级索引：3 页&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;回表：再次走聚簇 3 页&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;==&amp;gt; 总计 6 次（若根页 &amp;amp; 内部页已缓存，可能只剩 1~2 次实际磁盘 I/O）&lt;/p&gt;
&lt;h3 id=&#34;27-例子-索引嵌套循环连接-inlj&#34;&gt;2.7. 例子 索引嵌套循环连接 INLJ&lt;/h3&gt;
&lt;p&gt;假设所有目标页&lt;strong&gt;最开始都不在 Buffer Pool&lt;/strong&gt;（最坏路径）, 介质为 NVMe（一次随机 I/O≈ 20 µs）, 页大小 16 KB&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;表&lt;/th&gt;
          &lt;th&gt;主键聚簇索引&lt;/th&gt;
          &lt;th&gt;辅助索引&lt;/th&gt;
          &lt;th&gt;行数 (N)&lt;/th&gt;
          &lt;th&gt;平均行长&lt;/th&gt;
          &lt;th&gt;行 / 页 (估)&lt;/th&gt;
          &lt;th&gt;页数&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;orders&lt;/td&gt;
          &lt;td&gt;(id)&lt;/td&gt;
          &lt;td&gt;(customer_id, id)&lt;/td&gt;
          &lt;td&gt;1 000 000&lt;/td&gt;
          &lt;td&gt;150 B&lt;/td&gt;
          &lt;td&gt;≈100&lt;/td&gt;
          &lt;td&gt;≈10 000&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;order_items&lt;/td&gt;
          &lt;td&gt;(id)&lt;/td&gt;
          &lt;td&gt;(order_id, id)&lt;/td&gt;
          &lt;td&gt;5 000 000&lt;/td&gt;
          &lt;td&gt;120 B&lt;/td&gt;
          &lt;td&gt;≈120&lt;/td&gt;
          &lt;td&gt;≈41 700&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;两棵 B⁺Tree（聚簇 + 二级）高度都为 3：Root→Internal→Leaf&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;根页常驻内存&lt;/strong&gt;，但在“最坏估算”里仍计 1 次 I/O&lt;/li&gt;
&lt;li&gt;每遇到一层，可能触发一次随机 I/O；一次 miss = 1 次 I/O&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;查询&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SELECT  o.id, oi.product_id
FROM    orders       o
JOIN    order_items  oi  ON oi.order_id = o.id
WHERE   o.customer_id = 123;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;场景参数（假设）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;名称&lt;/th&gt;
          &lt;th&gt;数值&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;orders.customer_id = 123 的订单数&lt;/td&gt;
          &lt;td&gt;100 行&lt;/td&gt;
          &lt;td&gt;外表有 100 行&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;一张订单的明细数&lt;/td&gt;
          &lt;td&gt;5 行&lt;/td&gt;
          &lt;td&gt;内表平均值 5 行&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;B+Tree 高度&lt;/td&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;根 + 内部 + 叶子&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;查询开始时 Buffer Pool 为空&lt;/td&gt;
          &lt;td&gt;最坏路径；所有碰到的页都会 miss&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;访问外表 &lt;code&gt;orders&lt;/code&gt; 的随机 I/O&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;步骤（一次性完成）&lt;/th&gt;
          &lt;th&gt;随机 I/O 次数&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;a. 走二级复合索引 ⁠(customer_id, id)&lt;/td&gt;
          &lt;td&gt;3 页&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;b. 回到聚簇索引拿整行&lt;/td&gt;
          &lt;td&gt;3 页&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;c. 继续扫描叶子页把 100 行都读完&lt;/td&gt;
          &lt;td&gt;1 页（100 行刚好在同一叶子）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;小计&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;&lt;strong&gt;7 次&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;说明&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“走索引 3 页”= 根 1 + 内部 1 + 叶子 1&lt;/li&gt;
&lt;li&gt;“回表再 3 页” 同理&lt;/li&gt;
&lt;li&gt;最后那张叶子页已经在内存，往后读同页不再算随机 I/O&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;查询 customer_id = 123 的所有订单及其订单中包含的商品信息, 这种查询场景 &lt;code&gt;orders&lt;/code&gt; 是外表, &lt;code&gt;order_items oi&lt;/code&gt; 是内表:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;查询从 orders 表（外表）开始&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;WHERE o.customer_id = 123&lt;/code&gt; 条件会先筛选出 &lt;code&gt;orders&lt;/code&gt; 表中所有 &lt;code&gt;customer_id = 123&lt;/code&gt; 的记录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一次成本 IO 次数: 7 次, 这 7 次 加载了一页数据, 假设这一页包含了 100 个订单数据,&lt;/li&gt;
&lt;li&gt;如果 100 个订单需要两页, 则需要 7 + 1 = 8 次 IO, 而不是 7 * 2 = 14, 第二个叶子页只有 &lt;strong&gt;1 I/O&lt;/strong&gt;，而不是再付 7 I/O
&lt;ul&gt;
&lt;li&gt;路径上的根页、内部页已经在内存 → 不再 miss&lt;/li&gt;
&lt;li&gt;只需把第二个叶子页从磁盘搬进来 → 1 I/O&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据库将上一步的 &lt;code&gt;orders&lt;/code&gt; 表结果与 &lt;code&gt;order_items&lt;/code&gt; 表（内表）进行 &lt;code&gt;INNER JOIN&lt;/code&gt;, 根据 &lt;code&gt;ON oi.order_id = o.id&lt;/code&gt; 条件匹配&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一次成本 IO 次数: 同上 7 次, 这只是 对于一个订单, 找出其所有 items 的查询, 平均 5 个 items, 一页肯定放得下, 所以就是 7 次, 不是 上面的那种 可能为 7 + 1 次 或者 7 * 2 次, 即 不会是 2 页, 三页 只用来放了 5 个 item, 当然也有可能,除非 item 很大, 一个就超过 8kb, 2 * 8 &amp;gt;= 16 kb &amp;gt; 一页的大小&lt;/li&gt;
&lt;li&gt;因为有 100 个订单, 查询 100 次, 所以 100 * 7 = 700 次 IO
&lt;ul&gt;
&lt;li&gt;这么计算是错的, 因为 &lt;strong&gt;根页、内部页只在第一次 miss&lt;/strong&gt;, 当处理第 2 ~ 100 张订单时:&lt;/li&gt;
&lt;li&gt;二级索引根 / 内部页 已经在 Buffer Pool&lt;/li&gt;
&lt;li&gt;聚簇索引根 / 内部页 也已在 Buffer Pool&lt;/li&gt;
&lt;li&gt;因此后 99 次只剩：&lt;/li&gt;
&lt;li&gt;索引叶子 1 次 IO + 聚簇叶子 1 次 IO = 2 次, 即 &lt;code&gt;2 IO / 订单&lt;/code&gt; 而不是 7&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第一张订单 7 I/O + 后面 99 张 × 2 I/O ≈ &lt;strong&gt;205 I/O&lt;/strong&gt;, 远小于 700&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总计 内表 order_items 表进行了 205 次 IO + 外表 7 次 IO = 212 次IO&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可见 &lt;strong&gt;真正决定数量级的是：根/内部页是否命中&lt;/strong&gt;, 优化器在成本模型里正是用“根页大概率命中、内部页可能命中、叶子易 miss”这套概率，去预估 I/O 量&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    </item>
    
    <item>
      <title>技术选型 MySQL 还是 MongoDB?</title>
      <link>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/008-mysql%E8%BF%98%E6%98%AFmongodb/</link>
      <pubDate>Sun, 30 Mar 2025 11:09:56 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/008-mysql%E8%BF%98%E6%98%AFmongodb/</guid>
      <description>&lt;p&gt;选 NoSQL 的几个理由, 一定不是多表关联 join 慢, 所以选嵌套, 而是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;想快速启动小专案测试 idea&lt;/li&gt;
&lt;li&gt;资料格式不确定(unstable schema)，而未来很有可能调整&lt;/li&gt;
&lt;li&gt;资料之间没有复杂的关联(无结构, 无组织)、或未来读取资料时不需要使用JOIN 的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;In my 14 years of experience, most. It&amp;rsquo;s not that there&amp;rsquo;s anything wrong with using Mongo if it fits your use case, I&amp;rsquo;ve used it a handful of times, but I find that data, by nature, is almost always relational, or becomes relational very quickly as you start adding features. Then you either have to spend time and effort changing, or use Mongo like it&amp;rsquo;s a relation database, which you should never do as it defeats the point. You&amp;rsquo;d be surprised how many times I&amp;rsquo;ve seen Mongo instances like this. Programs push data around, and it&amp;rsquo;s usually related data.&lt;/p&gt;</description>
      <content>&lt;p&gt;选 NoSQL 的几个理由, 一定不是多表关联 join 慢, 所以选嵌套, 而是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;想快速启动小专案测试 idea&lt;/li&gt;
&lt;li&gt;资料格式不确定(unstable schema)，而未来很有可能调整&lt;/li&gt;
&lt;li&gt;资料之间没有复杂的关联(无结构, 无组织)、或未来读取资料时不需要使用JOIN 的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;In my 14 years of experience, most. It&amp;rsquo;s not that there&amp;rsquo;s anything wrong with using Mongo if it fits your use case, I&amp;rsquo;ve used it a handful of times, but I find that data, by nature, is almost always relational, or becomes relational very quickly as you start adding features. Then you either have to spend time and effort changing, or use Mongo like it&amp;rsquo;s a relation database, which you should never do as it defeats the point. You&amp;rsquo;d be surprised how many times I&amp;rsquo;ve seen Mongo instances like this. Programs push data around, and it&amp;rsquo;s usually related data.&lt;/p&gt;
&lt;p&gt;Tbh Mongo isn&amp;rsquo;t used that much in production from what I&amp;rsquo;ve seen really. The world runs on SQL and that&amp;rsquo;s not going to change. I think Mongo lends itself better to small &amp;ldquo;todo&amp;rdquo; apps and such, so it tends to get used in a lot of tutorials online. When you&amp;rsquo;re starting out and you&amp;rsquo;re watching these, it can give you a false sense that everyone is using it for everything.&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;d say if you think you have a complete picture of all your data requirements and know that they&amp;rsquo;re not going to change, and it&amp;rsquo;s not relational, Mongo is a great choice.&lt;/p&gt;
&lt;p&gt;If you don&amp;rsquo;t have the full picture yet, or something might change, going relational is more future proof. Relational databases can handle not having relations between tables just fine, and you can add them later if needed. Mongo doesn&amp;rsquo;t really handle relational data well at all. &lt;a href=&#34;https://www.reddit.com/r/learnprogramming/comments/gzvyoa/comment/ftiwqzm/?utm_source=share&amp;amp;utm_medium=web3x&amp;amp;utm_name=web3xcss&amp;amp;utm_term=1&amp;amp;utm_content=share_button&#34;&gt;Reddit&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;边缘场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MongoDB is not magically faster. If you store the same data, organised in basically the same fashion, and access it exactly the same way, then you really shouldn&amp;rsquo;t expect your results to be wildly different. After all, MySQL and MongoDB are both GPL, so if Mongo had some magically better IO code in it, then the MySQL team could just incorporate it into their codebase.&lt;/p&gt;
&lt;p&gt;People are seeing real world MongoDB performance largely because MongoDB allows you to query in a different manner that is more sensible to your workload.&lt;/p&gt;
&lt;p&gt;For example, consider a design that persisted a lot of information about a complicated entity in a normalised fashion. This could easily use dozens of tables in MySQL (or any relational db) to store the data in normal form, with many indexes needed to ensure relational integrity between tables.&lt;/p&gt;
&lt;p&gt;Now consider the same design with a document store. If all of those related tables are subordinate to the main table (and they often are), then you might be able to model the data such that the entire entity is stored in a single document. In MongoDB you can store this as a single document, in a single collection. This is where MongoDB starts enabling superior performance.&lt;/p&gt;
&lt;p&gt;In MongoDB, to retrieve the whole entity, you have to perform:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;One index lookup on the collection (assuming the entity is fetched by id)&lt;/li&gt;
&lt;li&gt;Retrieve the contents of one database page (the actual binary json document)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So a b-tree lookup, and a binary page read. Log(n) + 1 IOs. If the indexes can reside entirely in memory, then 1 IO.&lt;/p&gt;
&lt;p&gt;In MySQL with 20 tables, you have to perform:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;One index lookup on the root table (again, assuming the entity is fetched by id)&lt;/li&gt;
&lt;li&gt;With a clustered index, we can assume that the values for the root row are in the index&lt;/li&gt;
&lt;li&gt;20+ range lookups (hopefully on an index) for the entity&amp;rsquo;s pk value&lt;/li&gt;
&lt;li&gt;These probably aren&amp;rsquo;t clustered indexes, so the same 20+ data lookups once we figure out what the appropriate child rows are.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So the total for mysql, even assuming that all indexes are in memory (which is harder since there are 20 times more of them) is about 20 range lookups.&lt;/p&gt;
&lt;p&gt;These range lookups are likely comprised of random IO — different tables will definitely reside in different spots on disk, and it&amp;rsquo;s possible that different rows in the same range in the same table for an entity might not be contiguous (depending on how the entity has been updated, etc).&lt;/p&gt;
&lt;p&gt;So for this example, the final tally is about &lt;em&gt;20 times&lt;/em&gt; more IO with MySQL per logical access, compared to MongoDB.&lt;/p&gt;
&lt;p&gt;This is how MongoDB can boost performance &lt;em&gt;in some use cases&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/a/9703513/16317008&#34;&gt;Stackoverflow&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;1-多表关联查询-mongodb-处于劣势&#34;&gt;1. 多表关联查询 MongoDB 处于劣势&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;MongoDB 不支持原生的 JOIN 操作&lt;/strong&gt;, MongoDB 并不像 MySQL 那样在&lt;strong&gt;引擎层面原生支持 JOIN&lt;/strong&gt;，它是通过聚合管道的 &lt;code&gt;$lookup&lt;/code&gt; 操作符来模拟关联查询的&lt;/p&gt;
&lt;h3 id=&#34;11-mysql-如何做关联查询&#34;&gt;1.1. MySQL 如何做关联查询&lt;/h3&gt;
&lt;p&gt;假设我们有四个数据集合/表：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;users&lt;/code&gt;：存储用户信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;orders&lt;/code&gt;：存储订单信息，关联到用户&lt;/li&gt;
&lt;li&gt;&lt;code&gt;order_items&lt;/code&gt;：存储订单中的商品项，关联到订单和商品&lt;/li&gt;
&lt;li&gt;&lt;code&gt;products&lt;/code&gt;：存储商品信息&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; users (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    user_id INT &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; AUTO_INCREMENT,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    name VARCHAR(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    email VARCHAR(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; orders (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    order_id INT &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; AUTO_INCREMENT,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    user_id INT, &lt;span style=&#34;color:#75715e&#34;&gt;-- Foreign Key to users
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    order_date DATE,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;FOREIGN&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; (user_id) &lt;span style=&#34;color:#66d9ef&#34;&gt;REFERENCES&lt;/span&gt; users(user_id)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; products (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    product_id INT &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; AUTO_INCREMENT,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    name VARCHAR(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    price DECIMAL(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; order_items (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    item_id INT &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; AUTO_INCREMENT,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    order_id INT, &lt;span style=&#34;color:#75715e&#34;&gt;-- Foreign Key to orders
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    product_id INT, &lt;span style=&#34;color:#75715e&#34;&gt;-- Foreign Key to products
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    quantity INT,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;FOREIGN&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; (order_id) &lt;span style=&#34;color:#66d9ef&#34;&gt;REFERENCES&lt;/span&gt; orders(order_id),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;FOREIGN&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; (product_id) &lt;span style=&#34;color:#66d9ef&#34;&gt;REFERENCES&lt;/span&gt; products(product_id)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 假设在所有 Foreign Key 字段上都建立了索引
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INDEX&lt;/span&gt; idx_orders_user &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; orders (user_id);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INDEX&lt;/span&gt; idx_items_order &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; order_items (order_id);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INDEX&lt;/span&gt; idx_items_product &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; order_items (product_id);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;目标:&lt;/strong&gt; 查询用户 &amp;ldquo;Alice&amp;rdquo; 购买过的所有商品的名称和价格，以及对应的订单 ID&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    o.order_id,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p.name &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; product_name,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p.price &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; product_price
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    users u
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;JOIN&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;-- 第 1 次连接: users -&amp;gt; orders
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    orders o &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; u.user_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; o.user_id
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;JOIN&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;-- 第 2 次连接: orders -&amp;gt; order_items
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    order_items oi &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; o.order_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; oi.order_id
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;JOIN&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;-- 第 3 次连接: order_items -&amp;gt; products
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    products p &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; oi.product_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; p.product_id
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    u.name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Alice&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;MySQL 处理过程（概念性）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查询优化器分析阶段&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当你执行一个包含多表 JOIN 的 SQL 语句时，MySQL 不会简单地按照你编写的顺序执行&lt;/li&gt;
&lt;li&gt;优化器会分析表的统计信息，包括：
&lt;ul&gt;
&lt;li&gt;表的大小（行数）&lt;/li&gt;
&lt;li&gt;每个列的数据分布情况&lt;/li&gt;
&lt;li&gt;可用的索引&lt;/li&gt;
&lt;li&gt;条件谓词的选择性（如 &lt;code&gt;WHERE u.name = &#39;Alice&#39;&lt;/code&gt; 会过滤掉多少行）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;执行计划生成&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优化器会评估多种可能的连接顺序&lt;/li&gt;
&lt;li&gt;例如，虽然您编写的是 &lt;code&gt;users → orders → order_items → products&lt;/code&gt;，但优化器可能决定使用 &lt;code&gt;users(过滤Alice) → orders → products → order_items&lt;/code&gt; 或其他顺序&lt;/li&gt;
&lt;li&gt;优化器会选择估计成本最低的执行计划&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;连接算法选择&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据表的大小和索引情况，MySQL 会选择不同的连接算法&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12-mongodb-的实现&#34;&gt;1.2. MongoDB 的实现&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// users collection
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;{ &lt;span style=&#34;color:#a6e22e&#34;&gt;_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user1&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Alice&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;email&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;alice@example.com&amp;#34;&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// orders collection
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;{ &lt;span style=&#34;color:#a6e22e&#34;&gt;_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;order1&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;user_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user1&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;order_date&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ISODate&lt;/span&gt;(...) }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{ &lt;span style=&#34;color:#a6e22e&#34;&gt;_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;order2&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;user_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user1&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;order_date&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ISODate&lt;/span&gt;(...) }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// products collection
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;{ &lt;span style=&#34;color:#a6e22e&#34;&gt;_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;prodA&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Laptop&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;price&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1200&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{ &lt;span style=&#34;color:#a6e22e&#34;&gt;_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;prodB&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Mouse&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;price&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;25&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// order_items collection
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;{ &lt;span style=&#34;color:#a6e22e&#34;&gt;_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;item1&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;order_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;order1&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;product_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;prodA&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;quantity&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{ &lt;span style=&#34;color:#a6e22e&#34;&gt;_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;item2&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;order_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;order1&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;product_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;prodB&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;quantity&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{ &lt;span style=&#34;color:#a6e22e&#34;&gt;_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;item3&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;order_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;order2&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;product_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;prodA&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;quantity&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 假设在 `orders.user_id`, `order_items.order_id`, `order_items.product_id` 上有索引
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;db&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;orders&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;createIndex&lt;/span&gt;({ &lt;span style=&#34;color:#a6e22e&#34;&gt;user_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;db&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;order_items&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;createIndex&lt;/span&gt;({ &lt;span style=&#34;color:#a6e22e&#34;&gt;order_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;db&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;order_items&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;createIndex&lt;/span&gt;({ &lt;span style=&#34;color:#a6e22e&#34;&gt;product_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; });
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;查询语句 (使用聚合管道和 &lt;code&gt;$lookup&lt;/code&gt;):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;db&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;users&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;aggregate&lt;/span&gt;([
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 阶段 1: 找到用户 Alice
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  { &lt;span style=&#34;color:#a6e22e&#34;&gt;$match&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Alice&amp;#34;&lt;/span&gt; } },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 阶段 2: 关联 orders 集合 (类似 JOIN users ON users._id = orders.user_id)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;$lookup&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;from&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;orders&amp;#34;&lt;/span&gt;,           &lt;span style=&#34;color:#75715e&#34;&gt;// 目标集合
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;localField&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;_id&amp;#34;&lt;/span&gt;,        &lt;span style=&#34;color:#75715e&#34;&gt;// 当前集合 (users) 的字段
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;foreignField&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user_id&amp;#34;&lt;/span&gt;,  &lt;span style=&#34;color:#75715e&#34;&gt;// 目标集合 (orders) 的字段
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;as&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user_orders&amp;#34;&lt;/span&gt;       &lt;span style=&#34;color:#75715e&#34;&gt;// 输出数组的字段名
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 结果: Alice 文档 + user_orders: [ {order1 doc}, {order2 doc} ]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 阶段 3: 展开 user_orders 数组 (每个订单成为一个独立文档)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  { &lt;span style=&#34;color:#a6e22e&#34;&gt;$unwind&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;$user_orders&amp;#34;&lt;/span&gt; },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 结果: { Alice doc, user_orders: {order1 doc} }, { Alice doc, user_orders: {order2 doc} }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 阶段 4: 关联 order_items 集合 (类似 JOIN orders ON orders._id = order_items.order_id)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;$lookup&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;from&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;order_items&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;localField&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user_orders._id&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#75715e&#34;&gt;// 上一阶段展开后的订单 ID
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;foreignField&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;order_id&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;as&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;items&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 结果: { Alice doc, user_orders: {order1}, items: [ {item1}, {item2} ] }, { Alice doc, user_orders: {order2}, items: [ {item3} ] }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 阶段 5: 展开 items 数组
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  { &lt;span style=&#34;color:#a6e22e&#34;&gt;$unwind&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;$items&amp;#34;&lt;/span&gt; },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 结果: {..., items: {item1}}, {..., items: {item2}}, {..., items: {item3}}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 阶段 6: 关联 products 集合 (类似 JOIN order_items ON order_items.product_id = products._id)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;$lookup&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;from&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;products&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;localField&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;items.product_id&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#75715e&#34;&gt;// 上一阶段展开后的商品 ID
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;foreignField&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;_id&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;as&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;product_details&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 结果: {..., items: {item1}, product_details: [{prodA}]}, {..., items: {item2}, product_details: [{prodB}]}, {..., items: {item3}, product_details: [{prodA}]}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 阶段 7: 展开 product_details 数组
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  { &lt;span style=&#34;color:#a6e22e&#34;&gt;$unwind&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;$product_details&amp;#34;&lt;/span&gt; },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 结果: {..., product_details: {prodA}}, {..., product_details: {prodB}}, {..., product_details: {prodA}}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 阶段 8: 投影 (选择最终需要的字段)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;$project&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#75715e&#34;&gt;// 不显示 user 的 _id
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;order_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;$user_orders._id&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;product_name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;$product_details.name&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;product_price&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;$product_details.price&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 最终结果: { order_id: &amp;#34;order1&amp;#34;, product_name: &amp;#34;Laptop&amp;#34;, price: 1200 }, { order_id: &amp;#34;order1&amp;#34;, product_name: &amp;#34;Mouse&amp;#34;, price: 25 }, { order_id: &amp;#34;order2&amp;#34;, product_name: &amp;#34;Laptop&amp;#34;, price: 1200 }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;MongoDB 处理过程及潜在性能问题分析：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;阶段式执行：&lt;/strong&gt; 聚合管道是按顺序执行每个阶段的, 每个阶段的输出是下一个阶段的输入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$lookup&lt;/code&gt; 的代价：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;阶段 2 (&lt;code&gt;$lookup&lt;/code&gt; orders):&lt;/strong&gt; 找到 Alice 后，拿着 Alice 的 &lt;code&gt;_id&lt;/code&gt; 去 &lt;code&gt;orders&lt;/code&gt; 集合查询, 如果 &lt;code&gt;orders.user_id&lt;/code&gt; 有索引，这一步通常很快&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;阶段 4 (&lt;code&gt;$lookup&lt;/code&gt; order_items):&lt;/strong&gt; 经过 &lt;code&gt;$unwind&lt;/code&gt; 后，假设 Alice 有 M 个订单, MongoDB 需要对这 M 个文档&lt;strong&gt;分别&lt;/strong&gt;执行 &lt;code&gt;lookup&lt;/code&gt; 操作, 即，拿着每个订单的 &lt;code&gt;_id&lt;/code&gt; 去 &lt;code&gt;order_items&lt;/code&gt; 集合中查询, 相当于 M 次对 &lt;code&gt;order_items&lt;/code&gt; 的查询&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;阶段 6 (&lt;code&gt;$lookup&lt;/code&gt; products):&lt;/strong&gt; 假设 Alice 的 M 个订单总共有 N 个商品项（经过 &lt;code&gt;$unwind&lt;/code&gt; 后产生 N 个文档）MongoDB 需要对这 N 个文档&lt;strong&gt;分别&lt;/strong&gt;执行 &lt;code&gt;lookup&lt;/code&gt; 操作，拿着每个商品项的 &lt;code&gt;product_id&lt;/code&gt; 去 &lt;code&gt;products&lt;/code&gt; 集合查询。这相当于 N 次对 &lt;code&gt;products&lt;/code&gt; 的查询&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;$unwind&lt;/code&gt; 的代价：&lt;/strong&gt; &lt;code&gt;$unwind&lt;/code&gt; 操作会增加管道中流动的文档数量, 如果一个用户有很多订单，每个订单有很多商品，那么中间阶段的文档数量会急剧膨胀，加大了后续阶段的处理负担&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重复查询：&lt;/strong&gt; 注意在阶段 6，如果 Alice 多次购买了同一个商品 &lt;code&gt;prodA&lt;/code&gt;（来自不同订单或同一订单的不同 &lt;code&gt;item&lt;/code&gt; 记录），&lt;code&gt;$lookup&lt;/code&gt; 可能会多次去 &lt;code&gt;products&lt;/code&gt; 集合查找 &lt;code&gt;prodA&lt;/code&gt; 的信息（虽然缓存可能有所帮助，但查询动作本身是针对每个输入文档触发的）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优化限制：&lt;/strong&gt; 虽然 MongoDB 的聚合框架和 &lt;code&gt;$lookup&lt;/code&gt; 也在不断优化，但这种&lt;strong&gt;按文档流逐步处理和多次独立查询外部集合&lt;/strong&gt;的模式，相比于关系型数据库&lt;strong&gt;全局优化、基于集合的连接算法&lt;/strong&gt;，在多层关联、数据量大的情况下，更容易遇到性能瓶颈, 优化器很难像 SQL 那样进行彻底的连接顺序重排或选择根本不同的连接算法（如 Hash Join）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;对比之下性能明显低于 MySQL 的 JOIN 操作&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-join-算法&#34;&gt;2. join 算法&lt;/h2&gt;
&lt;h3 id=&#34;21-什么是表连接&#34;&gt;2.1. 什么是表连接？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;users 表&lt;/strong&gt;：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;id&lt;/th&gt;
          &lt;th&gt;name&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;Alice&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;Bob&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;Charlie&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;orders 表&lt;/strong&gt;：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;id&lt;/th&gt;
          &lt;th&gt;user_id&lt;/th&gt;
          &lt;th&gt;amount&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;100&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;200&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;150&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;查询每个用户的所有订单：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; u.name, o.amount &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; users u &lt;span style=&#34;color:#66d9ef&#34;&gt;JOIN&lt;/span&gt; orders o &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; u.id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; o.user_id;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;22-索引嵌套循环连接index-nested-loop-join-inlj&#34;&gt;2.2. 索引嵌套循环连接（Index Nested-Loop Join, INLJ）&lt;/h3&gt;
&lt;h4 id=&#34;221-基本思想&#34;&gt;2.2.1. 基本思想&lt;/h4&gt;
&lt;p&gt;索引嵌套循环连接利用&lt;strong&gt;索引&lt;/strong&gt;来加速连接过程, 当连接列（比如 &lt;code&gt;orders.user_id&lt;/code&gt;）上有索引时，这种方式非常高效&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一般建立外键约束的时候, 就应该手动在该列上建立索引, 因为外键基本上都是 一对多 关系中用来连接查询的, 比如 用户 - 订单, 一个用户对应多个订单, 那订单表中就应该放一个用户 id, 建立外键约束和索引, 因为未来一定会用到查找某个用户的订单&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;222-工作原理&#34;&gt;2.2.2. 工作原理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;MySQL 选择一个表作为&lt;strong&gt;外层表&lt;/strong&gt;（通常是行数较少的表），比如 &lt;code&gt;users&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;对于 &lt;code&gt;users&lt;/code&gt; 表的每一行，MySQL 用 &lt;code&gt;id&lt;/code&gt; 的值在 &lt;code&gt;orders&lt;/code&gt; 表的 &lt;code&gt;user_id&lt;/code&gt; 索引上查找匹配的行&lt;/li&gt;
&lt;li&gt;因为有索引，查找速度很快（接近 O(1)）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;为什么索引的查询速度接近 O(1) ?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;B+ Tree 的高度很小（即使数据量很大 几百万,可能高度就3~4）, 所以查找的实际时间几乎是个很小的常数, 注意  B+ Tree 和 二叉搜索树不是一个东西, 后面会详细讨论这部分&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;223-举例&#34;&gt;2.2.3. 举例&lt;/h4&gt;
&lt;p&gt;假设 &lt;code&gt;orders.user_id&lt;/code&gt; 列上有索引：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从 &lt;code&gt;users&lt;/code&gt; 表取第一行：&lt;code&gt;id = 1, name = Alice&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;id = 1&lt;/code&gt; 在 &lt;code&gt;orders&lt;/code&gt; 表的 &lt;code&gt;user_id&lt;/code&gt; 索引中查找，找到两行：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;user_id = 1, amount = 100&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;user_id = 1, amount = 150&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;移动到 &lt;code&gt;users&lt;/code&gt; 表的第二行：&lt;code&gt;id = 2, name = Bob&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;id = 2&lt;/code&gt; 在索引中查找，找到一行：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;user_id = 2, amount = 200&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;继续，直到处理完所有行&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;就像是 for 循环:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 模拟索引：把 orders 按 user_id 分组（类似哈希索引）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;order_index &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; order &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; orders:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    uid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; order[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user_id&amp;#34;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; uid &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; order_index:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        order_index[uid] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    order_index[uid]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(order)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 模拟 JOIN 查询：users 是驱动表&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; user &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; users:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    uid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; user[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;id&amp;#34;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 利用“索引”直接查找匹配的订单&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; uid &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; order_index:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; order &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; order_index[uid]:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;user[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;name&amp;#39;&lt;/span&gt;]&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; bought &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;order[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;item&amp;#39;&lt;/span&gt;]&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;h4 id=&#34;224-特点&#34;&gt;2.2.4. 特点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;当有良好索引支持时最快，因为索引让查找变得高效&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果 &lt;code&gt;orders.user_id&lt;/code&gt; 上没有索引，MySQL 不会选择这种方式&lt;/strong&gt;, 可能会选择其他连接方式
&lt;ul&gt;
&lt;li&gt;哈希连接（Hash Join）：构建哈希表来加速匹配，适合大表无索引的场景&lt;/li&gt;
&lt;li&gt;块嵌套循环连接（Block Nested-Loop Join, BNLJ）：扫描两表，分块处理以减少 I/O&lt;/li&gt;
&lt;li&gt;简单嵌套循环连接（Simple Nested-Loop Join, SNLJ）：最慢，通常不会选&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;23-哈希连接hash-join&#34;&gt;2.3 哈希连接（Hash Join）&lt;/h3&gt;
&lt;h4 id=&#34;231-基本思想&#34;&gt;2.3.1. 基本思想&lt;/h4&gt;
&lt;p&gt;哈希连接使用&lt;strong&gt;哈希表&lt;/strong&gt;来加速连接过程，特别适合&lt;strong&gt;大表且没有合适索引&lt;/strong&gt;的情况&lt;/p&gt;
&lt;h4 id=&#34;232-工作原理&#34;&gt;2.3.2. 工作原理&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;MySQL 选择一个表（通常较小的表）作为&lt;strong&gt;构建表&lt;/strong&gt;，比如 &lt;code&gt;users&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;为 &lt;code&gt;users&lt;/code&gt; 表的连接列 &lt;code&gt;id&lt;/code&gt; 创建一个哈希表：
&lt;ul&gt;
&lt;li&gt;键是 &lt;code&gt;id&lt;/code&gt;，值是对应的行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对另一个表（&lt;strong&gt;探针表&lt;/strong&gt;，比如 &lt;code&gt;orders&lt;/code&gt;）的每一行，计算 &lt;code&gt;user_id&lt;/code&gt; 的哈希值，在哈希表中查找匹配的行&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;233-举例&#34;&gt;2.3.3. 举例&lt;/h4&gt;
&lt;p&gt;假设 &lt;code&gt;orders.user_id&lt;/code&gt; 没有索引：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;构建阶段&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;从 &lt;code&gt;users&lt;/code&gt; 表创建哈希表：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 -&amp;gt; {id = 1, name = Alice}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2 -&amp;gt; {id = 2, name = Bob}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;3 -&amp;gt; {id = 3, name = Charlie}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;探针阶段&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;取 &lt;code&gt;orders&lt;/code&gt; 第一行：&lt;code&gt;user_id = 1, amount = 100&lt;/code&gt;，哈希表中找到 &lt;code&gt;name = Alice&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;取 &lt;code&gt;orders&lt;/code&gt; 第二行：&lt;code&gt;user_id = 2, amount = 200&lt;/code&gt;，哈希表中找到 &lt;code&gt;name = Bob&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;取 &lt;code&gt;orders&lt;/code&gt; 第三行：&lt;code&gt;user_id = 1, amount = 150&lt;/code&gt;，哈希表中找到 &lt;code&gt;name = Alice&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;234-特点&#34;&gt;2.3.4. 特点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：对于大表且无适合索引时最佳选择，哈希表查找速度是 O(1)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：需要内存存储哈希表，如果表太大可能内存不足&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;24-其他连接方式&#34;&gt;2.4. 其他连接方式&lt;/h3&gt;
&lt;h4 id=&#34;241-块嵌套循环连接block-nested-loop-join-bnlj&#34;&gt;2.4.1. 块嵌套循环连接（Block Nested-Loop Join, BNLJ）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基本思想&lt;/strong&gt;：这是嵌套循环的优化版，一次读取多行（一个块）来减少 I/O&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：是简单嵌套循环连接的改进版本，但通常不如哈希连接或索引嵌套循环连接快&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;举例&lt;/strong&gt;：MySQL 从 &lt;code&gt;users&lt;/code&gt; 读取一组行（比如 2 行），然后扫描 &lt;code&gt;orders&lt;/code&gt; 找匹配，效率比逐行扫描高&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;BNLJ的基本思想是将外表（Outer Table）的数据分块读取到内存中，然后对每个块内的元组与内表（Inner Table）的所有元组进行比较，从而减少对内表的重复扫描&lt;/p&gt;
&lt;p&gt;比如每次 从 users 表中 拿出 多行数据 而不是 1个, 每次分别把多行数据跟内表进行比较,  虽然 比较次数没变, 但内表加载次数变少了, 减少了 磁盘 IO, 因为内表只需要为每个外表块加载一次，而不是为每行外表记录加载一次, 所以更高效一些&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;242-简单嵌套循环连接simple-nested-loop-join-snlj&#34;&gt;2.4.2. 简单嵌套循环连接（Simple Nested-Loop Join, SNLJ）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;基本思想：最原始的方式，对 &lt;code&gt;users&lt;/code&gt; 的每一行，扫描 &lt;code&gt;orders&lt;/code&gt; 的所有行&lt;/li&gt;
&lt;li&gt;特点：最慢，时间复杂度 &lt;strong&gt;O(N * M)&lt;/strong&gt;，通常被优化为其他形式&lt;/li&gt;
&lt;li&gt;举例：对 &lt;code&gt;users&lt;/code&gt; 的 &lt;code&gt;id = 1&lt;/code&gt;，扫描 &lt;code&gt;orders&lt;/code&gt; 所有行找 &lt;code&gt;user_id = 1&lt;/code&gt;，重复此过程，效率极低&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;25-mysql-如何选择连接方式&#34;&gt;2.5. MySQL 如何选择连接方式？&lt;/h3&gt;
&lt;p&gt;MySQL 的查询优化器会根据以下因素选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;索引情况&lt;/strong&gt;：有索引时优先用索引嵌套循环连接。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;表大小&lt;/strong&gt;：大表无索引时可能用哈希连接。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存和 I/O&lt;/strong&gt;：内存不足时可能用块嵌套循环连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-mysql-中-索引的查找速度是否接近-o1&#34;&gt;3. MySQL 中, 索引的查找速度是否“接近 O(1)”&lt;/h2&gt;
&lt;h3 id=&#34;31-最常见的索引b-tree-索引&#34;&gt;3.1. 最常见的索引：B+ Tree 索引&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MySQL InnoDB 引擎默认的索引类型是 B+ Tree&lt;/li&gt;
&lt;li&gt;B+ Tree 是一种自平衡树结构, 它的查找时间复杂度是 &lt;strong&gt;O(log n)&lt;/strong&gt;, 其中 n 是数据的条数&lt;/li&gt;
&lt;li&gt;为什么是 &lt;code&gt;O(log n)&lt;/code&gt;？因为 B-Tree 的查找过程依赖于树的高度，而树的高度通常是 &lt;code&gt;O(log n)&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;即使存储数百万条记录，B+ Tree 的高度也不会超过几层&lt;/li&gt;
&lt;li&gt;每次查找只需要沿着树的高度走几步，所以实际耗时非常短&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;为什么常说“接近 O(1)”？&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;在实际应用中, 由于 B+ Tree 的高度很小（即使数据量很大），查找的实际时间几乎是个很小的常数&lt;/li&gt;
&lt;li&gt;因此，虽然理论上是 O(log n)，但表现上“感觉”像是接近 O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在理想情况下（即完全平衡的二叉搜索树）一棵满二叉树的节点总数是：&lt;/p&gt;
&lt;p&gt;$$
n = 2^0 + 2^1 + 2^2 + \cdots + 2^h = \sum_{i=0}^{h} 2^i
$$&lt;/p&gt;
&lt;p&gt;这是一个等比数列，求和公式为：&lt;/p&gt;
&lt;p&gt;$$
n = 2^{h+1} - 1
$$&lt;/p&gt;
&lt;p&gt;两边取对数，解出高度 &lt;code&gt;h&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;$$
n + 1 = 2^{h+1}
$$&lt;/p&gt;
&lt;p&gt;$$
\log_2(n + 1) = h + 1
$$&lt;/p&gt;
&lt;p&gt;$$
h = \log_2(n + 1) - 1
$$&lt;/p&gt;
&lt;p&gt;因此，在最理想的情况下，树的高度近似为：&lt;/p&gt;
&lt;p&gt;$$
h \approx \log_2 n
$$&lt;/p&gt;
&lt;p&gt;这说明，在平衡的二叉搜索树中，查找、插入、删除等操作的时间复杂度为：&lt;/p&gt;
&lt;p&gt;$$
O(\log n)
$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;32-哈希索引真正的-o1&#34;&gt;3.2. &lt;strong&gt;哈希索引：真正的 O(1)&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MySQL 也支持 哈希索引，它的查找时间复杂度在理想情况下是 O(1)&lt;/li&gt;
&lt;li&gt;但是，哈希索引的使用场景非常有限
&lt;ul&gt;
&lt;li&gt;它主要用于 &lt;strong&gt;MEMORY 存储引擎&lt;/strong&gt;, 而 InnoDB 默认不支持哈希索引（除非通过特殊配置）&lt;/li&gt;
&lt;li&gt;哈希索引不支持范围查询（比如 &amp;gt;、&amp;lt;），所以适用性不如 B+ Tree&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;因此，在大多数情况下，说“有索引”时，指的并不是哈希索引，而是 B+ Tree 索引&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>零碎知识 - MySQL</title>
      <link>https://blog.jiyi27.com/posts/database/mysql/001-nuggets-mysql/</link>
      <pubDate>Wed, 10 Jan 2024 23:06:36 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/database/mysql/001-nuggets-mysql/</guid>
      <description>&lt;h2 id=&#34;1-uuids-vs-auto-incrementing-keys&#34;&gt;1. UUIDs vs. Auto-incrementing Keys&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;特性&lt;/th&gt;
          &lt;th&gt;自增 ID (BIGINT)&lt;/th&gt;
          &lt;th&gt;UUID&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;存储空间&lt;/td&gt;
          &lt;td&gt;8 字节&lt;/td&gt;
          &lt;td&gt;16 字节 (BINARY) 或 36 字节 (CHAR)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;索引性能&lt;/td&gt;
          &lt;td&gt;优 - 顺序插入，页分裂少&lt;/td&gt;
          &lt;td&gt;差 - 随机插入，频繁页分裂&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;分布式友好度&lt;/td&gt;
          &lt;td&gt;差 - 需要额外设计（雪花算法）, 容易冲突&lt;/td&gt;
          &lt;td&gt;优 - 天然分布式友好&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;插入性能&lt;/td&gt;
          &lt;td&gt;优 - 顺序写入&lt;/td&gt;
          &lt;td&gt;差 - 随机写入&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;缓存友好度&lt;/td&gt;
          &lt;td&gt;高 - 连续存储&lt;/td&gt;
          &lt;td&gt;低 - 分散存储&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果主键是 UUID，数据插入时是随机的，会导致 B+ 树频繁分裂，影响索引性能。&lt;/p&gt;
&lt;p&gt;✅ &lt;strong&gt;优化方法&lt;/strong&gt;：使用 &lt;strong&gt;自增 ID&lt;/strong&gt; 作为主键。如果必须用 UUID，可以使用 &lt;strong&gt;UUIDv7&lt;/strong&gt;（时间戳递增的 UUID）。&lt;/p&gt;
&lt;h2 id=&#34;2-存储字符串&#34;&gt;2. 存储字符串&lt;/h2&gt;
&lt;p&gt;The most commonly used string data types in the context of databases are CHAR and VARCHAR. TEXT and LONGTEXT are also commonly used string data types.&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-uuids-vs-auto-incrementing-keys&#34;&gt;1. UUIDs vs. Auto-incrementing Keys&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;特性&lt;/th&gt;
          &lt;th&gt;自增 ID (BIGINT)&lt;/th&gt;
          &lt;th&gt;UUID&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;存储空间&lt;/td&gt;
          &lt;td&gt;8 字节&lt;/td&gt;
          &lt;td&gt;16 字节 (BINARY) 或 36 字节 (CHAR)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;索引性能&lt;/td&gt;
          &lt;td&gt;优 - 顺序插入，页分裂少&lt;/td&gt;
          &lt;td&gt;差 - 随机插入，频繁页分裂&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;分布式友好度&lt;/td&gt;
          &lt;td&gt;差 - 需要额外设计（雪花算法）, 容易冲突&lt;/td&gt;
          &lt;td&gt;优 - 天然分布式友好&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;插入性能&lt;/td&gt;
          &lt;td&gt;优 - 顺序写入&lt;/td&gt;
          &lt;td&gt;差 - 随机写入&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;缓存友好度&lt;/td&gt;
          &lt;td&gt;高 - 连续存储&lt;/td&gt;
          &lt;td&gt;低 - 分散存储&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果主键是 UUID，数据插入时是随机的，会导致 B+ 树频繁分裂，影响索引性能。&lt;/p&gt;
&lt;p&gt;✅ &lt;strong&gt;优化方法&lt;/strong&gt;：使用 &lt;strong&gt;自增 ID&lt;/strong&gt; 作为主键。如果必须用 UUID，可以使用 &lt;strong&gt;UUIDv7&lt;/strong&gt;（时间戳递增的 UUID）。&lt;/p&gt;
&lt;h2 id=&#34;2-存储字符串&#34;&gt;2. 存储字符串&lt;/h2&gt;
&lt;p&gt;The most commonly used string data types in the context of databases are CHAR and VARCHAR. TEXT and LONGTEXT are also commonly used string data types.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;char(10)&lt;/code&gt; vs &lt;code&gt;varchar(10)&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;When you define a column as CHAR(10), it will always occupy 10 characters of storage, regardless of the actual data length. If you store a string shorter than 10 characters, it will be padded with spaces to fill up the remaining space.&lt;/p&gt;
&lt;p&gt;When you define a column as VARCHAR(10), you store a string shorter than 10 characters, it will use only the necessary amount of storage, without any padding.&lt;/p&gt;
&lt;p&gt;In general, the performance difference between CHAR and VARCHAR is usually negligible unless you&amp;rsquo;re dealing with extremely large datasets or have specific performance requirements.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When the length of strings to be written to the field is explicitly specified choose CHAR as the data type. When the number of strings that users will input is not fixed, but there is a limit based on the number of characters, use VARCHAR as the data type. For example, for a username that can vary in length, VARCHAR is used as the data type.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;3-存储时间&#34;&gt;3. 存储时间&lt;/h2&gt;
&lt;h3 id=&#34;31-不要用字符串存储日期&#34;&gt;3.1. 不要用字符串存储日期&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;字符串占用的空间更大&lt;/li&gt;
&lt;li&gt;字符串存储的日期比较效率比较低（逐个字符进行比对），无法用日期相关的 API 进行计算和比较&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-datetime-and-timestamp&#34;&gt;3.2. Datetime and Timestamp&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Datetime&lt;/code&gt; 和 &lt;code&gt;Timestamp&lt;/code&gt; 是 MySQL 提供的两种比较相似的保存时间的数据类型, 通常我们都会首选 &lt;code&gt;Timestamp&lt;/code&gt;. 因为DateTime类型没有时区信息的, 而Timestamp可以存储time zone信息, 并且做转换.&lt;/p&gt;
&lt;p&gt;Timestamp 只需要使用 4 个字节的存储空间，但是 DateTime 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，Timestamp 表示的时间范围更小。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DateTime ：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59&lt;/li&gt;
&lt;li&gt;Timestamp： 1970-01-01 00:00:01 ~ 2037-12-31 23:59:59&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;time_zone_test&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;id&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; int &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; AUTO_INCREMENT,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;date_time&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; datetime &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;time_stamp&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;timestamp&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;id&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;INSERT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INTO&lt;/span&gt; time_zone_test(date_time) &lt;span style=&#34;color:#66d9ef&#34;&gt;VALUES&lt;/span&gt;(NOW());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;from&lt;/span&gt; time_zone_test;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;----+---------------------+---------------------+
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; date_time           &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; time_stamp          &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;----+---------------------+---------------------+
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2023&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;04&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;01&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;45&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;04&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2023&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;04&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;01&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;45&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;04&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;----+---------------------+---------------------+
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这也说明了一个问题, 就是我们插入数据的时候, 没必要在逻辑上获取时间再加入, 我们只需要在创建表的时候设置一个time column并为其设置default值, 即可, 每次只用在Java代码中插入其他column, 然后时间会被mysql自动加上去.&lt;/p&gt;
&lt;p&gt;对于上面的数据, 我们修改会话的时区, 可以看到时间就变了:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt; time_zone&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;+8:00&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;----+---------------------+---------------------+
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; date_time           &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; time_stamp          &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;----+---------------------+---------------------+
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2023&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;04&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;01&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;45&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;04&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2023&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;04&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;01&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;21&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;45&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;04&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;----+---------------------+---------------------+
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;4-default-vs-not-null&#34;&gt;4. Default vs NOT NULL&lt;/h2&gt;
&lt;p&gt;有没有想过, 建表的时候default 和 not null一起使用, 是不是有点redundant? 因为比如你不插入值的时候mysql会帮你插入默认值,&lt;/p&gt;
&lt;p&gt;其实这么想你就错了, 你想的是我不插入, mysql就会帮我插入个默认值, 所以似乎not null没起作用, 但是你有没有想过如果你只设置了default而没有设置not null限制, 那这时候我插入null个呢, 显然可以插入成功, 但有时候为null, 比如一个日期, 当我们在写Java或者其他代码的时候查询数据然后把date转为string, 如果数据为null可能就会发生异常~&lt;/p&gt;
&lt;h2 id=&#34;5-查看-mysql-warning&#34;&gt;5. 查看 MySQL Warning&lt;/h2&gt;
&lt;p&gt;有时候我们创建表的时候或者执行SQL语句, 虽然执行成功了但是会显示有警告,但是还不告诉你警告内容, 这时候你需要立刻执行&lt;code&gt;SHOW WARNINGS;&lt;/code&gt;语句, 否则你执行了其他语句再执行这个show, 那现实的就不是上一个语句的warnings了, 如下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pub-2a6758f3b2d64ef5bb71ba1601101d35.r2.dev/blogs/2025/01/ae56e684a1d7b2c0c6aab58d2064fdc0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@centizennationwide/mysql-naming-conventions-e3a6f6219efe&#34;&gt;MYSQL Naming Conventions. What is MYSQL? | by Centizen Nationwide | Medium&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/7899200/is-there-a-naming-convention-for-mysql&#34;&gt;Is there a naming convention for MySQL? - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.sqlstyle.guide/#columns&#34;&gt;SQL style guide by Simon Holywell&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.cn/post/7165675545965887525&#34;&gt;MySQL数据库中常见的几种表字段数据类型 - 掘金&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.cn/post/6844904047489581063&#34;&gt;老生常谈！数据库如何存储时间？你真的知道吗？ - 掘金&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>一对多, 多对多建表 MySQL MongoDB</title>
      <link>https://blog.jiyi27.com/posts/database/mysql/003-normalization-join/</link>
      <pubDate>Wed, 10 Jan 2024 11:51:35 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/database/mysql/003-normalization-join/</guid>
      <description>&lt;h2 id=&#34;1-规范化&#34;&gt;1. 规范化&lt;/h2&gt;
&lt;h3 id=&#34;11-normalization&#34;&gt;1.1. Normalization&lt;/h3&gt;
&lt;p&gt;规范化是一种将数据库表结构分解为更小的、更符合范式的表，以减少数据冗余，提高数据一致性的方法。它涉及将数据分解成多个相互关联的表。这种设计减少了数据的重复，但&lt;strong&gt;通常会导致更复杂的查询，因为需要多个JOIN操作来重建原始信息&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;12-denormalization&#34;&gt;1.2. Denormalization&lt;/h3&gt;
&lt;p&gt;Denormalization 是 Normalization 的对立面。它涉及将数据从多个表合并到一个表中，有时通过添加冗余数据来实现。在非关系型数据库，如MongoDB中，Denormalization 通常表现为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;嵌入子文档&lt;/strong&gt;：将相关的数据直接嵌入到一个文档中，而不是将它们分散到多个集合（表）中。例如，而不是在单独的集合中维护用户地址，可以将地址作为子文档直接嵌入到用户文档中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用数组&lt;/strong&gt;：在文档中使用数组来存储相关项的列表。例如，一个产品文档可能包含一个评论的数组，而不是将评论存储在一个单独的集合中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;13-结论&#34;&gt;1.3. 结论&lt;/h3&gt;
&lt;p&gt;在MongoDB这样的非关系型数据库中，反规范化是一种常见的数据建模技术，特别&lt;strong&gt;适用于读取操作远多于写入操作的场景&lt;/strong&gt;。它通过牺牲一定程度的数据冗余来换取读取性能的提升和查询逻辑的简化。然而，设计时需要平衡冗余带来的管理复杂性和性能优势。&lt;/p&gt;
&lt;h2 id=&#34;2-join--foreign-key&#34;&gt;2. Join &amp;amp; Foreign Key&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Join: &lt;a href=&#34;https://www.youtube.com/watch?v=G3lJAxg1cy8&#34;&gt;MySQL: JOINS are easy (INNER, LEFT, RIGHT)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Foreign Key is used to ensure the consistency and integrity of data.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;MongoDB 没有 join 和 foreign key 的的概念, 但是可以通过嵌套文档来实现类似 Join 的功能, 以及使用 Reference 来实现类似 Foreign Key 的功能.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JOIN操作经常利用外键来连接两个表, 虽然 JOIN 操作不一定要求存在外键约束, 但外键为 JOIN 提供了自然的连接点, 如下例子:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Users表&lt;/strong&gt; 存储用户信息：UserID (用户ID，主键), UserName (用户名)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Orders表&lt;/strong&gt; 存储订单信息：OrderID (订单ID，主键) OrderDate (订单日期) UserID (用户ID，外键)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这个情况下，&lt;code&gt;Orders.UserID&lt;/code&gt; 是一个外键, 它指向&lt;code&gt;Users.UserID&lt;/code&gt;, 这意味着每个订单都与一个特定的用户相关联，外键保证了每个订单中的UserID都对应于一个有效的用户, 假设我们想获取订单信息以及下单的用户的名称。我们可以使用以下SQL查询：&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-规范化&#34;&gt;1. 规范化&lt;/h2&gt;
&lt;h3 id=&#34;11-normalization&#34;&gt;1.1. Normalization&lt;/h3&gt;
&lt;p&gt;规范化是一种将数据库表结构分解为更小的、更符合范式的表，以减少数据冗余，提高数据一致性的方法。它涉及将数据分解成多个相互关联的表。这种设计减少了数据的重复，但&lt;strong&gt;通常会导致更复杂的查询，因为需要多个JOIN操作来重建原始信息&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;12-denormalization&#34;&gt;1.2. Denormalization&lt;/h3&gt;
&lt;p&gt;Denormalization 是 Normalization 的对立面。它涉及将数据从多个表合并到一个表中，有时通过添加冗余数据来实现。在非关系型数据库，如MongoDB中，Denormalization 通常表现为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;嵌入子文档&lt;/strong&gt;：将相关的数据直接嵌入到一个文档中，而不是将它们分散到多个集合（表）中。例如，而不是在单独的集合中维护用户地址，可以将地址作为子文档直接嵌入到用户文档中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用数组&lt;/strong&gt;：在文档中使用数组来存储相关项的列表。例如，一个产品文档可能包含一个评论的数组，而不是将评论存储在一个单独的集合中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;13-结论&#34;&gt;1.3. 结论&lt;/h3&gt;
&lt;p&gt;在MongoDB这样的非关系型数据库中，反规范化是一种常见的数据建模技术，特别&lt;strong&gt;适用于读取操作远多于写入操作的场景&lt;/strong&gt;。它通过牺牲一定程度的数据冗余来换取读取性能的提升和查询逻辑的简化。然而，设计时需要平衡冗余带来的管理复杂性和性能优势。&lt;/p&gt;
&lt;h2 id=&#34;2-join--foreign-key&#34;&gt;2. Join &amp;amp; Foreign Key&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Join: &lt;a href=&#34;https://www.youtube.com/watch?v=G3lJAxg1cy8&#34;&gt;MySQL: JOINS are easy (INNER, LEFT, RIGHT)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Foreign Key is used to ensure the consistency and integrity of data.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;MongoDB 没有 join 和 foreign key 的的概念, 但是可以通过嵌套文档来实现类似 Join 的功能, 以及使用 Reference 来实现类似 Foreign Key 的功能.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JOIN操作经常利用外键来连接两个表, 虽然 JOIN 操作不一定要求存在外键约束, 但外键为 JOIN 提供了自然的连接点, 如下例子:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Users表&lt;/strong&gt; 存储用户信息：UserID (用户ID，主键), UserName (用户名)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Orders表&lt;/strong&gt; 存储订单信息：OrderID (订单ID，主键) OrderDate (订单日期) UserID (用户ID，外键)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这个情况下，&lt;code&gt;Orders.UserID&lt;/code&gt; 是一个外键, 它指向&lt;code&gt;Users.UserID&lt;/code&gt;, 这意味着每个订单都与一个特定的用户相关联，外键保证了每个订单中的UserID都对应于一个有效的用户, 假设我们想获取订单信息以及下单的用户的名称。我们可以使用以下SQL查询：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; Users.UserName, Orders.OrderID, Orders.OrderDate
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; Orders
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;JOIN&lt;/span&gt; Users &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; Orders.UserID &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Users.UserID;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个查询中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;JOIN Users ON Orders.UserID = Users.UserID&lt;/code&gt;这一句是JOIN的核心，它说明了如何连接这两个表。我们通过&lt;code&gt;Orders&lt;/code&gt;表中的&lt;code&gt;UserID&lt;/code&gt;（外键）与&lt;code&gt;Users&lt;/code&gt;表中的&lt;code&gt;UserID&lt;/code&gt;（主键）进行匹配。&lt;/li&gt;
&lt;li&gt;由于使用了JOIN，我们可以同时从&lt;code&gt;Orders&lt;/code&gt;表和&lt;code&gt;Users&lt;/code&gt;表中选择数据。因此，我们能够在同一个查询结果中同时看到用户的名字和他们的订单信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-one-to-many--many-to-many&#34;&gt;3. One to Many &amp;amp; Many to Many&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一对多关系&lt;/strong&gt;：如订单和用户表, 通过在订单表中设置外键用户ID指向用户表的主键ID来实现&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多对多关系&lt;/strong&gt;：通过创建一个额外的关联表，其中包含指向两个相关表主键的外键来实现, 如术语和分类表, 每个术语可以有多个分类, 每个分类下可以有多个术语, 这时候需要一个单独的术语分类关系表, 来表示术语和分类的关系&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;多对多关系中, 可以在单独的那个关系表中建立一个复合索引, 比如术语和分类, 我们建立 (分类, 术语) 索引, 这样呢, 我们就可以很快的找到某个分类下的所有术语, 因为但我们建立了这个索引, 表中的存储结构就会变为: 同一分类下的术语都会在一块, 且 分类也是排序过的,&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;4-one-to-many-and-many-to-many-in-nosql-mongodb&#34;&gt;4. One-to-Many and Many-to-Many in NoSQL MongoDB&lt;/h2&gt;
&lt;p&gt;一对多关系在MongoDB中通常有两种表示方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;嵌入文档&lt;/strong&gt;: 如果一个用户有多个地址，那么地址可以直接嵌入到用户文档中&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;_id&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;userId123&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;John Doe&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;addresses&amp;#34;&lt;/span&gt;: [
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {&lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;street&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;123 Apple St&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;city&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;New York&amp;#34;&lt;/span&gt;},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {&lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;street&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;456 Orange Ave&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;city&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Boston&amp;#34;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;引用&lt;/strong&gt;: 类似关系型数据库中的外键&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// User document
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;_id&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;userId123&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;John Doe&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Address documents
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;[
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  {&lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;_id&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;addressId1&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;userId&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;ObjectID(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;userId123&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;)&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;street&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;123 Apple St&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;city&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;New York&amp;#34;&lt;/span&gt;},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  {&lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;_id&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;addressId2&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;userId&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;ObjectID(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;userId123&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;)&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;street&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;456 Orange Ave&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;city&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Boston&amp;#34;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;多对多关系在MongoDB中通常通过引用来表示, 每个文档存储与之相关联的其他文档的ID, &lt;strong&gt;an array of object IDs&lt;/strong&gt;. 假设有学生和课程，每个学生可以选修多门课程，每门课程也可以由多个学生选修&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学生文档&lt;/strong&gt;可能包含它们所选课程的ID列表:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;_id&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;studentId1&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Alice&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;courses&amp;#34;&lt;/span&gt;: [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;courseId1&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;courseId2&amp;#34;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;课程文档&lt;/strong&gt;可能包含选修该课程的学生ID列表:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;_id&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;courseId1&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;courseName&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Mathematics&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;students&amp;#34;&lt;/span&gt;: [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;studentId1&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;studentId3&amp;#34;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;嵌入文档可以提高读取性能，因为所有相关数据都在一个文档内；而引用更灵活，可以更容易地维护大量动态关联数据, 了解更多: MongoDB in Action: 4.2.1 Many-to-many relationships&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>索引和主键 - MySQL</title>
      <link>https://blog.jiyi27.com/posts/database/mysql/002-index-primary-key/</link>
      <pubDate>Thu, 02 Feb 2023 18:22:30 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/database/mysql/002-index-primary-key/</guid>
      <description>&lt;h2 id=&#34;1-when-will-index-be-created&#34;&gt;1. When will index be created&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Primary Key:&lt;/strong&gt; By default, when you define a primary key constraint on a column or set of columns using the PRIMARY KEY keyword, MySQL automatically creates an index on that column(s).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;index&lt;/span&gt; will created &lt;span style=&#34;color:#66d9ef&#34;&gt;on&lt;/span&gt; user_id &lt;span style=&#34;color:#66d9ef&#34;&gt;column&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;create&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;user&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;user_id&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; smallint &lt;span style=&#34;color:#66d9ef&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; auto_increment,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;username&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; varchar(&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;password&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; varchar(&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;primary&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;key&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;user_id&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Unique Constraints:&lt;/strong&gt; When you define a unique constraint on a column or set of columns using the UNIQUE keyword, MySQL automatically creates an index to enforce uniqueness.&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-when-will-index-be-created&#34;&gt;1. When will index be created&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Primary Key:&lt;/strong&gt; By default, when you define a primary key constraint on a column or set of columns using the PRIMARY KEY keyword, MySQL automatically creates an index on that column(s).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;index&lt;/span&gt; will created &lt;span style=&#34;color:#66d9ef&#34;&gt;on&lt;/span&gt; user_id &lt;span style=&#34;color:#66d9ef&#34;&gt;column&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;create&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;user&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;user_id&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; smallint &lt;span style=&#34;color:#66d9ef&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; auto_increment,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;username&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; varchar(&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;password&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; varchar(&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;primary&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;key&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;user_id&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Unique Constraints:&lt;/strong&gt; When you define a unique constraint on a column or set of columns using the UNIQUE keyword, MySQL automatically creates an index to enforce uniqueness.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;index&lt;/span&gt; will be created &lt;span style=&#34;color:#66d9ef&#34;&gt;on&lt;/span&gt; username &lt;span style=&#34;color:#66d9ef&#34;&gt;column&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;create&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;user&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;user_id&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; smallint &lt;span style=&#34;color:#66d9ef&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;username&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; varchar(&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;password&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; varchar(&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;unique&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;username&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt; there will be two indexes
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;index&lt;/span&gt; will be created &lt;span style=&#34;color:#66d9ef&#34;&gt;on&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;both&lt;/span&gt; user_id &lt;span style=&#34;color:#66d9ef&#34;&gt;and&lt;/span&gt; username &lt;span style=&#34;color:#66d9ef&#34;&gt;column&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;create&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;user&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;user_id&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; smallint &lt;span style=&#34;color:#66d9ef&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; auto_increment,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;username&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; varchar(&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;password&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; varchar(&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;primary&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;key&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;user_id&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;unique&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;username&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;When you define a &lt;code&gt;PRIMARY KEY&lt;/code&gt; on a table, &lt;code&gt;InnoDB&lt;/code&gt; uses it as the &lt;strong&gt;clustered index&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;A primary key should be defined for each table. If you do not define a &lt;code&gt;PRIMARY KEY&lt;/code&gt; for a table, &lt;code&gt;InnoDB&lt;/code&gt; uses the first &lt;code&gt;UNIQUE&lt;/code&gt; index with all key columns defined as &lt;code&gt;NOT NULL&lt;/code&gt; as the &lt;strong&gt;clustered index.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If a table has no &lt;code&gt;PRIMARY KEY&lt;/code&gt; or suitable &lt;code&gt;UNIQUE&lt;/code&gt; index, &lt;code&gt;InnoDB&lt;/code&gt; generates a hidden clustered index named &lt;code&gt;GEN_CLUST_INDEX&lt;/code&gt; on a synthetic column that contains row ID values.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-indexe-types&#34;&gt;2. Indexe Types&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;strong&gt;索引类型&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;存储结构&lt;/strong&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;主键索引（聚簇索引）&lt;/td&gt;
          &lt;td&gt;数据本身存储在 B+ 树的叶子节点，数据按照主键顺序存储&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;二级索引（普通索引）&lt;/td&gt;
          &lt;td&gt;额外的 B+ 树，只存储索引列和主键 ID，查询时需要回表&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;数据实际按照主键顺序物理存储在硬盘上, 主键索引的叶子节点存储的就是实际的数据行:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;users&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id &lt;span style=&#34;color:#66d9ef&#34;&gt;INT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    name &lt;span style=&#34;color:#66d9ef&#34;&gt;VARCHAR&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    age &lt;span style=&#34;color:#66d9ef&#34;&gt;INT&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;数据行是按照 &lt;code&gt;id&lt;/code&gt; 这个主键顺序排列的, 主键索引的叶子节点直接存储了数据:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;B&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;树（主键索引）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-------------------------------&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;--
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;| ID=1  | Alice   | 25  |
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; ID&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; Bob     &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; ID&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; Charlie &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;28&lt;/span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-------------------------------&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;--
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面我们知道 InnoDB 的数据是按照主键索引顺序存储在硬盘上的, 那建立其它索引是什么意思, 索引不会改变数据的存储顺序吗? 还是数据库会单独不同索引单独建立一个数据表按照索引排序?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二级索引&lt;/strong&gt;是为了加快查询速度，但不会改变数据的存储顺序！ 二级索引（普通索引）是 独立于主键索引 的，它只存储 索引字段值 + 主键值。当你查询时，数据库会先通过 二级索引找到主键值，然后再去 主键索引中找到数据。&lt;/p&gt;
&lt;p&gt;示例 如果我们对 &lt;code&gt;name&lt;/code&gt; 建立索引：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INDEX&lt;/span&gt; idx_name &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;users&lt;/span&gt;(name);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;数据库会额外建立一个 B+ 树 索引：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;B&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;树（&lt;/span&gt;name &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;索引）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-------------------------------&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;--
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;| Alice   | ID=1  |
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; Bob     &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; ID&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; Charlie &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; ID&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-------------------------------&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;--
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个 B+ 树按照 &lt;code&gt;name&lt;/code&gt; 排序，但它的叶子节点不存储数据，只存储 主键 ID！查询 &lt;code&gt;name=&#39;Bob&#39;&lt;/code&gt; 时，MySQL 先在 name 索引里找到 ID=5，然后再到主键索引里查找完整数据。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;现在回答上面的问题: 建立索引会不会改变数据的存储顺序？数据库会不会单独为索引建立一个新表？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;答案是： ✅ 不会改变数据存储顺序！ ✅ 但数据库会额外维护索引结构，每个索引是独立的 B+ 树！&lt;/p&gt;
&lt;h2 id=&#34;3-索引优化&#34;&gt;3. 索引优化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;优先为选择性高（区分度大）的列建索引，比如用户 ID，而不是性别这种低选择性的字段&lt;/li&gt;
&lt;li&gt;对于多条件查询，可以用复合索引，比如 where 条件里经常出现的字段组合，按照查询频率和字段顺序优化&lt;/li&gt;
&lt;li&gt;通过创建一个复合索引，使得查询可以仅通过索引而不需要访问表数据(避免回表)，从而提高查询效率&lt;/li&gt;
&lt;li&gt;避免过多索引过多的索引会增加写操作的开销，因为每次数据更新都会导致索引更新&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;复合索引指的是一个索引包含多个字段, 比如在 (age, name) 上建的索引, 就是一个复合索引, 它的作用主要是加速多条件查询（比如 WHERE age = 25 AND name = &amp;lsquo;Tom&amp;rsquo;），或者利用字段顺序优化排序、分组等操作。&lt;/p&gt;
&lt;p&gt;覆盖索引是指索引本身包含了查询所需的所有字段，使得查询不需要回表。复合索引可以成为覆盖索引，但前提是它“覆盖”了查询的字段。单列索引也可以是覆盖索引，只要满足条件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里解释一下回表的概念:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当你执行 SELECT name FROM users WHERE age = 25 时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果有 age 的索引，数据库会通过这个索引查找所有 age = 25 的记录。&lt;/li&gt;
&lt;li&gt;索引里存的是 age 和对应的主键 ID，数据库先找到这些 ID。&lt;/li&gt;
&lt;li&gt;因为你查询的是 name，而 age 的索引不包含 name，数据库需要拿着这些 ID 回表，去主表中查完整的记录。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果是覆盖索引（比如 (age, name) 的联合索引），索引里直接有 name，就不用回表了。&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>
