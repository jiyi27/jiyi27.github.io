<!DOCTYPE html>
<html lang="en">
<head>
  
    
    <title>git 工作流 :: 为霜的博客</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content=" 每次 commit 前都要看一下当前分支, 确认是不是要在这个分支提交修改, 避免在 main 分支直接修改
同理, 每次 push 代码的时候, 再三确认 push 的分支, 永远不要直接 push 到 main 分支, 而应该 push 到功能分支或其他分支
1. 准备的事 一般入职后, 应该了解公司的开发要求, 一般会有文档, 大致内容有:
变量 函数 文件 命名规则 (数据库 表 列 等等) 注释规则 了解当前都是有什么分支, 一般的会有 master, develop, feature, hotfix, release 等主要分支 git 分支命名规则, 提交信息格式 内容要求 如 feat: xxx, fix: xxx 一般习惯使用 rebase 还是 merge 2. 一般的工作流 2.1. 克隆仓库 &amp; 本地初始化 克隆公司仓库 查看分支
# 用 clone 命令会直接帮你在本地创建一个与远程关联好的仓库 git clone git@github.com:Company/xxx.git cd xxx git branch -a # 查看所有本地/远程分支 切换到 develop 分支（如果团队约定 develop 是主要的开发分支）
" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://blog.jiyi27.com/posts/git/006-git-workflow/" />





  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/buttons.min.2bc533403a27dfe0e93105a92502b42ce4587e2e4a87d9f7d349e51e16e09478.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/categories.min.3202f75cbb294747099af3850a68a09ee94b3ce505fc39e134692d90ff0a9b2a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/code.min.dd73d157e77e82a3dc1cb06ba424cf6cc6811af0bb604ad6c68e70faf2439c8a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/fonts.min.4881f0c525f3ce2a1864fb6e96676396cebe1e6fcef1933e8e1dde7041004fb5.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/footer.min.2e3eb191baee58dd05a9f0104ac1fab0827bca7c64dafe0b2579f934c33a1d69.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/header.min.b6fb4423cf82a9f9d7abc9cd010223fa3d70a6526a3f28f8e17d814c06e18f9e.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/main.min.3fb8954e26342ad3afabb4525959bfec6f9fc0d6929f0dda738ddeee30211690.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/menu.min.8cee75f73b9f9b1e40bd0dd53e6e770156b08bbfe1c579cd256c3f6cd3b6d32b.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/pagination.min.82f6400eae7c7c6dc3c866733c2ec0579e4089608fea69400ff85b3880aa0d3c.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/post.min.014a50745fbdd41d5f420a3e288730d5af4b7d90344dc6211d0e50c368b5b303.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/prism.min.b958d3d7c6c67361b945f9062d07d403422604b3d2cd33f93b88d41ed0ba634d.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/term.min.94de320c1b850e126e6d2c88a7c90acf58bb1313f0ea14a14cda2a42f2a88db2.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">


<link rel="stylesheet" href="https://blog.jiyi27.com/terminal.css">




<link rel="shortcut icon" href="https://blog.jiyi27.com/favicon.png">
<link rel="apple-touch-icon" href="https://blog.jiyi27.com/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="git 工作流">
<meta property="og:description" content=" 每次 commit 前都要看一下当前分支, 确认是不是要在这个分支提交修改, 避免在 main 分支直接修改
同理, 每次 push 代码的时候, 再三确认 push 的分支, 永远不要直接 push 到 main 分支, 而应该 push 到功能分支或其他分支
1. 准备的事 一般入职后, 应该了解公司的开发要求, 一般会有文档, 大致内容有:
变量 函数 文件 命名规则 (数据库 表 列 等等) 注释规则 了解当前都是有什么分支, 一般的会有 master, develop, feature, hotfix, release 等主要分支 git 分支命名规则, 提交信息格式 内容要求 如 feat: xxx, fix: xxx 一般习惯使用 rebase 还是 merge 2. 一般的工作流 2.1. 克隆仓库 &amp; 本地初始化 克隆公司仓库 查看分支
# 用 clone 命令会直接帮你在本地创建一个与远程关联好的仓库 git clone git@github.com:Company/xxx.git cd xxx git branch -a # 查看所有本地/远程分支 切换到 develop 分支（如果团队约定 develop 是主要的开发分支）
" />
<meta property="og:url" content="https://blog.jiyi27.com/posts/git/006-git-workflow/" />
<meta property="og:site_name" content="为霜的博客" />

  <meta property="og:image" content="https://blog.jiyi27.com/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">

  <meta property="article:section" content="git" />


  <meta property="article:published_time" content="2025-03-21 13:05:20 &#43;0000 UTC" />












</head>
<body>


<div class="container center">

  
  
  

  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://blog.jiyi27.com/posts/git/006-git-workflow/">git 工作流</a>
  </h1>
  <div class="post-meta"><time class="post-date">2025-03-21</time><span class="post-reading-time">5 分钟阅读 (950 字数)</span></div>

  
    <span class="post-tags">
      
      #<a href="https://blog.jiyi27.com/tags/git/">git</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <blockquote>
<p>每次 commit 前都要看一下当前分支, 确认是不是要在这个分支提交修改, 避免在 main 分支直接修改</p>
<p>同理, 每次 push 代码的时候, 再三确认 push 的分支, 永远不要直接 push 到 main 分支, 而应该 push 到功能分支或其他分支</p>
</blockquote>
<h2 id="1-准备的事">1. 准备的事<a href="#1-准备的事" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>一般入职后, 应该了解公司的开发要求, 一般会有文档, 大致内容有:</p>
<ul>
<li>变量 函数 文件 命名规则 (数据库 表 列 等等)</li>
<li>注释规则</li>
<li>了解当前都是有什么分支, 一般的会有 master, develop, feature, hotfix, release 等主要分支</li>
<li>git 分支命名规则, 提交信息格式 内容要求 如 <code>feat: xxx</code>, <code>fix: xxx</code></li>
<li>一般习惯使用 rebase 还是 merge</li>
</ul>
<h2 id="2-一般的工作流">2. 一般的工作流<a href="#2-一般的工作流" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<h3 id="21-克隆仓库--本地初始化">2.1. 克隆仓库 &amp; 本地初始化<a href="#21-克隆仓库--本地初始化" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>克隆公司仓库 查看分支</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 用 clone 命令会直接帮你在本地创建一个与远程关联好的仓库</span>
</span></span><span style="display:flex;"><span>git clone git@github.com:Company/xxx.git
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cd xxx
</span></span><span style="display:flex;"><span>git branch -a     <span style="color:#75715e"># 查看所有本地/远程分支</span>
</span></span></code></pre></div><p>切换到 develop 分支（如果团队约定 develop 是主要的开发分支）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 假设默认分支是 master 或 main，你想基于 develop 开发：</span>
</span></span><span style="display:flex;"><span>git switch develop
</span></span></code></pre></div><blockquote>
<p>如果是开源项目, 直接 fork 仓库, 然后 克隆自己 Forked 的仓库</p>
</blockquote>
<h3 id="22-创建本地功能分支feature-branch并开发">2.2. 创建本地功能分支（Feature Branch）并开发<a href="#22-创建本地功能分支feature-branch并开发" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>开始做一个新功能或需求，按团队约定应该基于 <code>develop</code> 分支拉出一个 feature 分支，比如 <code>feature/user-auth</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git switch develop         <span style="color:#75715e"># 确保当前在 develop 分支</span>
</span></span><span style="display:flex;"><span>git pull origin develop    <span style="color:#75715e"># 再次确认 develop 是最新的</span>
</span></span><span style="display:flex;"><span>git switch -c feature/user-auth
</span></span></code></pre></div><p>这样就创建了一个名为 <code>feature/user-auth</code> 的分支, 并自动切换到该分支进行后续开发, 你在 <code>feature/user-auth</code> 上开发用户认证功能：增删改文件等, 开发告一段落后，将改动提交到本地仓库:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git status
</span></span><span style="display:flex;"><span>git add .
</span></span><span style="display:flex;"><span>git commit -m <span style="color:#e6db74">&#34;feat: 实现基础的用户登录注册流程&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 首次推送新分支时，需声明关联远程分支：</span>
</span></span><span style="display:flex;"><span>git push --set-upstream origin feature/user-auth
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 以后就可以直接用 git push 命令了</span>
</span></span></code></pre></div><ul>
<li>当你创建一个新的本地分支 比如通过 <code>git switch -c feature/user-auth</code>, 这个分支只存在于你的本地仓库, 远程仓库（比如 GitHub、GitLab）还不知道这个分支的存在, 如果你直接运行 <code>git push</code>, Git 会报错, 因为它不知道要把代码推送到远程的哪个分支</li>
<li>这时 <code>--set-upstream</code> 就派上用场了，它不仅推送代码，还在远程仓库创建对应的分支，并建立跟踪关系</li>
<li><code>--set-upstream</code>: 这个选项告诉 Git 在推送的同时, 建立本地分支 <code>feature/user-auth </code>与远程分支 <code>origin/feature/user-auth</code> 之间的关联关系</li>
</ul>
<blockquote>
<p>一旦这个跟踪关系建立完成</p>
<p>当你<strong>处于 <code>feature/user-auth</code> 分支</strong>并运行 <code>git push</code> 时，Git 会根据已建立的跟踪关系，自动将代码推送到 <code>origin/feature/user-auth</code> 分支，而无需再次手动指定远程分支</p>
<p>但这仅适用于<strong>当前分支</strong>。如果你当前不在 <code>feature/user-auth</code> 分支（比如切换到了 <code>develop</code> 分支），运行 <code>git push</code> 时，Git 只会推送<strong>当前分支</strong>到它所跟踪的远程分支（如果有跟踪关系的话），或者根据 Git 的默认推送策略执行操作，而不会自动推送 <code>feature/user-auth</code></p>
</blockquote>
<h3 id="23-保持分支不过度落后的同步操作">2.3. 保持分支“不过度落后”的同步操作<a href="#23-保持分支不过度落后的同步操作" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>如果你的 <code>feature/user-auth</code> 分支开发周期较长，而 <code>develop</code> 分支上其他同事也在更新，担心合并冲突会越来越多，所以需要定期“同步”一下 <code>develop</code> 最新代码到你的 <code>feature/user-auth</code> 分支, 在开始操作前，先确认你的 <code>feature/user-auth</code> 分支没有未提交的更改：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git status
</span></span></code></pre></div><ul>
<li>如果有未提交的更改，先用 git add 和 git commit 提交，或者用 git stash 暂时保存</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git switch feature/user-auth <span style="color:#75715e"># 确保当前在 feature/user-auth 分支上操作</span>
</span></span><span style="display:flex;"><span>git fetch origin 						<span style="color:#75715e"># 拉取 合并 </span>
</span></span><span style="display:flex;"><span>git merge origin/develop
</span></span></code></pre></div><ul>
<li>为什么不用 <code>git pull</code>: <code>git pull</code> 是 <code>git fetch</code> 和 <code>git merge</code> 的组合，会直接合并远程分支到本地分支</li>
</ul>
<blockquote>
<p><strong>开源项目场景</strong></p>
<ul>
<li>origin 默认指向你自己 Forked 的仓库（例如 <a href="https://github.com/your-username/original-repo.git">https://github.com/your-username/original-repo.git</a>）</li>
<li>因此 <code>git fetch origin</code> 只会拉取你自己仓库的更新</li>
<li>但在开源协作中，你通常需要获取<strong>原始仓库</strong>（别人的仓库）的最新更新，而不是自己仓库的更新, 问题在于，你还没有设置一个指向原始仓库的远程仓库（通常命名为 upstream）, 因此，单纯使用 fetch origin 无法达到拉取更新的目的</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 添加原始仓库作为 upstream</span>
</span></span><span style="display:flex;"><span>git remote add upstream https://github.com/original-owner/original-repo.git
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 使用 fetch 从 upstream 获取最新更改</span>
</span></span><span style="display:flex;"><span>git fetch upstream
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>git checkout feature-branch
</span></span><span style="display:flex;"><span>git rebase/merage upstream/main
</span></span></code></pre></div></blockquote>
<blockquote>
<p>我们知道 在拉取更新的时候 一般会拉取某个特定的远程分支, 然后把它与我们的本地分支合并, 以便让自己的分支保持最新状态, 可是我们应该合并哪个分支？main 还是 develop 还是其他分支？</p>
<ul>
<li>查看项目文档：大多数开源项目会在 README 或 CONTRIBUTING.md 中说明分支使用规则，例如新特性应该基于 develop，bug 修复基于 main</li>
<li>分支基础：创建本地分支时，通常是从某个远程分支（如 main 或 develop）拉取的, 保持与这个“基础分支”一致即可</li>
<li>默认情况：如果项目没有明确说明，通常与 main（或 master）保持同步，因为它是默认的主分支</li>
</ul>
<p>不是所有开发分支都合并到主分支，直接合并主分支就行？</p>
<p>不一定, 不同的项目有不同的分支管理策略：</p>
<ul>
<li>单一主分支模型：只有一个 main 分支，所有开发分支最终合并到 main, 这种情况下，直接与 main 保持同步即可</li>
<li>多分支模型：例如有 main（稳定分支）和 develop（开发分支），新特性先合并到 develop，然后定期将 develop 合并到 main, 这种情况下，需要根据分支目的选择同步对象</li>
</ul>
</blockquote>
<h3 id="24-git-stash">2.4. git stash<a href="#24-git-stash" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>在上一步确保自己分支最新, 通常的流程是:</p>
<ul>
<li>使用 git fetch upstream 获取更新</li>
<li>使用 git merge upstream/main 或 git rebase upstream/main 将更新应用到本地分支</li>
</ul>
<p>但是否需要使用 git stash 和 git stash pop，取决于你的<strong>工作目录状态</strong>, git stash 的作用是临时保存当前工作目录和暂存区的未提交更改, 并将工作目录恢复到干净状态, 它的必要性取决于以下情况:</p>
<p>如果你在 feature-branch 上修改了文件但尚未提交（即 git status 显示有改动）, 直接执行 git merge 或 git rebase 会失败, Git 会提示你先提交或处理这些更改, 因为合并操作需要一个干净的工作目录</p>
<p><strong>解决方法</strong>：使用 git stash 保存未提交更改，拉取并合并更新后再恢复</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 隐藏更改</span>
</span></span><span style="display:flex;"><span>git stash
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 拉取更新</span>
</span></span><span style="display:flex;"><span>git fetch upstream main
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 合并更新</span>
</span></span><span style="display:flex;"><span>git merge upstream/main
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 弹出更改 继续工作</span>
</span></span><span style="display:flex;"><span>git stash pop
</span></span></code></pre></div><blockquote>
<p>注意一般只有参加开源项目才会使用 <code>upstream</code></p>
<ul>
<li>
<p>尽量在合并前提交更改 commit，保持工作目录干净，减少使用 git stash 的需求</p>
</li>
<li>
<p>如果使用 git stash，注意合并后的冲突处理</p>
</li>
</ul>
</blockquote>
<h3 id="25-rebase-vs-merge">2.5. rebase vs merge<a href="#25-rebase-vs-merge" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git fetch origin
</span></span><span style="display:flex;"><span>git switch feature/user-auth
</span></span><span style="display:flex;"><span>git rebase origin/develop
</span></span></code></pre></div><p>初始状态</p>
<pre tabindex="0"><code>origin/develop:   A --- B --- C
                  \
feature/user-auth:  D --- E
</code></pre><p>用 merge</p>
<pre tabindex="0"><code>origin/develop:   A --- B --- C
                  \           \
feature/user-auth:  D --- E --- M (M 是合并提交)
</code></pre><p>用 rebase</p>
<pre tabindex="0"><code>origin/develop:   A --- B --- C
                              \
feature/user-auth:             D&#39; --- E&#39;
</code></pre><p>D&rsquo; 和 E&rsquo; 是 D 和 E 的新版本, 基于 C</p>
<ul>
<li>rebase 通过把 feature/user-auth 的提交搬到 origin/develop 最新点的方式来更新  feature/user-auth 内容, 因为这样可以保持线性历史</li>
<li>rebase 让 feature/user-auth 的提交历史看起来像是直接从 origin/develop 的最新点开始，没有分叉和额外的合并提交。这种干净的线性历史更易读，尤其在将来合并回 develop 时</li>
<li>merge 会引入一个合并提交（比如 M），记录了分叉和汇合的过程。虽然这保留了完整的历史，但在一些团队中（尤其是追求简洁历史的团队），可能会显得“杂乱”</li>
<li>如果 <code>feature/user-auth</code> 是你个人的特性分支（未被多人共享），rebase 是安全的，因为它重写历史不会影响他人</li>
<li>但如果 <code>feature/user-auth</code> 是多人协作的分支，rebase 可能会导致问题（其他人需要同步重写后的历史），这时 merge 更合适</li>
</ul>
<p><code>develop</code> 是公共分支, <code>feature/user-auth</code> 是你自己的分支, 不要在 公共 分支上做 rebase, 只可以在自己的私有分支做 rebase, 就是记住一句话, 不要随便用 rebase, 用之前确认好, <code>git rebase origin/develop</code> 的意思是在 <code>feature/user-auth</code> 做 rebase, 不要理解错了</p>
<h3 id="26-推送">2.6. 推送<a href="#26-推送" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p><strong>用 merge 后的推送</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git push
</span></span></code></pre></div><ul>
<li>远程分支 origin/feature/user-auth 会更新为包含合并提交的历史（A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; M）</li>
<li>因为只是追加了新提交，推送是自然的增量更新，无需强制推送</li>
</ul>
<p><strong>用 rebase 后的推送</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git push --force-with-lease
</span></span></code></pre></div><ul>
<li>注意: <code>--force-with-lease</code> 不是 <code>--force</code></li>
<li>因为 rebase 重写了 feature/user-auth 的提交历史（从 A -&gt; D -&gt; E 变成 A -&gt; B -&gt; C -&gt; D&rsquo; -&gt; E&rsquo;），本地和远程的历史不再匹配</li>
<li>普通 <code>git push</code> 会被拒绝（因为不是快进更新），需要用 <code>--force-with-lease</code> 强制覆盖远程分支</li>
<li><code>rebase</code>  推送需要强制（git push &ndash;force-with-lease），会覆盖远程历史，仅适合个人分支或提前沟通好的团队</li>
</ul>
<h3 id="27-pr">2.7. PR<a href="#27-pr" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<ul>
<li>
<p>登录 Git 仓库平台（GitHub / GitLab），找到 <code>feature/user-auth</code> 分支，发起 Merge Request / Pull Request 到 <code>develop</code></p>
</li>
<li>
<p>填写说明，例如 “新增用户登录和注册，数据库schema改动如下&hellip;”</p>
</li>
<li>
<p>通过同事的 Review 后，点击“合并”按钮把 <code>feature/user-auth</code> 合并进 <code>develop</code></p>
</li>
<li>
<p>删掉远程 <code>feature/user-auth</code> 分支（可选），以及本地分支</p>
</li>
<li>
<p>你再切换回 develop 分支, 拉取最新改动, 准备下一个功能</p>
</li>
</ul>
<h2 id="3-一些注意的地方">3. 一些注意的地方<a href="#3-一些注意的地方" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<h3 id="31-公司内部--团队协作常见场景">3.1. 公司内部 / 团队协作（常见场景）<a href="#31-公司内部--团队协作常见场景" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>一般在开发中,你拥有直接向团队的远程仓库推送代码的权限</p>
<p>所以：</p>
<ol>
<li>直接克隆公司（或团队）仓库到本地：<code>git clone git@github.com:Company/Project.git</code></li>
<li>在同一个仓库中创建分支（如 <code>feature/xxx</code>），再 push 分支到公司远程库 <code>origin</code> 的 <code>feature/xxx</code> 分支</li>
<li>在 GitLab/GitHub 企业版上，对同一个远程仓库发起 Merge Request / Pull Request</li>
</ol>
<p>这一套流程下, 不需要你先 fork 一份“自己的”仓库, 因为你已经是这个仓库的协作者, 有权限直接操作主仓库分支</p>
<h3 id="32-个人--开源项目贡献fork-工作流">3.2. 个人 / 开源项目贡献（Fork 工作流）<a href="#32-个人--开源项目贡献fork-工作流" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>如果你想给某个 并非自己管理 的开源项目贡献代码，而你没有对它的仓库“写权限”，则必须先 Fork 一份到自己的 GitHub 账户下，做一个属于你自己的远程仓库, 典型流程：</p>
<ol>
<li>打开开源项目主页，点 Fork</li>
<li>在你的个人 GitHub 账户下，就会生成一个“forked” 仓库（地址类似：<code>github.com/YourName/Project</code>）</li>
<li>你再执行 <code>git clone git@github.com:YourName/Project.git</code>（从你自己的 fork 拉取到本地）</li>
<li>在本地切分支开发，push 到你自己的 fork（也就是 origin 指向 <code>YourName/Project.git</code>）</li>
<li>在 GitHub 上向 上游仓库（官方项目 <code>Company/Project.git</code>）提交 Pull Request</li>
</ol>
<p>这样就实现了“没有写权限的外部贡献者”把代码贡献到开源项目的流程, 在开源世界里，经常会看到文档写到 <code>upstream</code> 和 <code>origin</code> 两个远程：</p>
<ul>
<li><code>origin</code>：你自己 fork 的仓库地址（你有写权限）</li>
<li><code>upstream</code>：原始官方仓库地址（你没有写权限，只有读权限）</li>
<li>你会不定期执行 <code>git pull upstream main</code> (或 master, 或 develop) 来保持和官方仓库同步</li>
</ul>
<h2 id="4-实践">4. 实践<a href="#4-实践" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>现在的情况, 有下面这几个分支:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>  deps/update-requirements
</span></span><span style="display:flex;"><span>  feature/add-redis-client
</span></span><span style="display:flex;"><span>  feature/file-upload
</span></span><span style="display:flex;"><span>  fix/fk-reference-cycle
</span></span><span style="display:flex;"><span>  fix/init-data-migration
</span></span><span style="display:flex;"><span>* main
</span></span><span style="display:flex;"><span>  remotes/origin/HEAD -&gt; origin/main
</span></span></code></pre></div><ul>
<li>
<p>我在本地创建了新分支 deps/update-requirements 做了修改并提交, 推送到了远程仓库, 然后创建了 PR, 注意此时 PR 暂时没被接受</p>
</li>
<li>
<p>期间远程仓库有其他人做了提交</p>
</li>
<li>
<p>之后我又在本地创建了新分支 fix/fk-reference-cycle, 然后做了修改并提交, 然后推送到远程仓库, 然后创建了 PR, 注意此时 PR 暂时没被接受</p>
</li>
<li>
<p>期间远程仓库有其他人做了提交</p>
</li>
<li>
<p>之后相同, 创建提交推送 fix/init-data-migration, 创建 PR, 依然暂时没被接受</p>
</li>
<li>
<p>期间远程仓库有其他人做了提交</p>
</li>
<li>
<p>之后相同, 创建提交推送 feature/file-upload, 创建 PR, 依然暂时没被接受</p>
</li>
<li>
<p>期间远程仓库有其他人做了提交</p>
</li>
<li>
<p>此时之前所有的分支的 PR 都被合并到了 origin main 分支</p>
</li>
<li>
<p>然后我在本地创建新分支 feature/add-redis-client, fetch origin main, 然后 merge origin/mian, 所以此时 feature/add-redis-client 应该是最新的</p>
</li>
<li>
<p>然后我又转到了本地 main 分支, 执行 fetch origin main, 然后 merge origin/mian,</p>
</li>
</ul>
<blockquote>
<p>此时, 我想知道的是, 我打算删除 deps/update-requirements, fix/fk-reference-cycle, fix/init-data-migration 分支, 因为我可以确定以后不会使用他们了, 请问在一般的开发工作流中, 我应该怎么删除这些分支, 我应该同时删除本地和远程分支吗? 给出理由</p>
</blockquote>
<ul>
<li>是的, 应该同时删除本地和远程分支</li>
<li>远程分支删除后，本地保留分支可能会导致误解，比如误以为这些分支还有未完成的工作</li>
<li>删除远程分支可以避免其他开发者误用这些已合并的分支，保持远程仓库的整洁和清晰</li>
<li>在 Git 工作流（如 Git Flow）中，已合并的分支通常会在 PR 完成后被删除，这是标准实践</li>
</ul>
<p><strong>删除本地分支</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git branch -d deps/update-requirements
</span></span><span style="display:flex;"><span>git branch -d fix/fk-reference-cycle
</span></span><span style="display:flex;"><span>git branch -d fix/init-data-migration
</span></span></code></pre></div><ul>
<li><code>git branch -d</code> 是删除本地分支的安全方式, 它会检查这些分支是否已合并到当前分支, 通常是 main</li>
<li>因为这些分支的 PR 已被合并到 <code>origin/main</code>，而你已经将本地的 <code>main</code> 分支更新到 <code>origin/main</code> 的最新状态（通过 fetch 和 merge），所以这些分支的更改已经包含在本地 main 中，Git 会允许删除它们</li>
</ul>
<p><strong>删除远程分支</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git push origin --delete deps/update-requirements
</span></span><span style="display:flex;"><span>git push origin --delete fix/fk-reference-cycle
</span></span><span style="display:flex;"><span>git push origin --delete fix/init-data-migration
</span></span></code></pre></div><ul>
<li>
<p><code>git push origin --delete &lt;branch_name&gt;</code> 会删除远程仓库中的对应分支</p>
</li>
<li>
<p>这些分支的 PR 已经合并到 <code>origin/main</code>，远程分支已无保留必要，删除它们是常见做法</p>
</li>
</ul>
<blockquote>
<p>另外此时我想回到本地的 feature/file-upload 分支进行一些新的修改, 可是我在本地分支  feature/file-upload  还没有进行 merge 远程最新提交, 此时我应该怎么做?</p>
</blockquote>
<p><strong>首先, 切换到这个分支 并 合并 <code>main</code> 分支到 <code>feature/file-upload</code>:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git checkout feature/file-upload
</span></span><span style="display:flex;"><span>git merge main
</span></span></code></pre></div><ul>
<li>因为你的本地 <code>main</code> 分支已经通过 <code>fetch</code> 和 <code>merge</code> 更新到了 <code>origin/main</code> 的最新状态，你可以直接将 <code>main</code> 合并到 <code>feature/file-upload</code></li>
</ul>
<p><strong>进行新的修改</strong> 合并完成后, <code>feature/file-upload</code> 分支就处于最新状态, 你可以开始进行新的修改并提交:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 进行修改后</span>
</span></span><span style="display:flex;"><span>git add .
</span></span><span style="display:flex;"><span>git commit -m <span style="color:#e6db74">&#34;添加新的修改&#34;</span>
</span></span></code></pre></div><p>我在 main 分支上做了修改和提交, 其实我应该在 另外一个功能分支做 commit, 因此, 我应该撤销刚刚的提交:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span> git reset --soft HEAD^1
</span></span></code></pre></div>
      </div></div>

  
    
<div class="pagination">
  <div class="pagination__title">
    <span class="pagination__title-h">查看其他文章</span>
    <hr />
  </div>
  <div class="pagination__buttons">
    
      <a href="https://blog.jiyi27.com/posts/git/007-git-443-port/" class="button inline prev">
        git 22 端口被禁用
      </a>
    
    
      ::
    
    
      <a href="https://blog.jiyi27.com/posts/interview/%E7%AE%97%E6%B3%95/005-%E4%BA%8C%E5%8F%89%E6%A0%91/" class="button inline next">
        二叉树和堆
      </a>
    
  </div>
</div>


  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/jiyi27/jiyi27.github.io" target="_blank">Theme</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
