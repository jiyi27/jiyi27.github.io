<!DOCTYPE html>
<html lang="en">
<head>
  
    
    <title>Struct &amp; Class - Swift :: 为霜的博客</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="1. Struct vs Class 1.1. Value Types and Reference Types Structures are value types—unlike classes—local changes to a structure aren’t visible to the rest of your app unless you intentionally communicate those changes as part of the flow of your app.
Structures are Value Types: When you pass a structure to a function, or assign it to a variable, a copy of the structure&rsquo;s data is created. Modifying the copy doesn&rsquo;t affect the original.
" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://blog.jiyi27.com/posts/ios/swift/003-class-struct/" />





  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/buttons.min.2bc533403a27dfe0e93105a92502b42ce4587e2e4a87d9f7d349e51e16e09478.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/categories.min.3202f75cbb294747099af3850a68a09ee94b3ce505fc39e134692d90ff0a9b2a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/code.min.dd73d157e77e82a3dc1cb06ba424cf6cc6811af0bb604ad6c68e70faf2439c8a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/fonts.min.4881f0c525f3ce2a1864fb6e96676396cebe1e6fcef1933e8e1dde7041004fb5.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/footer.min.2e3eb191baee58dd05a9f0104ac1fab0827bca7c64dafe0b2579f934c33a1d69.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/header.min.b6fb4423cf82a9f9d7abc9cd010223fa3d70a6526a3f28f8e17d814c06e18f9e.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/main.min.3fb8954e26342ad3afabb4525959bfec6f9fc0d6929f0dda738ddeee30211690.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/menu.min.8cee75f73b9f9b1e40bd0dd53e6e770156b08bbfe1c579cd256c3f6cd3b6d32b.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/pagination.min.82f6400eae7c7c6dc3c866733c2ec0579e4089608fea69400ff85b3880aa0d3c.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/post.min.014a50745fbdd41d5f420a3e288730d5af4b7d90344dc6211d0e50c368b5b303.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/prism.min.b958d3d7c6c67361b945f9062d07d403422604b3d2cd33f93b88d41ed0ba634d.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/term.min.94de320c1b850e126e6d2c88a7c90acf58bb1313f0ea14a14cda2a42f2a88db2.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">


<link rel="stylesheet" href="https://blog.jiyi27.com/terminal.css">




<link rel="shortcut icon" href="https://blog.jiyi27.com/favicon.png">
<link rel="apple-touch-icon" href="https://blog.jiyi27.com/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Struct &amp; Class - Swift">
<meta property="og:description" content="1. Struct vs Class 1.1. Value Types and Reference Types Structures are value types—unlike classes—local changes to a structure aren’t visible to the rest of your app unless you intentionally communicate those changes as part of the flow of your app.
Structures are Value Types: When you pass a structure to a function, or assign it to a variable, a copy of the structure&rsquo;s data is created. Modifying the copy doesn&rsquo;t affect the original.
" />
<meta property="og:url" content="https://blog.jiyi27.com/posts/ios/swift/003-class-struct/" />
<meta property="og:site_name" content="为霜的博客" />

  <meta property="og:image" content="https://blog.jiyi27.com/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">

  <meta property="article:section" content="ios" />


  <meta property="article:published_time" content="2024-05-26 16:03:35 &#43;0000 UTC" />












</head>
<body>


<div class="container center">

  
  
  

  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://blog.jiyi27.com/posts/ios/swift/003-class-struct/">Struct &amp; Class - Swift</a>
  </h1>
  <div class="post-meta"><time class="post-date">2024-05-26</time><span class="post-reading-time">6 分钟阅读 (1262 字数)</span></div>

  
    <span class="post-tags">
      
      #<a href="https://blog.jiyi27.com/tags/ios/">ios</a>&nbsp;
      
      #<a href="https://blog.jiyi27.com/tags/swift/">swift</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <h2 id="1-struct-vs-class">1. Struct vs Class<a href="#1-struct-vs-class" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<h3 id="11-value-types-and-reference-types">1.1. Value Types and Reference Types<a href="#11-value-types-and-reference-types" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Structures are value types—unlike classes—local changes to a structure aren’t visible to the rest of your app unless you intentionally communicate those changes as part of the flow of your app.</p>
<ul>
<li>
<p><strong>Structures are Value Types:</strong> When you pass a structure to a function, or assign it to a variable, a <em>copy</em> of the structure&rsquo;s data is created. Modifying the copy doesn&rsquo;t affect the original.</p>
</li>
<li>
<p><strong>Classes are Reference Types:</strong> When you pass a class instance around, you&rsquo;re essentially passing a reference to the <em>same</em> underlying object. Changes made through one reference impact the original object and are visible everywhere else it&rsquo;s referenced.</p>
</li>
</ul>
<p>References: <a href="https://developer.apple.com/documentation/swift/choosing-between-structures-and-classes">Choosing Between Structures and Classes | Apple Developer Documentation</a></p>
<h3 id="12-mutable-and-immutable">1.2. Mutable and Immutable<a href="#12-mutable-and-immutable" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Structs are immutable, classed are mutable. What does this mean?</p>
<h4 id="121-let-and-var-instance-of-struct">1.2.1. <code>let</code> and <code>var</code> instance of <code>struct</code><a href="#121-let-and-var-instance-of-struct" class="hanchor" ariaLabel="Anchor">#</a> </h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Point</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> x: Int
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> y: Int
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> point1 = Point(x: <span style="color:#ae81ff">1</span>, y: <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>point.x = <span style="color:#ae81ff">10</span>  <span style="color:#75715e">// Can directly modify properties</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> point2 = Point(x: <span style="color:#ae81ff">3</span>, y: <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>point2.x = <span style="color:#ae81ff">5</span>  <span style="color:#75715e">// This would cause a compile-time error, class has no this limit</span>
</span></span></code></pre></div><h4 id="122-mutating-keyword-in-struct">1.2.2. <code>mutating</code> keyword in <code>struct</code><a href="#122-mutating-keyword-in-struct" class="hanchor" ariaLabel="Anchor">#</a> </h4>
<p>Structures and enumerations are <em>value types</em>. By default, the properties of a value type can’t be modified from within its instance methods. However, if you need to modify the properties of your structure or enumeration within a particular method, you can opt in to <code>mutating</code> behavior for that method. [&ndash;Apple Docs](</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Rectangle</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> width: Double = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> height: Double = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> area: Double {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">get</span> {
</span></span><span style="display:flex;"><span>            width = <span style="color:#ae81ff">9</span> <span style="color:#75715e">// error: Cannot assign to property: &#39;self&#39; is immutable</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> width <span style="color:#f92672">*</span> height
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">set</span> {
</span></span><span style="display:flex;"><span>            height = <span style="color:#ae81ff">3</span> <span style="color:#75715e">// only here is allowed</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">setWidth</span>(width: Double) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.width = width <span style="color:#75715e">// error: Cannot assign to property: &#39;self&#39; is immutable.</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">mutating</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">setHeight</span>(height: Double) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">self</span>.height = height <span style="color:#75715e">// No error.</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="123-weird-behavior">1.2.3. Weird Behavior<a href="#123-weird-behavior" class="hanchor" ariaLabel="Anchor">#</a> </h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Rectangle</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> width: Double = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> height: Double = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> area: Double {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">get</span> {
</span></span><span style="display:flex;"><span>            width = <span style="color:#ae81ff">9</span> <span style="color:#75715e">// error: Cannot assign to property: &#39;self&#39; is immutable</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> width <span style="color:#f92672">*</span> height
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">set</span> {
</span></span><span style="display:flex;"><span>            height = <span style="color:#ae81ff">3</span> <span style="color:#75715e">// only here is allowed, don&#39;t know why...</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p><strong>Note:</strong> <code>class</code> has no those limitations listed above.</p>
</blockquote>
<h3 id="struct-in-swiftui---practice"><code>struct</code> in SwiftUI - Practice<a href="#struct-in-swiftui---practice" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>除了使用 mutating 关键字, 在 SwiftUI 中, 我们常通过 @State 允许 struct 的属性被修改:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ContentView</span>: View {
</span></span><span style="display:flex;"><span>    @State <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> age = <span style="color:#ae81ff">12</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> name = <span style="color:#e6db74">&#34;John&#34;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> body: some View {
</span></span><span style="display:flex;"><span>        VStack {
</span></span><span style="display:flex;"><span>            Text(<span style="color:#e6db74">&#34;Name: </span><span style="color:#e6db74">\(</span>name<span style="color:#e6db74">)</span><span style="color:#e6db74">, Age: </span><span style="color:#e6db74">\(</span>age<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>            Button(<span style="color:#e6db74">&#34;Click to Increase Age by One&#34;</span>) {
</span></span><span style="display:flex;"><span>                age <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span> <span style="color:#75715e">// No error. </span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            Button(<span style="color:#e6db74">&#34;Change Name&#34;</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//name = &#34;Jane&#34; // error: Cannot assign to property: &#39;self&#39; is immutable</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>细心观察可以发现 SwiftUI 的 Views 都是 struct 而不是 class, 这也是因为 struct 是值类型, 这样每当你进行拷贝或者传递一个 view 时, 被传递的是个新的单独的 view, 而不是传递一个引用, 这样便有很好的隔离性, 这是什么意思呢,</p>
<p>The few posts here are missing the point. The point of structs is that they are copied on assignment. Why is that good? Because it’s the only thing that encourages local reasoning, which means the ability to look at one block of code and only have to think about what it is doing.</p>
<p>With classes, you pass them around by reference and all of a sudden you can have objects on the other side of the planet that are all referencing the same object. That’s not clear at all from looking at them, so you need to trace their origin back to some unrelated part of the system. This is known as reference aliasing. It’s not bad in itself, but when shared references are also allowed to be mutated, you can’t reason locally about anything. You have to know who had references to each object at all times. That can be the difference between looking at 10 and 100,000 lines of code. Which would you rather look at?</p>
<p>Yes, structs are also allocated on the stack. But that’s not what makes them useful. What makes them useful is their inability to be shared.</p>
<p>Reference: <a href="https://www.reddit.com/r/swift/comments/dg2lrp/comment/f39if54/?utm_source=share&amp;utm_medium=web3x&amp;utm_name=web3xcss&amp;utm_term=1&amp;utm_content=share_button">https://www.reddit.com/r/swift/comments/dg2lrp/comment/f39if54/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button</a></p>
<h2 id="2-property-observers-didset-and-willset">2. Property observers: <code>didSet</code> and <code>willSet</code><a href="#2-property-observers-didset-and-willset" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>Property observers let you execute code whenever a property has changed. To make them work, we use either <code>didSet</code> to execute code when a property has just been set, or <code>willSet</code> to execute code before a property has been set.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LightBulb</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> brightness: Int = <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">willSet</span>(newBrightness) { <span style="color:#75715e">// 显式声明 newValue 参数</span>
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">&#34;旧亮度为 </span><span style="color:#e6db74">\(</span>brightness<span style="color:#e6db74">)</span><span style="color:#e6db74">，即将调整为 </span><span style="color:#e6db74">\(</span>newBrightness<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">didSet</span> {
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">&#34;亮度从 </span><span style="color:#e6db74">\(</span>oldValue<span style="color:#e6db74">)</span><span style="color:#e6db74"> 调整为 </span><span style="color:#e6db74">\(</span>brightness<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> bulb = LightBulb()
</span></span><span style="display:flex;"><span>bulb.brightness = <span style="color:#ae81ff">50</span>  <span style="color:#75715e">// 输出：旧亮度为 0，即将调整为 50</span>
</span></span><span style="display:flex;"><span>                      <span style="color:#75715e">// 输出：亮度从 0 调整为 50</span>
</span></span></code></pre></div><p>The default parameter names are <code>newValue</code> for <code>willSet</code> and <code>oldValue</code> for <code>didSet</code>, or you can name them yourself as in <code>willSet(newTotalSteps)</code>.</p>
<h2 id="3-properties">3. Properties<a href="#3-properties" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p><em>Stored</em> and <em>computed properties</em> are usually associated with instances of a particular type. However, properties can also be associated with the type itself. Such properties are known as <em>type properties</em>.</p>
<p>In addition, you can define <strong>property observers</strong> to monitor changes in a property’s value, which you can respond to with custom actions. Property observers can be added to stored properties you define yourself, and also to properties that a subclass inherits from its superclass.</p>
<p>You can also use a <strong>property wrapper</strong> to reuse code in the getter and setter of multiple properties.</p>
<h3 id="31-lazy-stored-properties">3.1. Lazy Stored Properties<a href="#31-lazy-stored-properties" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>A <em>lazy stored property</em> is a property whose initial value isn’t calculated until the first time it’s used.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DataManager</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">lazy</span> <span style="color:#66d9ef">var</span> importer = DataImporter()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> data: [String] = []
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// the DataManager class would provide data management functionality here</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> manager = DataManager()
</span></span><span style="display:flex;"><span>manager.data.append(<span style="color:#e6db74">&#34;Some data&#34;</span>)
</span></span><span style="display:flex;"><span>manager.data.append(<span style="color:#e6db74">&#34;Some more data&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// the DataImporter instance for the importer property hasn&#39;t yet been created</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(manager.importer.filename)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// the DataImporter instance for the importer property has now been created</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Prints &#34;data.txt&#34;</span>
</span></span></code></pre></div><p>Because it’s possible for a <code>DataManager</code> instance to manage its data without ever importing data from a file, <code>DataManager</code> doesn’t create a new <code>DataImporter</code> instance when the <code>DataManager</code> itself is created. Instead, it makes more sense to create the <code>DataImporter</code> instance if and when it’s first used.</p>
<h3 id="32-computed-properties">3.2. Computed Properties<a href="#32-computed-properties" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>In addition to stored properties, classes, structures, and enumerations can define <em>computed properties</em>. In Swift, a computed property does not store a value itself. Instead, it provides a getter to retrieve a value and an optional setter to indirectly set other properties or values.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Rectangle</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">var</span> width: Double
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">var</span> height: Double
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">var</span> area: Double {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// implicit return</span>
</span></span><span style="display:flex;"><span>       width <span style="color:#f92672">*</span> height
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> rectangle = Rectangle(width: <span style="color:#ae81ff">5.0</span>, height: <span style="color:#ae81ff">10.0</span>)
</span></span><span style="display:flex;"><span>print(rectangle.area)  <span style="color:#75715e">// 50.0</span>
</span></span></code></pre></div><p>如果对计算属性赋值会发生什么?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> rectangle = Rectangle(width: <span style="color:#ae81ff">5</span>, height: <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>print(rectangle.area) <span style="color:#75715e">// 15.0</span>
</span></span><span style="display:flex;"><span>rectangle.area = <span style="color:#ae81ff">20.0</span> <span style="color:#75715e">// Error: Cannot assign to property: &#39;area&#39; is a get-only property</span>
</span></span></code></pre></div><p>上面的例子中是计算属性常见的样子, 即拥有一个默认的 getter, 此时它是一个只读属性,  你也可以让其可以被“赋值”, 如下:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Cat</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> age: Int
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> months: Int {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">get</span> {
</span></span><span style="display:flex;"><span>            age <span style="color:#f92672">*</span> <span style="color:#ae81ff">12</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// newValue is default parameter name of the setter.</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">set</span> {
</span></span><span style="display:flex;"><span>            age = newValue <span style="color:#f92672">/</span> <span style="color:#ae81ff">12</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> cat = Cat(age: <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>print(cat.months) <span style="color:#75715e">// 24</span>
</span></span><span style="display:flex;"><span>cat.months = <span style="color:#ae81ff">12</span>
</span></span><span style="display:flex;"><span>print(cat.age) <span style="color:#75715e">// 1</span>
</span></span></code></pre></div><p>计算属性本身并不存储任何东西, 它更像是个函数, 为什么可以被“赋值”呢? 仔细看看 set 函数里, <code>months</code> 真的被赋值了吗? 仍然没有, 只是在其复制的时候执行了 <code>age = newValue / 12</code> 而已.</p>
<p>代码 <code>cat.months = 12</code> 就是把 <code>12</code> 传给其 <code>setter</code>, 而 <code>cat.months</code> 就是调用其 <code>getter</code>, 返回 <code>age * 12</code>, 这也是为什么说其是计算属性. 所以有没有觉得如果在其 getter 里尝试访问 <code>months</code>的值很奇怪? 因为 months 本身就不存在啊, 它其实就是 <code>age * 12</code>,</p>
<blockquote>
<p>Stored property has default setter and getter, you cannot override <code>get</code>/<code>set</code> for a stored property.  But You can use property observers <code>willSet</code>/<code>didSet</code> to achiveve what you want.  Source: <a href="https://stackoverflow.com/a/24116083/16317008">https://stackoverflow.com/a/24116083/16317008</a></p>
</blockquote>
<p>设想一下, 每当你访问 area <code>rectangle.area</code>, 就会执行 <code>width * height</code> 并返回, 如果我们要在里面直接修改其他属性的值, 是不是很奇怪? 而 SwiftUI 中的 body 就是一个 read-only 计算属性, 所以直接在 body 中直接修改其属性是不推荐的,</p>

      </div></div>

  
    
<div class="pagination">
  <div class="pagination__title">
    <span class="pagination__title-h">查看其他文章</span>
    <hr />
  </div>
  <div class="pagination__buttons">
    
      <a href="https://blog.jiyi27.com/posts/ios/swiftui/001-basics/" class="button inline prev">
        SwiftUI Basics - Weather App
      </a>
    
    
      ::
    
    
      <a href="https://blog.jiyi27.com/posts/ios/swift/002-functions/" class="button inline next">
        Swift Functions
      </a>
    
  </div>
</div>


  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/jiyi27/jiyi27.github.io" target="_blank">Theme</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
