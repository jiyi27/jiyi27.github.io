<!DOCTYPE html>
<html lang="en">
<head>
  
    
    <title>Next.js 中间件漏洞 :: 为霜的博客</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="1. CDN 最近 Next.js 被发现安全漏洞, 今天休息来学习一下, 想要明白还是要先理解 CDN, 中间件, 缓存投毒等一些概念, 先来说一下 CDN, CDN 就像是个缓存, 这里的缓存和 Redis 缓存的数据不是一个东西, CDN 缓存的是静态页面:
Redis 缓存后端访问频繁的动态数据, 减少数据库压力, 提高 API 响应速度 CDN 缓存前端静态 HTML, CSS 文件, 减少前端服务器的压力, 节约成本, CDN 服务器的带宽大比较便宜些 常见的 CDN 服务商有赛博菩萨 Cloudflare, 一般我们都是使用他的域名托管服务, 他就像一个中间件, 在用户和我们前端服务器之间, 当用户访问我们的网站(通过域名), DNS 查询指向 Cloudflare 的服务器 (托管域名之后), 而不再是我们的 前端服务器 (运行 Nginx 的地方), 一般 Nginx 用来返回静态页面, 部署博客的话应该会很熟悉, 当然他也有反向代理, 负载均衡的功能, 所以用户请求 your_domain.com/index.html 时, Cloudflare 可能直接返回缓存的 index.html 文件, 而不是转发到你的 Nginx 服务器, 当然如果 Cloudflare 没缓存, 它会请求你的 Nginx, Nginx 返回 index.html, 然后 Cloudflare 缓存后分发, 大致是这样的:
" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://blog.jiyi27.com/posts/blogs/001-nextjs-middleware-bypass-issue/" />





  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/buttons.min.2bc533403a27dfe0e93105a92502b42ce4587e2e4a87d9f7d349e51e16e09478.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/categories.min.3202f75cbb294747099af3850a68a09ee94b3ce505fc39e134692d90ff0a9b2a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/code.min.dd73d157e77e82a3dc1cb06ba424cf6cc6811af0bb604ad6c68e70faf2439c8a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/fonts.min.4881f0c525f3ce2a1864fb6e96676396cebe1e6fcef1933e8e1dde7041004fb5.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/footer.min.2e3eb191baee58dd05a9f0104ac1fab0827bca7c64dafe0b2579f934c33a1d69.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/header.min.b6fb4423cf82a9f9d7abc9cd010223fa3d70a6526a3f28f8e17d814c06e18f9e.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/main.min.3fb8954e26342ad3afabb4525959bfec6f9fc0d6929f0dda738ddeee30211690.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/menu.min.8cee75f73b9f9b1e40bd0dd53e6e770156b08bbfe1c579cd256c3f6cd3b6d32b.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/pagination.min.82f6400eae7c7c6dc3c866733c2ec0579e4089608fea69400ff85b3880aa0d3c.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/post.min.014a50745fbdd41d5f420a3e288730d5af4b7d90344dc6211d0e50c368b5b303.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/prism.min.b958d3d7c6c67361b945f9062d07d403422604b3d2cd33f93b88d41ed0ba634d.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/term.min.94de320c1b850e126e6d2c88a7c90acf58bb1313f0ea14a14cda2a42f2a88db2.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">


<link rel="stylesheet" href="https://blog.jiyi27.com/terminal.css">




<link rel="shortcut icon" href="https://blog.jiyi27.com/favicon.png">
<link rel="apple-touch-icon" href="https://blog.jiyi27.com/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Next.js 中间件漏洞">
<meta property="og:description" content="1. CDN 最近 Next.js 被发现安全漏洞, 今天休息来学习一下, 想要明白还是要先理解 CDN, 中间件, 缓存投毒等一些概念, 先来说一下 CDN, CDN 就像是个缓存, 这里的缓存和 Redis 缓存的数据不是一个东西, CDN 缓存的是静态页面:
Redis 缓存后端访问频繁的动态数据, 减少数据库压力, 提高 API 响应速度 CDN 缓存前端静态 HTML, CSS 文件, 减少前端服务器的压力, 节约成本, CDN 服务器的带宽大比较便宜些 常见的 CDN 服务商有赛博菩萨 Cloudflare, 一般我们都是使用他的域名托管服务, 他就像一个中间件, 在用户和我们前端服务器之间, 当用户访问我们的网站(通过域名), DNS 查询指向 Cloudflare 的服务器 (托管域名之后), 而不再是我们的 前端服务器 (运行 Nginx 的地方), 一般 Nginx 用来返回静态页面, 部署博客的话应该会很熟悉, 当然他也有反向代理, 负载均衡的功能, 所以用户请求 your_domain.com/index.html 时, Cloudflare 可能直接返回缓存的 index.html 文件, 而不是转发到你的 Nginx 服务器, 当然如果 Cloudflare 没缓存, 它会请求你的 Nginx, Nginx 返回 index.html, 然后 Cloudflare 缓存后分发, 大致是这样的:
" />
<meta property="og:url" content="https://blog.jiyi27.com/posts/blogs/001-nextjs-middleware-bypass-issue/" />
<meta property="og:site_name" content="为霜的博客" />

  <meta property="og:image" content="https://blog.jiyi27.com/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">

  <meta property="article:section" content="随笔" />


  <meta property="article:published_time" content="2025-04-12 17:46:35 &#43;0000 UTC" />












</head>
<body>


<div class="container center">

  
  
  

  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://blog.jiyi27.com/posts/blogs/001-nextjs-middleware-bypass-issue/">Next.js 中间件漏洞</a>
  </h1>
  <div class="post-meta"><time class="post-date">2025-04-12</time><span class="post-reading-time">3 分钟阅读 (505 字数)</span></div>

  
    <span class="post-tags">
      
      #<a href="https://blog.jiyi27.com/tags/%E9%9A%8F%E7%AC%94/">随笔</a>&nbsp;
      
      #<a href="https://blog.jiyi27.com/tags/%E5%AE%9E%E4%BA%8B/">实事</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <h2 id="1-cdn">1. CDN<a href="#1-cdn" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>最近 Next.js 被发现安全漏洞, 今天休息来学习一下, 想要明白还是要先理解 CDN, 中间件, 缓存投毒等一些概念, 先来说一下 CDN, CDN 就像是个缓存, 这里的缓存和 Redis 缓存的数据不是一个东西, CDN 缓存的是静态页面:</p>
<ul>
<li>Redis 缓存<strong>后端</strong>访问频繁的动态数据, 减少数据库压力, 提高 API 响应速度</li>
<li>CDN 缓存<strong>前端</strong>静态 HTML, CSS 文件, 减少前端服务器的压力, 节约成本, CDN 服务器的带宽大比较便宜些</li>
</ul>
<p>常见的 CDN 服务商有赛博菩萨 Cloudflare, 一般我们都是使用他的域名托管服务, 他就像一个中间件, 在用户和我们前端服务器之间, 当用户访问我们的网站(通过域名), DNS 查询指向 Cloudflare 的服务器 (托管域名之后), 而不再是我们的 前端服务器 (运行 Nginx 的地方), 一般 Nginx 用来返回静态页面, 部署博客的话应该会很熟悉, 当然他也有反向代理, 负载均衡的功能, 所以用户请求  <code>your_domain.com/index.html</code> 时, Cloudflare 可能直接返回缓存的 <code>index.html</code> 文件, 而不是转发到你的 Nginx 服务器, 当然如果 Cloudflare 没缓存, 它会请求你的 Nginx, Nginx 返回 index.html, 然后 Cloudflare 缓存后分发, 大致是这样的:</p>
<pre tabindex="0"><code>用户                 CDN 边缘节点              源服务器
 |                       |                      |
 |                       |                      |
 |                       |                      |
 |                       |                      |
 |                       |                      |
 |                       |                      |
 ↓                       ↓                      ↓
+------+    请求     +---------+    未命中    +-----------------+
|      | ---------&gt; |         | -----------&gt; |                 |
| 用户 |             | CDN节点 |               | 源服务器(Nginx)  |
|      | &lt;--------- |         | &lt;----------- |                 |
+------+    响应     +---------+    响应      +-----------------+
                         ↑                        |
                         |                        |
                         |                        |
                         |                        |
                         +------------------------+
                              缓存静态资源
</code></pre><blockquote>
<p>为什么 Cloudflare 可以“拦截”用户请求?</p>
<p>我们主动把 your_domain.com 的 DNS 交给 Cloudflare 管理, 让它代理用户请求, 用户输入域名, DNS 解析到 Cloudflare 的边缘节点, Cloudflare 检查请求:</p>
<ul>
<li>静态文件（<em>.js、</em>.css）直接从缓存返回</li>
<li>动态请求（/api/*）原封不动的发送到后端服务器</li>
</ul>
</blockquote>
<h2 id="2-中间件-middlewares">2. 中间件 Middlewares<a href="#2-中间件-middlewares" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>中间件也是个中间人, 一般它在后端服务器内部, 就是前端的请求已经被转发到后端服务器了, 此时请求要先经过一系列的预处理(认证, 日志, CORS 等操作) 才能到达最终处理请求的 controller 层:</p>
<pre tabindex="0"><code>
+--------+    请求     +-------------+    +-------------+    +-----------+
|        | ---------&gt; | 中间件 1     | -&gt; | 中间件 2     | -&gt; | 路由/控制器 |
| 客户端  |            | (认证)       |    | (日志)       |    |           |
|        | &lt;--------- |             | &lt;- |             | &lt;- |           |
+--------+    响应     +-------------+    +-------------+    +-----------+
</code></pre><p>一般中间件的常见作用都是和认证日志相关, 比如最常见的问题 跨域, 我们会单独写个中间件, 处理 来自 前端的 preflight 请求, 告诉前端浏览器我们的跨域规则(通过一些响应头), 还可以写个 hsts, 把 http重定向为 https, 还有 cors, 又或者是处理认证, 检查 cookie 中的 JWT token, 若不存在 重定向到 <code>/login</code>, 或者根据预定义的路径 检查当前用户的权限, 是否可以访问, 返回 403 无权限:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">middleware</span>(<span style="color:#a6e22e">request</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">token</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">request</span>.<span style="color:#a6e22e">cookies</span>.<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#39;auth_token&#39;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">token</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">NextResponse</span>.<span style="color:#a6e22e">redirect</span>(<span style="color:#e6db74">&#39;/login&#39;</span>); <span style="color:#75715e">// 未登录，重定向到登录页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">user</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">verifyToken</span>(<span style="color:#a6e22e">token</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">role</span> <span style="color:#f92672">!==</span> <span style="color:#e6db74">&#39;admin&#39;</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">request</span>.<span style="color:#a6e22e">nextUrl</span>.<span style="color:#a6e22e">pathname</span>.<span style="color:#a6e22e">startsWith</span>(<span style="color:#e6db74">&#39;/admin&#39;</span>)) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">NextResponse</span>.<span style="color:#a6e22e">redirect</span>(<span style="color:#e6db74">&#39;/403&#39;</span>); <span style="color:#75715e">// 非管理员，拒绝访问
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">NextResponse</span>.<span style="color:#a6e22e">next</span>(); <span style="color:#75715e">// 继续处理请求 发送到下一个中间件或者 controller 层
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>反正就是中间件很重要, 就像是个看门狗, 如果没有他失去了作用, 那所有请求都会直接到后端的 controller 层, 直接处理业务逻辑了, 当然有时候后端也会用到当前用户的信息, 比如用户创建一个帖子, 我么要知道创建者的 id, 比如 Spring Boot 喜欢通过依赖注入的方式在 Security Chain 中就根据 token 创建用户对象, 然后 controller, service 层都可以使用访问使用 <code>user.getId()</code>, 但是有的比如仅仅是 GET 请求, 就不需要 controller 获取当前用户信息了, 而是直接返回数据, 因为我们默认相信 中间件一定会被执行, 不然请求也不会到达 controller 层, 综上中间件通常负责<strong>全局性</strong>或<strong>路径级别</strong>的认证和授权检查:</p>
<ul>
<li>检查用户是否登录（通过 cookie、JWT 或 session）</li>
<li>验证用户角色（例如，只有管理员才能访问 /admin）</li>
<li>设置请求上下文（如将用户 ID 附加到请求对象）</li>
</ul>
<h2 id="3-nextjs-中间件漏洞">3. Next.js 中间件漏洞<a href="#3-nextjs-中间件漏洞" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>首先和 Vercel 架构有关系, 刚开始使用 Next.js 的时候就觉得很方便, 直接免费部署到 Vercel 平台, CI CD 一键部署, 很是方便, 你以为你的中间件运行在 Node.js 服务器上? 并不是, Next.js 定义的中间件通常被 Vercel 抽取出来运行在边缘节点, 这时候就会出现一个问题, 就是上面我们说的:</p>
<p>用户访问一个受保护的资源(需要登录访问), 可是中间件发现用户没有登录, 因此返回重定向到登录页面, 这都没问题, 可是用户请求 <code>\login</code> 时依然请求会先到中间件, 而中间件运行在 边缘节点 上, 这就导致一个死循环, 因此 Next.js 需要区分“内部请求”和“外部请求”, CVE-2025-29927 的核心问题在于 Next.js 中间件处理 <strong>内部请求头 x-middleware-subrequest</strong> 的方式存在设计缺陷,</p>
<h3 id="31-漏洞的触发机制">3.1. <strong>漏洞的触发机制</strong><a href="#31-漏洞的触发机制" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<ul>
<li>Next.js 使用 <code>x-middleware-subrequest</code> 头来标记“内部子请求”, 以防止中间件在处理同一请求时陷入无限循环
<ul>
<li>例如, 当中间件重写路径（如将 /dashboard 重写为 /internal/dashboard）时, Next.js 会添加 <code>x-middleware-subrequest</code> 头, 告诉框架这是内部请求, 不需要再次运行中间件</li>
</ul>
</li>
<li><strong>漏洞点</strong>：这个头原本设计为内部使用, 但 Next.js 没有验证它的来源, 允许外部请求伪造该头</li>
</ul>
<p>攻击者只需在 HTTP 请求中添加:</p>
<pre tabindex="0"><code>x-middleware-subrequest: middleware:middleware:middleware
</code></pre><p>这会欺骗 Next.js, 认为这是一个内部请求, 直接<strong>跳过中间件执行, 绕过所有认证、授权</strong>或其他检查, 这就很严重了:</p>
<ul>
<li>
<p>一个电商网站可能用中间件检查用户是否登录才能访问订单页面</p>
</li>
<li>
<p>一个 SaaS 平台可能用中间件限制只有管理员才能访问 <code>/admin</code></p>
</li>
</ul>
<h3 id="32-后果分析">3.2. 后果分析<a href="#32-后果分析" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>一旦中间件被绕过, 所有依赖中间件的安全逻辑失效, 导致受保护资源完全暴露, 但是这里有个疑问 即使攻击者通过伪造 x-middleware-subrequest 头绕过了中间件的认证检查, 为什么后续的控制器（controller）层逻辑没有阻止未授权访问？</p>
<ul>
<li>许多应用依赖中间件作为唯一的认证入口，控制器层可能不做重复验证</li>
<li>即使控制器层检查用户 ID, 攻击者可能通过其他方式（如缓存投毒、默认行为）利用绕过后的访问权限</li>
<li>某些资源直接暴露, 无需额外验证即可访问</li>
</ul>
<p>许多开发者仅依赖中间件进行认证，没有实施多层防御:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// 许多开发者的实际实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">middleware</span>(<span style="color:#a6e22e">request</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 只在中间件中进行认证，没有在页面组件中重复验证
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">request</span>.<span style="color:#a6e22e">nextUrl</span>.<span style="color:#a6e22e">pathname</span>.<span style="color:#a6e22e">startsWith</span>(<span style="color:#e6db74">&#39;/admin&#39;</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">isAuthenticated</span>(<span style="color:#a6e22e">request</span>)) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">NextResponse</span>.<span style="color:#a6e22e">redirect</span>(<span style="color:#66d9ef">new</span> <span style="color:#a6e22e">URL</span>(<span style="color:#e6db74">&#39;/login&#39;</span>, <span style="color:#a6e22e">request</span>.<span style="color:#a6e22e">url</span>));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 页面组件可能缺乏二次验证
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getStaticProps</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 假设中间件已经处理了认证，这里直接获取数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">props</span><span style="color:#f92672">:</span> { <span style="color:#a6e22e">data</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">fetchSensitiveData</span>() },
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">revalidate</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">60</span> <span style="color:#75715e">// 使用ISR进行缓存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  };
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>参考:</p>
<ul>
<li><a href="https://securitylabs.datadoghq.com/articles/nextjs-middleware-auth-bypass/#understanding-cve-2025-29927-the-nextjs-middleware-authorization-bypass-vulnerability">Understanding CVE-2025-29927: The Next.js middleware authorization bypass vulnerability</a></li>
<li><a href="https://www.bilibili.com/video/BV1uCdUYPE6R/?share_source=copy_web&amp;vd_source=2c27ff6d58b80e3c8454f835acc72392">最致命的漏洞，来自最低级的错误</a></li>
</ul>

      </div></div>

  
    
<div class="pagination">
  <div class="pagination__title">
    <span class="pagination__title-h">查看其他文章</span>
    <hr />
  </div>
  <div class="pagination__buttons">
    
      <a href="https://blog.jiyi27.com/posts/networking/009-xss-attack/" class="button inline prev">
        XSS Attack
      </a>
    
    
      ::
    
    
      <a href="https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/008-%E5%A4%9A%E8%A1%A8%E5%85%B3%E8%81%94-mysql-mongodb/" class="button inline next">
        多表关联 MySQL 还是 MongoDB?
      </a>
    
  </div>
</div>


  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/jiyi27/jiyi27.github.io" target="_blank">Theme</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
