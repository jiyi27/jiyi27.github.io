<!DOCTYPE html>
<html lang="en">
<head>
  
    
    <title>Goroutines Model :: 为霜的博客</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="1. Two Styles of Concurrent Programming Go enables two styles of concurrent programming.
communicating sequential processes or CSP goroutines and channels shared memory multithreading traditional model multiple threads 2. Goroutines vs OS Threads Creation and Destruction Creating and destroying OS threads requires interacting with the operating system, involving system calls. Go routines managed by Go scheduler, in user space, no system calls. Context Switching needs a full context switch in os thread Level of Operation User Space Level vs Kernel Space Level Goroutines are multiplexed onto a smaller number of OS threads. Stack Size growable stack vs fixed-size stack 2.1. Growable Stacks Each OS thread has a fixed-size block of memory (often as large as 2MB) for its stack. This fixed-size stack is simultaneously too much and too little. Yet despite their size, fixed-size stacks are not always big enough for the most complex and deeply recursive of functions. Changing the fixed size can improve space efficiency and allow more threads to be created, or it can enable more deeply recursive functions, but it cannot do both.
" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://blog.jiyi27.com/posts/golang/advance/001-why-goroutines/" />





  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/buttons.min.2bc533403a27dfe0e93105a92502b42ce4587e2e4a87d9f7d349e51e16e09478.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/categories.min.3202f75cbb294747099af3850a68a09ee94b3ce505fc39e134692d90ff0a9b2a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/code.min.dd73d157e77e82a3dc1cb06ba424cf6cc6811af0bb604ad6c68e70faf2439c8a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/fonts.min.4881f0c525f3ce2a1864fb6e96676396cebe1e6fcef1933e8e1dde7041004fb5.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/footer.min.2e3eb191baee58dd05a9f0104ac1fab0827bca7c64dafe0b2579f934c33a1d69.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/header.min.b6fb4423cf82a9f9d7abc9cd010223fa3d70a6526a3f28f8e17d814c06e18f9e.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/main.min.3fb8954e26342ad3afabb4525959bfec6f9fc0d6929f0dda738ddeee30211690.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/menu.min.8cee75f73b9f9b1e40bd0dd53e6e770156b08bbfe1c579cd256c3f6cd3b6d32b.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/pagination.min.82f6400eae7c7c6dc3c866733c2ec0579e4089608fea69400ff85b3880aa0d3c.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/post.min.014a50745fbdd41d5f420a3e288730d5af4b7d90344dc6211d0e50c368b5b303.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/prism.min.b958d3d7c6c67361b945f9062d07d403422604b3d2cd33f93b88d41ed0ba634d.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/term.min.94de320c1b850e126e6d2c88a7c90acf58bb1313f0ea14a14cda2a42f2a88db2.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">


<link rel="stylesheet" href="https://blog.jiyi27.com/terminal.css">




<link rel="shortcut icon" href="https://blog.jiyi27.com/favicon.png">
<link rel="apple-touch-icon" href="https://blog.jiyi27.com/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Goroutines Model">
<meta property="og:description" content="1. Two Styles of Concurrent Programming Go enables two styles of concurrent programming.
communicating sequential processes or CSP goroutines and channels shared memory multithreading traditional model multiple threads 2. Goroutines vs OS Threads Creation and Destruction Creating and destroying OS threads requires interacting with the operating system, involving system calls. Go routines managed by Go scheduler, in user space, no system calls. Context Switching needs a full context switch in os thread Level of Operation User Space Level vs Kernel Space Level Goroutines are multiplexed onto a smaller number of OS threads. Stack Size growable stack vs fixed-size stack 2.1. Growable Stacks Each OS thread has a fixed-size block of memory (often as large as 2MB) for its stack. This fixed-size stack is simultaneously too much and too little. Yet despite their size, fixed-size stacks are not always big enough for the most complex and deeply recursive of functions. Changing the fixed size can improve space efficiency and allow more threads to be created, or it can enable more deeply recursive functions, but it cannot do both.
" />
<meta property="og:url" content="https://blog.jiyi27.com/posts/golang/advance/001-why-goroutines/" />
<meta property="og:site_name" content="为霜的博客" />

  <meta property="og:image" content="https://blog.jiyi27.com/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">

  <meta property="article:section" content="golang" />


  <meta property="article:published_time" content="2023-08-24 14:58:18 &#43;0000 UTC" />












</head>
<body>


<div class="container center">

  
  
  

  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://blog.jiyi27.com/posts/golang/advance/001-why-goroutines/">Goroutines Model</a>
  </h1>
  <div class="post-meta"><time class="post-date">2023-08-24</time><span class="post-reading-time">7 分钟阅读 (1354 字数)</span></div>

  
    <span class="post-tags">
      
      #<a href="https://blog.jiyi27.com/tags/golang/">golang</a>&nbsp;
      
      #<a href="https://blog.jiyi27.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <h2 id="1--two-styles-of-concurrent-programming">1.  Two Styles of Concurrent Programming<a href="#1--two-styles-of-concurrent-programming" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>Go enables two styles of concurrent programming.</p>
<ul>
<li><em>communicating sequential processes</em> or <em>CSP</em>
<ul>
<li>goroutines and channels</li>
</ul>
</li>
<li><em>shared memory multithreading</em>
<ul>
<li>traditional model</li>
<li>multiple threads</li>
</ul>
</li>
</ul>
<h2 id="2-goroutines-vs-os-threads">2. Goroutines vs OS Threads<a href="#2-goroutines-vs-os-threads" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<ul>
<li>Creation and Destruction
<ul>
<li>Creating and destroying OS threads requires interacting with the operating system, involving system calls.</li>
<li>Go routines managed by Go scheduler, in user space, no system calls.</li>
</ul>
</li>
<li>Context Switching
<ul>
<li>needs a full context switch in os thread</li>
</ul>
</li>
<li>Level of Operation
<ul>
<li>User Space Level vs Kernel Space Level</li>
<li>Goroutines are multiplexed onto a smaller number of OS threads.</li>
</ul>
</li>
<li>Stack Size
<ul>
<li>growable stack vs fixed-size stack</li>
</ul>
</li>
</ul>
<h3 id="21-growable-stacks">2.1. Growable Stacks<a href="#21-growable-stacks" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Each <strong>OS thread</strong> has a fixed-size block of memory (often as large as 2MB) for its <em>stack</em>. This fixed-size stack is simultaneously too much and too little. Yet despite their size, fixed-size stacks are not always big enough for the most complex and deeply recursive of functions. Changing the fixed size can improve space efficiency and allow more threads to be created, or it can enable more deeply recursive functions, but it cannot do both.</p>
<p>In contrast, a goroutine starts life with a small stack, typically 2KB. A goroutine’s stack, like the stack of an OS thread, holds the local variables of active and suspended function calls, but unlike an OS thread, <strong>a goroutine’s stack is not fixed; it grows and shrinks as needed</strong>. The size limit for a goroutine stack may be as much as 1GB.</p>
<h3 id="22-goroutine-scheduling">2.2. Goroutine Scheduling<a href="#22-goroutine-scheduling" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p><strong>OS threads are scheduled by the OS kernel</strong>. Every few milliseconds, a hardware timer interrupts the processor, which causes a kernel function called the <em>scheduler</em> to be invoked. This function suspends the currently executing thread and saves its registers in memory, looks over the list of threads and decides which one should run next, restores that thread’s registers from memory, then resumes the execution of that thread. Because OS threads are scheduled by the kernel, passing control from one thread to another requires <strong>a full <em>context switch</em>, that is, saving the state of one user thread to memory, restoring the state of another, and updating the scheduler’s data structures</strong>. This operation is slow, due to its poor locality and the number of memory accesses required</p>
<p>The Go runtime contains its own scheduler that uses a technique known as <em><strong>m:n scheduling</strong></em>, because it multiplexes (or schedules) <em>m</em> goroutines on <em>n</em> OS threads. The job of the Go scheduler is analogous to that of the kernel scheduler, but it is concerned only with the goroutines of a single Go program.</p>
<p>Unlike the operating system’s thread scheduler, the Go scheduler is not invoked periodically by a hardware timer, but implicitly by certain Go language constructs. For example, when a goroutine calls <code>time.Sleep</code> or blocks in a channel or mutex operation, the scheduler puts it to sleep and runs another goroutine until it is time to wake the first one up. Because it doesn’t need a switch to kernel context, rescheduling a goroutine is much cheaper than rescheduling a thread.</p>
<h2 id="3-goroutine-model">3. Goroutine Model<a href="#3-goroutine-model" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>go-routines are <strong>user-space threads</strong> not <strong>kernel threads</strong>, kernel threads created and managed by OS (sleep, wait, running), OS doesn&rsquo;t know user-space threads exist, Go shcduler multiplexes (or schedules) <em>m</em> goroutines on <em>n</em> OS threads, which is known as <em><strong>m:n scheduling</strong></em>.</p>
<p>Learn how goroutine works:</p>
<p>{% youtube YHRO5WQGh0k %}</p>
<h3 id="31-physical-thread-vs-kernel-thread">3.1. Physical Thread vs Kernel Thread<a href="#31-physical-thread-vs-kernel-thread" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<blockquote>
<p>A &ldquo;hardware thread&rdquo; is just a confusing name for a logical core, aka execution context. It has nothing to do with software threads or kernel threads. One physical core may support more than 1 logical core, e.g. via hyperthreading or other SMT.</p>
<p>A hardware thread is a set of registers that are able to hold the <a href="https://en.wikipedia.org/wiki/Context_switch"><em>context</em></a> of a software thread. Having two &ldquo;hardware threads&rdquo; enables a single CPU to concurrently execute the instructions of two software threads without help from the OS. P.S.: If a software thread is like an automobile, then a hardware thread is like a lane on a highway in which the automobile can drive. OK, that&rsquo;s kind of a weak anaology, but what I&rsquo;m trying to say is that a &ldquo;hardware thread&rdquo; and a thread in your program don&rsquo;t have much more in common with each other than the lane on the highway has in common with your car.</p>
<p>&ndash;<a href="https://stackoverflow.com/questions/73308353/kernel-threads-vs-cpu-threads">multithreading - Kernel threads VS CPU threads - Stack Overflow</a></p>
</blockquote>
<p>Learn more <a href="https://davidzhu.xyz/2023/05/28/Operating-System/001-cpu-architecture/">Hyper-Threading &amp; Physical Threads </a></p>
<p>无论语言层面何种并发模型, 到了操作系统一定是运行在 kernel thread 上的, 上面我们说到Go的做法是把多个 user-space threads 映射到一个 kernel thread, 以减少kernel thread切换时带来的消耗, 那其他语言怎么做的呢? 在C++里, 是通过syscall直接调用OS的kernel thread, 线程所有的行为如创建, 终止, 切换等操作都由内核来完成, 一个用户态的线程对应一个系统线程, 这时候C++在频繁创建删除thread的时候就要考虑上下文切换的开销了, 因为操作的直接是kernel thread, 比如来一个tcp连接就创建一个thread, 开销太大了, 所以这时候就出现了线程池, 说到底我们就是想要减少kernel thread创建切换的次数, 以减少开销,  你看无论C++还是Go都有自己的解决办法, 前者是通过thread pool来对kernel thread重复利用, 而后者因为通过map 多个goroutine到较少个kernel thread, 实现对kernel thread的重复利用, 减少上下文切换的次数, 减少开销,</p>
<h2 id="4-frequently-asked-questions-faq">4. Frequently Asked Questions (FAQ)<a href="#4-frequently-asked-questions-faq" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<h3 id="41-why-goroutines-instead-of-threads">4.1. why goroutines instead of threads?<a href="#41-why-goroutines-instead-of-threads" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Goroutines are part of making concurrency easy to use. The idea, which has been around for a while, is to multiplex independently executing functions—coroutines—onto a set of threads. When a coroutine blocks, such as by calling a blocking system call, the run-time automatically moves other coroutines on the same operating system thread to a different, runnable thread so they won&rsquo;t be blocked. The programmer sees none of this, which is the point. The result, which we call goroutines, can be very cheap: they have little overhead beyond the memory for the stack, which is just a few kilobytes.</p>
<p>To make the stacks small, Go&rsquo;s run-time uses resizable, bounded stacks. A newly minted goroutine is given a few kilobytes, which is almost always enough. When it isn&rsquo;t, the run-time grows (and shrinks) the memory for storing the stack automatically, allowing many goroutines to live in a modest amount of memory. The CPU overhead averages about three cheap instructions per function call. It is practical to create hundreds of thousands of goroutines in the same address space. If goroutines were just threads, system resources would run out at a much smaller number.</p>
<h3 id="42-why-is-there-no-goroutine-id">4.2. why is there no goroutine ID?<a href="#42-why-is-there-no-goroutine-id" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Goroutines do not have names; they are just anonymous workers. They expose no unique identifier, name, or data structure to the programmer. Some people are surprised by this, expecting the <code>go</code> statement to return some item that can be used to access and control the goroutine later.</p>
<p>The fundamental reason goroutines are anonymous is so that the full Go language is available when programming concurrent code. By contrast, the usage patterns that develop when threads and goroutines are named can restrict what a library using them can do.</p>
<p>Here is an illustration of the difficulties. Once one names a goroutine and constructs a model around it, it becomes special, and one is tempted to associate all computation with that goroutine, ignoring the possibility of using multiple, possibly shared goroutines for the processing. If the <code>net/http</code> package associated per-request state with a goroutine, clients would be unable to use more goroutines when serving a request.</p>
<p>Moreover, experience with libraries such as those for graphics systems that require all processing to occur on the &ldquo;main thread&rdquo; has shown how awkward and limiting the approach can be when deployed in a concurrent language. The very existence of a special thread or goroutine forces the programmer to distort the program to avoid crashes and other problems caused by inadvertently operating on the wrong thread.</p>
<p>For those cases where a particular goroutine is truly special, the language provides features such as channels that can be used in flexible ways to interact with it.</p>
<h2 id="5-conclusion">5. Conclusion<a href="#5-conclusion" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<ul>
<li>OS thread has a fixed-size block of memory (as large as 2MB) for its <em>stack</em>.</li>
<li>A goroutine starts life with a small stack, typically 2KB but goroutine’s stack is not fixed.</li>
<li>Thread stack holds the local variables of active and suspended function calls.</li>
<li>OS threads are scheduled by the OS kernel, Go runtime contains its own scheduler that uses a technique known as <em><strong>m:n scheduling</strong></em>, goroutine is much cheaper than rescheduling a thread.</li>
</ul>
<p>A great bolg: <a href="https://blog.carlmjohnson.net/post/share-memory-by-communicating/">Share memory by communicating · The Ethically-Trained Programmer</a></p>
<p>参考:</p>
<ul>
<li><a href="https://learning.oreilly.com/library/view/the-go-programming/9780134190570/ebook_split_094.html">9.8 Goroutines and Threads | The Go Programming Language</a></li>
<li><a href="https://go.dev/doc/faq">Frequently Asked Questions (FAQ) - The Go Programming Language</a></li>
<li><a href="https://www.youtube.com/watch?v=YHRO5WQGh0k">GopherCon 2018: Kavya Joshi - The Scheduler Saga</a></li>
<li><a href="https://stackoverflow.com/questions/73308353/kernel-threads-vs-cpu-threads">multithreading - Kernel threads VS CPU threads - Stack Overflow</a></li>
<li>书籍《Go并发编程实战》</li>
<li><a href="https://go.dev/doc/effective_go#introduction">Effective Go - The Go Programming Language</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/60613088">https://zhuanlan.zhihu.com/p/60613088</a></li>
</ul>

      </div></div>

  
    
<div class="pagination">
  <div class="pagination__title">
    <span class="pagination__title-h">查看其他文章</span>
    <hr />
  </div>
  <div class="pagination__buttons">
    
      <a href="https://blog.jiyi27.com/posts/golang/advance/002-concurrency-with-shared-variables/" class="button inline prev">
        Concurrency with Shared Variables
      </a>
    
    
      ::
    
    
      <a href="https://blog.jiyi27.com/posts/golang/basics/008-goroutine-channels/" class="button inline next">
        Goroutine &amp; Channel - Go Basics
      </a>
    
  </div>
</div>


  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/jiyi27/jiyi27.github.io" target="_blank">Theme</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
