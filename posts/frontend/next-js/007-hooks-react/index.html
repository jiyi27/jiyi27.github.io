<!DOCTYPE html>
<html lang="en">
<head>
  
    
    <title>Hooks React - Next.js :: 为霜的博客</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content=" Always keep in mind: By default, React rerenders a component and all its children whenever the parent component rerenders - even if the props haven&rsquo;t changed.
文章推荐:
React Hooks 如何工作的 useCallback &amp; useMemo 当一个组件被渲染, 它的所有子组件都会被重新渲染, 即使子组件没有任何变化, 若渲染子组件的代价很大, 父组件的频繁渲染则会导致效率问题, 我们可以 React.memo() 用来缓存整个组件, 让组件只有在其 props 改变的时候才会被重新渲染,
当 props 为变量的时候还好, React.memo 会比较 props 的值, 看有没有变化, 进而判断子组件是不是应该被重新渲染, 我们知道函数或变量都可以当作 props 传递给子组件, 若父组件重新渲染, 那么函数也是重新定义的, 也就是说函数也就变了(函数是对象, 对象被重新创建, 地址会变), 这会导致子组件被重新渲染 , 即使我们使用了 React.memo().
这时候就需要 useCallback 和 useMemo 上场了, 我们可以使用 useCallback 或 useMemo 包装一下作为 props 传递给子组件的函数或变量, 这样即使父组件重新渲染, 他们也不会被重新创建, 进而子组件也不会因为 props 的 “改变”, 而重新渲染, 因为他们的值被缓存了, 也就是说我们拿空间 内存 和额外的比较逻辑 (判断 props 是否改变 ) 来减少子组件重新渲染的次数, 因此, 若子组件逻辑很简单, 不要使用这种优化, 因为可能会适得其反,
" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://blog.jiyi27.com/posts/frontend/next-js/007-hooks-react/" />





  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/buttons.min.2bc533403a27dfe0e93105a92502b42ce4587e2e4a87d9f7d349e51e16e09478.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/categories.min.3202f75cbb294747099af3850a68a09ee94b3ce505fc39e134692d90ff0a9b2a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/code.min.dd73d157e77e82a3dc1cb06ba424cf6cc6811af0bb604ad6c68e70faf2439c8a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/fonts.min.4881f0c525f3ce2a1864fb6e96676396cebe1e6fcef1933e8e1dde7041004fb5.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/footer.min.2e3eb191baee58dd05a9f0104ac1fab0827bca7c64dafe0b2579f934c33a1d69.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/header.min.b6fb4423cf82a9f9d7abc9cd010223fa3d70a6526a3f28f8e17d814c06e18f9e.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/main.min.3fb8954e26342ad3afabb4525959bfec6f9fc0d6929f0dda738ddeee30211690.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/menu.min.8cee75f73b9f9b1e40bd0dd53e6e770156b08bbfe1c579cd256c3f6cd3b6d32b.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/pagination.min.82f6400eae7c7c6dc3c866733c2ec0579e4089608fea69400ff85b3880aa0d3c.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/post.min.014a50745fbdd41d5f420a3e288730d5af4b7d90344dc6211d0e50c368b5b303.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/prism.min.b958d3d7c6c67361b945f9062d07d403422604b3d2cd33f93b88d41ed0ba634d.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/term.min.94de320c1b850e126e6d2c88a7c90acf58bb1313f0ea14a14cda2a42f2a88db2.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">


<link rel="stylesheet" href="https://blog.jiyi27.com/terminal.css">




<link rel="shortcut icon" href="https://blog.jiyi27.com/favicon.png">
<link rel="apple-touch-icon" href="https://blog.jiyi27.com/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Hooks React - Next.js">
<meta property="og:description" content=" Always keep in mind: By default, React rerenders a component and all its children whenever the parent component rerenders - even if the props haven&rsquo;t changed.
文章推荐:
React Hooks 如何工作的 useCallback &amp; useMemo 当一个组件被渲染, 它的所有子组件都会被重新渲染, 即使子组件没有任何变化, 若渲染子组件的代价很大, 父组件的频繁渲染则会导致效率问题, 我们可以 React.memo() 用来缓存整个组件, 让组件只有在其 props 改变的时候才会被重新渲染,
当 props 为变量的时候还好, React.memo 会比较 props 的值, 看有没有变化, 进而判断子组件是不是应该被重新渲染, 我们知道函数或变量都可以当作 props 传递给子组件, 若父组件重新渲染, 那么函数也是重新定义的, 也就是说函数也就变了(函数是对象, 对象被重新创建, 地址会变), 这会导致子组件被重新渲染 , 即使我们使用了 React.memo().
这时候就需要 useCallback 和 useMemo 上场了, 我们可以使用 useCallback 或 useMemo 包装一下作为 props 传递给子组件的函数或变量, 这样即使父组件重新渲染, 他们也不会被重新创建, 进而子组件也不会因为 props 的 “改变”, 而重新渲染, 因为他们的值被缓存了, 也就是说我们拿空间 内存 和额外的比较逻辑 (判断 props 是否改变 ) 来减少子组件重新渲染的次数, 因此, 若子组件逻辑很简单, 不要使用这种优化, 因为可能会适得其反,
" />
<meta property="og:url" content="https://blog.jiyi27.com/posts/frontend/next-js/007-hooks-react/" />
<meta property="og:site_name" content="为霜的博客" />

  <meta property="og:image" content="https://blog.jiyi27.com/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">

  <meta property="article:section" content="前端开发" />


  <meta property="article:published_time" content="2024-12-11 20:50:01 &#43;0000 UTC" />












</head>
<body>


<div class="container center">

  
  
  

  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://blog.jiyi27.com/posts/frontend/next-js/007-hooks-react/">Hooks React - Next.js</a>
  </h1>
  <div class="post-meta"><time class="post-date">2024-12-11</time><span class="post-reading-time">3 分钟阅读 (488 字数)</span></div>

  
    <span class="post-tags">
      
      #<a href="https://blog.jiyi27.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/">前端开发</a>&nbsp;
      
      #<a href="https://blog.jiyi27.com/tags/react/">react</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <blockquote>
<p>Always keep in mind: By default, React rerenders a component and all its children whenever the parent component rerenders - even if the props haven&rsquo;t changed.</p>
</blockquote>
<p>文章推荐:</p>
<ul>
<li><a href="https://eliav2.github.io/how-react-hooks-work/">React Hooks 如何工作的</a></li>
</ul>
<h2 id="usecallback--usememo">useCallback &amp; useMemo<a href="#usecallback--usememo" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>当一个组件被渲染, 它的所有子组件都会被重新渲染, 即使子组件没有任何变化, 若渲染子组件的代价很大, 父组件的频繁渲染则会导致效率问题, 我们可以 React.memo() 用来缓存整个组件, 让组件只有在其 props 改变的时候才会被重新渲染,</p>
<p>当 props 为变量的时候还好, React.memo 会比较 props 的值, 看有没有变化, 进而判断子组件是不是应该被重新渲染, 我们知道函数或变量都可以当作 props 传递给子组件, 若父组件重新渲染, 那么函数也是重新定义的, 也就是说函数也就变了(函数是对象, 对象被重新创建, 地址会变), 这会导致子组件被重新渲染 , 即使我们使用了 React.memo().</p>
<p>这时候就需要 useCallback 和 useMemo 上场了, 我们可以使用 useCallback 或 useMemo 包装一下作为 props 传递给子组件的函数或变量, 这样即使父组件重新渲染, 他们也不会被重新创建, 进而子组件也不会因为 props 的 “改变”, 而重新渲染, 因为他们的值被缓存了, 也就是说我们拿空间 内存 和额外的比较逻辑 (判断 props 是否改变 ) 来减少子组件重新渲染的次数, 因此, 若子组件逻辑很简单, 不要使用这种优化, 因为可能会适得其反,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">useCallback</span>&lt;<span style="color:#f92672">T</span> <span style="color:#a6e22e">extends</span> <span style="color:#960050;background-color:#1e0010">(</span><span style="color:#a6e22e">...args</span><span style="color:#960050;background-color:#1e0010">:</span> <span style="color:#a6e22e">any</span><span style="color:#960050;background-color:#1e0010">[])</span> <span style="color:#960050;background-color:#1e0010">=</span>&gt; <span style="color:#66d9ef">any</span><span style="color:#f92672">&gt;</span>(
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">callback</span>: <span style="color:#66d9ef">T</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">dependencies</span>: <span style="color:#66d9ef">DependencyList</span>
</span></span><span style="display:flex;"><span>)<span style="color:#f92672">:</span> <span style="color:#a6e22e">T</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">useMemo</span>&lt;<span style="color:#f92672">T</span>&gt;(
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">factory</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">T</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">dependencies</span>: <span style="color:#66d9ef">DependencyList</span>
</span></span><span style="display:flex;"><span>)<span style="color:#f92672">:</span> <span style="color:#a6e22e">T</span>
</span></span></code></pre></div><p>useMemo, useCallback 都是使参数（函数）不会因为其他不相关的参数变化而重新渲染, 主要区别是 React.useMemo 将调用 fn 函数并返回其结果, 而 React.useCallback 只是返回 fn 函数而不调用它</p>
<ul>
<li>
<p><code>useCallback</code> 接收一个函数并返回这个函数的缓存版本</p>
</li>
<li>
<p><code>useMemo</code> 接收一个工厂函数（factory function）并返回这个函数运行的结果</p>
</li>
</ul>
<blockquote>
<p>useCallback 和 useMemo 不能滥用, 否则只会消耗性能, 利用闭包缓存上次结果, 成本为额外的缓存, 与比较逻辑, 不是绝对的优化, 而是一种成本的交换，并非使用所有场景</p>
</blockquote>
<h2 id="custom-hooks">Custom hooks<a href="#custom-hooks" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<blockquote>
<p>A custom Hook is a JavaScript function whose name starts with ”<code>use</code>” and that may call other Hooks. <a href="https://legacy.reactjs.org/docs/hooks-custom.html">React docs</a></p>
</blockquote>
<p>所有 Hooks 必须以 use 开头, 这不是约定, 而是 React 规则要求, 自定义 hooks 和 普通函数的区别:</p>
<ul>
<li>自定义 hooks 可以使用其他 hooks, 而普通函数不能</li>
<li>自定义 hooks 能保持状态 (可以使用 useState) , 普通函数每次调用都是独立的</li>
</ul>
<p>可以参考 <a href="https://stackoverflow.com/a/64904812/16317008">stack overflow</a> 的一个回答:</p>
<blockquote>
<p>React Hooks are JS functions with the power of react, it means that you can add some logic that you could also add into a normal JS function, but also you will be able to use the native hooks like useState, useEffect, etc, to power up that logic, to add it state, or add it side effects, memoization or more. So I believe hooks are a really good thing to <strong>manage the logic of the components in a isolated way</strong>.</p>
</blockquote>
<p>这里有个例子可以帮助理解上面这段话, 尤其是最后一句:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jS" data-lang="jS"><span style="display:flex;"><span><span style="color:#75715e">// 组件变得非常简洁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">UserList</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> { <span style="color:#a6e22e">data</span>, <span style="color:#a6e22e">loading</span>, <span style="color:#a6e22e">error</span> } <span style="color:#f92672">=</span> <span style="color:#a6e22e">useFetch</span>(<span style="color:#e6db74">&#39;/api/users&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">loading</span>) <span style="color:#66d9ef">return</span> <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">div</span><span style="color:#f92672">&gt;</span><span style="color:#a6e22e">Loading</span>...<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/div&gt;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">error</span>) <span style="color:#66d9ef">return</span> <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">div</span><span style="color:#f92672">&gt;</span>Error<span style="color:#f92672">:</span> {<span style="color:#a6e22e">error</span>.<span style="color:#a6e22e">message</span>}<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/div&gt;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">div</span><span style="color:#f92672">&gt;</span>{<span style="color:#a6e22e">data</span>.<span style="color:#a6e22e">map</span>(<span style="color:#a6e22e">user</span> =&gt; <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">div</span><span style="color:#f92672">&gt;</span>{<span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">name</span>}<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/div&gt;)}&lt;/div&gt;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 自定义 Hook, 保存状态, 独立组建逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">useFetch</span>(<span style="color:#a6e22e">url</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">data</span>, <span style="color:#a6e22e">setData</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">useState</span>(<span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">loading</span>, <span style="color:#a6e22e">setLoading</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">useState</span>(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">error</span>, <span style="color:#a6e22e">setError</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">useState</span>(<span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">useEffect</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fetch</span>(<span style="color:#a6e22e">url</span>)
</span></span><span style="display:flex;"><span>      .<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">res</span> =&gt; <span style="color:#a6e22e">res</span>.<span style="color:#a6e22e">json</span>())
</span></span><span style="display:flex;"><span>      ...
</span></span><span style="display:flex;"><span>  }, [<span style="color:#a6e22e">url</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> { <span style="color:#a6e22e">data</span>, <span style="color:#a6e22e">loading</span>, <span style="color:#a6e22e">error</span> }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="useref">useRef<a href="#useref" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>useRef 是 React 提供的一个 Hook，主要用于两个场景：</p>
<ol>
<li>获取 DOM 元素的引用</li>
<li>useRef 的第二个常见用途是&quot;在多次渲染之间保持数据&quot; : useRef 返回的对象是在首次渲染时创建, 后续渲染时返回的是同一个对象引用</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 1. 基础用法 - 获取 DOM 元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">useRef</span>, <span style="color:#a6e22e">useEffect</span> } <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#39;react&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">TextInputWithFocus() {</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 明确指定 ref 的类型为 HTMLInputElement
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">inputRef</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">useRef</span>&lt;<span style="color:#f92672">HTMLInputElement</span>&gt;(<span style="color:#66d9ef">null</span>);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">useEffect</span>(() <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 组件挂载后自动聚焦输入框
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 因为初始值是 null，所以需要判空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">inputRef</span>.<span style="color:#a6e22e">current</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">inputRef</span>.<span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">focus</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }, []);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> &lt;<span style="color:#f92672">input</span> <span style="color:#a6e22e">ref</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">inputRef</span>} <span style="color:#a6e22e">type</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;text&#34;</span> /&gt;;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>防抖（避免频繁操作）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">SearchInput() {</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">timeoutRef</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">useRef</span>&lt;<span style="color:#f92672">NodeJS.Timeout</span>&gt;();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">handleChange</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">e</span>: <span style="color:#66d9ef">React.ChangeEvent</span>&lt;<span style="color:#f92672">HTMLInputElement</span>&gt;) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 清除之前的定时器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">timeoutRef</span>.<span style="color:#a6e22e">current</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">clearTimeout</span>(<span style="color:#a6e22e">timeoutRef</span>.<span style="color:#a6e22e">current</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 设置新的定时器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">timeoutRef</span>.<span style="color:#a6e22e">current</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">setTimeout</span>(() <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;搜索:&#39;</span>, <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">target</span>.<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>    }, <span style="color:#ae81ff">500</span>);
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> &lt;<span style="color:#f92672">input</span> <span style="color:#a6e22e">onChange</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">handleChange</span>} <span style="color:#a6e22e">placeholder</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;输入搜索内容&#34;</span> /&gt;;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>控制视频播放</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">VideoPlayer() {</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">videoRef</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">useRef</span>&lt;<span style="color:#f92672">HTMLVideoElement</span>&gt;(<span style="color:#66d9ef">null</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">handlePlay</span> <span style="color:#f92672">=</span> () <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">videoRef</span>.<span style="color:#a6e22e">current</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">play</span>();
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">handlePause</span> <span style="color:#f92672">=</span> () <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">videoRef</span>.<span style="color:#a6e22e">current</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">pause</span>();
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (
</span></span><span style="display:flex;"><span>    &lt;<span style="color:#f92672">div</span>&gt;
</span></span><span style="display:flex;"><span>      &lt;<span style="color:#f92672">video</span> <span style="color:#a6e22e">ref</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">videoRef</span>} <span style="color:#a6e22e">src</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;...&#34;</span> /&gt;
</span></span><span style="display:flex;"><span>      &lt;<span style="color:#f92672">button</span> <span style="color:#a6e22e">onClick</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">handlePlay</span>}&gt;<span style="color:#960050;background-color:#1e0010">播放</span>&lt;/<span style="color:#f92672">button</span>&gt;
</span></span><span style="display:flex;"><span>      &lt;<span style="color:#f92672">button</span> <span style="color:#a6e22e">onClick</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">handlePause</span>}&gt;<span style="color:#960050;background-color:#1e0010">暂停</span>&lt;/<span style="color:#f92672">button</span>&gt;
</span></span><span style="display:flex;"><span>    &lt;/<span style="color:#f92672">div</span>&gt;
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
      </div></div>

  
    
<div class="pagination">
  <div class="pagination__title">
    <span class="pagination__title-h">查看其他文章</span>
    <hr />
  </div>
  <div class="pagination__buttons">
    
      <a href="https://blog.jiyi27.com/posts/frontend/next-js/006-why-pure-react/" class="button inline prev">
        Why a Component Needs to be a Pure Function - React.js
      </a>
    
    
      ::
    
    
      <a href="https://blog.jiyi27.com/posts/frontend/next-js/004-next-auth/" class="button inline next">
        NextAuth V5
      </a>
    
  </div>
</div>


  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/jiyi27/jiyi27.github.io" target="_blank">Theme</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
