<!DOCTYPE html>
<html lang="en">
<head>
  
    
    <title>浅谈序列化 :: 为霜的博客</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="1. 基本定义 看看维基百科的定义:
In computing, serialization is process of translating a data structure or object state into a format that can be stored or transmitted. 序列化是将内存中的数据结构或对象转换为可存储或传输的格式的过程
不是很懂, 看来需要一个例子来解释, 下面是我看到的一段话, 有一些疑问:
一个表述说: “序列化是将内存中的数据结构或对象转换为可存储或传输的格式（如二进制数据、XML、JSON等）”
内存中的数据结构或者对象 已经是二进制数据了 为什么不可以直接传输?
上面的表述说 “如二进制数据、XML、JSON等”, 网络传输不是只能传输 二进制数据吗, 为什么还有 xml 和 json 呢?
2. 对象在内存中的样子 表面上看, 内存中的数据确实是二进制字节（0 和 1）, 但这些字节的组织方式和语义高度依赖于程序的运行时环境, 直接传输这些字节会导致接收端无法正确解析:
type Student struct { Name string Age int Score float64 Active bool } func main() { student := Student{ Name: &#34;Alice&#34;, Age: 20, Score: 95.5, Active: true, } fmt.Printf(&#34;Student: %&#43;v\n&#34;, student) fmt.Printf(&#34;Size of Student: %d bytes\n&#34;, unsafe.Sizeof(student)) } 运行结果 arm64 系统:
" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/012-%E6%B5%85%E8%B0%88%E5%BA%8F%E5%88%97%E5%8C%96/" />





  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/buttons.min.2bc533403a27dfe0e93105a92502b42ce4587e2e4a87d9f7d349e51e16e09478.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/categories.min.3202f75cbb294747099af3850a68a09ee94b3ce505fc39e134692d90ff0a9b2a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/code.min.dd73d157e77e82a3dc1cb06ba424cf6cc6811af0bb604ad6c68e70faf2439c8a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/fonts.min.4881f0c525f3ce2a1864fb6e96676396cebe1e6fcef1933e8e1dde7041004fb5.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/footer.min.2e3eb191baee58dd05a9f0104ac1fab0827bca7c64dafe0b2579f934c33a1d69.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/header.min.b6fb4423cf82a9f9d7abc9cd010223fa3d70a6526a3f28f8e17d814c06e18f9e.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/main.min.3fb8954e26342ad3afabb4525959bfec6f9fc0d6929f0dda738ddeee30211690.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/menu.min.8cee75f73b9f9b1e40bd0dd53e6e770156b08bbfe1c579cd256c3f6cd3b6d32b.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/pagination.min.82f6400eae7c7c6dc3c866733c2ec0579e4089608fea69400ff85b3880aa0d3c.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/post.min.014a50745fbdd41d5f420a3e288730d5af4b7d90344dc6211d0e50c368b5b303.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/prism.min.b958d3d7c6c67361b945f9062d07d403422604b3d2cd33f93b88d41ed0ba634d.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/term.min.94de320c1b850e126e6d2c88a7c90acf58bb1313f0ea14a14cda2a42f2a88db2.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">


<link rel="stylesheet" href="https://blog.jiyi27.com/terminal.css">




<link rel="shortcut icon" href="https://blog.jiyi27.com/favicon.png">
<link rel="apple-touch-icon" href="https://blog.jiyi27.com/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="浅谈序列化">
<meta property="og:description" content="1. 基本定义 看看维基百科的定义:
In computing, serialization is process of translating a data structure or object state into a format that can be stored or transmitted. 序列化是将内存中的数据结构或对象转换为可存储或传输的格式的过程
不是很懂, 看来需要一个例子来解释, 下面是我看到的一段话, 有一些疑问:
一个表述说: “序列化是将内存中的数据结构或对象转换为可存储或传输的格式（如二进制数据、XML、JSON等）”
内存中的数据结构或者对象 已经是二进制数据了 为什么不可以直接传输?
上面的表述说 “如二进制数据、XML、JSON等”, 网络传输不是只能传输 二进制数据吗, 为什么还有 xml 和 json 呢?
2. 对象在内存中的样子 表面上看, 内存中的数据确实是二进制字节（0 和 1）, 但这些字节的组织方式和语义高度依赖于程序的运行时环境, 直接传输这些字节会导致接收端无法正确解析:
type Student struct { Name string Age int Score float64 Active bool } func main() { student := Student{ Name: &#34;Alice&#34;, Age: 20, Score: 95.5, Active: true, } fmt.Printf(&#34;Student: %&#43;v\n&#34;, student) fmt.Printf(&#34;Size of Student: %d bytes\n&#34;, unsafe.Sizeof(student)) } 运行结果 arm64 系统:
" />
<meta property="og:url" content="https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/012-%E6%B5%85%E8%B0%88%E5%BA%8F%E5%88%97%E5%8C%96/" />
<meta property="og:site_name" content="为霜的博客" />

  <meta property="og:image" content="https://blog.jiyi27.com/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">

  <meta property="article:section" content="面试" />


  <meta property="article:published_time" content="2025-04-22 10:03:38 &#43;0000 UTC" />












</head>
<body>


<div class="container center">

  
  
  

  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/012-%E6%B5%85%E8%B0%88%E5%BA%8F%E5%88%97%E5%8C%96/">浅谈序列化</a>
  </h1>
  <div class="post-meta"><time class="post-date">2025-04-22</time><span class="post-reading-time">8 分钟阅读 (1497 字数)</span></div>

  
    <span class="post-tags">
      
      #<a href="https://blog.jiyi27.com/tags/%E9%9D%A2%E8%AF%95/">面试</a>&nbsp;
      
      #<a href="https://blog.jiyi27.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>&nbsp;
      
      #<a href="https://blog.jiyi27.com/tags/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/">后端面试</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <h2 id="1-基本定义">1. 基本定义<a href="#1-基本定义" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>看看<a href="https://en.wikipedia.org/wiki/Serialization">维基百科</a>的定义:</p>
<blockquote>
<p>In computing, serialization is process of translating a data structure or object state into a format that can be stored or transmitted. 序列化是将内存中的数据结构或对象转换为<strong>可存储</strong>或<strong>传输</strong>的格式的过程</p>
</blockquote>
<p>不是很懂, 看来需要一个例子来解释, 下面是我看到的一段话, 有一些疑问:</p>
<blockquote>
<p>一个表述说: “序列化是将内存中的数据结构或对象转换为可存储或传输的格式（如二进制数据、XML、JSON等）”</p>
<ul>
<li>
<p>内存中的数据结构或者对象 已经是二进制数据了  为什么不可以直接传输?</p>
</li>
<li>
<p>上面的表述说 “如二进制数据、XML、JSON等”, 网络传输不是只能传输 二进制数据吗, 为什么还有 xml 和 json 呢?</p>
</li>
</ul>
</blockquote>
<h2 id="2-对象在内存中的样子">2. 对象在内存中的样子<a href="#2-对象在内存中的样子" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>表面上看, 内存中的数据确实是二进制字节（0 和 1）, 但这些字节的组织方式和语义高度依赖于程序的运行时环境, 直接传输这些字节会导致<strong>接收端无法正确解析</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Student</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Name</span>   <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Age</span>    <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Score</span>  <span style="color:#66d9ef">float64</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Active</span> <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">student</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Student</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">Name</span>:   <span style="color:#e6db74">&#34;Alice&#34;</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">Age</span>:    <span style="color:#ae81ff">20</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">Score</span>:  <span style="color:#ae81ff">95.5</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">Active</span>: <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Student: %+v\n&#34;</span>, <span style="color:#a6e22e">student</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Size of Student: %d bytes\n&#34;</span>, <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(<span style="color:#a6e22e">student</span>))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>运行结果 arm64 系统:</p>
<pre tabindex="0"><code>Student: {Name:Alice Age:20 Score:95.5 Active:true}
Size of Student: 40 bytes
</code></pre><p>为了理解为什么不能直接传输, 我们需要看看 <code>Student</code> 结构体在内存中的实际布局:</p>
<table>
  <thead>
      <tr>
          <th>字段</th>
          <th>大小</th>
          <th>内存内容（示例）</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Name (ptr)</td>
          <td>8 字节</td>
          <td>指针，指向 &ldquo;Alice&rdquo; 的内存地址（如 <code>0x12345678</code>）</td>
      </tr>
      <tr>
          <td>Name (len)</td>
          <td>8 字节</td>
          <td>字符串长度（<code>5</code>，表示 &ldquo;Alice&rdquo; 的长度）</td>
      </tr>
      <tr>
          <td>Age</td>
          <td>8 字节</td>
          <td>整数 <code>20</code>（二进制表示）</td>
      </tr>
      <tr>
          <td>Score</td>
          <td>8 字节</td>
          <td>浮点数 <code>95.5</code>（IEEE 754 格式）</td>
      </tr>
      <tr>
          <td>Active</td>
          <td>1 字节</td>
          <td>布尔值 <code>1</code>（true）</td>
      </tr>
      <tr>
          <td>Padding</td>
          <td>7 字节</td>
          <td>填充字节（通常为 0，用于对齐）</td>
      </tr>
  </tbody>
</table>
<blockquote>
<p>在 Go 中, string 是一个结构体, 包含两个字段:</p>
<ul>
<li>指向字符串数据的指针（<code>unsafe.Pointer</code>, 8 字节）</li>
<li>字符串长度（<code>int</code>, 8 字节）</li>
</ul>
<p>所以 string 总共占用 16 字节, 例如，<code>Name: &quot;Alice&quot;</code> 的实际数据（<code>&quot;Alice&quot;</code> 的字节 <code>[65, 108, 105, 99, 101]</code>）存储在内存的某个区域，<code>Name</code> 字段只保存指向该区域的指针和长度</p>
</blockquote>
<p>假设 <code>student</code> 结构体存储在内存地址 <code>0x1000</code>，其二进制数据可能如下（简化表示）：</p>
<ul>
<li><code>0x1000 - 0x1007</code>：<code>Name</code> 的指针（例如 <code>0x12345678</code>，指向 <code>&quot;Alice&quot;</code> 的实际数据的地址）</li>
<li><code>0x1008 - 0x100F</code>：<code>Name</code> 的长度（<code>5</code>）</li>
<li><code>0x1010 - 0x1017</code>：<code>Age</code> 的值（<code>20</code>，二进制 <code>00000014</code>）</li>
<li><code>0x1018 - 0x101F</code>：<code>Score</code> 的值（<code>95.5</code>，IEEE 754 格式的二进制）</li>
<li><code>0x1020</code>：<code>Active</code> 的值（<code>1</code>，表示 <code>true</code>）</li>
<li><code>0x1021 - 0x1027</code>：填充字节（<code>0</code>）</li>
</ul>
<p><strong>关键点</strong>：</p>
<ul>
<li><code>Name</code> 字段的指针（<code>0x12345678</code>）指向内存中 <code>&quot;Alice&quot;</code> 的实际数据（<code>[65, 108, 105, 99, 101]</code>）的地址</li>
<li>这些二进制数据高度依赖 Go 的运行时环境，比如：
<ul>
<li>指针地址（<code>0x12345678</code>）只在当前程序的内存空间有效</li>
<li>内存对齐和填充字节依赖于 Go 编译器和 CPU 架构</li>
<li><code>&quot;Alice&quot;</code> 的实际数据存储在堆上，由 Go 的垃圾回收器管理</li>
</ul>
</li>
</ul>
<h2 id="3-内存中的数据结构已经是二进制数据为什么不能直接传输">3. 内存中的数据结构已经是二进制数据，为什么不能直接传输？<a href="#3-内存中的数据结构已经是二进制数据为什么不能直接传输" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>现在，假设我们将这 40 字节的二进制数据（从 <code>0x1000</code> 到 <code>0x1027</code>）直接传输到另一台机器, 接收端会遇到以下问题:</p>
<h3 id="31-指针无效">3.1. 指针无效<a href="#31-指针无效" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<ul>
<li><strong>问题</strong>：<code>Name</code> 字段的指针（<code>0x12345678</code>）指向当前程序的内存地址, 在接收端的机器上, 这个地址要么无效（指向不存在的内存）, 要么指向完全无关的数据</li>
<li><strong>后果</strong>：接收端无法访问 <code>&quot;Alice&quot;</code> 的实际数据（<code>[65, 108, 105, 99, 101]</code>），因为这些数据没有随结构体一起传输</li>
<li><strong>解决方法</strong>：序列化（如 JSON）会将 <code>&quot;Alice&quot;</code> 的实际内容嵌入到序列化数据中, 而不是只传输指针, 例如, JSON 会生成 <code>{&quot;name&quot;:&quot;Alice&quot;,...}</code></li>
</ul>
<h3 id="32-缺少类型信息">3.2. 缺少类型信息<a href="#32-缺少类型信息" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<ul>
<li><strong>问题</strong>：内存中的二进制数据没有显式的类型信息, 接收端不知道：
<ul>
<li>这 32 字节代表一个 <code>Student</code> 结构体</li>
<li>前 16 字节是 <code>string</code>，接下来的 8 字节是 <code>int</code>，等等</li>
</ul>
</li>
<li><strong>后果</strong>：接收端无法正确解析二进制数据，除非它运行完全相同的 Go 程序（相同的结构体定义和编译器）</li>
<li><strong>解决方法</strong>：序列化格式（如 JSON）通过键值对显式定义字段名和值（<code>{&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:20}</code>），接收端根据字段名重建数据结构</li>
</ul>
<h3 id="33-内存布局不兼容">3.3. 内存布局不兼容<a href="#33-内存布局不兼容" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<ul>
<li><strong>问题</strong>：不同系统、编译器或 Go 版本可能有不同的内存布局：
<ul>
<li>32 位 vs. 64 位系统：<code>int</code> 和指针的大小不同（4 字节 vs. 8 字节）</li>
<li>内存对齐规则：某些系统可能不使用 8 字节对齐，填充字节不同</li>
<li>字段顺序：编译器可能重新排列字段以优化内存访问（尽管 Go 通常按声明顺序）</li>
</ul>
</li>
<li><strong>后果</strong>：接收端可能错误解析字段, 例如，接收端可能将 <code>Age</code> 的 8 字节解析为两个 4 字节字段，导致数据错乱</li>
<li><strong>解决方法</strong>：序列化格式（如 JSON）是标准化的，字段顺序和类型由格式定义（如 <code>{&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:20}</code>），与内存布局无关</li>
</ul>
<h3 id="34-跨语言和跨平台问题">3.4. 跨语言和跨平台问题<a href="#34-跨语言和跨平台问题" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<ul>
<li><strong>问题</strong>：如果接收端不是 Go 程序（比如 Python 或 Java），它无法理解 Go 的内存布局（指针、字符串结构体、内存对齐等）</li>
<li><strong>后果</strong>：非 Go 程序无法解析这 32 字节的二进制数据</li>
<li><strong>解决方法</strong>：序列化格式（如 JSON、XML）是语言无关的，Python 和 Java 都能解析 <code>{&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:20}</code></li>
</ul>
<h3 id="35-示例直接传输的失败场景">3.5. 示例：直接传输的失败场景<a href="#35-示例直接传输的失败场景" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>假设我们将 <code>student</code> 的 32 字节内存数据传输到另一台机器：</p>
<ul>
<li>发送端：传输 <code>[0x12345678, 5, 20, 95.5, 1, 0, 0, 0, 0, 0, 0, 0]</code></li>
<li>接收端：
<ul>
<li>看到 <code>0x12345678</code>，但这个地址无效，无法找到 <code>&quot;Alice&quot;</code></li>
<li>不知道前 16 字节是 <code>string</code>，可能误以为是两个 <code>int64</code></li>
<li>内存对齐不同，可能将 <code>Age</code> 的 8 字节解析为其他类型</li>
</ul>
</li>
<li>结果：数据完全不可用</li>
</ul>
<blockquote>
<p>所以我对序列化的理解是:</p>
<ul>
<li>
<p><strong>序列化</strong>是将内存中的对象转换为一种<strong>约定好的格式</strong>（如 Protobuf、JSON、Gob、XML 等）</p>
</li>
<li>
<p>这些格式在网络传输时仍然是<strong>二进制数据</strong>（字节流）</p>
</li>
<li>
<p>但这些二进制数据是按照<strong>约定的格式</strong>组织的，而不是内存中对象的<strong>原始内存格式</strong></p>
</li>
</ul>
</blockquote>
<h2 id="4-更上一层楼-加深理解">4. 更上一层楼 (加深理解)<a href="#4-更上一层楼-加深理解" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<h3 id="41-序列化是将内存对象转为约定格式">4.1. 序列化是将内存对象转为约定格式<a href="#41-序列化是将内存对象转为约定格式" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<ul>
<li>内存中的对象（比如 Go 的 <code>struct</code>）包含复杂的信息：指针、类型元数据、内存对齐填充、运行时状态等</li>
<li>序列化的目的是将这些对象转换为一种标准化的、平台无关的格式
<ul>
<li>去除指针，直接嵌入实际数据（比如 <code>&quot;Alice&quot;</code> 的字符），<strong>只保留数据的逻辑内容</strong></li>
<li>去除了填充和运行时元数据</li>
<li>使用标准化的结构（键值对、字段标签等），确保跨平台、跨语言可解析</li>
</ul>
</li>
<li>例如：
<ul>
<li>JSON：<code>{&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:20}</code></li>
<li>Protobuf：紧凑的二进制格式，包含字段标签和值</li>
<li>Gob：Go 专用的二进制格式，包含类型信息和数据</li>
<li>XML：<code>&lt;person&gt;&lt;name&gt;Alice&lt;/name&gt;&lt;age&gt;20&lt;/age&gt;&lt;/person&gt;</code></li>
</ul>
</li>
</ul>
<h3 id="42-传输时是二进制数据-但按约定格式组织">4.2. 传输时是二进制数据, 但按约定格式组织：<a href="#42-传输时是二进制数据-但按约定格式组织" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<ul>
<li>网络传输只能传输二进制字节流（0 和 1）</li>
<li>序列化后的数据（JSON、XML 等）在传输前会被编码为二进制字节流。例如：
<ul>
<li>JSON 字符串 <code>{&quot;name&quot;:&quot;Alice&quot;}</code> 编码为 UTF-8 字节（<code>[123, 34, 110, 97, 109, 101, 34, ...]</code>）</li>
<li>Protobuf 直接生成紧凑的二进制字节，包含字段编号和值</li>
</ul>
</li>
<li>这些字节流的组织方式遵循约定的格式规则（比如 JSON 的键值对结构，Protobuf 的字段标签），<strong>接收端根据相同的规则解析</strong></li>
</ul>
<h3 id="44-代码示例">4.4. 代码示例<a href="#44-代码示例" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Student</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Name</span>   <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Age</span>    <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Score</span>  <span style="color:#66d9ef">float64</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">student</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Student</span>{<span style="color:#a6e22e">Name</span>: <span style="color:#e6db74">&#34;Alice&#34;</span>, <span style="color:#a6e22e">Age</span>: <span style="color:#ae81ff">20</span>, <span style="color:#a6e22e">Score</span>: <span style="color:#ae81ff">95.5</span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 1. 序列化为 JSON</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">jsonData</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Marshal</span>(<span style="color:#a6e22e">student</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalf</span>(<span style="color:#e6db74">&#34;JSON 序列化失败: %v&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;JSON 数据:&#34;</span>, string(<span style="color:#a6e22e">jsonData</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;JSON 字节:&#34;</span>, <span style="color:#a6e22e">jsonData</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 2. 序列化为 Gob</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">buf</span> <span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">enc</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gob</span>.<span style="color:#a6e22e">NewEncoder</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">buf</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">enc</span>.<span style="color:#a6e22e">Encode</span>(<span style="color:#a6e22e">student</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalf</span>(<span style="color:#e6db74">&#34;Gob 序列化失败: %v&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Gob 字节:&#34;</span>, <span style="color:#a6e22e">buf</span>.<span style="color:#a6e22e">Bytes</span>())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 3. 反序列化 JSON</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">jsonStudent</span> <span style="color:#a6e22e">Student</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Unmarshal</span>(<span style="color:#a6e22e">jsonData</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">jsonStudent</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalf</span>(<span style="color:#e6db74">&#34;JSON 反序列化失败: %v&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;JSON 反序列化结果: %+v\n&#34;</span>, <span style="color:#a6e22e">jsonStudent</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 4. 反序列化 Gob</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">gobStudent</span> <span style="color:#a6e22e">Student</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">dec</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gob</span>.<span style="color:#a6e22e">NewDecoder</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">buf</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">dec</span>.<span style="color:#a6e22e">Decode</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">gobStudent</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalf</span>(<span style="color:#e6db74">&#34;Gob 反序列化失败: %v&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Gob 反序列化结果: %+v\n&#34;</span>, <span style="color:#a6e22e">gobStudent</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>输出（部分简化）</strong></p>
<pre tabindex="0"><code>JSON 数据: {&#34;Name&#34;:&#34;Alice&#34;,&#34;Age&#34;:20,&#34;Score&#34;:95.5}
JSON 字节: [123 34 78 97 109 101 34 58 34 65 108 105 99 101 34 44 ...]
Gob 字节: [40 255 129 3 1 1 7 83 116 117 100 101 110 116 ...]
JSON 反序列化结果: {Name:Alice Age:20 Score:95.5}
Gob 反序列化结果: {Name:Alice Age:20 Score:95.5}
</code></pre><h3 id="45-内存数据-vs-序列化数据的对比">4.5. 内存数据 vs. 序列化数据的对比<a href="#45-内存数据-vs-序列化数据的对比" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<table>
  <thead>
      <tr>
          <th>特性</th>
          <th>内存中的二进制数据</th>
          <th>序列化数据（JSON）</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>内容</strong></td>
          <td>指针、长度、值、填充字节</td>
          <td>实际数据（<code>&quot;Alice&quot;</code>、20、95.5、true）</td>
      </tr>
      <tr>
          <td><strong>大小</strong></td>
          <td>32 字节（固定，含指针和填充）</td>
          <td>变长（约 50 字节，视数据内容）</td>
      </tr>
      <tr>
          <td><strong>平台依赖</strong></td>
          <td>高度依赖（指针、内存对齐、架构）</td>
          <td>平台无关（标准化的文本格式）</td>
      </tr>
      <tr>
          <td><strong>类型信息</strong></td>
          <td>隐式（依赖 Go 运行时）</td>
          <td>显式（键值对定义字段和类型）</td>
      </tr>
      <tr>
          <td><strong>跨语言支持</strong></td>
          <td>不支持（仅 Go 程序可解析）</td>
          <td>支持（JSON 被广泛支持）</td>
      </tr>
      <tr>
          <td><strong>传输后可用性</strong></td>
          <td>不可用（指针无效，布局不同）</td>
          <td>可用（接收端可直接解析）</td>
      </tr>
  </tbody>
</table>
<h2 id="5-常见的序列化库">5. 常见的序列化库<a href="#5-常见的序列化库" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>因为不同格式有特定的编码/解码规则和数据结构, 通常每种序列化格式（如 JSON、Gob、Protobuf）都会有对应的库来处理:</p>
<ul>
<li>JSON 是跨语言的通用格式, 几乎每种语言都有 JSON 库</li>
<li>Gob 是 Go 特有的二进制格式，仅由 Go 的 encoding/gob 支持</li>
<li>Protobuf 是一种高效的跨语言二进制格式，需专用库支持</li>
</ul>
<p>我们分别举例看一下各自怎么做序列化的</p>
<h3 id="51-go-序列化">5.1. Go 序列化<a href="#51-go-序列化" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p><strong>JSON 序列化 - 使用 <code>encoding/json</code></strong></p>
<p><code>encoding/json</code> 是 Go 标准库提供的 JSON 序列化工具, 最流行且易用:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建对象</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Person</span>{<span style="color:#a6e22e">Name</span>: <span style="color:#e6db74">&#34;Alice&#34;</span>, <span style="color:#a6e22e">Age</span>: <span style="color:#ae81ff">30</span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 序列化：对象 -&gt; JSON</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">jsonData</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Marshal</span>(<span style="color:#a6e22e">p</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatal</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;JSON:&#34;</span>, string(<span style="color:#a6e22e">jsonData</span>)) <span style="color:#75715e">// 输出：JSON: {&#34;name&#34;:&#34;Alice&#34;,&#34;age&#34;:30}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 反序列化：JSON -&gt; 对象</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">p2</span> <span style="color:#a6e22e">Person</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Unmarshal</span>(<span style="color:#a6e22e">jsonData</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">p2</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatal</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Deserialized:&#34;</span>, <span style="color:#a6e22e">p2</span>) <span style="color:#75715e">// 输出：Deserialized: {Alice 30}</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>Gob 序列化 - 使用 <code>encoding/gob</code></strong></p>
<p><code>encoding/gob</code> 是 Go 标准库提供的二进制序列化工具，<strong>仅用于 Go 程序间通信</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Person</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Name</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Age</span>  <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建对象</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Person</span>{<span style="color:#a6e22e">Name</span>: <span style="color:#e6db74">&#34;Alice&#34;</span>, <span style="color:#a6e22e">Age</span>: <span style="color:#ae81ff">30</span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 序列化：对象 -&gt; Gob</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">buf</span> <span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">enc</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gob</span>.<span style="color:#a6e22e">NewEncoder</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">buf</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">enc</span>.<span style="color:#a6e22e">Encode</span>(<span style="color:#a6e22e">p</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatal</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Gob bytes:&#34;</span>, <span style="color:#a6e22e">buf</span>.<span style="color:#a6e22e">Bytes</span>()) <span style="color:#75715e">// 输出：Gob bytes: [二进制数据]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 反序列化：Gob -&gt; 对象</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">p2</span> <span style="color:#a6e22e">Person</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dec</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gob</span>.<span style="color:#a6e22e">NewDecoder</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">buf</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">dec</span>.<span style="color:#a6e22e">Decode</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">p2</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatal</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Deserialized:&#34;</span>, <span style="color:#a6e22e">p2</span>) <span style="color:#75715e">// 输出：Deserialized: {Alice 30}</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>Protobuf 序列化 - 使用 <code>github.com/golang/protobuf</code></strong></p>
<p>Protobuf 是一种高效的跨语言二进制序列化格式, 需定义 <code>.proto</code> 文件并生成 Go 代码, <code>github.com/golang/protobuf</code> 是最流行的 Protobuf 实现:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-protobuf" data-lang="protobuf"><span style="display:flex;"><span>syntax <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;proto3&#34;</span>;<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#f92672">package</span> main;<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">option</span> go_package <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;./main&#34;</span>;<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">message</span> <span style="color:#a6e22e">Person</span> {<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    <span style="color:#66d9ef">string</span> name <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    <span style="color:#66d9ef">int32</span> age <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>}<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ protoc --go_out<span style="color:#f92672">=</span>. person.proto
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建 Protobuf 对象</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Person</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Name</span>: <span style="color:#e6db74">&#34;Alice&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Age</span>:  <span style="color:#ae81ff">30</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 序列化：对象 -&gt; Protobuf</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">protoData</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">proto</span>.<span style="color:#a6e22e">Marshal</span>(<span style="color:#a6e22e">p</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatal</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Protobuf bytes:&#34;</span>, <span style="color:#a6e22e">protoData</span>) <span style="color:#75715e">// 输出：Protobuf bytes: [二进制数据]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 反序列化：Protobuf -&gt; 对象</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">p2</span> <span style="color:#a6e22e">Person</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">proto</span>.<span style="color:#a6e22e">Unmarshal</span>(<span style="color:#a6e22e">protoData</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">p2</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatal</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Deserialized:&#34;</span>, <span style="color:#a6e22e">p2</span>) <span style="color:#75715e">// 输出：Deserialized: name:&#34;Alice&#34; age:30</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>Protobuf 需要预定义 <code>.proto</code> 文件，生成 Go 结构体和序列化代码</li>
<li>使用 <code>proto.Marshal</code> 和 <code>proto.Unmarshal</code> 进行序列化/反序列化</li>
<li>Protobuf 是高效的二进制格式，适合跨语言、高性能场景</li>
</ul>
<h3 id="52-java-序列化">5.2. Java 序列化<a href="#52-java-序列化" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Java 这里只讨论 JSON 序列化, 至于其其他格式, 类似 Golang, 就不讨论了,  <strong>Jackson</strong> 是 Java 中最流行的 JSON 序列化库</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 定义 Person 类</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> String name;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> age;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 构造函数</span>
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Getter 和 Setter</span>
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">toString</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Person{name=&#39;&#34;</span> <span style="color:#f92672">+</span> name <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#39;, age=&#34;</span> <span style="color:#f92672">+</span> age <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;}&#34;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 创建 ObjectMapper</span>
</span></span><span style="display:flex;"><span>            ObjectMapper mapper <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ObjectMapper();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 创建对象</span>
</span></span><span style="display:flex;"><span>            Person p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Person(<span style="color:#e6db74">&#34;Alice&#34;</span>, 30);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 序列化：对象 -&gt; JSON</span>
</span></span><span style="display:flex;"><span>            String json <span style="color:#f92672">=</span> mapper.<span style="color:#a6e22e">writeValueAsString</span>(p);
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;JSON: &#34;</span> <span style="color:#f92672">+</span> json); <span style="color:#75715e">// 输出：JSON: {&#34;name&#34;:&#34;Alice&#34;,&#34;age&#34;:30}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 反序列化：JSON -&gt; 对象</span>
</span></span><span style="display:flex;"><span>            Person p2 <span style="color:#f92672">=</span> mapper.<span style="color:#a6e22e">readValue</span>(json, Person.<span style="color:#a6e22e">class</span>);
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Deserialized: &#34;</span> <span style="color:#f92672">+</span> p2); <span style="color:#75715e">// 输出：Deserialized: Person{name=&#39;Alice&#39;, age=30}</span>
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">catch</span> (Exception e) {
</span></span><span style="display:flex;"><span>            e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><code>ObjectMapper</code> 是 <code>Jackson</code> 的核心类，<code>writeValueAsString</code> 序列化为 JSON 字符串，<code>readValue</code> 反序列化为对象</li>
</ul>
<h3 id="53-c-序列化">5.3. C# 序列化<a href="#53-c-序列化" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>C# 中最流行的 JSON 库是 Json.NET  (<code>Newtonsoft.Json</code>), 在 .NET 社区中广为人知, 它提供了一组类和方法, 用于:</p>
<ul>
<li><strong>序列化</strong>：将 C# 对象转换为 JSON 字符串</li>
<li><strong>反序列化</strong>：将 JSON 字符串转换回 C# 对象</li>
<li><strong>自定义序列化</strong>：通过特性（如 <code>[JsonConverter]</code>）或配置，允许开发者控制 JSON 的格式和行为</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> person = <span style="color:#66d9ef">new</span> { Name = <span style="color:#e6db74">&#34;Alice&#34;</span>, Age = <span style="color:#ae81ff">30</span> };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">string</span> json = JsonConvert.SerializeObject(person);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 输出: {&#34;Name&#34;:&#34;Alice&#34;,&#34;Age&#34;:30}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">string</span> json = <span style="color:#e6db74">&#34;{\&#34;Name\&#34;:\&#34;Alice\&#34;,\&#34;Age\&#34;:30}&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> person = JsonConvert.DeserializeObject&lt;<span style="color:#66d9ef">dynamic</span>&gt;(json);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// person.Name == &#34;Alice&#34;</span>
</span></span></code></pre></div><blockquote>
<p><strong>JsonConvert</strong> 是 <strong>Newtonsoft.Json</strong> 命名空间中的一个静态类, 属于 Json.NET 库</p>
</blockquote>
<h2 id="6-protobuf-vs-json">6. <code>protobuf</code> vs <code>json</code><a href="#6-protobuf-vs-json" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p><code>protobuf</code> 是用来序列化的, 主要用在进程间通信尤其是 RPC 中, 前面讨论的时候说到:</p>
<blockquote>
<p>序列化是将内存中的数据结构或对象转换为<strong>可存储</strong>或<strong>传输</strong>的格式的过程</p>
</blockquote>
<p>所以 <code>protobuf</code> 也是用来干这个的, 可是为什么要用 <code>protobuf</code>  呢, 它很快?</p>
<ul>
<li>
<p><strong>紧凑的二进制格式</strong>：Protobuf 相比 JSON 的文本格式，数据体积更小（通常比 JSON 小 <strong>3-10 倍</strong>，具体取决于数据结构）</p>
</li>
<li>
<p><strong>高效的序列化/反序列化</strong>：Protobuf 的编码规则（如变长编码 Varint）优化了 CPU 和内存使用，解析速度比 JSON 快（通常快 <strong>5-100 倍</strong>，视场景而定）</p>
</li>
</ul>
<h3 id="61-为什么体积这么小">6.1. 为什么体积这么小<a href="#61-为什么体积这么小" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Person</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Name</span> <span style="color:#66d9ef">string</span> <span style="color:#75715e">// &#34;Alice&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Age</span>  <span style="color:#66d9ef">int</span>    <span style="color:#75715e">// 30</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="1-json-的编码">(1) JSON 的编码<a href="#1-json-的编码" class="hanchor" ariaLabel="Anchor">#</a> </h4>
<p>JSON 是文本格式，序列化后的结果是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{<span style="color:#f92672">&#34;name&#34;</span>:<span style="color:#e6db74">&#34;Alice&#34;</span>,<span style="color:#f92672">&#34;age&#34;</span>:<span style="color:#ae81ff">30</span>}
</span></span></code></pre></div><p><strong>数据体积</strong>：</p>
<ul>
<li><code>{&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:30}</code> 总共 24 个字符（假设 UTF-8 编码，每个字符 1 字节）
<ul>
<li>字段名：<code>&quot;name&quot;</code>（6 字节，含引号），<code>&quot;age&quot;</code>（5 字节）</li>
<li>值：<code>&quot;Alice&quot;</code>（7 字节，含引号），<code>30</code>（2 字节）</li>
<li>分隔符：<code>{</code>, <code>}</code>, <code>,</code>, <code>:</code>（4 字节）</li>
</ul>
</li>
<li><strong>总计</strong>：24 字节</li>
</ul>
<h4 id="2-protobuf-的编码">(2) Protobuf 的编码<a href="#2-protobuf-的编码" class="hanchor" ariaLabel="Anchor">#</a> </h4>
<p>Protobuf 需要先定义 <code>.proto</code> 文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-proto" data-lang="proto"><span style="display:flex;"><span>syntax <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;proto3&#34;</span>;<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">message</span> <span style="color:#a6e22e">Person</span> {<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    <span style="color:#66d9ef">string</span> name <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    <span style="color:#66d9ef">int32</span> age <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>}<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><p>序列化后的结果是二进制数据（不可读），我们逐步分析其编码</p>
<p><strong>数据体积</strong>：</p>
<p>Protobuf 的二进制编码格式为 <code>[field_number][type][value]</code> 的组合：</p>
<ul>
<li><strong>字段 <code>name</code>（字符串，编号 1）</strong>：
<ul>
<li>字段编号和类型：编号 <code>1</code>，类型为 <code>string</code>（长度编码，Wire Type = 2）
<ul>
<li>编号 <code>1</code> 和 Wire Type 组合编码为 1 字节：<code>00001010</code>（二进制，<code>0x0A</code>）</li>
</ul>
</li>
<li>值：字符串 <code>&quot;Alice&quot;</code>（5 字节）
<ul>
<li>字符串前缀长度：<code>5</code>（1 字节，Varint 编码）</li>
<li>字符串内容：<code>Alice</code>（5 字节）</li>
</ul>
</li>
<li><strong>小计</strong>：1（编号+类型） + 1（长度） + 5（内容） = 7 字节</li>
</ul>
</li>
<li><strong>字段 <code>age</code>（int32，编号 2）</strong>：
<ul>
<li>字段编号和类型：编号 <code>2</code>，类型为 <code>int32</code>（Varint，Wire Type = 0）
<ul>
<li>编号 <code>2</code> 和 Wire Type 组合编码为 1 字节：<code>00010000</code>（二进制，<code>0x10</code>）</li>
</ul>
</li>
<li>值：整数 <code>30</code>（Varint 编码）
<ul>
<li><code>30</code> 在 Varint 中编码为 1 字节：<code>00011110</code>（二进制，<code>0x1E</code>）</li>
</ul>
</li>
<li>小计：1（编号+类型） + 1（值） = 2 字节</li>
</ul>
</li>
<li>总计：7（name） + 2（age） = 9 字节</li>
</ul>
<p><strong>性能优势</strong>：</p>
<ul>
<li><strong>Varint 编码</strong>：<code>age = 30</code> 只用 1 字节，JSON 用 2 字节（文本 <code>&quot;30&quot;</code>）, 对于小整数，Varint 极大地节省空间</li>
<li><strong>无字段名</strong>：Protobuf 用编号 <code>1</code> 和 <code>2</code>（1 字节）替代 <code>&quot;name&quot;</code>（6 字节）和 <code>&quot;age&quot;</code>（5 字节）</li>
<li><strong>无分隔符</strong>：JSON 的 <code>{</code>, <code>}</code>, <code>,</code> 等占用 4 字节，Protobuf 无需这些</li>
<li><strong>硬编码逻辑</strong>：Protobuf 的生成代码避免了 JSON 的动态解析和反射</li>
</ul>
<h3 id="62-为什么这么快">6.2. 为什么这么快?<a href="#62-为什么这么快" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>JSON序列化本质上是一个<strong>数据转换</strong>过程，目标是将内存中的数据结构（例如Python的字典、Java的对象、Go的结构体等）转换为符合JSON规范的字符串, <strong>JSON规范定义了数据结构</strong>，包括对象（<code>{}</code>）、数组（<code>[]</code>）、字符串（<code>&quot;&quot;</code>）、数字、布尔值（<code>true</code>/<code>false</code>）、<code>null</code>等, 序列化的底层实现通常涉及:</p>
<ul>
<li><strong>数据结构解析</strong>：递归遍历输入数据结构的层次结构</li>
<li><strong>类型映射</strong>：将编程语言的原生类型映射到JSON支持的类型</li>
<li><strong>编码</strong>：将数据按照JSON语法规则生成字符串，通常使用UTF-8编码</li>
<li><strong>内存管理</strong>：高效分配和操作字符串缓冲区</li>
<li><strong>错误处理</strong>：处理不支持的类型或循环引用等问题</li>
</ul>
<p>Protobuf 使用 <code>protoc</code> 生成<strong>静态 Go 代码</strong>，序列化逻辑是<strong>硬编码</strong>的，直接访问结构体字段（通过偏移量），无需反射</p>
<p><code>protoc</code> 是 Protobuf 的编译器（Protocol Buffers Compiler），用于将用户定义的 <code>.proto</code> 文件（描述数据结构的 Schema）转换为特定语言（如 Go）的源代码, <code>.proto</code> 文件定义了消息（message）的结构，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-protobuf" data-lang="protobuf"><span style="display:flex;"><span><span style="color:#66d9ef">message</span> <span style="color:#a6e22e">User</span> {<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    <span style="color:#66d9ef">string</span> name <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    <span style="color:#66d9ef">int32</span> age <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>}<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><p>运行命令 protoc &ndash;go_out=. user.proto，protoc 会生成一个 Go 文件（例如 user.pb.go），包含：</p>
<ul>
<li>Go 结构体（如 <code>type User struct</code>）</li>
<li><strong>硬编码:</strong> 序列化/反序列化方法（如 <code>Marshal 和 Unmarshal</code>）</li>
<li>其他辅助代码</li>
</ul>
<p><strong>什么是静态 Go 代码？</strong></p>
<ul>
<li>“静态”意味着这些代码在<strong>编译时</strong>生成, 运行时<strong>无需动态解析数据结构</strong></li>
<li>生成的代码是针对特定 <code>.proto</code> 文件的, 包含了所有必要的序列化逻辑, 例如, <code>user.pb.go</code> 中会为 <code>User</code> 结构体生成一个 <code>Marshal</code> 方法，明确知道如何处理 <code>name</code> 和 <code>age</code> 字段</li>
<li>对比 JSON 的 <code>encoding/json</code>, 后者在运行时通过<strong>反射动态解析任意结构体</strong>, 生成的 JSON 依赖于运行时的类型信息</li>
</ul>
<p><code>.proto</code> 文件定义了 <code>User</code> 消息，<code>protoc</code> 生成的 <code>user.pb.go</code> 可能包含：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">User</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Name</span> <span style="color:#66d9ef">string</span> <span style="color:#e6db74">`protobuf:&#34;bytes,1,opt,name=name&#34; json:&#34;name,omitempty&#34;`</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Age</span>  <span style="color:#66d9ef">int32</span>  <span style="color:#e6db74">`protobuf:&#34;varint,2,opt,name=age&#34; json:&#34;age,omitempty&#34;`</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">User</span>) <span style="color:#a6e22e">Marshal</span>() ([]<span style="color:#66d9ef">byte</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 硬编码的序列化逻辑</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>什么是硬编码？</strong></p>
<ul>
<li>“硬编码”意味着序列化逻辑是直接写死的代码，针对特定的数据结构（如 <code>User</code> 结构体），而不是通用的解析逻辑</li>
<li>在 JSON 中，<code>encoding/json</code> 使用通用的反射逻辑，适用于任何 Go 数据结构（结构体、映射、切片等）它在运行时检查类型、字段名、标签等，逻辑是“通用的”</li>
<li>在 Protobuf 中，<code>protoc</code> 生成的 Marshal 方法是针对特定结构体的专用代码, 例如，<code>User.Marshal</code> 只知道如何序列化 <code>User</code> 结构体的 <code>Name</code> 和 <code>Age</code> 字段，逻辑是固定的</li>
</ul>
<blockquote>
<p>综上效率更高是因为 <code>protoc</code> 根据 预先定义的 <code>.proto</code> 文件, <strong>专门为 User 结构生成静态的</strong>  <code>user.pb.go</code>, 也就是生成 <strong>硬编码的序列化和反序列化方法</strong>, 而 <strong>JSON 序列化逻辑是通用的,</strong></p>
</blockquote>

      </div></div>

  
    
<div class="pagination">
  <div class="pagination__title">
    <span class="pagination__title-h">查看其他文章</span>
    <hr />
  </div>
  <div class="pagination__buttons">
    
      <a href="https://blog.jiyi27.com/posts/csharp/dot-net/004-%E6%B3%A8%E8%A7%A3%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/" class="button inline prev">
        注解如何工作的 C#
      </a>
    
    
      ::
    
    
      <a href="https://blog.jiyi27.com/posts/database/mongodb/004-%E5%88%86%E8%A1%A8%E8%BF%98%E6%98%AF%E5%B5%8C%E5%A5%97/" class="button inline next">
        MongoDB 规范化还是嵌套
      </a>
    
  </div>
</div>


  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/jiyi27/jiyi27.github.io" target="_blank">Theme</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
