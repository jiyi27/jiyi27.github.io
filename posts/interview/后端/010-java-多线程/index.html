<!DOCTYPE html>
<html lang="en">
<head>
  
    
    <title>Java 多线程 并发编程 :: 为霜的博客</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="1. 并行 并发 并行：多核 CPU 上的多任务处理，多个任务在同一时间真正地同时执行
并发：单核 CPU 上的多任务处理，多个任务在同一时间段内交替执行，通过时间片轮转实现交替执行
2. 进程和线程 线程是进程的一个执行单位, 进程就是启用的一个程序, 比如本地启动 MySQL 服务, MySQL 服务创建和管理多个线程来分别处理客户端连接、查询解析、后端IO操作、缓存管理等，借此提升性能和响应能力
3. 线程安全的理解 线程安全主要涉及到多个线程同时尝试访问同一个共享数据, 能否正确处理共享数据的问题, 就是线程安全的关键:
首先通过的就是锁机制, 互斥锁, 保证同一时刻只有一个线程修改共享数据 而锁机制就会引起锁的强占, 所以要确保线程不会因为死锁问题导致无法继续执行 协程更轻量, 不属于操作系统级别, 而是属于更高一层对线程的包装, 不涉及系统调用, 因此等待到执行状态也不需要上下文切换, 或者说很代价很小, 因此也不用使用线程池这种东西了
4. Java 线程间通信方式 - 共享内存 线程之间想要进行通信, 可以通过消息传递和共享内存两种方法来完成, 那 Java 采用的是共享内存的并发模型, 而 Golang 使用的就是前者 CSP, 利用 Channel 传递消息, 正如他的 Slogan: Don&rsquo;t communicate by sharing memory, share memory by communicating.
各有优缺点吧, 前者不需要锁机制了, 所有消息数据串行发送, 后者则需要锁来控制
CSP 避免了共享内存带来的竞争条件, 天然线程安全, 缺点是 Channel 通信需要额外的同步和数据拷贝, 在某些低延迟场景下可能不如共享内存高效 CSP 适合 适合高并发、事件驱动的场景, 如 Web 服务器、微服务, 用 goroutine 处理 HTTP 请求，通过 Channel 传递任务结果 共享内存模型数据不一致的风险较高, 需要使用锁来实现线程安全问题, 比较复杂, 容易出 bug 共享内存模型如何保证线程安全: Java 的并发主要依赖线程和共享内存, 线程通过访问共享对象（如变量、集合等）来进行通信, 为了避免竞争条件和数据不一致问题, Java 提供了同步机制 ,如 synchronized 关键字、锁（Lock）、以及并发工具类（java.util.concurrent 包，例如 ConcurrentHashMap、ExecutorService 等）
" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/010-java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" />





  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/buttons.min.2bc533403a27dfe0e93105a92502b42ce4587e2e4a87d9f7d349e51e16e09478.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/categories.min.3202f75cbb294747099af3850a68a09ee94b3ce505fc39e134692d90ff0a9b2a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/code.min.dd73d157e77e82a3dc1cb06ba424cf6cc6811af0bb604ad6c68e70faf2439c8a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/fonts.min.4881f0c525f3ce2a1864fb6e96676396cebe1e6fcef1933e8e1dde7041004fb5.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/footer.min.2e3eb191baee58dd05a9f0104ac1fab0827bca7c64dafe0b2579f934c33a1d69.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/header.min.b6fb4423cf82a9f9d7abc9cd010223fa3d70a6526a3f28f8e17d814c06e18f9e.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/main.min.3fb8954e26342ad3afabb4525959bfec6f9fc0d6929f0dda738ddeee30211690.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/menu.min.8cee75f73b9f9b1e40bd0dd53e6e770156b08bbfe1c579cd256c3f6cd3b6d32b.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/pagination.min.82f6400eae7c7c6dc3c866733c2ec0579e4089608fea69400ff85b3880aa0d3c.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/post.min.014a50745fbdd41d5f420a3e288730d5af4b7d90344dc6211d0e50c368b5b303.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/prism.min.b958d3d7c6c67361b945f9062d07d403422604b3d2cd33f93b88d41ed0ba634d.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/term.min.94de320c1b850e126e6d2c88a7c90acf58bb1313f0ea14a14cda2a42f2a88db2.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">


<link rel="stylesheet" href="https://blog.jiyi27.com/terminal.css">




<link rel="shortcut icon" href="https://blog.jiyi27.com/favicon.png">
<link rel="apple-touch-icon" href="https://blog.jiyi27.com/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Java 多线程 并发编程">
<meta property="og:description" content="1. 并行 并发 并行：多核 CPU 上的多任务处理，多个任务在同一时间真正地同时执行
并发：单核 CPU 上的多任务处理，多个任务在同一时间段内交替执行，通过时间片轮转实现交替执行
2. 进程和线程 线程是进程的一个执行单位, 进程就是启用的一个程序, 比如本地启动 MySQL 服务, MySQL 服务创建和管理多个线程来分别处理客户端连接、查询解析、后端IO操作、缓存管理等，借此提升性能和响应能力
3. 线程安全的理解 线程安全主要涉及到多个线程同时尝试访问同一个共享数据, 能否正确处理共享数据的问题, 就是线程安全的关键:
首先通过的就是锁机制, 互斥锁, 保证同一时刻只有一个线程修改共享数据 而锁机制就会引起锁的强占, 所以要确保线程不会因为死锁问题导致无法继续执行 协程更轻量, 不属于操作系统级别, 而是属于更高一层对线程的包装, 不涉及系统调用, 因此等待到执行状态也不需要上下文切换, 或者说很代价很小, 因此也不用使用线程池这种东西了
4. Java 线程间通信方式 - 共享内存 线程之间想要进行通信, 可以通过消息传递和共享内存两种方法来完成, 那 Java 采用的是共享内存的并发模型, 而 Golang 使用的就是前者 CSP, 利用 Channel 传递消息, 正如他的 Slogan: Don&rsquo;t communicate by sharing memory, share memory by communicating.
各有优缺点吧, 前者不需要锁机制了, 所有消息数据串行发送, 后者则需要锁来控制
CSP 避免了共享内存带来的竞争条件, 天然线程安全, 缺点是 Channel 通信需要额外的同步和数据拷贝, 在某些低延迟场景下可能不如共享内存高效 CSP 适合 适合高并发、事件驱动的场景, 如 Web 服务器、微服务, 用 goroutine 处理 HTTP 请求，通过 Channel 传递任务结果 共享内存模型数据不一致的风险较高, 需要使用锁来实现线程安全问题, 比较复杂, 容易出 bug 共享内存模型如何保证线程安全: Java 的并发主要依赖线程和共享内存, 线程通过访问共享对象（如变量、集合等）来进行通信, 为了避免竞争条件和数据不一致问题, Java 提供了同步机制 ,如 synchronized 关键字、锁（Lock）、以及并发工具类（java.util.concurrent 包，例如 ConcurrentHashMap、ExecutorService 等）
" />
<meta property="og:url" content="https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/010-java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" />
<meta property="og:site_name" content="为霜的博客" />

  <meta property="og:image" content="https://blog.jiyi27.com/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">

  <meta property="article:section" content="面试" />


  <meta property="article:published_time" content="2025-03-11 12:30:20 &#43;0000 UTC" />












</head>
<body>


<div class="container center">

  
  
  

  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/010-java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Java 多线程 并发编程</a>
  </h1>
  <div class="post-meta"><time class="post-date">2025-03-11</time><span class="post-reading-time">4 分钟阅读 (776 字数)</span></div>

  
    <span class="post-tags">
      
      #<a href="https://blog.jiyi27.com/tags/%E9%9D%A2%E8%AF%95/">面试</a>&nbsp;
      
      #<a href="https://blog.jiyi27.com/tags/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/">后端面试</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <h2 id="1-并行-并发">1. 并行 并发<a href="#1-并行-并发" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>并行：多核 CPU 上的多任务处理，多个任务在同一时间真正地同时执行</p>
<p>并发：单核 CPU 上的多任务处理，多个任务在同一时间段内交替执行，通过时间片轮转实现交替执行</p>
<h2 id="2-进程和线程">2. 进程和线程<a href="#2-进程和线程" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>线程是进程的一个执行单位, 进程就是启用的一个程序, 比如本地启动 MySQL 服务, MySQL 服务创建和管理多个线程来分别处理客户端连接、查询解析、后端IO操作、缓存管理等，借此提升性能和响应能力</p>
<h2 id="3-线程安全的理解">3. 线程安全的理解<a href="#3-线程安全的理解" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>线程安全主要涉及到多个线程同时尝试访问同一个共享数据, 能否正确处理共享数据的问题, 就是线程安全的关键:</p>
<ul>
<li>首先通过的就是锁机制, 互斥锁, 保证同一时刻只有一个线程修改共享数据</li>
<li>而锁机制就会引起锁的强占, 所以要确保线程不会因为死锁问题导致无法继续执行</li>
</ul>
<blockquote>
<p>协程更轻量, 不属于操作系统级别, 而是属于更高一层对线程的包装, 不涉及系统调用, 因此等待到执行状态也不需要上下文切换, 或者说很代价很小, 因此也不用使用线程池这种东西了</p>
</blockquote>
<h2 id="4-java-线程间通信方式---共享内存">4. Java 线程间通信方式 - 共享内存<a href="#4-java-线程间通信方式---共享内存" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>线程之间想要进行通信, 可以通过消息传递和共享内存两种方法来完成, 那 Java 采用的是共享内存的并发模型, 而 Golang 使用的就是前者 CSP, 利用 Channel 传递消息, 正如他的 Slogan: Don&rsquo;t communicate by sharing memory, share memory by communicating.</p>
<p>各有优缺点吧, 前者不需要锁机制了, 所有消息数据串行发送, 后者则需要锁来控制</p>
<ul>
<li>CSP 避免了共享内存带来的竞争条件, 天然线程安全, 缺点是 Channel 通信需要额外的同步和数据拷贝, 在某些低延迟场景下可能不如共享内存高效</li>
<li>CSP 适合 适合高并发、事件驱动的场景, 如 Web 服务器、微服务, 用 goroutine 处理 HTTP 请求，通过 Channel 传递任务结果</li>
<li>共享内存模型数据不一致的风险较高, 需要使用锁来实现线程安全问题, 比较复杂, 容易出 bug</li>
</ul>
<blockquote>
<p><strong>共享内存模型如何保证线程安全:</strong> Java 的并发主要依赖线程和共享内存, 线程通过访问共享对象（如变量、集合等）来进行通信, 为了避免竞争条件和数据不一致问题, Java 提供了同步机制 ,如 synchronized 关键字、锁（Lock）、以及并发工具类（java.util.concurrent 包，例如 ConcurrentHashMap、ExecutorService 等）</p>
<p>线程间同步实现方式: 各种锁, 互斥锁, 读写锁, 信号量, 注意互斥锁和读写锁不同</p>
</blockquote>
<h2 id="5-线程创建方式">5. 线程创建方式<a href="#5-线程创建方式" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>Java 中创建线程主要有三种方式，分别为继承 Thread 类、实现 Runnable 接口、实现 Callable 接口</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ThreadTask</span> <span style="color:#66d9ef">extends</span> Thread {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;看完二哥的 Java 进阶之路，上岸了!&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        ThreadTask task <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ThreadTask();
</span></span><span style="display:flex;"><span>        task.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RunnableTask</span> <span style="color:#66d9ef">implements</span> Runnable {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;看完二哥的 Java 进阶之路，上岸了!&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        RunnableTask task <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> RunnableTask();
</span></span><span style="display:flex;"><span>        Thread thread <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(task);
</span></span><span style="display:flex;"><span>        thread.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>调用 start()方法时会执行 run()方法，那怎么不直接调用 run()方法？</p>
<p>当调用<code>start()</code>方法时, 会<strong>启动一个新的线程</strong>, 并让这个新线程调用<code>run()</code>方法, 如果直接调用<code>run()</code>方法, 那么<code>run()</code>方法就在当前线程中运行, 没有新的线程被创建, 也就没有实现多线程的效果</p>
</blockquote>
<h2 id="6-java-线程安全如何实现">6. Java 线程安全如何实现<a href="#6-java-线程安全如何实现" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>使用共享对象, 多个线程可以访问和修改同一个对象, 从而实现信息的传递, 但是我们需要有锁的机制来保证线程安全, 在多线程编程中, 线程之间共享变量时可能会出现问题</p>
<ul>
<li>可见性问题：一个线程改了变量，其他线程看不到最新值</li>
<li>原子性问题：多个线程同时改变量，导致结果出错</li>
<li>原子性问题还有一个体现, 就是指令重新排序, 创建一个对象并赋值给一个变量, 其实包含三个步骤, 若第一步和第二步交换了顺序, 若是多线程访问这个对象, 则可能出现问题, 单线程没问题:
<ul>
<li>分配内存</li>
<li>在分配的内存上初始化对象(调用构造方法)</li>
<li>讲变量指向这个内内存</li>
</ul>
</li>
</ul>
<p>上面说的两个问题: 指令重新排序, 可见性问题, 都可以由 <code>volatile</code> 解决, 至于数据竞争, 则只能由锁 <code>lock</code>,  <code>synchronized</code> 来避免了</p>
<h3 id="61-volatile">6.1. <code>volatile</code><a href="#61-volatile" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p><strong>首先看第一个问题 可见性问题</strong></p>
<p>因为 JMM 允许线程使用缓存作为自己的本地内存, 以提高性能, 缓存是寄存器, 比主内存还要快, 普通变量的读写可能发生以下情况</p>
<ul>
<li>
<p>线程 A 读取变量 x 到自己的本地内存（缓存），后续操作可能直接访问缓存，而不是主内存</p>
</li>
<li>
<p>如果线程 B 修改了主内存中的 x，线程 A 的缓存可能仍持有旧值，导致线程 A 看不到最新的修改</p>
</li>
<li>
<p>这种现象称为缓存不一致，因为线程 A 和线程 B 对 x 的值有不同的视图</p>
</li>
</ul>
<p><code>volatile</code> 修饰的变量强制线程绕过本地内存，直接操作主内存</p>
<ul>
<li>读操作：线程每次读取 volatile 变量时，直接从主内存获取最新值，忽略本地缓存</li>
<li>写操作：线程修改 volatile 变量时，立即将新值写入主内存，并使其他线程的本地缓存失效（通过缓存一致性协议，如 MESI）</li>
<li>效果：所有线程对 volatile 变量的读写始终看到一致的最新值</li>
</ul>
<p><strong>然后看第三个问题, 指令重新排序</strong>, <code>volatile</code> 关键字的一个重要作用是禁止指令重排序, 并确保变量的读写操作按照程序员预期的顺序执行, 同时保证内存可见性 (一个线程改了变量，其他线程立刻能看到, 上面已经说了) 禁止指令重排序的场景单例模式的双重检查锁:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Singleton</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> Singleton instance;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">Singleton</span>() {}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Singleton <span style="color:#a6e22e">getInstance</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (instance <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) { <span style="color:#75715e">// 第一次检查</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">synchronized</span> (Singleton.<span style="color:#a6e22e">class</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (instance <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) { <span style="color:#75715e">// 第二次检查</span>
</span></span><span style="display:flex;"><span>                    instance <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Singleton(); <span style="color:#75715e">// 创建实例</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> instance;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的代码中 <code>instance = new Singleton()</code> 看似是一行简单的赋值，但实际上 JVM 会将其分解为以下步骤：</p>
<ol>
<li>分配内存空间</li>
<li>初始化对象（调用构造方法）</li>
<li>将 instance 引用指向这块内存</li>
</ol>
<p>由于指令重排序的存在，JVM 和 CPU 可能会将步骤 3（赋值）提前到步骤 2（初始化）之前, 假设有两个线程 A 和 B：</p>
<ul>
<li>线程 A 执行 getInstance()，进入同步块，开始创建对象</li>
<li>线程 A 执行到“分配内存并赋值”（步骤 1 和 3），但还未完成初始化（步骤 2）</li>
<li>此时线程 B 调用 getInstance()，看到 instance 不为 null（因为已经被赋值），直接返回未初始化的对象</li>
<li>结果：线程 B 拿到了一个未完全初始化的 Singleton 对象，可能导致空指针异常或逻辑错误</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Singleton</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">volatile</span> Singleton instance; <span style="color:#75715e">// 添加 volatile</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">Singleton</span>() {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Singleton <span style="color:#a6e22e">getInstance</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (instance <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">synchronized</span> (Singleton.<span style="color:#a6e22e">class</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (instance <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>                    instance <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Singleton();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> instance;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>volatile 如何解决问题？</p>
<ol>
<li><strong>禁止指令重排序</strong>：volatile 确保 instance = new Singleton(); 的三个步骤（分配内存、初始化、赋值）按照代码顺序执行，不会将赋值提前到初始化之前</li>
<li><strong>内存可见性</strong>：线程 A 修改 instance 后，线程 B 能立即看到最新的值</li>
</ol>
<p>结果：线程 B 要么看到 instance 是 null（等待初始化），要么看到一个完全初始化的对象，不会出现“半初始化”状态,</p>
<p>虽然 <code>volatile</code> 可以禁止指令重排序，但它不能保证操作的原子性，比如 <code>++</code> 操作仍然不是线程安全的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> counter <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">threadFunc</span>() {
</span></span><span style="display:flex;"><span>    counter<span style="color:#f92672">++</span>; <span style="color:#75715e">// 这个操作不是原子的</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>如果 Singleton 只在单线程环境中使用，则<strong>不需要使用 volatile</strong>，因为：</p>
<ul>
<li>单线程环境中不存在线程间的竞争，不会有可见性或重排序导致的问题</li>
<li>JVM 的内存操作顺序对单线程程序是透明的，程序的行为总是符合代码的逻辑顺序</li>
</ul>
</blockquote>
<h3 id="62-synchronized">6.2. <code>synchronized</code><a href="#62-synchronized" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<ul>
<li>
<p>保证<strong>互斥性</strong>：同一时间只有一个线程能执行锁住的代码</p>
</li>
<li>
<p>保证<strong>可见性</strong>：进入锁时加载最新值，退出锁时刷新修改</p>
</li>
<li>
<p>保证<strong>原子性</strong>：锁内的操作不会被打断</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CounterExample</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">synchronized</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">increment</span>() {
</span></span><span style="display:flex;"><span>        count<span style="color:#f92672">++</span>; <span style="color:#75715e">// 线程安全</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">synchronized</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getCount</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> count; <span style="color:#75715e">// 线程安全</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>两种用法</strong></p>
<ol>
<li><strong>同步方法</strong>：锁住整个方法（例子如上）</li>
<li><strong>同步块</strong>：锁住部分代码，灵活性更高</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BlockExample</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> Object lock <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Object();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">increment</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">synchronized</span> (lock) { <span style="color:#75715e">// 只锁关键部分</span>
</span></span><span style="display:flex;"><span>            count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>前面说到 进入 <code>synchronized</code> 块时, 线程会从主内存加载变量的最新值, 退出时，会将修改后的值刷新回主内存, 为什么有时需要一起用？</p>
<ul>
<li>因为 synchronized 只保证锁内代码的可见性，而锁外的代码仍然可能依赖线程本地缓存的旧值</li>
<li>volatile 可以确保即使在无锁的情况下，读线程也能立即看到变量的最新值</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TaskQueue</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> taskCount <span style="color:#f92672">=</span> 0; <span style="color:#75715e">// 任务计数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span> hasNewTask <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>; <span style="color:#75715e">// 是否有新任务</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> Object lock <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Object();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 生产者：添加任务</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">produceTask</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">synchronized</span> (lock) {
</span></span><span style="display:flex;"><span>            taskCount<span style="color:#f92672">++</span>; <span style="color:#75715e">// 增加任务数</span>
</span></span><span style="display:flex;"><span>            hasNewTask <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>; <span style="color:#75715e">// 标记有新任务</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 消费者：检查是否有新任务</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">hasNewTask</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> hasNewTask; <span style="color:#75715e">// 无锁读取，可能看不到最新值</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 消费者：获取任务数并处理</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">consumeTask</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">synchronized</span> (lock) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (hasNewTask) {
</span></span><span style="display:flex;"><span>                hasNewTask <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>; <span style="color:#75715e">// 重置标志</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> taskCount; <span style="color:#75715e">// 返回任务数</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> 0;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></blockquote>
<h2 id="7-reentrantlock-vs-readwritelock">7. ReentrantLock vs ReadWriteLock<a href="#7-reentrantlock-vs-readwritelock" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<h3 id="71-reentrantlock">7.1. ReentrantLock<a href="#71-reentrantlock" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p><code>ReentrantLock</code> Java <code>java.util.concurrent.locks</code> 包中的显式锁，提供比 <code>synchronized</code> 更灵活的功能,</p>
<p>在锁竞争激烈时，可以通过 <code>tryLock(timeout)</code> 避免线程无限等待:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ReentrantLock lock <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ReentrantLock();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryMethod</span>() <span style="color:#66d9ef">throws</span> InterruptedException {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (lock.<span style="color:#a6e22e">tryLock</span>(1, TimeUnit.<span style="color:#a6e22e">SECONDS</span>)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 获取锁成功</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>            lock.<span style="color:#a6e22e">unlock</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>; <span style="color:#75715e">// 超时未获取锁</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当需要按照线程请求顺序分配锁（避免线程饥饿）时，可以配置公平锁</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ReentrantLock lock <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ReentrantLock(<span style="color:#66d9ef">true</span>); <span style="color:#75715e">// 公平锁</span>
</span></span></code></pre></div><p>实际示例对比:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Counter</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">synchronized</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">increment</span>() {
</span></span><span style="display:flex;"><span>        count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Counter</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> ReentrantLock lock <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ReentrantLock();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">increment</span>() {
</span></span><span style="display:flex;"><span>        lock.<span style="color:#a6e22e">lock</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>            lock.<span style="color:#a6e22e">unlock</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="72-readwritelock">7.2. ReadWriteLock<a href="#72-readwritelock" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>在 Java 中，ReadWriteLock（通常通过其实现类 ReentrantReadWriteLock 使用）是一种<strong>专门为读多写少场景</strong>设计的锁机制。与 ReentrantLock 相比，它提供了更细粒度的并发控制，允许多个线程同时读取，但写操作是独占的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ReentrantReadWriteLock rwLock <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ReentrantReadWriteLock();
</span></span><span style="display:flex;"><span>Map<span style="color:#f92672">&lt;</span>String, String<span style="color:#f92672">&gt;</span> cache <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashMap<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">get</span>(String key) {
</span></span><span style="display:flex;"><span>    rwLock.<span style="color:#a6e22e">readLock</span>().<span style="color:#a6e22e">lock</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> cache.<span style="color:#a6e22e">get</span>(key);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>        rwLock.<span style="color:#a6e22e">readLock</span>().<span style="color:#a6e22e">unlock</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">put</span>(String key, String value) {
</span></span><span style="display:flex;"><span>    rwLock.<span style="color:#a6e22e">writeLock</span>().<span style="color:#a6e22e">lock</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        cache.<span style="color:#a6e22e">put</span>(key, value);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>        rwLock.<span style="color:#a6e22e">writeLock</span>().<span style="color:#a6e22e">unlock</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
      </div></div>

  
    
<div class="pagination">
  <div class="pagination__title">
    <span class="pagination__title-h">查看其他文章</span>
    <hr />
  </div>
  <div class="pagination__buttons">
    
      <a href="https://blog.jiyi27.com/posts/interview/%E7%BC%93%E5%AD%98%E5%92%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/001-kafka-rabbitmq/" class="button inline prev">
        Kafka vs RabbitMQ
      </a>
    
    
      ::
    
    
      <a href="https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/005-%E5%B1%9E%E6%80%A7%E4%B8%8D%E5%9B%BA%E5%AE%9A%E8%A1%A8%E8%AE%BE%E8%AE%A1/" class="button inline next">
        属性不固定如何设计 MySQL MongoDB -- 软件开发一面
      </a>
    
  </div>
</div>


  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/jiyi27/jiyi27.github.io" target="_blank">Theme</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
