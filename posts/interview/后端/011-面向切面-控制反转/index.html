<!DOCTYPE html>
<html lang="en">
<head>
  
    
    <title>面向切面编程 控制反转 :: 为霜的博客</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="1. Aspect Oriented Program 1.1. 基础概念 面向切面编程（AOP是Aspect Oriented Program的首字母缩写） ，我们知道，面向对象的特点是继承、多态和封装。而封装就要求将功能分散到不同的对象中去，这在软件设计中往往称为职责分配。实际上也就是说，让不同的类设计不同的方法。这样代码就分散到一个个的类中去了。这样做的好处是降低了代码的复杂程度，使类可重用
但是人们也发现，在分散代码的同时，也增加了代码的重复性。什么意思呢？比如说，我们在两个类中，可能都需要在每个方法中做日志。按面向对象的设计方法，我们就必须在两个类的方法中都加入日志的内容。也许他们是完全相同的，但就是因为面向对象的设计让类与类之间无法联系，而不能将这些重复的代码统一起来
也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程
一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为
这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的
AOP在编程历史上可以说是里程碑式的，对OOP编程是一种十分有益的补充
来源: https://www.iteye.com/blog/hejiajunsh-1776569
1.2. 举例解释 假设有一个大的项目，包含多个服务类（如UserService、OrderService、ProductService），每个类有多个方法，都需要日志
直接写日志的方式
public class UserService { public void saveUser(String username) { System.out.println(&#34;Before saving user&#34;); System.out.println(&#34;Saving user: &#34; &#43; username); System.out.println(&#34;After saving user&#34;); } public void deleteUser(String username) { System.out.println(&#34;Before deleting user&#34;); System.out.println(&#34;Deleting user: &#34; &#43; username); System.out.println(&#34;After deleting user&#34;); } } public class OrderService { public void createOrder(String orderId) { System.out.println(&#34;Before creating order&#34;); System.out.println(&#34;Creating order: &#34; &#43; orderId); System.out.println(&#34;After creating order&#34;); } // 更多方法... } 如果要改日志格式（比如加时间戳），得改动所有方法 如果要加新功能（比如记录方法执行时间），又得在每个方法里加代码 用AOP的方式
" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/011-%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/" />





  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/buttons.min.2bc533403a27dfe0e93105a92502b42ce4587e2e4a87d9f7d349e51e16e09478.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/categories.min.3202f75cbb294747099af3850a68a09ee94b3ce505fc39e134692d90ff0a9b2a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/code.min.dd73d157e77e82a3dc1cb06ba424cf6cc6811af0bb604ad6c68e70faf2439c8a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/fonts.min.4881f0c525f3ce2a1864fb6e96676396cebe1e6fcef1933e8e1dde7041004fb5.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/footer.min.2e3eb191baee58dd05a9f0104ac1fab0827bca7c64dafe0b2579f934c33a1d69.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/header.min.b6fb4423cf82a9f9d7abc9cd010223fa3d70a6526a3f28f8e17d814c06e18f9e.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/main.min.3fb8954e26342ad3afabb4525959bfec6f9fc0d6929f0dda738ddeee30211690.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/menu.min.8cee75f73b9f9b1e40bd0dd53e6e770156b08bbfe1c579cd256c3f6cd3b6d32b.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/pagination.min.82f6400eae7c7c6dc3c866733c2ec0579e4089608fea69400ff85b3880aa0d3c.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/post.min.014a50745fbdd41d5f420a3e288730d5af4b7d90344dc6211d0e50c368b5b303.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/prism.min.b958d3d7c6c67361b945f9062d07d403422604b3d2cd33f93b88d41ed0ba634d.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/term.min.94de320c1b850e126e6d2c88a7c90acf58bb1313f0ea14a14cda2a42f2a88db2.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">


<link rel="stylesheet" href="https://blog.jiyi27.com/terminal.css">




<link rel="shortcut icon" href="https://blog.jiyi27.com/favicon.png">
<link rel="apple-touch-icon" href="https://blog.jiyi27.com/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="面向切面编程 控制反转">
<meta property="og:description" content="1. Aspect Oriented Program 1.1. 基础概念 面向切面编程（AOP是Aspect Oriented Program的首字母缩写） ，我们知道，面向对象的特点是继承、多态和封装。而封装就要求将功能分散到不同的对象中去，这在软件设计中往往称为职责分配。实际上也就是说，让不同的类设计不同的方法。这样代码就分散到一个个的类中去了。这样做的好处是降低了代码的复杂程度，使类可重用
但是人们也发现，在分散代码的同时，也增加了代码的重复性。什么意思呢？比如说，我们在两个类中，可能都需要在每个方法中做日志。按面向对象的设计方法，我们就必须在两个类的方法中都加入日志的内容。也许他们是完全相同的，但就是因为面向对象的设计让类与类之间无法联系，而不能将这些重复的代码统一起来
也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程
一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为
这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的
AOP在编程历史上可以说是里程碑式的，对OOP编程是一种十分有益的补充
来源: https://www.iteye.com/blog/hejiajunsh-1776569
1.2. 举例解释 假设有一个大的项目，包含多个服务类（如UserService、OrderService、ProductService），每个类有多个方法，都需要日志
直接写日志的方式
public class UserService { public void saveUser(String username) { System.out.println(&#34;Before saving user&#34;); System.out.println(&#34;Saving user: &#34; &#43; username); System.out.println(&#34;After saving user&#34;); } public void deleteUser(String username) { System.out.println(&#34;Before deleting user&#34;); System.out.println(&#34;Deleting user: &#34; &#43; username); System.out.println(&#34;After deleting user&#34;); } } public class OrderService { public void createOrder(String orderId) { System.out.println(&#34;Before creating order&#34;); System.out.println(&#34;Creating order: &#34; &#43; orderId); System.out.println(&#34;After creating order&#34;); } // 更多方法... } 如果要改日志格式（比如加时间戳），得改动所有方法 如果要加新功能（比如记录方法执行时间），又得在每个方法里加代码 用AOP的方式
" />
<meta property="og:url" content="https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/011-%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/" />
<meta property="og:site_name" content="为霜的博客" />

  <meta property="og:image" content="https://blog.jiyi27.com/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">

  <meta property="article:section" content="面试" />


  <meta property="article:published_time" content="2025-04-16 20:32:19 &#43;0000 UTC" />












</head>
<body>


<div class="container center">

  
  
  

  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/011-%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/">面向切面编程 控制反转</a>
  </h1>
  <div class="post-meta"><time class="post-date">2025-04-16</time><span class="post-reading-time">2 分钟阅读 (330 字数)</span></div>

  
    <span class="post-tags">
      
      #<a href="https://blog.jiyi27.com/tags/%E9%9D%A2%E8%AF%95/">面试</a>&nbsp;
      
      #<a href="https://blog.jiyi27.com/tags/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/">后端面试</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <h2 id="1-aspect-oriented-program">1. Aspect Oriented Program<a href="#1-aspect-oriented-program" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<h3 id="11-基础概念">1.1. 基础概念<a href="#11-基础概念" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<blockquote>
<p>面向切面编程（AOP是Aspect Oriented Program的首字母缩写） ，我们知道，面向对象的特点是继承、多态和封装。而封装就要求将功能分散到不同的对象中去，这在软件设计中往往称为职责分配。实际上也就是说，让不同的类设计不同的方法。这样代码就分散到一个个的类中去了。这样做的好处是降低了代码的复杂程度，使类可重用</p>
<p>但是人们也发现，在分散代码的同时，也增加了代码的重复性。什么意思呢？比如说，我们在两个类中，可能都需要在每个方法中做日志。按面向对象的设计方法，我们就必须在两个类的方法中都加入日志的内容。也许他们是完全相同的，但就是因为面向对象的设计让类与类之间无法联系，而不能将这些重复的代码统一起来</p>
<p>也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程</p>
<p>一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为</p>
<p>这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的</p>
<p>AOP在编程历史上可以说是里程碑式的，对OOP编程是一种十分有益的补充</p>
<p>来源: <a href="https://www.iteye.com/blog/hejiajunsh-1776569">https://www.iteye.com/blog/hejiajunsh-1776569</a></p>
</blockquote>
<h3 id="12-举例解释">1.2. 举例解释<a href="#12-举例解释" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>假设有一个大的项目，包含多个服务类（如UserService、OrderService、ProductService），每个类有多个方法，都需要日志</p>
<p><strong>直接写日志的方式</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UserService</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">saveUser</span>(String username) {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Before saving user&#34;</span>);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Saving user: &#34;</span> <span style="color:#f92672">+</span> username);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;After saving user&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">deleteUser</span>(String username) {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Before deleting user&#34;</span>);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Deleting user: &#34;</span> <span style="color:#f92672">+</span> username);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;After deleting user&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">OrderService</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">createOrder</span>(String orderId) {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Before creating order&#34;</span>);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Creating order: &#34;</span> <span style="color:#f92672">+</span> orderId);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;After creating order&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 更多方法...</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>如果要改日志格式（比如加时间戳），得改动所有方法</li>
<li>如果要加新功能（比如记录方法执行时间），又得在每个方法里加代码</li>
</ul>
<p><strong>用AOP的方式</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 业务逻辑</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UserService</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">saveUser</span>(String username) {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Saving user: &#34;</span> <span style="color:#f92672">+</span> username);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">deleteUser</span>(String username) {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Deleting user: &#34;</span> <span style="color:#f92672">+</span> username);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">OrderService</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">createOrder</span>(String orderId) {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Creating order: &#34;</span> <span style="color:#f92672">+</span> orderId);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 切面</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Aspect</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Component</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LoggingAspect</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Before</span>(<span style="color:#e6db74">&#34;execution(* com.example.*Service.*(..))&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">logBefore</span>() {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Before method execution&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@After</span>(<span style="color:#e6db74">&#34;execution(* com.example.*Service.*(..))&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">logAfter</span>() {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;After method execution&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>
<p><strong>代码简洁</strong>：业务代码只关注核心逻辑（如保存用户、创建订单），日志逻辑集中在 LoggingAspect</p>
</li>
<li>
<p><strong>一处修改，处处生效</strong>：改日志格式只需改 LoggingAspect，无需动业务代码</p>
</li>
</ul>
<h2 id="2-ioc">2. IoC<a href="#2-ioc" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<h3 id="21-dependency-inject">2.1. Dependency Inject<a href="#21-dependency-inject" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>ASP.NET Core 通过其内置的<strong>依赖注入容器</strong>（DI 容器）来管理依赖注入</p>
<h3 id="22-通过构造函数注入">2.2. 通过构造函数注入<a href="#22-通过构造函数注入" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<ul>
<li>ASP.NET Core 的 DI 容器会检查类的构造函数，判断构造函数中是否有需要注入的依赖</li>
<li>如果构造函数的参数类型（如 UserService）<strong>已经在 DI 容器中注册</strong>，容器会在实例化类时自动解析这些依赖并传入</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>public <span style="color:#a6e22e">UserController</span>(UserManageService userManageService, IMapper mapper)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    _mapper <span style="color:#f92672">=</span> mapper;
</span></span><span style="display:flex;"><span>    _userManageService <span style="color:#f92672">=</span> userManageService;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当 ASP.NET Core 需要实例化 UserController（例如处理 HTTP 请求时），DI 容器会检查构造函数的参数类型：</p>
<ul>
<li>UserService：一个自定义服务，可能用于处理用户管理逻辑</li>
<li>如果这些类型已经在 DI 容器中注册，容器会自动解析并提供对应的实例，注入到 <code>UserController</code> 中</li>
</ul>
<h3 id="23-di容器注册">2.3. DI容器注册<a href="#23-di容器注册" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>依赖注入的前提是服务必须在 DI 容器中注册, 通常在 <code>Startup.cs</code> 或 <code>Program.cs</code> 的 <code>ConfigureServices</code> 方法中完成注册</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> ConfigureServices(IServiceCollection services)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    services.AddScoped&lt;UserManageService&gt;();
</span></span><span style="display:flex;"><span>    services.AddSingleton&lt;IMapper&gt;(<span style="color:#66d9ef">new</span> MapperConfiguration(cfg =&gt; { <span style="color:#75715e">/* 配置 AutoMapper */</span> }).CreateMapper());
</span></span><span style="display:flex;"><span>    services.AddControllers();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><code>AddScoped&lt;UserManageService&gt;()</code>：注册<code> UserService</code>，指定其生命周期为 <code>Scoped</code>（每个 HTTP 请求一个实例）</li>
<li><code>AddSingleton&lt;IMapper&gt;()</code>：注册 <code>IMapper</code>，指定为 <code>Singleton</code>（整个应用程序共享一个实例）</li>
<li>DI 容器会记录这些服务及其生命周期，并在需要时解析</li>
</ul>
<blockquote>
<p>ASP.NET Core 的依赖注入<strong>不依赖注解</strong>（如 Java 中的 @Inject 或 @Autowired）, 它通过<strong>构造函数的签名</strong>和 DI 容器中的服务注册来自动识别和注入依赖</p>
<p>只要服务在容器中注册，并且构造函数中声明了这些服务作为参数，ASP.NET Core 就会自动进行依赖注入</p>
</blockquote>
<h3 id="24-控制反转ioc是什么意思">2.4. 控制反转（IoC）是什么意思？<a href="#24-控制反转ioc是什么意思" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>控制反转（Inversion of Control, IoC） 是一种设计原则，用于降低代码之间的耦合度, 它的核心思想是将对象的创建和管理的控制权从类本身转移到外部容器</p>
<p>Inversion of Control (IoC) is a design principle aimed at <strong>decreasing coupling</strong> among software components. The fundamental concept involves shifting the responsibility for object creation and lifecycle management away from the components themselves and delegating it to an external container or framework.</p>
<blockquote>
<p>依赖注入（DI）是实现 IoC 的一种具体方式，通过构造函数、属性或方法将依赖传递给类</p>
<p>在 <code>UserController</code> 中，构造函数注入是 ASP.NET Core 实现 IoC 的方式，DI 容器负责解析和提供 <code>UserService</code> 和 <code>IMapper</code></p>
</blockquote>

      </div></div>

  
    
<div class="pagination">
  <div class="pagination__title">
    <span class="pagination__title-h">查看其他文章</span>
    <hr />
  </div>
  <div class="pagination__buttons">
    
      <a href="https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/012-bson-json-%E5%BA%8F%E5%88%97%E5%8C%96/" class="button inline prev">
        BSON JSON 序列化 反序列化
      </a>
    
    
      ::
    
    
      <a href="https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/010-juc-%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88/" class="button inline next">
        Java 多线程 并发编程
      </a>
    
  </div>
</div>


  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/jiyi27/jiyi27.github.io" target="_blank">Theme</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
