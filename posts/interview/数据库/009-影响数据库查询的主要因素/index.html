<!DOCTYPE html>
<html lang="en">
<head>
  
    
    <title>影响数据库查询的主要因素 :: 为霜的博客</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="(1) 磁盘 I/O 次数
磁盘访问速度远低于内存. 频繁的磁盘读取/写入会严重影响性能, 最主要的瓶颈之一 比如：查询没有命中索引，就要扫描大量数据页，导致大量 I/O (2) 网络 I/O
通常在本地数据库中影响较小，除非是跨地域、大量数据传输 主要在分布式数据库或客户端-服务器架构下才会成为瓶颈 (3) Join 的实现方式与次数
Join 本质上会涉及多个表的数据访问 Join 的次数和方式（Nested Loop、Hash Join、Merge Join）会直接影响 I/O 次数和 CPU 计算量 可以理解为“Join 越多，可能导致 I/O 次数越多”，但不等同于“Join 次数 = I/O 次数” 现在有一个问题, 一般我们如何粗略计算 磁盘 IO 次数 来判断查询效率? 比如一次查询, 需要考虑哪些呢?
数据库把数据存储在 page 里, 常见的大小是 8KB（MySQL/InnoDB）或 4KB（PostgreSQL）, 一次磁盘 I/O 一般指读取一个页到内存
是否命中索引？
命中索引：
需要读取索引页（几页）&#43; 数据页（通常 1 页） 查询主键，一般只需要 1~3 次 I/O 未命中索引（全表扫描）：
需要读取整个表的数据页数
数据页数 = 表大小 / 页大小（如 1GB 表 / 8KB = ~131,000 页 = 131,000 次 I/O）
" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/009-%E5%BD%B1%E5%93%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%B8%BB%E8%A6%81%E5%9B%A0%E7%B4%A0/" />





  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/buttons.min.2bc533403a27dfe0e93105a92502b42ce4587e2e4a87d9f7d349e51e16e09478.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/categories.min.3202f75cbb294747099af3850a68a09ee94b3ce505fc39e134692d90ff0a9b2a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/code.min.dd73d157e77e82a3dc1cb06ba424cf6cc6811af0bb604ad6c68e70faf2439c8a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/fonts.min.4881f0c525f3ce2a1864fb6e96676396cebe1e6fcef1933e8e1dde7041004fb5.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/footer.min.2e3eb191baee58dd05a9f0104ac1fab0827bca7c64dafe0b2579f934c33a1d69.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/header.min.b6fb4423cf82a9f9d7abc9cd010223fa3d70a6526a3f28f8e17d814c06e18f9e.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/main.min.3fb8954e26342ad3afabb4525959bfec6f9fc0d6929f0dda738ddeee30211690.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/menu.min.8cee75f73b9f9b1e40bd0dd53e6e770156b08bbfe1c579cd256c3f6cd3b6d32b.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/pagination.min.82f6400eae7c7c6dc3c866733c2ec0579e4089608fea69400ff85b3880aa0d3c.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/post.min.014a50745fbdd41d5f420a3e288730d5af4b7d90344dc6211d0e50c368b5b303.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/prism.min.b958d3d7c6c67361b945f9062d07d403422604b3d2cd33f93b88d41ed0ba634d.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/term.min.94de320c1b850e126e6d2c88a7c90acf58bb1313f0ea14a14cda2a42f2a88db2.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">


<link rel="stylesheet" href="https://blog.jiyi27.com/terminal.css">




<link rel="shortcut icon" href="https://blog.jiyi27.com/favicon.png">
<link rel="apple-touch-icon" href="https://blog.jiyi27.com/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="影响数据库查询的主要因素">
<meta property="og:description" content="(1) 磁盘 I/O 次数
磁盘访问速度远低于内存. 频繁的磁盘读取/写入会严重影响性能, 最主要的瓶颈之一 比如：查询没有命中索引，就要扫描大量数据页，导致大量 I/O (2) 网络 I/O
通常在本地数据库中影响较小，除非是跨地域、大量数据传输 主要在分布式数据库或客户端-服务器架构下才会成为瓶颈 (3) Join 的实现方式与次数
Join 本质上会涉及多个表的数据访问 Join 的次数和方式（Nested Loop、Hash Join、Merge Join）会直接影响 I/O 次数和 CPU 计算量 可以理解为“Join 越多，可能导致 I/O 次数越多”，但不等同于“Join 次数 = I/O 次数” 现在有一个问题, 一般我们如何粗略计算 磁盘 IO 次数 来判断查询效率? 比如一次查询, 需要考虑哪些呢?
数据库把数据存储在 page 里, 常见的大小是 8KB（MySQL/InnoDB）或 4KB（PostgreSQL）, 一次磁盘 I/O 一般指读取一个页到内存
是否命中索引？
命中索引：
需要读取索引页（几页）&#43; 数据页（通常 1 页） 查询主键，一般只需要 1~3 次 I/O 未命中索引（全表扫描）：
需要读取整个表的数据页数
数据页数 = 表大小 / 页大小（如 1GB 表 / 8KB = ~131,000 页 = 131,000 次 I/O）
" />
<meta property="og:url" content="https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/009-%E5%BD%B1%E5%93%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%B8%BB%E8%A6%81%E5%9B%A0%E7%B4%A0/" />
<meta property="og:site_name" content="为霜的博客" />

  <meta property="og:image" content="https://blog.jiyi27.com/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">

  <meta property="article:section" content="面试" />


  <meta property="article:published_time" content="2025-04-23 20:18:45 &#43;0000 UTC" />












</head>
<body>


<div class="container center">

  
  
  

  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/009-%E5%BD%B1%E5%93%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%B8%BB%E8%A6%81%E5%9B%A0%E7%B4%A0/">影响数据库查询的主要因素</a>
  </h1>
  <div class="post-meta"><time class="post-date">2025-04-23</time><span class="post-reading-time">1 分钟阅读 (200 字数)</span></div>

  
    <span class="post-tags">
      
      #<a href="https://blog.jiyi27.com/tags/%E9%9D%A2%E8%AF%95/">面试</a>&nbsp;
      
      #<a href="https://blog.jiyi27.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95/">数据库面试</a>&nbsp;
      
      #<a href="https://blog.jiyi27.com/tags/mysql/">mysql</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <p><strong>(1) 磁盘 I/O 次数</strong></p>
<ul>
<li>磁盘访问速度远低于内存. 频繁的磁盘读取/写入会严重影响性能, <strong>最主要的瓶颈之一</strong></li>
<li>比如：查询没有命中索引，就要扫描大量数据页，导致大量 I/O</li>
</ul>
<p><strong>(2) 网络 I/O</strong></p>
<ul>
<li>通常在本地数据库中影响较小，除非是跨地域、大量数据传输</li>
<li>主要在<strong>分布式数据库</strong>或<strong>客户端-服务器</strong>架构下才会成为瓶颈</li>
</ul>
<p><strong>(3) Join 的实现方式与次数</strong></p>
<ul>
<li>Join 本质上会涉及多个表的数据访问</li>
<li><strong>Join 的次数和方式</strong>（Nested Loop、Hash Join、Merge Join）会直接影响 I/O 次数和 CPU 计算量</li>
<li>可以理解为“Join 越多，可能导致 I/O 次数越多”，但不等同于“Join 次数 = I/O 次数”</li>
</ul>
<blockquote>
<p>现在有一个问题, 一般我们如何粗略计算 磁盘 IO 次数 来判断查询效率? 比如一次查询, 需要考虑哪些呢?</p>
<p>数据库把数据存储在 page 里, 常见的大小是 8KB（MySQL/InnoDB）或 4KB（PostgreSQL）, <strong>一次磁盘 I/O 一般指读取一个页到内存</strong></p>
<p><strong>是否命中索引？</strong></p>
<p>命中索引：</p>
<ul>
<li>需要读取索引页（几页）+ 数据页（通常 1 页）</li>
<li>查询主键，一般只需要 <strong>1~3 次 I/O</strong></li>
</ul>
<p>未命中索引（全表扫描）：</p>
<ul>
<li>
<p>需要读取整个表的数据页数</p>
</li>
<li>
<p>数据页数 = 表大小 / 页大小（如 1GB 表 / 8KB = ~131,000 页 = 131,000 次 I/O）</p>
</li>
</ul>
<p><strong>索引结构的深度（B+树）</strong></p>
<p>假设一棵 B+树高度为 3：</p>
<ul>
<li>查询需要读取 <strong>根节点 + 中间节点 + 叶子节点</strong> = 3 次 I/O</li>
<li>如果再加上数据行本身，也许是 4 次</li>
</ul>
<p><strong>是否走了回表？</strong></p>
<ul>
<li>如果你查询了非聚簇索引上的字段，还需要回到聚簇索引找完整行</li>
<li>一次“回表”= 至少 1 次 I/O</li>
</ul>
<p><strong>缓存命中</strong></p>
<p>若数据页已在内存，I/O 为 0</p>
</blockquote>
<p>我觉得有几点需要澄清:</p>
<ol>
<li>索引和数据是分开存储的吗?</li>
<li>找到索引后, 直接就能定位到数据吗 类似 O(1) 复杂度?</li>
<li>查找索引的复杂度为什么只和 B+ 树的高度有关系</li>
</ol>
<p><strong>第一个问题:</strong></p>
<table>
  <thead>
      <tr>
          <th>索引类型</th>
          <th>数据存储在哪里？</th>
          <th>是否需要回表</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>主键（聚簇索引）</strong></td>
          <td><strong>数据直接存储在索引的叶子节点</strong></td>
          <td>❌ 不需要回表</td>
      </tr>
      <tr>
          <td><strong>辅助索引（非聚簇索引）</strong></td>
          <td>索引只存储“键 + 主键值”，不含整行数据</td>
          <td>✅ 需要回表</td>
      </tr>
  </tbody>
</table>
<ul>
<li>也就是说如果你查的是主键（聚簇索引），查到了叶子节点，<strong>就等于查到了整行数据</strong></li>
<li>如果你查的是非主键（辅助索引），叶子节点只有部分信息，需要**“通过主键值再去聚簇索引查一次”**，这就是所谓“回表”</li>
</ul>
<p><strong>第二个问题:</strong></p>
<p>分两种情况, 如果找到的是主键索引, 那就等于找到了数据行本身, 因为主键索引的顺序就是实际数据的顺序, 他们的位置是一样的, 都在 B+ 树的同一个叶子上</p>
<p>如果找到的是二级索引, 也就是相当于你知道了主键是什么, 此时想获取数据行的所有数据, 需要回表, 那就要在 主键的 B+ 树上再走一边,  也是 <code>O(lgn)</code></p>
<p>例如，假设有一个表 <code>users(id, name, age)</code>，其中 <code>id</code> 是主键，<code>name</code> 上有一个辅助索引, 如果你执行 <code>SELECT id, name FROM users WHERE name = 'Alice'</code>：</p>
<ul>
<li>
<p>MySQL 会在 <code>name</code> 的辅助索引 B+ 树中查找，找到 <code>name = 'Alice'</code> 的叶子节点，这个节点会包含 <code>name</code> 和对应的 <code>id</code>（主键值）</p>
</li>
<li>
<p>如果查询需要的数据不在辅助索引中（例如，你需要 <code>age</code> 列，而 <code>age</code> 不在 <code>name</code> 的辅助索引中），MySQL 需要拿着查到的主键值（<code>id</code>），去聚簇索引（主键索引）的 B+ 树中查找整行数据, 这个过程叫<strong>回表</strong></p>
</li>
<li>
<p>回表的查找仍然是基于 B+ 树，时间复杂度为 <code>O(log n)</code>，因为需要从聚簇索引的根节点遍历到叶子节点</p>
</li>
</ul>

      </div></div>

  
    
<div class="pagination">
  <div class="pagination__title">
    <span class="pagination__title-h">查看其他文章</span>
    <hr />
  </div>
  <div class="pagination__buttons">
    
      <a href="https://blog.jiyi27.com/posts/database/mongodb/003-lookup%E8%81%9A%E5%90%88%E7%AE%A1%E9%81%93/" class="button inline prev">
        MongoDB $lookup 聚合管道
      </a>
    
    
      ::
    
    
      <a href="https://blog.jiyi27.com/posts/csharp/dot-net/004-%E6%B3%A8%E8%A7%A3%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/" class="button inline next">
        注解如何工作的 C#
      </a>
    
  </div>
</div>


  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/jiyi27/jiyi27.github.io" target="_blank">Theme</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
