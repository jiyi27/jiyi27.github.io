<!DOCTYPE html>
<html lang="en">
<head>
  
    
    <title>MongoDB 规范化还是嵌套 :: 为霜的博客</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content=" Embed when data is read together in most cases
Embedded data models are often denormalized, because frequently-accessed data is duplicated in multiple collections Query on Embedded/Nested Documents Reference when data is read together &ldquo;sometimes&rdquo;
To query normalized data in multiple collections, MongoDB provides $lookup aggregation stage 你可以尝试搜索:
MongoDB references vs embedding
MongoDB normalization vs denormalization
MongoDB nested documents vs separate collections
MongoDB schema design
MongoDB aggregation lookup vs embedded
总结一下也很简单, 当系统结构简单, 子文档也很小的时候, 可以不用规范化, 直接嵌套, 比如用户里面直接嵌入地址信息, 地址嘛, 也不会很大, 获取用户信息的时候, 直接一个 document 什么都有了, 减少连表查询, 速度也很快,
" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://blog.jiyi27.com/posts/database/mongodb/004-%E5%88%86%E8%A1%A8%E8%BF%98%E6%98%AF%E5%B5%8C%E5%A5%97/" />





  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/buttons.min.2bc533403a27dfe0e93105a92502b42ce4587e2e4a87d9f7d349e51e16e09478.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/categories.min.3202f75cbb294747099af3850a68a09ee94b3ce505fc39e134692d90ff0a9b2a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/code.min.dd73d157e77e82a3dc1cb06ba424cf6cc6811af0bb604ad6c68e70faf2439c8a.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/fonts.min.4881f0c525f3ce2a1864fb6e96676396cebe1e6fcef1933e8e1dde7041004fb5.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/footer.min.2e3eb191baee58dd05a9f0104ac1fab0827bca7c64dafe0b2579f934c33a1d69.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/header.min.b6fb4423cf82a9f9d7abc9cd010223fa3d70a6526a3f28f8e17d814c06e18f9e.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/main.min.3fb8954e26342ad3afabb4525959bfec6f9fc0d6929f0dda738ddeee30211690.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/menu.min.8cee75f73b9f9b1e40bd0dd53e6e770156b08bbfe1c579cd256c3f6cd3b6d32b.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/pagination.min.82f6400eae7c7c6dc3c866733c2ec0579e4089608fea69400ff85b3880aa0d3c.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/post.min.014a50745fbdd41d5f420a3e288730d5af4b7d90344dc6211d0e50c368b5b303.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/prism.min.b958d3d7c6c67361b945f9062d07d403422604b3d2cd33f93b88d41ed0ba634d.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/term.min.94de320c1b850e126e6d2c88a7c90acf58bb1313f0ea14a14cda2a42f2a88db2.css">

  
  <link rel="stylesheet" href="https://blog.jiyi27.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">


<link rel="stylesheet" href="https://blog.jiyi27.com/terminal.css">




<link rel="shortcut icon" href="https://blog.jiyi27.com/favicon.png">
<link rel="apple-touch-icon" href="https://blog.jiyi27.com/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="MongoDB 规范化还是嵌套">
<meta property="og:description" content=" Embed when data is read together in most cases
Embedded data models are often denormalized, because frequently-accessed data is duplicated in multiple collections Query on Embedded/Nested Documents Reference when data is read together &ldquo;sometimes&rdquo;
To query normalized data in multiple collections, MongoDB provides $lookup aggregation stage 你可以尝试搜索:
MongoDB references vs embedding
MongoDB normalization vs denormalization
MongoDB nested documents vs separate collections
MongoDB schema design
MongoDB aggregation lookup vs embedded
总结一下也很简单, 当系统结构简单, 子文档也很小的时候, 可以不用规范化, 直接嵌套, 比如用户里面直接嵌入地址信息, 地址嘛, 也不会很大, 获取用户信息的时候, 直接一个 document 什么都有了, 减少连表查询, 速度也很快,
" />
<meta property="og:url" content="https://blog.jiyi27.com/posts/database/mongodb/004-%E5%88%86%E8%A1%A8%E8%BF%98%E6%98%AF%E5%B5%8C%E5%A5%97/" />
<meta property="og:site_name" content="为霜的博客" />

  <meta property="og:image" content="https://blog.jiyi27.com/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">

  <meta property="article:section" content="数据库" />


  <meta property="article:published_time" content="2025-04-21 20:39:18 &#43;0000 UTC" />












</head>
<body>


<div class="container center">

  
  
  

  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://blog.jiyi27.com/posts/database/mongodb/004-%E5%88%86%E8%A1%A8%E8%BF%98%E6%98%AF%E5%B5%8C%E5%A5%97/">MongoDB 规范化还是嵌套</a>
  </h1>
  <div class="post-meta"><time class="post-date">2025-04-21</time><span class="post-reading-time">1 分钟阅读 (166 字数)</span></div>

  
    <span class="post-tags">
      
      #<a href="https://blog.jiyi27.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>&nbsp;
      
      #<a href="https://blog.jiyi27.com/tags/mongodb/">mongodb</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <blockquote>
<p>Embed when data is read together in most cases</p>
<ul>
<li>Embedded data models are often denormalized,  because frequently-accessed data is duplicated in multiple collections</li>
<li><a href="https://www.mongodb.com/docs/manual/tutorial/query-embedded-documents/#std-label-read-operations-embedded-documents">Query on Embedded/Nested Documents</a></li>
</ul>
<p>Reference when data is read together &ldquo;sometimes&rdquo;</p>
<ul>
<li>To query normalized data in multiple collections, MongoDB provides <a href="https://www.mongodb.com/docs/manual/reference/operator/aggregation/lookup/#mongodb-pipeline-pipe.-lookup"><code>$lookup</code></a> aggregation stage</li>
</ul>
</blockquote>
<p>你可以尝试搜索:</p>
<ul>
<li>
<p>MongoDB references vs embedding</p>
</li>
<li>
<p>MongoDB normalization vs denormalization</p>
</li>
<li>
<p>MongoDB nested documents vs separate collections</p>
</li>
<li>
<p>MongoDB schema design</p>
</li>
<li>
<p>MongoDB <strong>aggregation lookup vs embedded</strong></p>
</li>
</ul>
<p>总结一下也很简单, 当系统结构简单, 子文档也很小的时候, 可以不用规范化, 直接嵌套, 比如用户里面直接嵌入地址信息, 地址嘛, 也不会很大, 获取用户信息的时候, 直接一个 document 什么都有了, 减少连表查询, 速度也很快,</p>
<p>但系统复杂的时候, 比如<strong>多对多关系</strong>, 很多表需要相互关联, 需要经常修改, 这个时候就不可以嵌套了, 比如我们需要经常修改商品信息, 或者商品的评论信息, 这个时候就不可以采用 把 评论 嵌入 商品, 把商品嵌入商店, 因为这样, 每次你修改评论, 都需要去查找商店, 然后对应的商品, 然后去修改对应的评论, 这肯定不高效, 不如使用规范化, 直接根据评论 id 去更新数据,</p>
<blockquote>
<p>MongoDB 没有传统数据库中 join 操作和 foreign key, 但可以通过 <a href="https://www.mongodb.com/docs/manual/data-modeling/concepts/embedding-vs-references/#embedded-data-models">embedded documents</a> 或者 <a href="https://www.mongodb.com/docs/manual/data-modeling/concepts/embedding-vs-references/#std-label-data-modeling-referencing">reference</a> 来表示一对多关系, 也可使用聚合管道 <code>$lookup</code> 来实现类似 Join 的功能, 但注意 <code>$lookup</code>  只适用于 Reference 存储的查询, 而不是嵌套文档, 上面已经给出了两种方法具体的查询方式</p>
</blockquote>
<hr>
<p>至于规范化的设计, 一般有两种存储</p>
<ul>
<li>商店添加一个数组字段存储拥有的商品 id</li>
<li>商品添加一个字段, 标注其所属的 id</li>
</ul>
<p>前者需要使用 MongoDB 的数组查询, 后者使用 <code>$lookup</code> 聚合管道查询, 这都是规范化的设计, 至于哪个更好, 要看具体的场景, 注意想要查询效率, 就要接受一定程度数据冗余, 当然有了冗余, 不仅仅是占用空间的问题, 还存在更新的问题, 比如商店存储其拥有的所有商品 id 或者 name 这就是冗余, 因为可以直接通过 商品 collection 查询到某个商店的所有商品, 那为什么会导致更新问题呢?</p>
<ul>
<li>当商品的名字更新的时候, 商店若存了所拥有的所有商品名字列表, 是不是也需要更新这个数组?</li>
<li>当商品被删除下架的时候, 是不是也要处理商店的商品名字列表?</li>
</ul>

      </div></div>

  
    
<div class="pagination">
  <div class="pagination__title">
    <span class="pagination__title-h">查看其他文章</span>
    <hr />
  </div>
  <div class="pagination__buttons">
    
      <a href="https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/012-%E6%B5%85%E8%B0%88%E5%BA%8F%E5%88%97%E5%8C%96/" class="button inline prev">
        浅谈序列化
      </a>
    
    
      ::
    
    
      <a href="https://blog.jiyi27.com/posts/git/007-%E4%B8%80%E4%BA%9B%E6%96%B0%E7%9A%84git%E6%8C%87%E4%BB%A4/" class="button inline next">
        git 一些魔法指令
      </a>
    
  </div>
</div>


  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/jiyi27/jiyi27.github.io" target="_blank">Theme</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
