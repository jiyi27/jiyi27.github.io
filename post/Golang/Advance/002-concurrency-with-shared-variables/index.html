<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Concurrency with Shared Variables - David&#39;s Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="David" /><meta name="description" content="1. Concurrency Safe In a program with two or more goroutines, the steps within each goroutine happen in the familiar order, but in general we don’t know whether an event x in one goroutine happens before an event y in another goroutine, or happens after it, or is simultaneous with it. When we cannot confidently say that one event happens before the other, then the events x and y are concurrent." />






<meta name="generator" content="Hugo 0.123.7 with theme even" />


<link rel="canonical" href="https://davidzhu.xyz/post/golang/advance/002-concurrency-with-shared-variables/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Concurrency with Shared Variables" />
<meta property="og:description" content="1. Concurrency Safe In a program with two or more goroutines, the steps within each goroutine happen in the familiar order, but in general we don’t know whether an event x in one goroutine happens before an event y in another goroutine, or happens after it, or is simultaneous with it. When we cannot confidently say that one event happens before the other, then the events x and y are concurrent." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://davidzhu.xyz/post/golang/advance/002-concurrency-with-shared-variables/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-08-24T19:16:59+00:00" />
<meta property="article:modified_time" content="2023-08-24T19:16:59+00:00" />

<meta itemprop="name" content="Concurrency with Shared Variables">
<meta itemprop="description" content="1. Concurrency Safe In a program with two or more goroutines, the steps within each goroutine happen in the familiar order, but in general we don’t know whether an event x in one goroutine happens before an event y in another goroutine, or happens after it, or is simultaneous with it. When we cannot confidently say that one event happens before the other, then the events x and y are concurrent."><meta itemprop="datePublished" content="2023-08-24T19:16:59+00:00" />
<meta itemprop="dateModified" content="2023-08-24T19:16:59+00:00" />
<meta itemprop="wordCount" content="2580">
<meta itemprop="keywords" content="golang,concurrency," /><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Concurrency with Shared Variables"/>
<meta name="twitter:description" content="1. Concurrency Safe In a program with two or more goroutines, the steps within each goroutine happen in the familiar order, but in general we don’t know whether an event x in one goroutine happens before an event y in another goroutine, or happens after it, or is simultaneous with it. When we cannot confidently say that one event happens before the other, then the events x and y are concurrent."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">David&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">David&#39;s Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Concurrency with Shared Variables</h1>

      <div class="post-meta">
        <span class="post-time"> 2023-08-24 </span>
        <div class="post-category">
            <a href="/categories/golang/"> golang </a>
            <a href="/categories/advance/"> advance </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#1-concurrency-safe">1. Concurrency Safe</a></li>
        <li><a href="#2-data-race">2. Data Race</a></li>
        <li><a href="#3-mutual-exclusion">3. Mutual Exclusion</a>
          <ul>
            <li><a href="#31-mutex-vs-semaphore">3.1. Mutex vs Semaphore</a></li>
            <li><a href="#32-mutual-exclusion-syncmutex">3.2. Mutual Exclusion: <code>sync.Mutex</code></a></li>
            <li><a href="#33-readwrite-mutexes-syncrwmutex">3.3. Read/Write Mutexes: <code>sync.RWMutex</code></a></li>
          </ul>
        </li>
        <li><a href="#4-memory-synchronization">4. Memory Synchronization</a></li>
        <li><a href="#5-race-conditions-vs-data-race">5. Race Conditions vs Data Race</a></li>
        <li><a href="#6-conclusion">6. Conclusion</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="1-concurrency-safe">1. Concurrency Safe</h2>
<p>In a program with two or more goroutines, the steps within each goroutine happen in the familiar order, but in general we don’t know whether an event <em>x</em> in one goroutine happens before an event <em>y</em> in another goroutine, or happens after it, or is simultaneous with it. When we cannot confidently say that one event <em>happens before</em> the other, then the events <em>x</em> and <em>y</em> are <em><strong>concurrent</strong></em>.</p>
<p>That function is <em><strong>concurrency-safe</strong></em> if it continues to work correctly even when called concurrently, that is, from two or more goroutines with no additional synchronization. We can generalize this notion to a set of collaborating functions, such as the methods and operations of a particular type. A type is <em><strong>concurrency-safe</strong></em> if all its accessible methods and operations are concurrency-safe.</p>
<p>Concurrency-safe types are the exception rather than the rule, so you should access a variable concurrently only if the documentation for its type says that this is safe. We avoid concurrent access to most variables either by <em>confining</em> them to a single goroutine or by maintaining a higher-level invariant of <em>mutual exclusion</em>.</p>
<p>In contrast, exported package-level functions <em>are</em> generally expected to be concurrency-safe. Since package-level variables cannot be confined to a single goroutine, functions that modify them must enforce <em><strong>mutual exclusion</strong></em>.</p>
<h2 id="2-data-race">2. Data Race</h2>
<p>A <em><strong>data race</strong></em> occurs whenever two goroutines access the same variable <em><strong>concurrently</strong></em> and at least one of the accesses is a write. Notice that &ldquo;access the same variable concurrently&rdquo; means: there are two or more goroutines (threads) to access a same variable <code>x</code>, and we cannot assure the order of accessing variable <code>x</code>.</p>
<p>Aussume we have these code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">balance</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Deposit</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="nx">balance</span> <span class="p">=</span> <span class="nx">balance</span> <span class="o">+</span> <span class="nx">amount</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Balance</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">balance</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>And there are two goroutines access <code>balance</code>  concurrently,</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Alice:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">bank</span><span class="p">.</span><span class="nf">Deposit</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span>                <span class="c1">// A1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;=&#34;</span><span class="p">,</span> <span class="nx">bank</span><span class="p">.</span><span class="nf">Balance</span><span class="p">())</span> <span class="c1">// A2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Bob:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">go</span> <span class="nx">bank</span><span class="p">.</span><span class="nf">Deposit</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>                 <span class="c1">// B
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Alice deposits $200, then checks her balance, while Bob deposits $100. Since the steps <code>A1</code> and <code>A2</code> occur <em><strong>concurrently</strong></em> with <code>B</code>, we cannot predict the order in which they happen. Intuitively, it might seem that there are only three possible orderings, which we’ll call “Alice first,” “Bob first,” and “Alice/Bob/Alice.” The following table shows the value of the <code>balance</code> variable after each step. The quoted strings represent the printed balance slips.</p>
<p>In all cases the final balance is $300. The only variation is whether Alice’s balance slip includes Bob’s transaction or not, but the customers are satisfied either way.</p>
<p>But this intuition is wrong. There is a fourth possible outcome, in which Bob’s deposit occurs in the middle of Alice’s deposit, after the balance has been read (<code>balance + amount</code>) but before it has been updated (<code>balance = ...</code>), causing Bob’s transaction to disappear. This is because Alice’s deposit operation <code>A1</code> is really a sequence of two operations, a read and a write; call them <code>A1r</code> and <code>A1w</code>. Here’s the problematic interleaving:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">Data race
</span></span><span class="line"><span class="cl">         <span class="m">0</span>
</span></span><span class="line"><span class="cl">A1r      <span class="m">0</span>          ... <span class="o">=</span> balance + amount
</span></span><span class="line"><span class="cl"><span class="c1"># happend in the middle, balance = 100 but A1 will make balance = balance + amount which equals to 200 above</span>
</span></span><span class="line"><span class="cl">B      <span class="m">100</span>
</span></span><span class="line"><span class="cl">A1w    <span class="m">200</span>          <span class="nv">balance</span> <span class="o">=</span> ...
</span></span><span class="line"><span class="cl">A2  <span class="s2">&#34;= 200&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>After <code>A1r</code>, the expression <code>balance + amount</code> evaluates to 200, so this is the value written during <code>A1w</code>, despite the intervening deposit. The final balance is only $200.</p>
<p>We’ll repeat the definition, since it is so important: A data race occurs whenever two goroutines access the same variable concurrently and at least one of the accesses is a write. It follows from this definition that there are three ways to avoid a data race:</p>
<ul>
<li>first way: not to write the variable
<ul>
<li>try to use read only variable</li>
</ul>
</li>
<li>second way: avoid accessing the variable from multiple goroutines (<em>confined</em> to a single goroutine)
<ul>
<li>access the variable need to write in only one goroutine which called monitor goroutine</li>
<li>other goroutine want to modify this variable can notify the monitor goroutine of that variable</li>
<li>Since other goroutines cannot access the variable directly, they must use a channel to send the confining goroutine a request to query or update the variable. This is what is meant by the Go mantra “Do not communicate by sharing memory; instead, share memory by communicating.”</li>
</ul>
</li>
</ul>
<p>Here’s the bank example rewritten with the <code>balance</code> variable confined to a monitor goroutine called <code>teller</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Package bank provides a concurrency-safe bank with one account.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">package</span> <span class="nx">bank</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">deposits</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="c1">// send amount to deposit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">balances</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="c1">// receive balance
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Deposit</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="nx">deposits</span> <span class="o">&lt;-</span> <span class="nx">amount</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Balance</span><span class="p">()</span> <span class="kt">int</span>       <span class="p">{</span> <span class="k">return</span> <span class="o">&lt;-</span><span class="nx">balances</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">teller</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">balance</span> <span class="kt">int</span> <span class="c1">// balance is confined to teller goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nx">amount</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">deposits</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="nx">balance</span> <span class="o">+=</span> <span class="nx">amount</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nx">balances</span> <span class="o">&lt;-</span> <span class="nx">balance</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">go</span> <span class="nf">teller</span><span class="p">()</span> <span class="c1">// start the monitor goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>You can see, when there are some variables in a package, we better tell user if it is concurrency-safe.</p>
<p>The third way to avoid a data race is to allow many goroutines to access the variable, but only one at a time. This approach is known as <em><strong>mutual exclusion</strong></em>.</p>
<h2 id="3-mutual-exclusion">3. Mutual Exclusion</h2>
<h3 id="31-mutex-vs-semaphore">3.1. Mutex vs Semaphore</h3>
<p>A semaphore is a non-negative integer variable that is shared between various threads. Mutex is a specific kind of binary semaphore that is used to provide a locking mechanism.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">P(mutex);
</span></span><span class="line"><span class="cl">execute CS;
</span></span><span class="line"><span class="cl">V(mutex);
</span></span></code></pre></td></tr></table>
</div>
</div><table>
<thead>
<tr>
<th style="text-align:center">Mutex</th>
<th style="text-align:center">Semaphore</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A mutex is an object.</td>
<td style="text-align:center">A semaphore is an integer.</td>
</tr>
<tr>
<td style="text-align:center">Mutex works upon the locking mechanism.</td>
<td style="text-align:center">Semaphore uses signaling mechanism</td>
</tr>
<tr>
<td style="text-align:center">Operations on mutex:LockUnlock</td>
<td style="text-align:center">Operation on semaphore:WaitSignal</td>
</tr>
<tr>
<td style="text-align:center">Mutex doesn’t have any subtypes.</td>
<td style="text-align:center">Semaphore is of two types:Counting SemaphoreBinary Semaphore</td>
</tr>
<tr>
<td style="text-align:center">A mutex can only be modified by the process that is requesting or releasing a resource.</td>
<td style="text-align:center">Semaphore work with two atomic operations (Wait, signal) which can modify it.</td>
</tr>
<tr>
<td style="text-align:center">If the mutex is locked then the process needs to wait in the process queue, and mutex can only be accessed once the lock is released.</td>
<td style="text-align:center">If the process needs a resource, and no resource is free. So, the process needs to perform a wait operation until the semaphore value is greater than zero.</td>
</tr>
</tbody>
</table>
<h3 id="32-mutual-exclusion-syncmutex">3.2. Mutual Exclusion: <code>sync.Mutex</code></h3>
<p>In <a href="https://learning.oreilly.com/library/view/the-go-programming/9780134190570/ebook_split_081.html#id-exampleconcurrentwebcrawler">Section 8.6</a>, we used a buffered channel as a <em><strong>counting semaphore</strong></em> to ensure that no more than 20 goroutines made simultaneous HTTP requests. With the same idea, we can use a channel of capacity 1 to ensure that at most one goroutine accesses a shared variable at a time. A semaphore that counts only to 1 is called a <em><strong>binary semaphore</strong></em>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sema</span>    <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// a binary semaphore guarding balance
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">balance</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Deposit</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sema</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span> <span class="c1">// acquire token
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">balance</span> <span class="p">=</span> <span class="nx">balance</span> <span class="o">+</span> <span class="nx">amount</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;-</span><span class="nx">sema</span> <span class="c1">// release token
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Balance</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sema</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span> <span class="c1">// acquire token
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">b</span> <span class="o">:=</span> <span class="nx">balance</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;-</span><span class="nx">sema</span> <span class="c1">// release token
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>This pattern of <em>mutual exclusion</em> is so useful that it is supported directly by the <code>Mutex</code> type from the <code>sync</code> package. Its <code>Lock</code> method acquires the token (called a <em>lock</em>) and its <code>Unlock</code> method releases it:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mu</span>      <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// guards balance
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">balance</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Deposit</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nx">balance</span> <span class="p">=</span> <span class="nx">balance</span> <span class="o">+</span> <span class="nx">amount</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Balance</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nx">b</span> <span class="o">:=</span> <span class="nx">balance</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="33-readwrite-mutexes-syncrwmutex">3.3. Read/Write Mutexes: <code>sync.RWMutex</code></h3>
<p>Since the <code>Balance</code> function only needs to <em>read</em> the state of the variable, it would in fact be safe for multiple <code>Balance</code> calls to run concurrently, so long as no <code>Deposit</code> or <code>Withdraw</code> call is running. In this scenario we need a special kind of lock that allows read-only operations to proceed in parallel with each other, but write operations to have fully exclusive access. This lock is called a <em>multiple readers</em>, <em>single writer</em> lock, and in Go it’s provided by <code>sync.RWMutex</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">balance</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Balance</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mu</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span> <span class="c1">// readers lock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">defer</span> <span class="nx">mu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">balance</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="4-memory-synchronization">4. Memory Synchronization</h2>
<p>You may wonder why the <code>Balance</code> method needs mutual exclusion, either channel-based or mutex-based. After all, unlike <code>Deposit</code>, it consists only of a single operation, so there is no danger of another goroutine executing “in the middle” of it.</p>
<p>The reason is that synchronization is about more than just the order of execution of multiple goroutines; synchronization also affects memory.</p>
<p>In a modern computer there may be dozens of processors, <strong>each with its own local cache of the main memory</strong>. <strong>For efficiency, writes to memory are buffered</strong> within each processor and flushed out to main memory only when necessary. <em><strong>Synchronization primitives</strong></em> like <em><strong>channel communications</strong></em> and <em><strong>mutex operations</strong></em> cause the processor to flush out and commit all its accumulated writes so that the effects of goroutine execution up to that point <strong>are guaranteed to be visible to</strong> goroutines running on other processors.</p>
<p>Consider the possible outputs of the following snippet of code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">x</span> <span class="p">=</span> <span class="mi">1</span>                   <span class="c1">// A1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="s">&#34;y:&#34;</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">)</span> <span class="c1">// A2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}()</span>
</span></span><span class="line"><span class="cl"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">y</span> <span class="p">=</span> <span class="mi">1</span>                   <span class="c1">// B1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="s">&#34;x:&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">)</span> <span class="c1">// B2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Since these two goroutines are concurrent and access shared variables without mutual exclusion, there is a data race, so we should not be surprised that the program is not deterministic.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">y:0 x:1
</span></span><span class="line"><span class="cl">x:0 y:1
</span></span><span class="line"><span class="cl">x:1 y:1
</span></span><span class="line"><span class="cl">y:1 x:1
</span></span></code></pre></td></tr></table>
</div>
</div><p>The fourth line could be explained by the sequence <code>A1,B1,A2,B2</code> or by <code>B1,A1,A2,B2</code>, for example. However, these two outcomes might come as a surprise:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">x:0 y:0
</span></span><span class="line"><span class="cl">y:0 x:0
</span></span></code></pre></td></tr></table>
</div>
</div><p>but depending on the compiler, CPU, and many other factors, they can happen too. What possible interleaving of the four statements could explain them?</p>
<p>Within a single goroutine, the effects of each statement are guaranteed to occur in the order of execution; goroutines are <em>sequentially consistent</em>. But in the absence of explicit synchronization using a channel or mutex, there is no guarantee that events are seen in the same order by all goroutines. Although goroutine <em>A</em> must observe the effect of the write <code>x = 1</code> before it reads the value of <code>y</code>, it does not necessarily observe the write to <code>y</code> done by goroutine <em>B</em>, so <em>A</em> may print a <em>stale</em> value of <code>y</code>.</p>
<p>It is tempting to try to understand concurrency as if it corresponds to <em>some</em> interleaving of the statements of each goroutine, but as the example above shows, this is not how a modern compiler or CPU works. Because the assignment and the <code>Print</code> refer to different variables, <strong>a compiler may conclude that the order of the two statements</strong> cannot affect the result, and swap them. If the two goroutines execute on different CPUs, each with its own cache, writes by one goroutine <strong>are not visible to</strong> the other goroutine’s <code>Print</code> until the caches are synchronized with main memory.</p>
<p>All these concurrency problems can be avoided by the consistent use of simple, established patterns. Where possible, confine variables to a single goroutine; for all other variables, use mutual exclusion.</p>
<h2 id="5-race-conditions-vs-data-race">5. Race Conditions vs Data Race</h2>
<p>A <em><strong>race condition</strong></em> is a flaw that occurs when the timing or ordering of events affects a program’s correctness. Generally speaking, some kind of external timing or ordering non-determinism is needed to produce a race condition; typical examples are context switches, OS signals, memory operations on a multiprocessor, and hardware interrupts.</p>
<p>A <em><strong>data race</strong></em> occurs whenever two goroutines access the same variable <em><strong>concurrently</strong></em> and at least one of the accesses is a write.</p>
<p>Race conditions are pernicious because they may remain latent in a program and appear infrequently, perhaps only under heavy load or when using certain compilers, platforms, or architectures. This makes them hard to reproduce and diagnose.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nf">transfer1</span> <span class="p">(</span><span class="nx">amount</span><span class="p">,</span> <span class="nx">account_from</span><span class="p">,</span> <span class="nx">account_to</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">account_from</span><span class="p">.</span><span class="nx">balance</span> <span class="p">&lt;</span> <span class="nx">amount</span><span class="p">)</span> <span class="k">return</span> <span class="nx">NOPE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">account_to</span><span class="p">.</span><span class="nx">balance</span> <span class="o">+=</span> <span class="nx">amount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">account_from</span><span class="p">.</span><span class="nx">balance</span> <span class="o">-=</span> <span class="nx">amount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">YEP</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Of course this is not how banks really move money, but the example is useful anyway because we understand intuitively that account balances should be non-negative and that a transfer must not create or lose money. When called from multiple threads without external synchronization, this function admits both data races (multiple threads can concurrently try to update an account balance) and race conditions (in a parallel context it will create or lose money). We can try to fix it like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nf">transfer2</span> <span class="p">(</span><span class="nx">amount</span><span class="p">,</span> <span class="nx">account_from</span><span class="p">,</span> <span class="nx">account_to</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">atomic</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">bal</span> <span class="p">=</span> <span class="nx">account_from</span><span class="p">.</span><span class="nx">balance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">bal</span> <span class="p">&lt;</span> <span class="nx">amount</span><span class="p">)</span> <span class="k">return</span> <span class="nx">NOPE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">atomic</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">account_to</span><span class="p">.</span><span class="nx">balance</span> <span class="o">+=</span> <span class="nx">amount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">atomic</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">account_from</span><span class="p">.</span><span class="nx">balance</span> <span class="o">-=</span> <span class="nx">amount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">YEP</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Here “atomic” is implemented by the language runtime, perhaps simply by acquiring a thread mutex at the start of the atomic block and releasing it at the end, perhaps using some sort of transaction, or perhaps by disabling interrupts — for purposes of the example it doesn’t matter as long as the code inside the block executes atomically.</p>
<p>transfer2 has no data races when called by multiple threads, but obviously it is an extremely silly function containing race conditions that will cause it to create or lose money almost as badly as the unsynchronized function. From a technical point of view, the problem with transfer2 is that it permits other threads to see memory states where a key invariant — conservation of money — is broken.</p>
<p>To preserve the invariant, we have to use a better locking strategy. As long as atomic’s semanatics are to end the atomic section on any exit from the block, the solution can be blunt:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">transfer3 (amount, account_from, account_to) {
</span></span><span class="line"><span class="cl">  atomic {
</span></span><span class="line"><span class="cl">    if (account_from.balance &lt; amount) return NOPE;
</span></span><span class="line"><span class="cl">    account_to.balance += amount;
</span></span><span class="line"><span class="cl">    account_from.balance -= amount;
</span></span><span class="line"><span class="cl">    return YEP;
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>This function is free of data races and also of race conditions.</p>
<p>Everything in this post is pretty obvious, but I’ve observed real confusion about the distinction between data race and race condition by people who should know better (for example because they are doing research on concurrency correctness). Muddying the waters further, even when people are perfectly clear on the underlying concepts, they sometimes say “race condition” when the really mean “data race.” Certainly I’ve caught myself doing this.</p>
<h2 id="6-conclusion">6. Conclusion</h2>
<ul>
<li>
<p><em><strong>concurrent</strong></em> envolves two or more threads, and it&rsquo;s all about the <em>unpredictable</em> order of the execution.</p>
</li>
<li>
<p><em><strong>concurrency-safe type</strong></em> if that all its accessible methods and operations are concurrency-safe.</p>
</li>
<li>
<p>A <em><strong>data race</strong></em> occurs whenever two goroutines access the same variable <em><strong>concurrently</strong></em> and at least one of the accesses is a write.</p>
<ul>
<li>data race can cause data lost, the bank example</li>
<li>when there is data race, you&rsquo;d better use <em><strong>Mutual Exclusion</strong></em>: <code>sync.RWMutex</code>,  <code>sync.Mutex</code></li>
</ul>
</li>
<li>
<p>Mutex vs Semaphore</p>
</li>
<li>
<p>A <em><strong>race condition</strong></em> is a flaw that occurs when the timing or ordering of events affects a program’s correctness.</p>
</li>
</ul>
<p>References:</p>
<ul>
<li><a href="https://learning.oreilly.com/library/view/the-go-programming/9780134190570/ebook_split_087.html">9.1 Race Conditions | The Go Programming Language</a></li>
<li><a href="https://www.geeksforgeeks.org/mutex-vs-semaphore/">Mutex vs Semaphore - GeeksforGeeks</a></li>
<li><a href="https://blog.regehr.org/archives/490">Race Condition vs. Data Race – Embedded in Academia</a></li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">David</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2023-08-24
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/golang/">golang</a>
          <a href="/tags/concurrency/">concurrency</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/linux/003-shell-expansion/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Shell Expansion</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/golang/advance/001-why-goroutines/">
            <span class="next-text nav-default">Goroutines Model</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:shwezhu@qq.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/shwezhu" class="iconfont icon-github" title="github"></a>
  <a href="https://davidzhu.xyz/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2023 - 
    2024<span class="heart"><i class="iconfont icon-heart"></i></span><span>David</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
