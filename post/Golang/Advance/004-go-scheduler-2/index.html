<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go Scheduler (2) - David&#39;s Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="David" /><meta name="description" content="0. Parrallelism is not concurrency Parallelism is about multiple tasks or subtasks of the same task that literally run at the same time on a hardware with multiple computing resources like multi-core processor, while concurrency is about multiple tasks which start, run, and complete in overlapping time periods, in no specific order. 1. Your program starts When your Go program starts up, it’s given a Logical Processor" />






<meta name="generator" content="Hugo 0.123.7 with theme even" />


<link rel="canonical" href="https://davidzhu.xyz/post/golang/advance/004-go-scheduler-2/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go Scheduler (2)" />
<meta property="og:description" content="0. Parrallelism is not concurrency Parallelism is about multiple tasks or subtasks of the same task that literally run at the same time on a hardware with multiple computing resources like multi-core processor, while concurrency is about multiple tasks which start, run, and complete in overlapping time periods, in no specific order. 1. Your program starts When your Go program starts up, it’s given a Logical Processor" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://davidzhu.xyz/post/golang/advance/004-go-scheduler-2/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-05-28T18:06:20+00:00" />
<meta property="article:modified_time" content="2023-05-28T18:06:20+00:00" />

<meta itemprop="name" content="Go Scheduler (2)">
<meta itemprop="description" content="0. Parrallelism is not concurrency Parallelism is about multiple tasks or subtasks of the same task that literally run at the same time on a hardware with multiple computing resources like multi-core processor, while concurrency is about multiple tasks which start, run, and complete in overlapping time periods, in no specific order. 1. Your program starts When your Go program starts up, it’s given a Logical Processor"><meta itemprop="datePublished" content="2023-05-28T18:06:20+00:00" />
<meta itemprop="dateModified" content="2023-05-28T18:06:20+00:00" />
<meta itemprop="wordCount" content="2501">
<meta itemprop="keywords" content="golang,concurrency," /><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Go Scheduler (2)"/>
<meta name="twitter:description" content="0. Parrallelism is not concurrency Parallelism is about multiple tasks or subtasks of the same task that literally run at the same time on a hardware with multiple computing resources like multi-core processor, while concurrency is about multiple tasks which start, run, and complete in overlapping time periods, in no specific order. 1. Your program starts When your Go program starts up, it’s given a Logical Processor"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">David&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">David&#39;s Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go Scheduler (2)</h1>

      <div class="post-meta">
        <span class="post-time"> 2023-05-28 </span>
        <div class="post-category">
            <a href="/categories/golang/"> golang </a>
            <a href="/categories/advance/"> advance </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#0-parrallelism-is-not-concurrency">0. Parrallelism is not concurrency</a></li>
        <li><a href="#1-your-program-starts">1. Your program starts</a></li>
        <li><a href="#2-cooperating-scheduler">2. Cooperating scheduler</a></li>
        <li><a href="#3-goroutine-states">3. Goroutine states</a></li>
        <li><a href="#4-context-switching">4. Context switching</a></li>
        <li><a href="#5-asynchronous-system-calls">5. Asynchronous system calls</a></li>
        <li><a href="#6-synchronous-system-calls">6. Synchronous system calls</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="0-parrallelism-is-not-concurrency">0. Parrallelism is not concurrency</h2>
<p><strong>Parallelism</strong> is about multiple tasks or subtasks of the same task that literally run at the same time on a hardware with multiple computing resources like multi-core processor, while <strong>concurrency</strong> is about multiple tasks which start, run, and complete in overlapping time periods, in no specific order.</p>
<h2 id="1-your-program-starts">1. Your program starts</h2>
<p>When your Go program starts up, it’s given a <strong>Logical Processor (P)</strong> for every <strong>virtual core</strong> that is identified on the host machine. If you have a processor with multiple <strong>hardware threads</strong> per <strong>physical core</strong> (<strong>Hyper-Threading</strong>), each hardware thread will be presented to your Go program as a virtual core. To better understand this, take a look at the system report for my MacBook Pro.</p>
<p>Hyper-Threading: one physical core corresponds to two virtual cores. And one virtual core can run one hadware thread at a same time.</p>
<img src="/004-go-scheduler-2/a.png" alt="a" style="zoom:33%;" /> 
<p>You can see I have a single processor with 4 physical cores. What this report is not exposing is the number of hardware threads I have per physical core. The Intel Core i7 processor has Hyper-Threading, which means there are 2 hardware threads per physical core. This will report to the Go program that 8 virtual cores are available for executing OS Threads in parallel.</p>
<p>To test this, consider the following program:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// NumCPU returns the number of logical
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// CPUs usable by the current process.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">runtime</span><span class="p">.</span><span class="nf">NumCPU</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>When I run this program on my local machine, the result of the <code>NumCPU()</code> function call will be the value of 8. Any Go program I run on my machine will be given 8 P’s.</p>
<p>Every P is assigned an OS Thread (“M”). The ‘M’ stands for machine. This Thread is still managed by the OS and the OS is still responsible for placing the Thread on a Core for execution, as explained in the <a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html">last post</a>. This means when I run a Go program on my machine, I have 8 threads available to execute my work, each individually attached to a P.</p>
<p>Every Go program is also given an initial Goroutine (“G”), which is the path of execution for a Go program. A Goroutine is essentially a Coroutine but this is Go, so we replace the letter “C” with a “G” and we get the word Goroutine. You can think of Goroutines as application-level threads and they are similar to OS Threads in many ways. Just as <strong>OS Threads are context-switched on and off a core, Goroutines are context-switched on and off an M.</strong></p>
<p>The last piece of the puzzle is the <strong>run queues</strong>. There are two different run queues in the Go scheduler: the Global Run Queue (GRQ) and the Local Run Queue (LRQ). <strong>Each P is given a LRQ that manages the Goroutines assigned to be executed within the context of a P</strong>. (这句话也就说明了 多个goroutine映射到一个kernel thread, 减少kernel thread上下文切换的次数.) These Goroutines take turns being context-switched on and off the M assigned to that P. The GRQ is for Goroutines that have not been assigned to a P yet. There is a process to move Goroutines from the GRQ to a LRQ that we will discuss later.</p>
<p>M和P是一一对应的关系, M机器即用来运行Goroutine的,  而P拥有一个runqueue, 这个runqueue里面有多个等待被M执行的goroutine, 在M上只能同时运行一个goroutine, 所以当go scheduler要switch 一个goroutine的时候, 这时候进行goroutine上下文切换, 注意这里不是对kernel thread, 即M进行上下文切换,</p>
<img src="/004-go-scheduler-2/b.png" alt="b" style="zoom:33%;" /> 
<p>根据图可以看出, 一个kernel thread维护一个runqueue, 请参考: <a href="https://youtu.be/YHRO5WQGh0k">https://youtu.be/YHRO5WQGh0k</a></p>
<p>另外的我电脑是芯片是M1, 信息如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Total Number of Cores: 8 (4 performance and 4 efficiency)
</span></span></code></pre></td></tr></table>
</div>
</div><p>执行上面Go程序, 仍为8, 推断M1没有利用Hyper-Threading技术, 这个技术是Intel的, 当然其他制造商也有类似技术,</p>
<h2 id="2-cooperating-scheduler">2. Cooperating scheduler</h2>
<p>As we discussed in the first post, the OS scheduler is a <strong>preemptive scheduler</strong>. Essentially that means you can’t predict what the scheduler is going to do at any given time. The kernel is making decisions and everything is non-deterministic. Applications that run on top of the OS have no control over what is happening inside the kernel with scheduling unless they leverage synchronization primitives like <a href="https://en.wikipedia.org/wiki/Linearizability">atomic</a> instructions and <a href="https://en.wikipedia.org/wiki/Lock_(computer_science)">mutex</a> calls.</p>
<p>The Go scheduler is part of the Go runtime, and the Go runtime is built into your application. This means the Go scheduler runs in <a href="https://en.wikipedia.org/wiki/User_space">user space</a>, above the kernel. The current implementation of the Go scheduler is not a preemptive scheduler but a <a href="https://en.wikipedia.org/wiki/Cooperative_multitasking">cooperating</a> scheduler. Being a cooperating scheduler means the scheduler needs well-defined user space events that happen at safe points in the code to make scheduling decisions.</p>
<p>What’s brilliant about the Go cooperating scheduler is that it looks and feels preemptive. You can’t predict what the Go scheduler is going to do. This is because decision making for this cooperating scheduler doesn’t rest in the hands of developers, but in the Go runtime. It’s important to think of the Go scheduler as a preemptive scheduler and since the scheduler is non-deterministic, this is not much of a stretch.</p>
<h2 id="3-goroutine-states">3. Goroutine states</h2>
<p>Just like Threads, Goroutines have the same three high-level states. These dictate the role the Go scheduler takes with any given Goroutine. A Goroutine can be in one of three states: <em>Waiting</em>, <em>Runnable</em> or <em>Executing</em>.</p>
<p><strong>Waiting</strong>: This means the Goroutine is stopped and waiting for something in order to continue. This could be for reasons like waiting for the operating system (system calls) or synchronization calls (atomic and mutex operations). These types of <a href="https://en.wikipedia.org/wiki/Latency_(engineering)">latencies</a> are a root cause for bad performance.</p>
<p><strong>Runnable</strong>: This means the Goroutine wants time on an M so it can execute its assigned instructions. If you have a lot of Goroutines that want time, then Goroutines have to wait longer to get time. Also, the individual amount of time any given Goroutine gets is shortened as more Goroutines compete for time. This type of scheduling latency can also be a cause of bad performance.</p>
<p><strong>Executing</strong>: This means the Goroutine has been placed on an M and is executing its instructions. The work related to the application is getting done. This is what everyone wants.</p>
<h2 id="4-context-switching">4. Context switching</h2>
<p>The Go scheduler requires well-defined user-space events that occur at safe points in the code to context-switch from. These events and safe points manifest themselves within function calls. Function calls are critical to the health of the Go scheduler. Today (with Go 1.11 or less), if you run any tight loops that are not making function calls, you will cause latencies within the scheduler and garbage collection. It’s critically important that function calls happen within reasonable timeframes.</p>
<p><em>Note: There is a <a href="https://github.com/golang/go/issues/24543">proposal</a> for 1.12 that was accepted to apply non-cooperative preemption techniques inside the Go scheduler to allow for the preemption of tight loops.</em></p>
<p>There are four classes of events that occur in your Go programs that allow the scheduler to make scheduling decisions. This doesn’t mean it will always happen on one of these events. It means the scheduler gets the opportunity.</p>
<ul>
<li>The use of the keyword <code>go</code></li>
<li>Garbage collection</li>
<li>System calls</li>
<li>Synchronization and Orchestration</li>
</ul>
<p><strong>System calls</strong></p>
<p><strong>If a Goroutine makes a system call that will cause the Goroutine to block the M</strong>, sometimes the scheduler is capable of <strong>context-switching the Goroutine off the M</strong> and <strong>context-switch a new Goroutine onto that same M</strong>. However, sometimes a new M is required to keep executing Goroutines that are queued up in the P. How this works will be explained in more detail in the next section.</p>
<p><strong>Synchronization and Orchestration</strong></p>
<p>If an atomic, mutex, or channel operation call will cause the Goroutine to block, the scheduler can context-switch a new Goroutine to run. Once the Goroutine can run again, it can be re-queued and eventually context-switched back on an M.</p>
<h2 id="5-asynchronous-system-calls">5. Asynchronous system calls</h2>
<p>When the OS you are running on has the ability to handle a system call asynchronously, something called the <a href="https://golang.org/src/runtime/netpoll.go">network poller</a> can be used to process the system call more efficiently. This is accomplished by using kqueue (MacOS), epoll (Linux) or iocp (Windows) within these respective OS’s.</p>
<p>Networking-based system calls can be processed asynchronously by many of the OSs we use today. This is where the network poller gets its name, since its primary use is handling networking operations. By using the network poller for networking system calls, the scheduler can prevent Goroutines from blocking the M when those system calls are made. This helps to keep the M available to execute other Goroutines in the P’s LRQ without the need to create new Ms. This helps to reduce scheduling load on the OS.</p>
<p>The best way to see how this works is to run through an example.</p>
<img src="/004-go-scheduler-2/c.png" alt="c" style="zoom:33%;" />
<p>Figure 3 shows our base scheduling diagram. Goroutine-1 is executing on the M and there are 3 more Goroutines waiting in the LRQ to get their time on the M. The network poller is idle with nothing to do.</p>
<img src="/004-go-scheduler-2/d.png" alt="d" style="zoom:33%;" />
<p>In figure 4, Goroutine-1 wants to make a network system call, so Goroutine-1 is moved to the network poller and the asynchronous network system call is processed. Once Goroutine-1 is moved to the network poller, the M is now available to execute a different Goroutine from the LRQ. In this case, Goroutine-2 is context-switched on the M.</p>
<img src="/004-go-scheduler-2/e.png" alt="e" style="zoom:33%;" />
<p>In figure 5, the asynchronous network system call is completed by the network poller and Goroutine-1 is moved back into the LRQ for the P. Once Goroutine-1 can be context-switched back on the M, the Go related code it’s responsible for can execute again. The big win here is that, to execute network system calls, no extra Ms are needed. The network poller has an OS Thread and it is handling an efficient event loop.</p>
<h2 id="6-synchronous-system-calls">6. Synchronous system calls</h2>
<p>What happens when the Goroutine wants to make a system call that can’t be done asynchronously? In this case, the network poller can’t be used and the Goroutine making the system call is going to block the M. This is unfortunate but there’s no way to prevent this from happening. One example of a system call that can’t be made asynchronously is file-based system calls. If you are using CGO, there may be other situations where calling C functions will block the M as well.</p>
<p><em>Note: The Windows OS does have the capability of making file-based system calls asynchronously. Technically when running on Windows, the network poller can be used.</em></p>
<p>Let’s walk through what happens with a synchronous system call (like file I/O) that will cause the M to block.</p>
<img src="/004-go-scheduler-2/f.png" alt="f" style="zoom:33%;" />
<p>Figure 6 is showing our basic scheduling diagram again but this time Goroutine-1 is going to make a synchronous system call that will block M1.</p>
<img src="/004-go-scheduler-2/g.png" alt="g" style="zoom:33%;" />
<p>In figure 7, the scheduler is able to identify that Goroutine-1 has caused the M to block. At this point, the scheduler detaches M1 from the P with the blocking Goroutine-1 still attached. Then the scheduler brings in a new M2 to service the P. At that point, Goroutine-2 can be selected from the LRQ and context-switched on M2. If an M already exists because of a previous swap, this transition is quicker than having to create a new M.</p>
<img src="/004-go-scheduler-2/h.png" alt="h" style="zoom:33%;" />
<p>In figure 8, the blocking system call that was made by Goroutine-1 finishes. At this point, Goroutine-1 can move back into the LRQ and be serviced by the P again. M1 is then placed on the side for future use if this scenario needs to happen again.</p>
<p>到这我们也可以理解为什么说P是连接M和G的桥梁, P维护一个runqueue, 里面存的是等待被M执行G, M执行G时从和他连接的那个P的runqueue里拿G, 至于谁更新P的runqueue, 谁负责把G context switch onto M或者off M, 是P自己呢?还是Go Scheduler负责呢?</p>
<p>这里也注意一下, M 可以被 (OS) contex-switched M off/onto the Core, G可以被 contex-switched M off/onto the M, 至于被谁, 那肯定是Go Scheduler了, 上面提到了: The Go scheduler requires well-defined user-space events that occur at safe points in the code to context-switch from. context-switch谁? 当然是 context-switch G onto/off from M 了,</p>
<p>Source:</p>
<ul>
<li><a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html">Scheduling In Go : Part II - Go Scheduler</a></li>
<li><a href="https://www.youtube.com/watch?v=YHRO5WQGh0k&amp;list=PLn7Fivb51OvJLdfD8KrhgiawFINb94j9X&amp;index=1&amp;t=1416s">GopherCon 2018: Kavya Joshi - The Scheduler Saga</a></li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">David</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2023-05-28
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/golang/">golang</a>
          <a href="/tags/concurrency/">concurrency</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/python/practice/001-add-space/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">用Python脚本给文章中英字符以及符号间加空格</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/golang/advance/003-go-scheduler-1/">
            <span class="next-text nav-default">Go Scheduler (1)</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:shwezhu@qq.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/shwezhu" class="iconfont icon-github" title="github"></a>
  <a href="https://davidzhu.xyz/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2023 - 
    2024<span class="heart"><i class="iconfont icon-heart"></i></span><span>David</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
