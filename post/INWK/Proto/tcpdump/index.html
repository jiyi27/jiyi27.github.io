<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>tcpdump - 课堂笔记 - David&#39;s Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="David" /><meta name="description" content="原文: 4.3 TCP 实战抓包分析 | 小林coding 1. 显形“不可见”的网络包 1.1. tcpdump 和 Wireshark 有什么区别 tcpdump 和 Wireshark 就是最常用的网络抓包和分析工具，更是分析网络性能必不" />






<meta name="generator" content="Hugo 0.111.3 with theme even" />


<link rel="canonical" href="https://shaowenzhu.top/post/inwk/proto/tcpdump/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="tcpdump - 课堂笔记" />
<meta property="og:description" content="原文: 4.3 TCP 实战抓包分析 | 小林coding 1. 显形“不可见”的网络包 1.1. tcpdump 和 Wireshark 有什么区别 tcpdump 和 Wireshark 就是最常用的网络抓包和分析工具，更是分析网络性能必不" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://shaowenzhu.top/post/inwk/proto/tcpdump/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-07-17T23:11:38+00:00" />
<meta property="article:modified_time" content="2023-07-17T23:11:38+00:00" />
<meta itemprop="name" content="tcpdump - 课堂笔记">
<meta itemprop="description" content="原文: 4.3 TCP 实战抓包分析 | 小林coding 1. 显形“不可见”的网络包 1.1. tcpdump 和 Wireshark 有什么区别 tcpdump 和 Wireshark 就是最常用的网络抓包和分析工具，更是分析网络性能必不"><meta itemprop="datePublished" content="2023-07-17T23:11:38+00:00" />
<meta itemprop="dateModified" content="2023-07-17T23:11:38+00:00" />
<meta itemprop="wordCount" content="4464">
<meta itemprop="keywords" content="inwk," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="tcpdump - 课堂笔记"/>
<meta name="twitter:description" content="原文: 4.3 TCP 实战抓包分析 | 小林coding 1. 显形“不可见”的网络包 1.1. tcpdump 和 Wireshark 有什么区别 tcpdump 和 Wireshark 就是最常用的网络抓包和分析工具，更是分析网络性能必不"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">David&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">David&#39;s Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">tcpdump - 课堂笔记</h1>

      <div class="post-meta">
        <span class="post-time"> 2023-07-17 </span>
        <div class="post-category">
            <a href="/categories/inwk/"> inwk </a>
            <a href="/categories/proto/"> proto </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#1-显形不可见的网络包">1. 显形“不可见”的网络包</a>
          <ul>
            <li><a href="#11-tcpdump-和-wireshark-有什么区别">1.1. tcpdump 和 Wireshark 有什么区别</a></li>
            <li><a href="#12-tcpdump-在-linux-下如何抓包">1.2. tcpdump 在 Linux 下如何抓包</a></li>
            <li><a href="#13-wireshark-工具如何分析数据包">1.3. Wireshark 工具如何分析数据包？</a></li>
          </ul>
        </li>
        <li><a href="#2-解密-tcp-三次握手和四次挥手">2. 解密 TCP 三次握手和四次挥手</a>
          <ul>
            <li><a href="#21-为什么三次握手连接过程的-seq-是-0-">2.1. 为什么三次握手连接过程的 Seq 是 0 ？</a></li>
            <li><a href="#22-为什么抓到的-tcp-挥手是三次而不是书上说的四次">2.2. 为什么抓到的 TCP 挥手是三次，而不是书上说的四次？</a></li>
          </ul>
        </li>
        <li><a href="#3-tcp-三次握手异常情况实战分析">3. TCP 三次握手异常情况实战分析</a>
          <ul>
            <li><a href="#31-实验场景">3.1. 实验场景</a></li>
            <li><a href="#32-实验一tcp-第一次握手-syn-丢包">3.2. 实验一：TCP 第一次握手 SYN 丢包</a></li>
            <li><a href="#33-实验一的实验小结">3.3. 实验一的实验小结</a></li>
            <li><a href="#34-实验二tcp-第二次握手-synack-丢包">3.4. 实验二：TCP 第二次握手 SYN、ACK 丢包</a></li>
          </ul>
        </li>
        <li><a href="#4-tcp-重复确认和快速重传">4. TCP 重复确认和快速重传</a></li>
        <li><a href="#5-tcp-流量控制">5. TCP 流量控制</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>原文: <a href="https://www.xiaolincoding.com/network/3_tcp/tcp_tcpdump.html">4.3 TCP 实战抓包分析 | 小林coding</a></p>
<h2 id="1-显形不可见的网络包">1. 显形“不可见”的网络包</h2>
<h3 id="11-tcpdump-和-wireshark-有什么区别">1.1. tcpdump 和 Wireshark 有什么区别</h3>
<p>tcpdump 和 Wireshark 就是最常用的网络抓包和分析工具，更是分析网络性能必不可少的利器。</p>
<ul>
<li>tcpdump 仅支持命令行格式使用，常用在 Linux 服务器中抓取和分析网络包。</li>
<li>Wireshark 除了可以抓包外，还提供了可视化分析网络包的图形页面。</li>
</ul>
<p>所以，这两者实际上是搭配使用的，先用 tcpdump 命令在 Linux 服务器上抓包，接着把抓包的文件拖出到 Windows 电脑后，用 Wireshark 可视化分析。</p>
<p>当然，如果你是在 Windows 上抓包，只需要用 Wireshark 工具就可以。</p>
<h3 id="12-tcpdump-在-linux-下如何抓包">1.2. tcpdump 在 Linux 下如何抓包</h3>
<p>tcpdump 提供了大量的选项以及各式各样的过滤表达式，来帮助你抓取指定的数据包，不过不要担心，只需要掌握一些常用选项和过滤表达式，就可以满足大部分场景的需要了。</p>
<p>假设我们要抓取下面的 ping 的数据包：</p>
<p><img src="1.png" alt="1"></p>
<p>要抓取上面的 ping 命令数据包，首先我们要知道 ping 的数据包是 <code>icmp</code> 协议，接着在使用 tcpdump 抓包的时候，就可以指定只抓 icmp 协议的数据包：</p>
<p><img src="2.png" alt="2"></p>
<p>从 tcpdump 抓取的 icmp 数据包，我们很清楚的看到 <code>icmp echo</code> 的交互过程了，首先发送方发起了 <code>ICMP echo request</code> 请求报文，接收方收到后回了一个 <code>ICMP echo reply</code> 响应报文，之后 <code>seq</code> 是递增的。</p>
<p>我在这里也帮你整理了一些最常见的用法，并且绘制成了表格，你可以参考使用。</p>
<p>首先，先来看看常用的选项类，在上面的 ping 例子中，我们用过 <code>-i</code> 选项指定网口，用过 <code>-nn</code> 选项不对 IP 地址和端口名称解析。其他常用的选项，如下表格：</p>
<p><img src="3.png" alt="3"></p>
<p>接下来，我们再来看看常用的过滤表用法，在上面的 ping 例子中，我们用过的是 <code>icmp and host 183.232.231.174</code>，表示抓取 icmp 协议的数据包，以及源地址或目标地址为 183.232.231.174 的包。其他常用的过滤选项，我也整理成了下面这个表格。</p>
<p><img src="4.png" alt="4"></p>
<p>说了这么多，你应该也发现了，tcpdump 虽然功能强大，但是输出的格式并不直观。</p>
<p>所以，在工作中 tcpdump 只是用来抓取数据包，不用来分析数据包，而是把 tcpdump 抓取的数据包保存成 pcap 后缀的文件，接着用 Wireshark 工具进行数据包分析。</p>
<h3 id="13-wireshark-工具如何分析数据包">1.3. Wireshark 工具如何分析数据包？</h3>
<p>Wireshark 除了可以抓包外，还提供了可视化分析网络包的图形页面，同时，还内置了一系列的汇总分析工具。</p>
<p>比如，拿上面的 ping 例子来说，我们可以使用下面的命令，把抓取的数据包保存到 ping.pcap 文件</p>
<p><img src="5.png" alt="5"></p>
<p>接着把 ping.pcap 文件拖到电脑，再用 Wireshark 打开它。打开后，你就可以看到下面这个界面：</p>
<p><img src="11.png" alt="11"></p>
<p>是吧？在 Wireshark 的页面里，可以更加直观的分析数据包，不仅展示各个网络包的头部信息，还会用不同的颜色来区分不同的协议，由于这次抓包只有 ICMP 协议，所以只有紫色的条目。</p>
<p>接着，在网络包列表中选择某一个网络包后，在其下面的网络包详情中，<strong>可以更清楚的看到，这个网络包在协议栈各层的详细信息</strong>。比如，以编号 1 的网络包为例子：</p>
<p><img src="7.png" alt="7"></p>
<ul>
<li>可以在数据链路层，看到 MAC 包头信息，如源 MAC 地址和目标 MAC 地址等字段；</li>
<li>可以在 IP 层，看到 IP 包头信息，如源 IP 地址和目标 IP 地址、TTL、IP 包长度、协议等 IP 协议各个字段的数值和含义；</li>
<li>可以在 ICMP 层，看到 ICMP 包头信息，比如 Type、Code 等 ICMP 协议各个字段的数值和含义；</li>
</ul>
<p>Wireshark 用了分层的方式，展示了各个层的包头信息，把“不可见”的数据包，清清楚楚的展示了给我们，还有理由学不好计算机网络吗？是不是<strong>相见恨晚</strong>？</p>
<p>从 ping 的例子中，我们可以看到网络分层就像有序的分工，每一层都有自己的责任范围和信息，上层协议完成工作后就交给下一层，最终形成一个完整的网络包。</p>
<p><img src="8.png" alt="8"></p>
<h2 id="2-解密-tcp-三次握手和四次挥手">2. 解密 TCP 三次握手和四次挥手</h2>
<p>既然学会了 tcpdump 和 Wireshark 两大网络分析利器，那我们快马加鞭，接下来用它俩抓取和分析 HTTP 协议网络包，并理解 TCP 三次握手和四次挥手的工作原理。</p>
<p>本次例子，我们将要访问的 <code>http://192.168.3.200</code> 服务端。在终端一用 tcpdump 命令抓取数据包：</p>
<p><img src="10.png" alt="10"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 在我的电脑上用的是(不要忘记筛选条件里的 and)</span>
</span></span><span class="line"><span class="cl">sudo tcpdump -i any tcp and host 192.168.2.15 and port <span class="m">8080</span> -w ~/Downloads/http.pcap
</span></span></code></pre></td></tr></table>
</div>
</div><p>接着，在终端二执行下面的 curl 命令：</p>
<p><img src="11-9783940.png" alt="11"></p>
<p>最后，回到终端一，按下 Ctrl+C 停止 tcpdump，并把得到的 http.pcap 取出到电脑。</p>
<p>使用 Wireshark 打开 http.pcap 后，你就可以在 Wireshark 中，看到如下的界面：</p>
<p><img src="13.png" alt="13"></p>
<p>上面给的例子是理想状态, 我在电脑上开启http服务器, 然后捕捉到的数据如下, 可以看到有重传, duplicate ack 等:</p>
<p><img src="15.png" alt="15"></p>
<p>我们都知道 HTTP 是基于 TCP 协议进行传输的，那么：</p>
<ul>
<li>最开始的 3 个包就是 TCP 三次握手建立连接的包</li>
<li>中间是 HTTP 请求和响应的包</li>
<li>而最后的 3 个包则是 TCP 断开连接的挥手包</li>
</ul>
<p>Wireshark 可以用时序图的方式显示数据包交互的过程，从菜单栏中，点击 统计 (Statistics) -&gt; 流量图 (Flow Graph)，然后，在弹出的界面中的「流量类型」选择 「TCP Flows」，你可以更清晰的看到，整个过程中 TCP 流的执行过程：</p>
<p><img src="14.png" alt="14"></p>
<h3 id="21-为什么三次握手连接过程的-seq-是-0-">2.1. 为什么三次握手连接过程的 Seq 是 0 ？</h3>
<p>实际上是因为 Wireshark 工具帮我们做了优化，它默认显示的是序列号 seq 是相对值，而不是真实值。</p>
<p>如果你想看到实际的序列号的值，可以右键菜单， 然后找到「协议首选项」，接着找到「Relative Seq」后，把它给取消，操作如下：</p>
<p><img src="16.png" alt="16"></p>
<p>取消后，Seq 显示的就是真实值了：</p>
<p><img src="17.png" alt="17"></p>
<p>可见，客户端和服务端的序列号实际上是不同的，序列号是一个随机值。</p>
<p>这其实跟我们书上看到的 TCP 三次握手和四次挥手很类似，作为对比，你通常看到的 TCP 三次握手和四次挥手的流程，基本是这样的</p>
<p><img src="17-9784596.png" alt="17"></p>
<h3 id="22-为什么抓到的-tcp-挥手是三次而不是书上说的四次">2.2. 为什么抓到的 TCP 挥手是三次，而不是书上说的四次？</h3>
<p>当被动关闭方（上图的服务端）在 TCP 挥手过程中，「<strong>没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></p>
<p>而通常情况下，服务器端收到客户端的 <code>FIN</code> 后，很可能还没发送完数据，所以就会先回复客户端一个 <code>ACK</code> 包，稍等一会儿，完成所有数据包的发送后，才会发送 <code>FIN</code> 包，这也就是四次挥手了。</p>
<h2 id="3-tcp-三次握手异常情况实战分析">3. TCP 三次握手异常情况实战分析</h2>
<p>TCP 三次握手的过程相信大家都背的滚瓜烂熟，那么你有没有想过这三个异常情况：</p>
<ul>
<li><strong>TCP 第一次握手的 SYN 丢包了，会发生了什么？</strong></li>
<li><strong>TCP 第二次握手的 SYN、ACK 丢包了，会发生什么？</strong></li>
<li><strong>TCP 第三次握手的 ACK 包丢了，会发生什么？</strong></li>
</ul>
<p>有的小伙伴可能说：“很简单呀，包丢了就会重传嘛。”</p>
<p>那我在继续问你：</p>
<ul>
<li>那会重传几次？</li>
<li>超时重传的时间 RTO 会如何变化？</li>
<li>在 Linux 下如何设置重传次数？</li>
<li>&hellip;.</li>
</ul>
<p>是不是哑口无言，无法回答？</p>
<p>不知道没关系，接下里我用三个实验案例，带大家一起探究探究这三种异常。</p>
<h3 id="31-实验场景">3.1. 实验场景</h3>
<p>本次实验用了两台虚拟机，一台作为服务端，一台作为客户端，它们的关系如下：</p>
<p><img src="18.png" alt="18"></p>
<h3 id="32-实验一tcp-第一次握手-syn-丢包">3.2. 实验一：TCP 第一次握手 SYN 丢包</h3>
<p>为了模拟 TCP 第一次握手 SYN 丢包的情况，我是在拔掉服务器的网线后，立刻在客户端执行 curl 命令：</p>
<p><img src="001.png" alt="001"></p>
<p>其间 tcpdump 抓包的命令如下：</p>
<p><img src="002.png" alt="002"></p>
<p>过了一会， curl 返回了超时连接的错误：</p>
<p><img src="003.png" alt="003"></p>
<p>从 <code>date</code> 返回的时间，可以发现在超时接近 1 分钟的时间后，curl 返回了错误。</p>
<p>接着，把 tcp_sys_timeout.pcap 文件用 Wireshark 打开分析，显示如下图：</p>
<p><img src="004.png" alt="004"></p>
<p>从上图可以发现， 客户端发起了 SYN 包后，一直没有收到服务端的 ACK ，所以一直超时重传了 5 次，并且每次 RTO 超时时间是不同的：</p>
<ul>
<li>第一次是在 1 秒超时重传</li>
<li>第二次是在 3 秒超时重传</li>
<li>第三次是在 7 秒超时重传</li>
<li>第四次是在 15 秒超时重传</li>
<li>第五次是在 31 秒超时重传</li>
</ul>
<p>可以发现，每次超时时间 RTO 是<strong>指数（翻倍）上涨的</strong>，当超过最大重传次数后，客户端不再发送 SYN 包。</p>
<p>在 Linux 中，第一次握手的 <code>SYN</code> 超时重传次数，是如下内核参数指定的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ cat /proc/sys/net/ipv4/tcp_syn_retries
</span></span><span class="line"><span class="cl"><span class="m">5</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>tcp_syn_retries</code> 默认值为 5，也就是 SYN 最大重传次数是 5 次。</p>
<p>接下来，我们继续做实验，把 <code>tcp_syn_retries</code> 设置为 2 次：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ <span class="nb">echo</span> <span class="m">2</span> &gt; /proc/sys/net/ipv4/tcp_syn_retries
</span></span></code></pre></td></tr></table>
</div>
</div><p>重传抓包后，用 Wireshark 打开分析，显示如下图：</p>
<p><img src="005.png" alt="005"></p>
<h3 id="33-实验一的实验小结">3.3. 实验一的实验小结</h3>
<p>通过实验一的实验结果，我们可以得知，当客户端发起的 TCP 第一次握手 SYN 包，在超时时间内没收到服务端的 ACK，就会在超时重传 SYN 数据包，每次超时重传的 RTO 是翻倍上涨的，直到 SYN 包的重传次数到达 <code>tcp_syn_retries</code> 值后，客户端不再发送 SYN 包。</p>
<p><img src="27.webp" alt="27"></p>
<h3 id="34-实验二tcp-第二次握手-synack-丢包">3.4. 实验二：TCP 第二次握手 SYN、ACK 丢包</h3>
<p>为了模拟客户端收不到服务端第二次握手 SYN、ACK 包，我的做法是在客户端加上防火墙限制，直接粗暴的把来自服务端的数据都丢弃，防火墙的配置如下：</p>
<p><img src="007.png" alt="007"></p>
<p>接着，在客户端执行 curl 命令：</p>
<p><img src="008.png" alt="008"></p>
<p>从 <code>date</code> 返回的时间前后，可以算出大概 1 分钟后，curl 报错退出了。</p>
<p>客户端在这其间抓取的数据包，用 Wireshark 打开分析，显示的时序图如下：</p>
<p><img src="009.png" alt="009"></p>
<p>从图中可以发现：</p>
<ul>
<li>客户端发起 SYN 后，由于防火墙屏蔽了服务端的所有数据包，所以 curl 是无法收到服务端的 SYN、ACK 包，当发生超时后，就会重传 SYN 包</li>
<li>服务端收到客户的 SYN 包后，就会回 SYN、ACK 包，但是客户端一直没有回 ACK，服务端在超时后，重传了 SYN、ACK 包，<strong>接着一会，客户端超时重传的 SYN 包又抵达了服务端，服务端收到后，然后回了 SYN、ACK 包，但是SYN、ACK包的重传定时器并没有重置，还持续在重传，因为第二次握手在没收到第三次握手的 ACK 确认报文时，会继续重传，直到达到重传到最大次数。</strong></li>
<li>最后，客户端 SYN 超时重传次数达到了 5 次（tcp_syn_retries 默认值 5 次），就不再继续发送 SYN 包了。</li>
</ul>
<p>所以，我们可以发现，<strong>当第二次握手的 SYN、ACK 丢包时，客户端会超时重发 SYN 包，服务端也会超时重传 SYN、ACK 包。</strong></p>
<blockquote>
<p>咦？客户端设置了防火墙，屏蔽了服务端的网络包，为什么 tcpdump 还能抓到服务端的网络包？</p>
</blockquote>
<p>添加 iptables 限制后， tcpdump 是否能抓到包 ，这要看添加的 iptables 限制条件：</p>
<ul>
<li>如果添加的是 <code>INPUT</code> 规则，则可以抓得到包</li>
<li>如果添加的是 <code>OUTPUT</code> 规则，则抓不到包</li>
</ul>
<p>网络包进入主机后的顺序如下：</p>
<ul>
<li>进来的顺序 Wire -&gt; NIC -&gt; <strong>tcpdump -&gt; netfilter/iptables</strong></li>
<li>出去的顺序 <strong>iptables -&gt; tcpdump</strong> -&gt; NIC -&gt; Wire</li>
</ul>
<h2 id="4-tcp-重复确认和快速重传">4. TCP 重复确认和快速重传</h2>
<p>当接收方收到乱序数据包时，会发送重复的 ACK，以便告知发送方要重发该数据包，<strong>当发送方收到 3 个重复 ACK 时，就会触发快速重传，立刻重发丢失数据包。</strong></p>
<p><img src="22.png" alt="22"></p>
<p>TCP 重复确认和快速重传的一个案例，用 Wireshark 分析，显示如下：</p>
<p><img src="23.png" alt="23"></p>
<ul>
<li>数据包 1 期望的下一个数据包 Seq 是 1，但是数据包 2 发送的 Seq 却是 10945，说明收到的是乱序数据包，于是回了数据包 3 ，还是同样的 Seq = 1，Ack = 1，这表明是重复的 ACK；</li>
<li>数据包 4 和 6 依然是乱序的数据包，于是依然回了重复的 ACK；</li>
<li>当对方收到三次重复的 ACK 后，于是就快速重传了 Seq = 1 、Len = 1368 的数据包 8；</li>
<li>当收到重传的数据包后，发现 Seq = 1 是期望的数据包，于是就发送了个确认收到快速重传的 ACK</li>
</ul>
<p>注意：快速重传和重复 ACK 标记信息是 Wireshark 的功能，非数据包本身的信息。</p>
<p>以上案例在 TCP 三次握手时协商开启了<strong>选择性确认 SACK</strong>，因此一旦数据包丢失并收到重复 ACK ，即使在丢失数据包之后还成功接收了其他数据包，也只需要重传丢失的数据包。如果不启用 SACK，就必须重传丢失包之后的每个数据包。</p>
<p>如果要支持 <code>SACK</code>，必须双方都要支持。在 Linux 下，可以通过 <code>net.ipv4.tcp_sack</code> 参数打开这个功能（Linux 2.4 后默认打开）。</p>
<h2 id="5-tcp-流量控制">5. TCP 流量控制</h2>
<p>TCP 为了防止发送方无脑的发送数据，导致接收方缓冲区被填满，所以就有了滑动窗口的机制，它可利用接收方的接收窗口来控制发送方要发送的数据量，也就是流量控制。</p>
<p>接收窗口是由接收方指定的值，存储在 TCP 头部中，它可以告诉发送方自己的 TCP 缓冲空间区大小，这个缓冲区是给应用程序读取数据的空间：</p>
<ul>
<li>如果应用程序读取了缓冲区的数据，那么缓冲空间区就会把被读取的数据移除</li>
<li>如果应用程序没有读取数据，则数据会一直滞留在缓冲区。</li>
</ul>
<p>接收窗口的大小，是在 TCP 三次握手中协商好的，后续数据传输时，接收方发送确认应答 ACK 报文时，会携带当前的接收窗口的大小，以此来告知发送方。</p>
<p>假设接收方接收到数据后，应用层能很快的从缓冲区里读取数据，那么窗口大小会一直保持不变，过程如下：</p>
<p><img src="24.png" alt="24"></p>
<p>但是现实中服务器会出现繁忙的情况，当应用程序读取速度慢，那么缓存空间会慢慢被占满，于是为了保证发送方发送的数据不会超过缓冲区大小，服务器则会调整窗口大小的值，接着通过 ACK 报文通知给对方，告知现在的接收窗口大小，从而控制发送方发送的数据大小。</p>
<p><img src="50.webp" alt="50"></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">David</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2023-07-17
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/inwk/">inwk</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/inwk/proto/tcp/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">TCP 4 Way Handshake - 课堂笔记</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/other/006-english-reading-1/">
            <span class="next-text nav-default">英语阅读(一)</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:shwezhu@qq.com" class="iconfont icon-email" title="email"></a>
      <a href="https://twitter.com/shwezhu" class="iconfont icon-twitter" title="twitter"></a>
      <a href="http://localhost:1313" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="https://github.com/shwezhu" class="iconfont icon-github" title="github"></a>
  <a href="https://shaowenzhu.top/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2023<span class="heart"><i class="iconfont icon-heart"></i></span><span>David</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
