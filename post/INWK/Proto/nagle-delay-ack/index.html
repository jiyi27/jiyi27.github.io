<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Nagle算法和延迟ack - 课堂笔记 - David&#39;s Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="David" /><meta name="description" content="原文: 深入浅出TCPIP之Nagle算法-腾讯云开发者社区-腾讯云 TCP的数据流大致可以分为两类，交互数据流与成块的数据流。交互数据流就是发" />






<meta name="generator" content="Hugo 0.111.3 with theme even" />


<link rel="canonical" href="https://shaowenzhu.top/post/inwk/proto/nagle-delay-ack/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Nagle算法和延迟ack - 课堂笔记" />
<meta property="og:description" content="原文: 深入浅出TCPIP之Nagle算法-腾讯云开发者社区-腾讯云 TCP的数据流大致可以分为两类，交互数据流与成块的数据流。交互数据流就是发" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://shaowenzhu.top/post/inwk/proto/nagle-delay-ack/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-07-22T19:46:40+00:00" />
<meta property="article:modified_time" content="2023-07-22T19:46:40+00:00" />
<meta itemprop="name" content="Nagle算法和延迟ack - 课堂笔记">
<meta itemprop="description" content="原文: 深入浅出TCPIP之Nagle算法-腾讯云开发者社区-腾讯云 TCP的数据流大致可以分为两类，交互数据流与成块的数据流。交互数据流就是发"><meta itemprop="datePublished" content="2023-07-22T19:46:40+00:00" />
<meta itemprop="dateModified" content="2023-07-22T19:46:40+00:00" />
<meta itemprop="wordCount" content="2696">
<meta itemprop="keywords" content="inwk," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Nagle算法和延迟ack - 课堂笔记"/>
<meta name="twitter:description" content="原文: 深入浅出TCPIP之Nagle算法-腾讯云开发者社区-腾讯云 TCP的数据流大致可以分为两类，交互数据流与成块的数据流。交互数据流就是发"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">David&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">David&#39;s Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Nagle算法和延迟ack - 课堂笔记</h1>

      <div class="post-meta">
        <span class="post-time"> 2023-07-22 </span>
        <div class="post-category">
            <a href="/categories/inwk/"> inwk </a>
            <a href="/categories/proto/"> proto </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#nagle算法分析">Nagle算法分析</a></li>
        <li><a href="#延迟确认机制tcp-delayed-acknowledgment">延迟确认机制（TCP delayed acknowledgment）</a></li>
        <li><a href="#当nagle算法遇到delayed-ack">当Nagle算法遇到Delayed ACK</a></li>
        <li><a href="#应用场景">应用场景：</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>原文: <a href="https://cloud.tencent.com/developer/article/1784570">深入浅出TCPIP之Nagle算法-腾讯云开发者社区-腾讯云</a></p>
<p>TCP的数据流大致可以分为两类，交互数据流与成块的数据流。交互数据流就是发送控制命令的数据流，比如relogin，telnet，ftp命令等等；成块数据流是用来发送数据的包，网络上大部分的TCP包都是这种包。</p>
<p>很明显，TCP在传输这两种类型的包时的效率是不一样的，因此为了提高TCP的传输效率，应该对这两种类型的包采用不同的算法。</p>
<p>总之，TCP的传输原则是尽量减少小分组传输的数量。</p>
<h2 id="nagle算法分析">Nagle算法分析</h2>
<p>Nagle算法主要用来预防小分组的产生。在广域网上，大量TCP小分组极有可能造成网络的拥塞。</p>
<p>Nagle时针对每一个TCP连接的。它要求一个TCP连接上最多只能有一个未被确认的小分组。在改分组的确认到达之前不能发送其他小分组。TCP会搜集这些小的分组，然后在之前小分组的确认到达后将刚才搜集的小分组合并发送出去。</p>
<p>有时候我们必须要关闭Nagle算法，特别是在一些对时延要求较高的交互式操作环境中，所有的小分组必须尽快发送出去。</p>
<p>我们可以通过编程取消Nagle算法，利用TCP_NODELAY选项来关闭Nagle算法。</p>
<p>来看看Nagle大致的逻辑：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">if 有数据要发送：
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">if 可用窗口大小 &gt;= MSS and 可发送的数据 &gt;= MSS：
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">立刻发送MSS大小的数据
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">else ：
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">if 有未确认的数据：
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">将数据放入缓存等待接收ACK
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">else：
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">立刻发送数据
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过上面的逻辑可以看到，如果是大量数据需要发送，大部分情况都可以填满一个MSS（也就不存在&quot;小包&quot;的问题），是不需要等待一个未确认包的。</p>
<p>Nagle算法是时代的产物，因为当时网络带宽有限。而当前的局域网、广域网的带宽则宽裕得多，所以目前的TCP/IP协议栈默认将Nagle算法关闭</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// 1打开nagle算法，为0禁用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">long</span> <span class="n">noDelay</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">setsockopt</span><span class="p">(</span><span class="n">m_hSocket</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">,</span> <span class="n">TCP_NODELAY</span><span class="p">,(</span><span class="n">LPSTR</span><span class="p">)</span><span class="o">&amp;</span><span class="n">noDelay</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="延迟确认机制tcp-delayed-acknowledgment">延迟确认机制（TCP delayed acknowledgment）</h2>
<p>wiki的解释https://en.wikipedia.org/wiki/TCP_delayed_acknowledgment</p>
<p>1989 RFC 1122定义，全名Delayed Acknowledgment，简称延迟ACK，翻译为<em>延迟确认。</em></p>
<p>与Nagle算法一样，延迟ACK的目的也是为了减少网络中传输大量的小报文数，但该报文数是针对ACK报文的。</p>
<p>一个来自发送端的报文到达接收端，TCP会延迟ACK的发送，希望应用程序会对刚刚收到的数据进行应答，这样就可以用新数据将ACK捎带过去。</p>
<h2 id="当nagle算法遇到delayed-ack">当Nagle算法遇到Delayed ACK</h2>
<p>在一个有数据传输的TCP连接中，如果只有数据发送方启用Nagle算法，在其连续发送多个小报文时，Nagle算法机制会减少网络中的小报文数量。这就意味着，同样传输相同大小的应用数据，在网络上的报文个数却不同。</p>
<p>举个例子，发送端需要连续发送5个写操作（应用程序将数据写入到缓冲池的动作）的小报文，<em>首先发送第一个，由于Nagle算法的作用，在未收到第一个报文确认前，发送端在等待写操作的同时进行读操作，接收端并未启用延迟确认（视TCP delay ACK时间为0），尽管刚收到该报文就发出确认，但由于网络延时的原因，在收集齐另外4个小报文后，发送方才收到了第一个报文的ACK，则后面的4个报文会一起发送出去（大小未超过MSS），接收端再次ACK。</em></p>
<p><img src="1.png" alt="1"></p>
<p>在上述发送5个小报文的过程中，只用了4个报文就实现了。但如果发送端未启用Nagle算法，完成整个过程则至少需要8个报文或10个报文才能实现，这里接收端未启用延迟确认，如下图所示。启用Nagle算法和未启用Nagle算法的场景中，从完成数据发送的时间来看，未启用Nagle算法的方式花费的时间会更长一些，如下图所示。这里基本看到了Nagle算法的好处了。</p>
<p><img src="2.png" alt="2"></p>
<p>还是上述数据传输场景，*发送端未启用Nagle算法，但接收端延迟确认默认时间为200ms，来看看这时的情况。RFC 1122规定，Delayed ACK对单个的小报文可以延长确认的时间，但不允许有两个连续的小报文不被确认。所以，当发送端连续发送两个报文后，接收端必须给予确认。*这时的数据传输情况如下图，只有当第5个报文到达后，接收端由于延迟确认机制，会导致200ms的延时存在。</p>
<p><img src="3.png" alt="3"></p>
<p><em>接下来看看，当Nagle算法遇到Delayed ACK时会是什么情况。按照常理推断，两种深思熟虑的功能设计，应该是1+1&gt;2的效果。具体如何，还是请事实说话。</em></p>
<p>先继续看上面的假设场景，该场景要求发送端向接收端发送5个连续的写操作数据，但网络延时较大，同时发送端启用Nagle算法，接收端Delayed ACK默认为200ms。</p>
<p>发送方先发出一个小报文，接收端收到后，由于延迟确认的机制，等待发送方的下一个报文到达。而发送方由于Nagle算法机制，在未接收到第一个报文的确认前，不会发送已读取到的报文。 在这种场景下，暂不考虑应用处理时间，完成整个数据传输所需时间为2RTT+400ms，貌似情况不是特别糟糕。</p>
<p><img src="4.png" alt="4"></p>
<p>如果上述其他条件不变，发送方应用写操作延时稍微变大，或发送端的应用操作延时稍大，我们再看看，完成这个操作的延时情况。</p>
<p>发送方先发出一个小报文，接收端收到后，由于延迟确认的机制，等待发送方的下一个报文到达。由于发送方应用数据写操作延时较大，在经过RTT+200ms后，读取到了下一个需要发送的内容，此时接收到了第一个报文的确认，而网络中未有没被确认的报文，发送方需要再将第二个小报文发送出去，以此类推，直到最后一个小报文被发送，且接收到该报文的确认，此时整个数据传输过程完成。</p>
<p>在这种情景下，完成整个数据传输所需时间则为5RTT+5*200ms，明显增大了不少。如果相同情境下，有成千上万的小报文发送，则整体使用时间相当可观了。</p>
<p><img src="5.png" alt="5"></p>
<p>在实际情况下，如果发送方程序做了一系列的写、写、读操作的现象，这样的操作都会触发Nagle和延迟ACK算法之间的交互作用，应该尽量避免。</p>
<h2 id="应用场景">应用场景：</h2>
<p>1.对于实时性要求很高的交互上，我们不能使用nagle算法，比如FPS射击类PVP对抗类游戏，或者MMO类的对实时要求很高的游戏开发来说是显而易见需要禁掉的，因为假如玩家的一次移动，或者状态同步到<a href="https://cloud.tencent.com/product/cvm?from_column=20420&amp;from=20420">服务器</a>，加上协议头，包体不会太大，如果使用Nagle算法，后果将是，客户端本来完成一次射击动作，或者释放技能的动作却因为此算法，因为发送包体较小，被放置到缓冲区，等其他包到达可发送了才一起发送到服务器端，那么你不坑队友，还能有谁你？</p>
<p>2.对于发送接收的业务，但是每次发送的包体又是很小的，对于业务的实时性不是非常强的，我们可以使用nagle算法，将小包组成大包统一发送，减少交互次数。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">David</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2023-07-22
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/inwk/">inwk</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/java/basics/how-jvm-find-class/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">手动编译运行Java程序之JVM加载类的顺序</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/inwk/proto/tcp/">
            <span class="next-text nav-default">TCP 4 Way Handshake - 课堂笔记</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:shwezhu@qq.com" class="iconfont icon-email" title="email"></a>
      <a href="https://twitter.com/shwezhu" class="iconfont icon-twitter" title="twitter"></a>
      <a href="http://localhost:1313" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="https://github.com/shwezhu" class="iconfont icon-github" title="github"></a>
  <a href="https://shaowenzhu.top/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2023<span class="heart"><i class="iconfont icon-heart"></i></span><span>David</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
