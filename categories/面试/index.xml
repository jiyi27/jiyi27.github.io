<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>面试 on 为霜的博客</title>
    <link>https://blog.jiyi27.com/categories/%E9%9D%A2%E8%AF%95/</link>
    <description>Recent content in 面试 on 为霜的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 26 Apr 2025 17:15:56 +0000</lastBuildDate><atom:link href="https://blog.jiyi27.com/categories/%E9%9D%A2%E8%AF%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>解释大名鼎鼎的 B&#43; Tree</title>
      <link>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/009-b&#43;-tree/</link>
      <pubDate>Sat, 26 Apr 2025 17:15:56 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/009-b&#43;-tree/</guid>
      <description>&lt;h2 id=&#34;1-节点-键值-指针-是什么&#34;&gt;1. 节点 键值 指针 是什么&lt;/h2&gt;
&lt;p&gt;好奇 B+ Tree 接近 O(1) 是怎么做到的, 不应该是 像二叉搜索树那样的 就是 &lt;code&gt;lgn&lt;/code&gt; 吗, 如果高度很低, 横向数据就很多吧, 不也是需要遍历, 单是横向数据这不就是 &lt;code&gt;O(n) &lt;/code&gt;了吗?&lt;/p&gt;
&lt;p&gt;想要了解这些问题, 还是需要了解一下 B+ Tree 的结构&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;术语&lt;/th&gt;
          &lt;th&gt;含义&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;节点 (Node)&lt;/td&gt;
          &lt;td&gt;磁盘页 (默认 16 KB)，在 B+ 树层次结构中的一个元素&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;非叶子节点 (Internal / Branch page)&lt;/td&gt;
          &lt;td&gt;存放&lt;strong&gt;键值 + 子页指针&lt;/strong&gt;，负责导航&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;叶子节点 (Leaf page)&lt;/td&gt;
          &lt;td&gt;1) 聚簇索引：存放&lt;strong&gt;键值 + 整行数据&lt;/strong&gt; 2) 二级索引：存放&lt;strong&gt;键值 + 主键值&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;指针&lt;/td&gt;
          &lt;td&gt;在磁盘实现里是“页号 + 槽号”或 RowID；在逻辑图中可视作“去哪个子节点”&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;键值 (Key)&lt;/td&gt;
          &lt;td&gt;用来比较、决定走哪条路径的字段值&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;一个节点可以存多个数据, 并不是一个节点只能存一个数据, 非叶子节点, 叶子节点都是这样, 比如下面的描述:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个聚簇索引的叶子节点可以存 200 行数据&lt;/li&gt;
&lt;li&gt;一个二级索引的叶子节点可以存 200 个主键&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就是说一个节点可以存多个数据, 只是节点种类不同, 索引种类不同(聚簇索引, 二级索引), 存储的数据是不一样的:&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-节点-键值-指针-是什么&#34;&gt;1. 节点 键值 指针 是什么&lt;/h2&gt;
&lt;p&gt;好奇 B+ Tree 接近 O(1) 是怎么做到的, 不应该是 像二叉搜索树那样的 就是 &lt;code&gt;lgn&lt;/code&gt; 吗, 如果高度很低, 横向数据就很多吧, 不也是需要遍历, 单是横向数据这不就是 &lt;code&gt;O(n) &lt;/code&gt;了吗?&lt;/p&gt;
&lt;p&gt;想要了解这些问题, 还是需要了解一下 B+ Tree 的结构&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;术语&lt;/th&gt;
          &lt;th&gt;含义&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;节点 (Node)&lt;/td&gt;
          &lt;td&gt;磁盘页 (默认 16 KB)，在 B+ 树层次结构中的一个元素&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;非叶子节点 (Internal / Branch page)&lt;/td&gt;
          &lt;td&gt;存放&lt;strong&gt;键值 + 子页指针&lt;/strong&gt;，负责导航&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;叶子节点 (Leaf page)&lt;/td&gt;
          &lt;td&gt;1) 聚簇索引：存放&lt;strong&gt;键值 + 整行数据&lt;/strong&gt; 2) 二级索引：存放&lt;strong&gt;键值 + 主键值&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;指针&lt;/td&gt;
          &lt;td&gt;在磁盘实现里是“页号 + 槽号”或 RowID；在逻辑图中可视作“去哪个子节点”&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;键值 (Key)&lt;/td&gt;
          &lt;td&gt;用来比较、决定走哪条路径的字段值&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;一个节点可以存多个数据, 并不是一个节点只能存一个数据, 非叶子节点, 叶子节点都是这样, 比如下面的描述:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个聚簇索引的叶子节点可以存 200 行数据&lt;/li&gt;
&lt;li&gt;一个二级索引的叶子节点可以存 200 个主键&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就是说一个节点可以存多个数据, 只是节点种类不同, 索引种类不同(聚簇索引, 二级索引), 存储的数据是不一样的:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无论聚簇索引还是二级索引, 非叶子节点存的都是 多个指针 + 多个键值
&lt;ul&gt;
&lt;li&gt;键值用来与要查询的条件 (比如 id, name) 比较接下来 (下一层) 去哪个指针找下一个节点&lt;/li&gt;
&lt;li&gt;指针用来指向子节点 (子页) 的位置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;叶子节点就有所不同了
&lt;ul&gt;
&lt;li&gt;聚簇索引的叶子节点存储的是 &lt;strong&gt;键值 + 整行数据&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;二级索引存放&lt;strong&gt;键值 + 主键值&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意哪个列的索引, 对应的 B+ Tree 的节点的键值类型, 就是那个列的类型, 比如 &lt;code&gt;name&lt;/code&gt; 对应的索引 B+ Tree 每个节点的多个键值的类型肯定是 &lt;code&gt;name&lt;/code&gt;, 而聚簇索引是根据 id 建立的 B+ Tree, 所以每个非叶子节点 存的是很多个 id + 指针 这样的数据, 此时 id 是键值:&lt;/p&gt;
&lt;p&gt;所以上面我们说: &lt;em&gt;键值用来与要查询的条件 (比如 id, name) 比较接下来 (下一层) 去哪个指针找下一个节点&lt;/em&gt;, 现在可以理解了吧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-详细结构介绍&#34;&gt;2. 详细结构介绍&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;叶子节点&lt;/strong&gt;：存储所有键值和数据, 并通过&lt;strong&gt;双向链表&lt;/strong&gt;连接, 便于范围查询&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非叶子节点&lt;/strong&gt;：由&amp;quot;键值&amp;quot;和&amp;quot;指针&amp;quot;组成, 用于导航, &lt;strong&gt;不存储实际数据&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;键值(Key)&lt;/strong&gt;: 用于比较和决策的值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;指针(Pointer)&lt;/strong&gt;: 指向下一层节点的地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在一个非叶子节点中, 指针的数量总是比键值的数量多1个, 每个指针指向下一层的一个节点, 非叶子节点在物理结构上是一个连续的数据区域, 其中键值和指针是按特定顺序交替排列的:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[指针P1] [键值K1] [指针P2] [键值K2] [指针P3]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其实指针笔键值多一个很好理解, 比如一个节点有 3 个键值 010, 020, 030, 那数据就有四个范围:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;x &amp;lt; 010&lt;/li&gt;
&lt;li&gt;010 &amp;lt;= x &amp;lt; 020&lt;/li&gt;
&lt;li&gt;020 &amp;lt;= x &amp;lt; 030&lt;/li&gt;
&lt;li&gt;030 &amp;lt;= x&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以需要四个指针来指明 x 在哪个节点上, 通过实际例子解释一下 聚簇索引 B+ Tree 的结构&lt;/p&gt;
&lt;h3 id=&#34;22-primary-key-聚簇索引结构&#34;&gt;2.2. PRIMARY KEY 聚簇索引结构&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;id&lt;/th&gt;
          &lt;th&gt;name&lt;/th&gt;
          &lt;th&gt;age&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;Alice&lt;/td&gt;
          &lt;td&gt;23&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;Bob&lt;/td&gt;
          &lt;td&gt;31&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;Cindy&lt;/td&gt;
          &lt;td&gt;27&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;David&lt;/td&gt;
          &lt;td&gt;35&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;Emma&lt;/td&gt;
          &lt;td&gt;22&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;6&lt;/td&gt;
          &lt;td&gt;Frank&lt;/td&gt;
          &lt;td&gt;28&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;7&lt;/td&gt;
          &lt;td&gt;Grace&lt;/td&gt;
          &lt;td&gt;30&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;8&lt;/td&gt;
          &lt;td&gt;Helen&lt;/td&gt;
          &lt;td&gt;26&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;9&lt;/td&gt;
          &lt;td&gt;Iris&lt;/td&gt;
          &lt;td&gt;24&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;10&lt;/td&gt;
          &lt;td&gt;Jack&lt;/td&gt;
          &lt;td&gt;29&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;假设每个页能装 4 行记录（仅用于示意）:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;                 (Root, non-leaf page)
                 +------------------+
                 | key=5 | ptr(P2)  |
ptr(P1)----------| key=9 | ptr(P3)  |
                 +------------------+
                    /         \
         +--------------+   +--------------+
         | leaf page P1 |   | leaf page P2 |    ……
         +--------------+   +--------------+
&lt;/code&gt;&lt;/pre&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;页号&lt;/th&gt;
          &lt;th&gt;类型&lt;/th&gt;
          &lt;th&gt;内容 (简化后的顺序存储)&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;P1&lt;/td&gt;
          &lt;td&gt;叶子&lt;/td&gt;
          &lt;td&gt;(1,Alice,23) (2,Bob,31) (3,Cindy,27) (4,David,35)&lt;/td&gt;
          &lt;td&gt;键≤5&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;P2&lt;/td&gt;
          &lt;td&gt;叶子&lt;/td&gt;
          &lt;td&gt;(5,Emma,22) (6,Frank,28) (7,Grace,30) (8,Helen,26)&lt;/td&gt;
          &lt;td&gt;5&amp;lt;键≤9&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;P3&lt;/td&gt;
          &lt;td&gt;叶子&lt;/td&gt;
          &lt;td&gt;(9,Iris,24) (10,Jack,29)&lt;/td&gt;
          &lt;td&gt;键&amp;gt;9&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Root&lt;/td&gt;
          &lt;td&gt;非叶子&lt;/td&gt;
          &lt;td&gt;key=5 →P2, key=9 →P3&lt;/td&gt;
          &lt;td&gt;P1 通过最左指针隐式链接&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;解释&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;非叶子节点 Root 里只保存分隔点 key=5、key=9 以及指向子页的指针&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;叶子节点 P1/P2/P3 按主键顺序链表相连，保存 “键值 + 整行”&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查询 &lt;code&gt;SELECT * FROM users WHERE id = 7;&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;从 Root 读取, 7 &amp;gt; 5 走 ptr(P2)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;P2 里二分查找, 定位记录 (7,Grace,30)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接返回整行, 因为行数据就在叶子&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;聚簇索引和非聚簇索引的结构一样, 只是叶子节点存储的内容不一样, 前者存 键值 + 对应的一整行数据, 后者存 键值 + 主键值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;22-二级索引-idx_name-结构&#34;&gt;2.2. 二级索引 idx_name 结构&lt;/h3&gt;
&lt;p&gt;假设每个页能装 4 行记录（仅用于示意）：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;             (Root, non-leaf)
             +--------------------+
             | key=Bob | ptr(S2)  |
ptr(S1)------| key=Helen| ptr(S3) |
             +--------------------+
&lt;/code&gt;&lt;/pre&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;页号&lt;/th&gt;
          &lt;th&gt;类型&lt;/th&gt;
          &lt;th&gt;内容&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;S1&lt;/td&gt;
          &lt;td&gt;叶子&lt;/td&gt;
          &lt;td&gt;(Alice,1) (Bob,2) (Cindy,3) (David,4)&lt;/td&gt;
          &lt;td&gt;键 &amp;lt; Bob&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;S2&lt;/td&gt;
          &lt;td&gt;叶子&lt;/td&gt;
          &lt;td&gt;(Emma,5) (Frank,6) (Grace,7) (Helen,8)&lt;/td&gt;
          &lt;td&gt;Bob ≤ 键 &amp;lt; Helen&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;S3&lt;/td&gt;
          &lt;td&gt;叶子&lt;/td&gt;
          &lt;td&gt;(Iris,9) (Jack,10)&lt;/td&gt;
          &lt;td&gt;键 ≥ Helen&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Root&lt;/td&gt;
          &lt;td&gt;非叶子&lt;/td&gt;
          &lt;td&gt;key=Bob →S2, key=Helen →S3&lt;/td&gt;
          &lt;td&gt;S1 通过最左指针隐式链接&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;查询 &lt;code&gt;SELECT age FROM users WHERE name = &#39;Grace&#39;;&lt;/code&gt; 步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从 idx_name.Root 读，&amp;lsquo;Grace&amp;rsquo; &amp;gt; &amp;lsquo;Bob&amp;rsquo; 且 &amp;lt; &amp;lsquo;Helen&amp;rsquo; 走 S2&lt;/li&gt;
&lt;li&gt;在 S2 找到条目 (&amp;lsquo;Grace&amp;rsquo;, 7)&lt;/li&gt;
&lt;li&gt;拿到主键 id=7，用它去聚簇索引 Root，再走 P2，然后定位 (7,Grace,30)&lt;/li&gt;
&lt;li&gt;取出 age=30&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;23-决策流程总结&#34;&gt;2.3. 决策流程总结&lt;/h3&gt;
&lt;p&gt;优先检查能否用索引：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查询包含 WHERE id = ? → 使用聚簇索引&lt;/li&gt;
&lt;li&gt;查询 WHERE name = ? → 使用 idx_name，然后回表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;执行器根据统计信息估算成本，再选择走哪个索引（或全表扫）, 一旦选定索引，引擎从 Root 开始，逐层比较键值直到叶子, 如果是二级索引，还需拿到主键，按同样 B+ 树规则走聚簇树&lt;/p&gt;
&lt;h2 id=&#34;3-叶子节点是双向连表的优势&#34;&gt;3. 叶子节点是双向连表的优势&lt;/h2&gt;
&lt;p&gt;假设我们有一个订单表&lt;code&gt;orders&lt;/code&gt;，包含订单ID、客户名、订单日期和金额：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;orders(order_id, customer_name, order_date, amount)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中 &lt;code&gt;order_id&lt;/code&gt; 是主键，在 &lt;code&gt;order_date&lt;/code&gt; 上创建了索引:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;(1, &amp;#39;张三&amp;#39;, &amp;#39;2023-01-15&amp;#39;, 100)
(2, &amp;#39;李四&amp;#39;, &amp;#39;2023-02-20&amp;#39;, 200)
(3, &amp;#39;王五&amp;#39;, &amp;#39;2023-03-10&amp;#39;, 150)
(4, &amp;#39;赵六&amp;#39;, &amp;#39;2023-03-15&amp;#39;, 300)
(5, &amp;#39;钱七&amp;#39;, &amp;#39;2023-04-05&amp;#39;, 250)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在B+ Tree索引结构中，&lt;code&gt;order_date&lt;/code&gt; 索引的叶子节点可能如下所示:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[2023-01-15, ID=1] &amp;lt;-&amp;gt; [2023-02-20, ID=2] &amp;lt;-&amp;gt; [2023-03-10, ID=3] &amp;lt;-&amp;gt; [2023-03-15, ID=4] &amp;lt;-&amp;gt; [2023-04-05, ID=5]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这些节点通过双向链表连接, 每个节点都有指向前一个和后一个节点的指针,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;范围查询&lt;/strong&gt; 假设我们需要查询3月份的所有订单:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; orders &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; order_date &lt;span style=&#34;color:#66d9ef&#34;&gt;BETWEEN&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2023-03-01&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2023-03-31&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;数据库会：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过B+树索引结构找到第一个满足条件的叶子节点（&amp;lsquo;2023-03-10&amp;rsquo;）&lt;/li&gt;
&lt;li&gt;然后沿着链表顺序遍历，直到找到超出范围的节点&lt;/li&gt;
&lt;li&gt;无需回到树的上层节点再向下查找&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果没有双向链表, 每找到一个节点都需要&lt;strong&gt;从根节点重新遍历&lt;/strong&gt;, 效率会大大降低&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;排序查询&lt;/strong&gt; 执行如下排序查询&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; orders &lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; order_date;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由于叶子节点已经按 &lt;code&gt;order_date&lt;/code&gt; 排序并通过链表连接, 数据库只需按链表顺序读取即可, 无需额外排序步骤&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分页查询&lt;/strong&gt; 当执行分页查询时：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; orders &lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; order_date &lt;span style=&#34;color:#66d9ef&#34;&gt;LIMIT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;数据库可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到排序起始位置&lt;/li&gt;
&lt;li&gt;跳过前2条记录&lt;/li&gt;
&lt;li&gt;沿着链表读取接下来的2条记录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;全表扫描&lt;/strong&gt; 如果需要全表扫描，可以从第一个叶子节点开始，沿着链表顺序读取所有数据，这种顺序访问&lt;strong&gt;比随机访问磁盘更高效&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;4-为什么索引查询速度接近-o1&#34;&gt;4. 为什么索引查询速度接近 O(1)&lt;/h2&gt;
&lt;p&gt;有人分析说 因为 B+ Tree 树的高度很低, 一般都是 3~4, 所以 I/O 次数 只有 3 ~ 4 次, 接近常数 1, 可是我认为, B+ Tree 不像 二叉搜索树那样, 只有每个节点只有两个子节点, 有可能会有多个节点, 比如 100 个, 这没关系, 因为每个节点页都由上层 的节点 通过指针指出, 可是每个节点也就是数据页可能会有多个数据啊, 比如 100 个, 这个时候 定位数据, 复杂度不应该是 O(n) 吗?&lt;/p&gt;
&lt;h3 id=&#34;42-公式推导&#34;&gt;4.2. 公式推导&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;一次查找包含两个独立成本&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;步骤&lt;/th&gt;
          &lt;th&gt;在 B⁺Tree 中做什么&lt;/th&gt;
          &lt;th&gt;理论开销&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;A. 自根向叶走指针&lt;/td&gt;
          &lt;td&gt;需要读取「树高 h」个节点页&lt;/td&gt;
          &lt;td&gt;O(h) = O(logₘ N)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;B. 在单个节点里找分隔键&lt;/td&gt;
          &lt;td&gt;对 m-1 个键比较，可做线性查找或二分查找&lt;/td&gt;
          &lt;td&gt;O(m) 或 O(log m)&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;记号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;m = 分叉因子（一个非叶子能容纳的最大子页数）&lt;/li&gt;
&lt;li&gt;N = 总记录行数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;页大小 = 16 KB&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非叶子节点：每条索引条目 24 B（键 + 子页号）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每页可容纳 ⌊16384 / 24⌋ ≈ &lt;strong&gt;680 个分叉&lt;/strong&gt;，即 m ≈ 680&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;叶子节点：每条索引项 40 B（键 + 主键）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每页 ≈ 400 条记录&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;计算树高 h
$$
h = \lceil \log_{m}(N) \rceil
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;N (行数)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;h (向上取整)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;N (行数)&lt;/th&gt;
          &lt;th&gt;h (向上取整)&lt;/th&gt;
          &lt;th&gt;需要随机 I/O&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;100 万&lt;/td&gt;
          &lt;td&gt;⌈log₆₈₀(10⁶)⌉ = 2.4 → 3&lt;/td&gt;
          &lt;td&gt;3 次&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;1 亿&lt;/td&gt;
          &lt;td&gt;⌈log₆₈₀(10⁸)⌉ = 3.2 → 4&lt;/td&gt;
          &lt;td&gt;4 次&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;100 亿&lt;/td&gt;
          &lt;td&gt;⌈log₆₈₀(10¹⁰)⌉ = 4.0 → 4&lt;/td&gt;
          &lt;td&gt;4 次&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;N 从 10⁶ ➜ 10¹⁰ 扩大一万倍，h 只从 3 ➜ 4&lt;/li&gt;
&lt;li&gt;若页缓存命中，步骤 A 甚至是 0 次磁盘 I/O，仅 CPU 比较&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;节点内比较成本&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;线性查找：≤ 680 次比较&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二分查找：⌈log₂ 680⌉ ≈ 10 次比较&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在现代 CPU 上比较 10~680 个整数几乎可忽略, 于是&lt;strong&gt;总体壁钟时间看起来几乎不随 N 增长&lt;/strong&gt;，这就是「接近 O(1)」的直观感受&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;壁钟时间是程序运行的“真实世界时间”, 而这里强调它几乎不受 N 影响, 直观上接近常数时间复杂度,&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;42-实际数据比较&#34;&gt;4.2. 实际数据比较&lt;/h3&gt;
&lt;p&gt;我们来比较一下 做一次随机磁盘 IO + 把数据页拷贝进内存 的时间 和 CPU 比较一次的耗时做对比:&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;存储介质&lt;/th&gt;
          &lt;th&gt;一次随机 I/O 大概耗时(包括拷贝进内存的时间)&lt;/th&gt;
          &lt;th&gt;CPU 比较一次耗时&lt;/th&gt;
          &lt;th&gt;数量级差距&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;机械盘&lt;/td&gt;
          &lt;td&gt;≈ 5 ms&lt;/td&gt;
          &lt;td&gt;≈ 5 ns&lt;/td&gt;
          &lt;td&gt;≈ 1 000 000 : 1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;SATA SSD&lt;/td&gt;
          &lt;td&gt;≈ 100 µs&lt;/td&gt;
          &lt;td&gt;≈ 5 ns&lt;/td&gt;
          &lt;td&gt;≈ 20 000 : 1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;NVMe SSD&lt;/td&gt;
          &lt;td&gt;≈ 20 µs&lt;/td&gt;
          &lt;td&gt;≈ 5 ns&lt;/td&gt;
          &lt;td&gt;≈ 4 000 : 1&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;即使换成 NVMe，随机 I/O 仍比 CPU 比较慢四个数量级&lt;/li&gt;
&lt;li&gt;因此&lt;strong&gt;决定查询延迟的第一因素仍是“要做几次随机 I/O”&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;B⁺Tree 通过把分叉数 m 做到几百，使树高 h≤3–4，从而把“随机 I/O 次数”限制到 3–4 次——这远比 “&lt;strong&gt;页内要比较多少键”&lt;/strong&gt; 重要&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;为什么复杂度推导 没有包括 叶子页找目标记录的开销&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;O(log N)&lt;/code&gt; 级别推导中, 页内比较最多几百次, 比一次 I/O 快万倍, 可忽略不计&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有人可能会问 你把 在存储介质 &lt;em&gt;一次随机 I/O 耗时&lt;/em&gt; 与 &lt;em&gt;CPU 比较一次耗时&lt;/em&gt; 进行比较准确吗?&lt;/p&gt;
&lt;p&gt;&lt;em&gt;一次磁盘随机 I/O 耗时&lt;/em&gt; 不应该加上从内存读取数据的时间吗, 因为数据加载的过程, 是把该节点的整个数据页加载进内存, 然后再比较数据,&lt;/p&gt;
&lt;p&gt;下面把 &lt;em&gt;一次磁盘随机 I/O 到真正完成键值比较&lt;/em&gt; 所经历的全部路径拆开, 给出各阶段的量级, 看看 &lt;strong&gt;磁盘→内存→CPU&lt;/strong&gt; 各环节到底谁是瓶颈, 为便于对比, 以一次读取 16 KB InnoDB 页为例:&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;阶段&lt;/th&gt;
          &lt;th&gt;机械盘&lt;/th&gt;
          &lt;th&gt;SATA SSD&lt;/th&gt;
          &lt;th&gt;NVMe SSD&lt;/th&gt;
          &lt;th&gt;仅 DRAM (页已在 Buffer Pool)&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;A. 设备随机寻道/寻址&lt;/td&gt;
          &lt;td&gt;≈ 5 ms&lt;/td&gt;
          &lt;td&gt;≈ 50 µs&lt;/td&gt;
          &lt;td&gt;≈ 10 µs&lt;/td&gt;
          &lt;td&gt;0&lt;/td&gt;
          &lt;td&gt;硬盘最耗时；SSD 仍需闪存地址译码+控制器排队&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;B. 媒体读出到控制器缓存&lt;/td&gt;
          &lt;td&gt;≈ 0.2 ms&lt;/td&gt;
          &lt;td&gt;≈ 40 µs&lt;/td&gt;
          &lt;td&gt;≈ 5 µs&lt;/td&gt;
          &lt;td&gt;0&lt;/td&gt;
          &lt;td&gt;顺序传输 16 KB 原始位流&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;C. PCIe/SATA DMA 传到主机 DRAM&lt;/td&gt;
          &lt;td&gt;≈ 50 µs&lt;/td&gt;
          &lt;td&gt;≈ 10 µs&lt;/td&gt;
          &lt;td&gt;≈ 3 µs&lt;/td&gt;
          &lt;td&gt;0&lt;/td&gt;
          &lt;td&gt;含协议栈、DMA 成本&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;D. OS/Buffer Pool 拷贝 + 校验&lt;/td&gt;
          &lt;td&gt;≈ 5 µs&lt;/td&gt;
          &lt;td&gt;≈ 5 µs&lt;/td&gt;
          &lt;td&gt;≈ 5 µs&lt;/td&gt;
          &lt;td&gt;≈ 5 µs&lt;/td&gt;
          &lt;td&gt;memcpy + CRC，一次 copy≈0.8 µs，算上校验约 5 µs&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;E. InnoDB 页目录二分 + 线性扫&lt;/td&gt;
          &lt;td&gt;≈ 0.05 µs&lt;/td&gt;
          &lt;td&gt;≈ 0.05 µs&lt;/td&gt;
          &lt;td&gt;≈ 0.05 µs&lt;/td&gt;
          &lt;td&gt;≈ 0.05 µs&lt;/td&gt;
          &lt;td&gt;几十次 CPU 指令：10–100 ns&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;总耗时&lt;/td&gt;
          &lt;td&gt;≈ 5.26 ms&lt;/td&gt;
          &lt;td&gt;≈ 115 µs&lt;/td&gt;
          &lt;td&gt;≈ 18 µs&lt;/td&gt;
          &lt;td&gt;≈ 5 µs&lt;/td&gt;
          &lt;td&gt;A+B+C 占主导，D、E 几乎可忽略&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;数值按公开硬件数据取近似中位数, 偏差 1–2 倍不影响量级结论, 结论&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;随机 I/O 的主耗时就是 &lt;strong&gt;设备端寻址 + 媒体读出&lt;/strong&gt;（A+B）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对机械盘：&amp;gt; 99 % 的时间耗在磁头定位和旋转等待（A）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对 SSD：A 仍是大头，只是毫秒级→微秒级&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DMA + 内存拷贝&lt;/strong&gt;（C+D）加起来只是几个微秒，机械盘情况下占比 &amp;lt; 0.1 %&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因此前面的表格 磁盘 IO 时间 &lt;code&gt;5 ms / 100 µs / 20 µs&lt;/code&gt; 这种 “磁盘随机 I/O 耗时” 通常已经把拷贝进内存的时间统合在内；再细分也不改变大局——I/O 仍比内存-CPU 操作慢三个以上数量级&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;页内比较&lt;/strong&gt;（E）只有几十纳秒；即便连带一次 L1→L2 缓存失效也就是百纳秒量级, 和微秒～毫秒的 I/O 相比同样可以忽略&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果页已在 Buffer Pool（只需 D+E）：总耗时约 5 µs，比 NVMe 随机 I/O 快 3～4 倍，比机械盘快千倍；此时查找延迟主要是 &lt;strong&gt;CPU-DRAM&lt;/strong&gt; 以及锁、版本检查等开销&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以说 “数据库查找最贵的是随机 I/O” 是对的: 只要页不在内存，I/O 时间会压倒后续所有 CPU 计算&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在数据库查询中, &lt;strong&gt;磁盘随机 I/O 操作是最耗时的部分&lt;/strong&gt;, 而不是单纯的计算次数, B-Tree 的每一层对应一次磁盘 I/O, 而高度低意味着 I/O 次数少, 只要页不在内存, I/O 时间会压倒后续所有 CPU 计算, 因为 CPU 比较数据 &amp;amp; 内存拷贝视为“几乎免费”在数量级上是成立的, B⁺ Tree 之所以追求低树高, 就是为了把这个昂贵的随机 I/O 次数从 &lt;code&gt;O(log N)&lt;/code&gt; 压到 3–4 次, 之后&lt;strong&gt;页内二分或线性扫描&lt;/strong&gt;的优化相对只是“锦上添花”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;5-页的概念是什么意思&#34;&gt;5. 页的概念是什么意思&lt;/h2&gt;
&lt;h3 id=&#34;51-什么是页page&#34;&gt;5.1. 什么是页（Page）&lt;/h3&gt;
&lt;p&gt;在 InnoDB（MySQL 8.x 默认存储引擎）里, &lt;strong&gt;页是磁盘与内存之间读写的最小物理单元&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任何数据（表、索引、Undo、字典等）都被切成若干页来管理&lt;/li&gt;
&lt;li&gt;数据库一次随机 I/O 最多只把一个完整页搬到 Buffer Pool，随后对该页里的记录做 CPU 运算&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;页的大小&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;参数&lt;/th&gt;
          &lt;th&gt;默认值&lt;/th&gt;
          &lt;th&gt;可否修改&lt;/th&gt;
          &lt;th&gt;作用&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;innodb_page_size&lt;/td&gt;
          &lt;td&gt;16 KB (16 384 字节)&lt;/td&gt;
          &lt;td&gt;初始化实例时可改为 4 KB / 8 KB / 32 KB / 64 KB&lt;/td&gt;
          &lt;td&gt;决定所有 InnoDB 页大小&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;52-页里存放什么&#34;&gt;5.2. 页里存放什么？&lt;/h3&gt;
&lt;p&gt;以一页 “索引页（INDEX PAGE，类型 0x45BF）” 为例&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;+----------------------+  0     ← file offset
| File Header (38 B)   |
| Page Header (56 B)   |
| Infimum / Supremum   | 伪记录做边界
| User Records ...     | 按主键或二级索引键有序
| Free Space           | 插入时向中间填充
| Page Directory       | 每 128 条插一槽，向下增长
| File Trailer (8 B)   |
+----------------------+ 16384  ← 16 KB
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;User Records&lt;/strong&gt;：真正的行记录或索引条目&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Page Directory&lt;/strong&gt;：偏移量数组，用来做二分搜索&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Header&lt;/strong&gt; 包括页号、上一页/下一页指针、校验值、空闲链等元数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;53-页与-btree节点的关系&#34;&gt;5.3. 页与 B⁺Tree节点的关系&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;B⁺Tree 术语&lt;/th&gt;
          &lt;th&gt;InnoDB 对应&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Node (节点)&lt;/td&gt;
          &lt;td&gt;Page (16 KB)&lt;/td&gt;
          &lt;td&gt;一页就是一个节点&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Child Pointer&lt;/td&gt;
          &lt;td&gt;在非叶子记录中的 page_no + slot&lt;/td&gt;
          &lt;td&gt;指向子页&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Sibling Pointer&lt;/td&gt;
          &lt;td&gt;页头的 prev / next&lt;/td&gt;
          &lt;td&gt;把叶子页串成双向链表&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;所以常听到“树高 = 3～4 页深”本质上是“从根页经 3～4 次指针跳到目标叶子页”&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>浅谈IO模型 异步IO</title>
      <link>https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/013-%E6%B5%85%E8%B0%88io%E6%A8%A1%E5%9E%8B-%E5%BC%82%E6%AD%A5io/</link>
      <pubDate>Thu, 24 Apr 2025 22:35:26 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/013-%E6%B5%85%E8%B0%88io%E6%A8%A1%E5%9E%8B-%E5%BC%82%E6%AD%A5io/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;其实面试的时候一个问题就可以看清是否对这些理解透彻了, Node.js 事件循环机制如何实现的,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关键点是, 是否可以分清 libuv 库, 事件循环, v8 引擎, nodejs 这几个概念的关系, 以及 IO 复用在这里面的作用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;异步 IO 和 非阻塞 IO 的区别 又是什么&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是否理解事件驱动&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;1-阻塞io-blocking-io&#34;&gt;1. 阻塞IO (Blocking IO)&lt;/h2&gt;
&lt;p&gt;阻塞IO是指在进行IO操作（如读写文件或网络通信）时，调用线程会一直等待直到操作完成。阻塞IO通常实现简单，但在&lt;strong&gt;高并发场景下效率较低&lt;/strong&gt;，因为每个连接可能需要一个线程，线程切换和资源占用会成为瓶颈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传统的socket编程中 使用 &lt;code&gt;socket.recv()&lt;/code&gt; 读取网络数据时，线程会等待直到数据到达&lt;/li&gt;
&lt;li&gt;MySQL客户端连接 传统数据库查询（如SELECT）通常是阻塞的，等待数据库返回结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;早期 Java 服务器为每个连接分配一个线程, 遇到高并发（如 C10K）时性能急剧下降, 促使了NIO（非阻塞IO）和 Netty 的流行&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;C10K（Concurrency 10K）问题&lt;/strong&gt; 指的是服务器如何高效地处理 1万个并发连接&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当并发连接数增加（例如C10K问题，即1万个并发连接），服务器需要创建大量线程（每个连接一个线程）&lt;/li&gt;
&lt;li&gt;因为线程很多, 操作系统需要处理大量&lt;strong&gt;线程上下文切换&lt;/strong&gt;, 这会消耗大量CPU资源&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此在高并发场景下, BIO模型效率低下, 性能会急剧下降, 这也是为什么 C10K 问题推动了非阻塞 IO（NIO）和异步框架（如Netty）的流行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;现在的 Spring MVC 不也是为每个连接分配一个线程吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spring MVC 通常运行在 Servlet 容器（如Tomcat、Jetty）之上, 这些容器的线程模型决定了 Spring MVC 的并发处理方式, &lt;strong&gt;现代Servlet 容器&lt;/strong&gt;并不为每个客户端连接分配一个专用线程，而是使用&lt;strong&gt;线程池&lt;/strong&gt;和&lt;strong&gt;事件驱动&lt;/strong&gt;机制: 在高并发场景下，线程池的大小远小于并发连接数, &lt;strong&gt;线程可以复用&lt;/strong&gt;, 极大减少了线程切换和内存开销&lt;/p&gt;</description>
      <content>&lt;blockquote&gt;
&lt;p&gt;其实面试的时候一个问题就可以看清是否对这些理解透彻了, Node.js 事件循环机制如何实现的,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关键点是, 是否可以分清 libuv 库, 事件循环, v8 引擎, nodejs 这几个概念的关系, 以及 IO 复用在这里面的作用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;异步 IO 和 非阻塞 IO 的区别 又是什么&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是否理解事件驱动&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;1-阻塞io-blocking-io&#34;&gt;1. 阻塞IO (Blocking IO)&lt;/h2&gt;
&lt;p&gt;阻塞IO是指在进行IO操作（如读写文件或网络通信）时，调用线程会一直等待直到操作完成。阻塞IO通常实现简单，但在&lt;strong&gt;高并发场景下效率较低&lt;/strong&gt;，因为每个连接可能需要一个线程，线程切换和资源占用会成为瓶颈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传统的socket编程中 使用 &lt;code&gt;socket.recv()&lt;/code&gt; 读取网络数据时，线程会等待直到数据到达&lt;/li&gt;
&lt;li&gt;MySQL客户端连接 传统数据库查询（如SELECT）通常是阻塞的，等待数据库返回结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;早期 Java 服务器为每个连接分配一个线程, 遇到高并发（如 C10K）时性能急剧下降, 促使了NIO（非阻塞IO）和 Netty 的流行&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;C10K（Concurrency 10K）问题&lt;/strong&gt; 指的是服务器如何高效地处理 1万个并发连接&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当并发连接数增加（例如C10K问题，即1万个并发连接），服务器需要创建大量线程（每个连接一个线程）&lt;/li&gt;
&lt;li&gt;因为线程很多, 操作系统需要处理大量&lt;strong&gt;线程上下文切换&lt;/strong&gt;, 这会消耗大量CPU资源&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此在高并发场景下, BIO模型效率低下, 性能会急剧下降, 这也是为什么 C10K 问题推动了非阻塞 IO（NIO）和异步框架（如Netty）的流行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;现在的 Spring MVC 不也是为每个连接分配一个线程吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spring MVC 通常运行在 Servlet 容器（如Tomcat、Jetty）之上, 这些容器的线程模型决定了 Spring MVC 的并发处理方式, &lt;strong&gt;现代Servlet 容器&lt;/strong&gt;并不为每个客户端连接分配一个专用线程，而是使用&lt;strong&gt;线程池&lt;/strong&gt;和&lt;strong&gt;事件驱动&lt;/strong&gt;机制: 在高并发场景下，线程池的大小远小于并发连接数, &lt;strong&gt;线程可以复用&lt;/strong&gt;, 极大减少了线程切换和内存开销&lt;/p&gt;
&lt;p&gt;不太懂现代 Servlet 容器的 IO 模型, 为什么是事件驱动?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-非阻塞io-non-blocking-io&#34;&gt;2. 非阻塞IO (Non-blocking IO)&lt;/h2&gt;
&lt;p&gt;非阻塞IO允许线程在执行IO操作时立即返回，而不会等待操作完成。如果数据不可用，会返回一个错误或标志（如EAGAIN），调用者&lt;strong&gt;需要轮询（polling）来检查状态&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;C语言的socket编程&lt;/strong&gt;：通过 &lt;code&gt;fcntl&lt;/code&gt; 设置 &lt;code&gt;socket&lt;/code&gt; 为 &lt;code&gt;O_NONBLOCK&lt;/code&gt;, 调用 &lt;code&gt;recv&lt;/code&gt; 时立即返回&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Java NIO（New IO）&lt;/strong&gt;：使用 &lt;code&gt;SocketChannel&lt;/code&gt; 配置为非阻塞模式，检查 &lt;code&gt;read()&lt;/code&gt; 返回值&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;非阻塞IO虽然避免了线程阻塞，但&lt;strong&gt;频繁轮询会消耗CPU资源&lt;/strong&gt;，因此单独使用非阻塞IO在高并发场景下效率也不高, &lt;strong&gt;非阻塞IO常与IO复用结合使用&lt;/strong&gt;（如 &lt;code&gt;select&lt;/code&gt; 或 &lt;code&gt;epoll&lt;/code&gt;），单独使用效率低&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;21-为什么非阻塞io需要与io复用结合&#34;&gt;2.1. 为什么非阻塞IO需要与IO复用结合？&lt;/h3&gt;
&lt;p&gt;先看看非阻塞 I/O 的使用场景 理解了非阻塞 IO 的使用场景, 才能更好的了解为什么和 IO 复用搭配使用更好, 假设你正在开发一个简单的TCP服务器, 需要同时处理多个客户端连接, 但没有使用IO复用机制:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 简单的非阻塞TCP服务器轮询示例
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; server_fd, client_fds[MAX_CLIENTS] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; client_count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 创建服务器socket并设置为非阻塞
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    server_fd &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;socket&lt;/span&gt;(AF_INET, SOCK_STREAM, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fcntl&lt;/span&gt;(server_fd, F_SETFL, O_NONBLOCK);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 绑定和监听代码省略...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 1. 轮询接受新连接
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; sockaddr_in client_addr;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;socklen_t&lt;/span&gt; addr_len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(client_addr);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; new_fd &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;accept&lt;/span&gt;(server_fd, (&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; sockaddr&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;client_addr, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;addr_len);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(new_fd &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 新连接成功
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;新客户端连接: %d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, new_fd);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;fcntl&lt;/span&gt;(new_fd, F_SETFL, O_NONBLOCK);  &lt;span style=&#34;color:#75715e&#34;&gt;// 设置客户端socket为非阻塞
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            client_fds[client_count&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; new_fd;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(errno &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; EAGAIN &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; errno &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; EWOULDBLOCK) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 真正的错误
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;perror&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;accept失败&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 2. 轮询检查每个客户端是否有数据可读
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; client_count; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; buffer[&lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; ret &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;recv&lt;/span&gt;(client_fds[i], buffer, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(buffer), &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(ret &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 成功读取数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#a6e22e&#34;&gt;printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;从客户端%d接收: %s&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, client_fds[i], buffer);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 处理数据并回复
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#a6e22e&#34;&gt;send&lt;/span&gt;(client_fds[i], &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;已收到消息&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(ret &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 客户端关闭连接
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#a6e22e&#34;&gt;printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;客户端%d断开连接&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, client_fds[i]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a6e22e&#34;&gt;close&lt;/span&gt;(client_fds[i]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 移除该客户端
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                client_fds[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; client_fds[&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;client_count];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                i&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;// 重新检查当前位置
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(errno &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; EAGAIN &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; errno &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; EWOULDBLOCK) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 真正的错误
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#a6e22e&#34;&gt;perror&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;recv失败&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a6e22e&#34;&gt;close&lt;/span&gt;(client_fds[i]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                client_fds[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; client_fds[&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;client_count];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                i&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 如果errno是EAGAIN或EWOULDBLOCK，表示没有数据可读，继续轮询下一个
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 可选：短暂休眠以减少CPU使用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;usleep&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;);  &lt;span style=&#34;color:#75715e&#34;&gt;// 休眠1毫秒
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在资源受限的嵌入式系统中，可能没有复杂的IO复用机制，需要轮询多个传感器：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 嵌入式系统传感器轮询示例
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main_loop&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 初始化传感器
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;init_sensors&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 轮询温度传感器
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; temp_ready &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;check_temperature_sensor&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(temp_ready) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;read_temperature&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;process_temperature_data&lt;/span&gt;(temp);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 轮询湿度传感器
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 执行其他任务
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;perform_periodic_tasks&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 短暂休眠以节省电量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;sleep_ms&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;轮询的主要问题&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CPU资源浪费&lt;/strong&gt;：大部分时间在检查没有变化的资源&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;响应延迟&lt;/strong&gt;：轮询间隔决定了响应延迟&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩展性差&lt;/strong&gt;：随着监控资源数量增加，性能下降&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;轮询与IO复用的对比&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 纯轮询方式&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;; i++) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 每次循环都要对100个socket调用recv系统调用&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ret = recv(sockets[i], buffer, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(buffer), MSG_DONTWAIT);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 处理结果...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    usleep(&lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// IO复用方式 (epoll)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; epfd = epoll_create1(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 注册100个socket到epoll...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 只有当有事件发生时才会返回&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; nfds = epoll_wait(epfd, events, MAX_EVENTS, -&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 只处理有事件的socket，通常远少于100个&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &amp;lt; nfds; i++) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; fd = events[i].data.fd;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ret = recv(fd, buffer, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(buffer), &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 处理结果...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;非阻塞IO避免线程等待IO操作完成, 通过IO复用（如select、poll、epoll）高效监控多个IO描述符的状态, 从而&lt;strong&gt;减少轮询开销并提升性能&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;除此之外, 主动轮询, 频繁调用 &lt;code&gt;recv()&lt;/code&gt; 系统调用, 需要从用户态切换到内核态, 上下文切换也是一个不小的开销
&lt;ul&gt;
&lt;li&gt;这涉及到保存用户态的寄存器状态、切换到内核堆栈、执行内核代码等操作&lt;/li&gt;
&lt;li&gt;IO复用通过一次系统调用（例如 &lt;code&gt;select()&lt;/code&gt; 或 &lt;code&gt;epoll_wait()&lt;/code&gt;）监控多个 &lt;code&gt;socket&lt;/code&gt; 的状态，而不是为每个 &lt;code&gt;socket&lt;/code&gt; 单独调用 &lt;code&gt;recv()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;3-io复用-io-multiplexing&#34;&gt;3. IO复用 (IO Multiplexing)&lt;/h2&gt;
&lt;p&gt;IO复用是指一个线程监控多个IO描述符, 当某个描述符就绪时通知应用程序, 常见的实现包括 &lt;code&gt;select&lt;/code&gt;、&lt;code&gt;poll&lt;/code&gt; 和 &lt;code&gt;epoll&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Nginx&lt;/strong&gt;：使用 &lt;code&gt;epoll&lt;/code&gt;（Linux）或 &lt;code&gt;kqueue&lt;/code&gt;（BSD）处理高并发连接&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Redis&lt;/strong&gt;：基于 &lt;code&gt;epoll/select&lt;/code&gt; 的单线程事件循环，高效处理客户端请求&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;libevent/libuv&lt;/strong&gt;：高性能事件循环库，广泛用于 Nginx、Node.js 等&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;31-select-poll-epoll-kqueue&#34;&gt;3.1. select, poll, epoll, kqueue&lt;/h3&gt;
&lt;p&gt;IO 复用 如何监听的文件描述符? 比如是否可读, 可写等&amp;hellip;&lt;/p&gt;
&lt;p&gt;IO复用机制通过不同的API和数据结构来监听文件描述符的状态：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;机制&lt;/th&gt;
          &lt;th&gt;平台&lt;/th&gt;
          &lt;th&gt;监听方式&lt;/th&gt;
          &lt;th&gt;性能&lt;/th&gt;
          &lt;th&gt;最大连接数&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;select&lt;/td&gt;
          &lt;td&gt;全平台&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;fd_set&lt;/code&gt; 位图&lt;/td&gt;
          &lt;td&gt;O(n)&lt;/td&gt;
          &lt;td&gt;受限(通常1024)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;poll&lt;/td&gt;
          &lt;td&gt;全平台&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;pollfd&lt;/code&gt; 结构体数组&lt;/td&gt;
          &lt;td&gt;O(n)&lt;/td&gt;
          &lt;td&gt;不受限&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;epoll&lt;/td&gt;
          &lt;td&gt;Linux&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;epoll_event&lt;/code&gt; 结构体&lt;/td&gt;
          &lt;td&gt;O(1)&lt;/td&gt;
          &lt;td&gt;不受限&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;kqueue&lt;/td&gt;
          &lt;td&gt;BSD/macOS&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;kevent&lt;/code&gt; 结构体&lt;/td&gt;
          &lt;td&gt;O(1)&lt;/td&gt;
          &lt;td&gt;不受限&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;select epoll 核心区别：通知机制&lt;/strong&gt; &lt;strong&gt;最本质的区别&lt;/strong&gt;: select 是主动轮询，而 epoll 是被动通知&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;既然 select 也是轮询, 和 非阻塞 IO 中的主动轮询有什么区别呢, 为什么要用 select?&lt;/p&gt;
&lt;p&gt;在纯非阻塞 IO 轮询中, 应用程序直接轮询每个文件描述符, 假设我们有 100 个连接, 但在某一时刻只有 5 个连接有数据可读,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;纯非阻塞 IO 轮询&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 每次循环需要 100 次系统调用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;recv&lt;/span&gt;(sockets[i], buffer, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(buffer), MSG_DONTWAIT);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 95次调用会立即返回EAGAIN
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;select 轮询&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 设置fd_set (一次系统调用)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;FD_ZERO&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;read_fds);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;FD_SET&lt;/span&gt;(sockets[i], &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;read_fds);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// select调用 (一次系统调用)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;select&lt;/span&gt;(max_fd &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;read_fds, NULL, NULL, NULL);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 只对就绪的5个连接调用recv (5次系统调用)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;FD_ISSET&lt;/span&gt;(sockets[i], &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;read_fds)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;recv&lt;/span&gt;(sockets[i], buffer, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(buffer), &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;32-select-epoll-区别&#34;&gt;3.2. select epoll 区别&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;系统调用开销&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;select：每次调用都需要传递完整的文件描述符集合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;epoll：通过 epoll_ctl 注册一次，之后无需重复传递&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;内存拷贝&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;select：每次调用需要在用户空间和内核空间之间复制 fd_set&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;epoll：通过 mmap 共享内存，减少数据拷贝&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;就绪通知方式&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;select：返回后需要遍历所有文件描述符检查状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;epoll：只返回就绪的文件描述符列表&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;33-实际应用中的io复用&#34;&gt;3.3. &lt;strong&gt;实际应用中的IO复用&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Node.js使用 &lt;code&gt;libuv&lt;/code&gt; 库实现事件循环，根据平台自动选择最优的IO复用机制：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Node.js服务器示例
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;net&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;require&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;net&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;server&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;net&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;createServer&lt;/span&gt;((&lt;span style=&#34;color:#a6e22e&#34;&gt;socket&lt;/span&gt;) =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;客户端连接&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 监听可读事件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;socket&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;on&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;data&amp;#39;&lt;/span&gt;, (&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;) =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;收到数据:&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;toString&lt;/span&gt;());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 响应客户端
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;socket&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;write&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;服务器已收到消息&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 监听关闭事件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;socket&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;on&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;close&amp;#39;&lt;/span&gt;, () =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;客户端断开连接&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 监听错误事件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;socket&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;on&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;error&amp;#39;&lt;/span&gt;, (&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;) =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;连接错误:&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;server&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;listen&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;8000&lt;/span&gt;, () =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;服务器启动在端口8000&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Nginx使用事件驱动架构，根据平台选择最佳的IO复用机制：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Nginx事件处理伪代码
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ngx_event_module_init&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 根据平台选择最佳的IO复用机制
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (epoll_supported) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;use_epoll&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (kqueue_supported) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;use_kqueue&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (poll_supported) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;use_poll&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;use_select&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 事件循环
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ngx_process_events_and_timers&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 等待事件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    events &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;io_multiplexing_wait&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 处理所有事件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; events.count; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        event &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; events[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (event.read) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            event.&lt;span style=&#34;color:#a6e22e&#34;&gt;read_handler&lt;/span&gt;(event.connection);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (event.write) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            event.&lt;span style=&#34;color:#a6e22e&#34;&gt;write_handler&lt;/span&gt;(event.connection);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 处理定时器事件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;process_timers&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;应用总结:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;高并发Web服务器&lt;/strong&gt;：如Nginx，处理数千个并发连接&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;单线程高性能系统&lt;/strong&gt;：如Redis，单线程处理大量客户端请求&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;4-异步-io-asynchronous-io&#34;&gt;4. 异步 IO (Asynchronous IO)&lt;/h2&gt;
&lt;p&gt;异步IO是指发起IO操作后立即返回, 操作系统在后台完成IO, 完成后&lt;strong&gt;通过回调、协程或事件通知应用程序&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Node.js&lt;/strong&gt;：基于 &lt;code&gt;libuv&lt;/code&gt; 的事件循环，异步处理文件、网络IO&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Python FastAPI&lt;/strong&gt;：依赖 &lt;code&gt;asyncio&lt;/code&gt; 和 &lt;code&gt;uvicorn&lt;/code&gt;，通过 &lt;code&gt;async/await&lt;/code&gt; 实现异步Web服务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Java Netty&lt;/strong&gt;：异步网络框架，基于NIO和事件驱动，广泛用于高性能服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;41-异步-io-的本质-&#34;&gt;4.1. 异步 IO 的本质 ‼️&lt;/h3&gt;
&lt;p&gt;思考一个问题 异步 IO (Asynchronous IO) 的本质是什么? 和非阻塞 IO 的区别呢?&lt;/p&gt;
&lt;p&gt;我的理解 异步的本质就是通过回调函数来执行, 可是异步好像也像是同步:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;response&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fetch&lt;/span&gt;(....);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 执行其他的任务
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;异步 IO 的本质是&lt;strong&gt;允许程序在 IO 操作进行时继续执行其他任务, 而不是等待 IO 操作完成&lt;/strong&gt;, 异步 IO 确实常常通过回调函数实现, 但这只是实现机制之一, 而非本质, 异步 IO 的核心在于: &lt;strong&gt;IO 操作的发起与结果的获取被分离&lt;/strong&gt;, 当 IO 操作完成后, 通过某种机制（回调函数、Promise、事件等）&lt;strong&gt;通知程序处理结果&lt;/strong&gt;, 中间的等待时间可以用来做其他事情&lt;/p&gt;
&lt;p&gt;上面的例子:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;response&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fetch&lt;/span&gt;(...);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 执行其他的
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的 ⁠await 并不意味着同步。它只是让代码看起来像同步，但实际上：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;⁠fetch&lt;/code&gt; 是异步操作，调用后立即返回 &lt;code&gt;Promise&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;⁠&lt;code&gt;await&lt;/code&gt; 暂停当前函数的执行，&lt;strong&gt;但不会阻塞 JavaScript 的主线程&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在 IO 操作进行时，JavaScript 引擎可以执行其他任务（事件循环中的其他回调）&lt;/li&gt;
&lt;li&gt;IO 完成后，事件循环会让暂停的函数继续执行&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以 ⁠&lt;code&gt;await&lt;/code&gt; 是异步 IO 的语法糖, 让异步代码更易读, 但底层仍然是异步的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虽然异步 IO 和非阻塞 IO 都允许程序在 IO 操作进行时继续执行其他任务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非阻塞 IO&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非阻塞 IO 是指在发起 IO 操作时, 设置 IO 操作（如 socket 或文件描述符）为非阻塞模式, 如果 IO 操作无法立即完成, 系统调用会立即返回一个错误（如 &lt;code&gt;EAGAIN&lt;/code&gt; 或 &lt;code&gt;EWOULDBLOCK&lt;/code&gt;）, 而不是等待操作完成&lt;/li&gt;
&lt;li&gt;程序需要**轮询（polling）**或通过其他机制（如 &lt;code&gt;select&lt;/code&gt;、&lt;code&gt;poll&lt;/code&gt;、&lt;code&gt;epoll&lt;/code&gt;）检查 IO 操作是否完成&lt;/li&gt;
&lt;li&gt;非阻塞 IO 的核心是&lt;strong&gt;系统调用立即返回&lt;/strong&gt;, 但后续是否&lt;strong&gt;需要程序主动检查&lt;/strong&gt;状态取决于具体实现&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;set_socket_nonblocking&lt;/span&gt;(socket);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 轮询检查 + 做其他的事情 同时发生
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (true) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;socket_ready&lt;/span&gt;(socket)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;read&lt;/span&gt;(socket, buffer);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 做其他事情
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;异步 IO&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;异步 IO 是指程序发起 IO 操作后, &lt;strong&gt;操作系统接管整个 IO 过程&lt;/strong&gt;, 程序无需主动关心操作状态, 当 IO 操作完成时, 操作系统通过&lt;strong&gt;回调、事件通知或信号&lt;/strong&gt;等方式通知程序&lt;/li&gt;
&lt;li&gt;异步 IO 的核心是&lt;strong&gt;完全将 IO 操作交给操作系统&lt;/strong&gt;, 程序只需在操作完成时处理结果, 中间&lt;strong&gt;无需轮询&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;async_read&lt;/span&gt;(socket, buffer, callback);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 直接做其他事情
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 操作系统会在完成后调用 callback
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;有没有发现 异步IO 有点像 非阻塞IO + IO复用, 只不过是 IO 复用的部分, 自动帮你实现了?&lt;/p&gt;
&lt;p&gt;确实很像, 但并不是, 但你可以把 异步IO看作是&amp;quot;非阻塞IO + IO复用 + 自动通知机制&amp;quot; 的组合&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;模型&lt;/th&gt;
          &lt;th&gt;组成部分&lt;/th&gt;
          &lt;th&gt;谁负责轮询/等待&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;非阻塞IO&lt;/td&gt;
          &lt;td&gt;仅非阻塞调用&lt;/td&gt;
          &lt;td&gt;应用程序自己轮询&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;IO复用&lt;/td&gt;
          &lt;td&gt;非阻塞IO + 集中式事件监听&lt;/td&gt;
          &lt;td&gt;应用程序通过select/epoll等等待&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;异步IO&lt;/td&gt;
          &lt;td&gt;非阻塞IO + 系统级事件监听 + 回调机制&lt;/td&gt;
          &lt;td&gt;操作系统/运行时负责&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在很多系统中, 异步IO 的实现确实是建立在非阻塞IO 和 IO复用的基础上的:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Node.js的libuv&lt;/strong&gt;：在Linux上，libuv使用epoll（一种IO复用机制）实现异步IO&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Windows的IOCP&lt;/strong&gt;：完整的异步IO实现&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Java的NIO&lt;/strong&gt;：基于非阻塞IO和Selector（IO复用）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以 Node.js 为例, 其事件循环大致如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Node.js事件循环的简化伪代码
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 1. 处理定时器回调
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;processTimerCallbacks&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 2. 处理IO回调（使用epoll/kqueue/IOCP等实现）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;processIOCallbacks&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 3. 处理其他类型的事件...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;processOtherEvents&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 如果没有待处理的事件，可能会退出
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;noMoreCallbacks&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;noMoreWork&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;在一些异步 IO 框架（如 Node.js 的 libuv）中，底层甚至可能使用 IO 复用机制（如 epoll 或 kqueue）来实现异步效果, 例如，Node.js 的事件循环会使用 epoll 监控 socket，并在就绪时触发回调，这让人感觉异步 IO 是“非阻塞 IO + IO 复用”的封装&lt;/p&gt;
&lt;p&gt;但关键区别在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;异步 IO 更彻底地将 IO 操作的完成交给内核，程序无需主动执行后续的 IO 调用&lt;/li&gt;
&lt;li&gt;异步 IO 的通知是&lt;strong&gt;操作完成&lt;/strong&gt;（数据已准备好），而 IO 复用通知的是&lt;strong&gt;描述符就绪&lt;/strong&gt;（仍需程序执行 IO）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;非阻塞 IO&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;常用于高性能服务器开发，如 Nginx、Redis 等，它们通过事件循环和非阻塞 socket 处理大量并发连接&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;适合需要细粒度控制 IO 行为的场景&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;异步 IO&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常用于需要简化并发处理的场景，如 Node.js 的异步文件操作、网络请求，或者数据库查询&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;42-事件驱动&#34;&gt;4.2. 事件驱动&lt;/h3&gt;
&lt;p&gt;可以看 009-事件驱动-异步编程.md 文件&lt;/p&gt;
&lt;h2 id=&#34;5-事件循环-和-io-复用的关系&#34;&gt;5. 事件循环 和 IO 复用的关系&lt;/h2&gt;
&lt;p&gt;强调 epoll 相较 select 的性能优势（select的O(n) vs epoll的O(1)），并提到Nginx如何利用epoll实现高并发&lt;/p&gt;
&lt;p&gt;事件循环是什么? 怎么实现的?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;应用总结: &lt;strong&gt;高并发Web服务器&lt;/strong&gt;：如Node.js、FastAPI，处理大量HTTP请求&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;51-事件循环-event-loop&#34;&gt;5.1. 事件循环 Event Loop&lt;/h3&gt;
&lt;p&gt;事件循环 是一种编程架构，用于处理和协调异步操作（主要是 IO 操作，如网络请求、文件读写等），它通过一个循环不断检查是否有事件（如 IO 操作完成、定时器触发）需要处理，&lt;strong&gt;并在事件发生时调用相应的回调函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事件循环的核心思想：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;1 非阻塞&lt;/strong&gt;：事件循环允许程序在等待 IO 操作（如网络数据到达、文件读取完成）时不被阻塞，而是继续执行其他任务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2 事件驱动&lt;/strong&gt;：程序通过注册事件（event）和回调函数（callback），当事件发生时，事件循环触发对应的回调来处理结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;事件循环的典型流程：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检查&lt;strong&gt;事件队列&lt;/strong&gt;是否有待处理的事件&lt;/li&gt;
&lt;li&gt;如果有事件，取出事件并执行对应的回调函数&lt;/li&gt;
&lt;li&gt;执行完回调后，继续循环检查队列，直到程序结束&lt;/li&gt;
&lt;li&gt;如果没有事件，事件循环可能进入休眠状态（阻塞等待新事件），以避免 CPU 空转&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;52-libuv-库---事件循环--io-复用&#34;&gt;5.2. libuv 库 - 事件循环 + IO 复用&lt;/h3&gt;
&lt;p&gt;Node.js 的事件循环实现依赖于 &lt;strong&gt;libuv&lt;/strong&gt; 库, 这是一个跨平台的异步 I/O 库, 用 C 语言编写, &lt;strong&gt;libuv&lt;/strong&gt; 是 Node.js 的底层支柱, Node.js 通过 &lt;strong&gt;V8 引擎&lt;/strong&gt;执行 JavaScript 代码, 并通过 &lt;strong&gt;libuv&lt;/strong&gt; 处理异步事件和 I/O 操作&lt;/p&gt;
&lt;p&gt;事件循环是 libuv 的核心机制, 它本质上是一个&lt;strong&gt;状态机&lt;/strong&gt;, 不断地检查是否有事件需要处理, 并按照特定顺序处理这些事件:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;libuv 事件循环过程
├── Timers
│   ├── 处理 setTimeout() 和 setInterval() 的回调
│   └── 回调放入 Timers 队列
│
├── I/O 回调
│   ├── 处理一些系统操作的回调（如 TCP 错误）
│   └── 回调放入 I/O 回调队列
│
├── Poll
│   ├── 获取新的 I/O 事件
│   ├── 执行与 I/O 相关的回调
│   ├── 使用 IO 复用技术（如 epoll, kqueue, IOCP）
│   └── 回调放入 Poll 队列
│
├── Check
│   ├── 处理 setImmediate() 的回调
│   └── 回调放入 Check 队列
│
├── Close Callbacks
│   ├── 处理关闭事件的回调（如 socket.on(&amp;#39;close&amp;#39;)）
│   └── 回调放入 Close Callbacks 队列
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;IO 复用就是(只能) 用来监视多个文件描述符（网络连接、文件）变得可读或可写, 你猜他为什么叫 IO 复用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fs&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;require&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;fs&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;require&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;http&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;1. 程序开始执行&amp;#39;&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 主线程直接执行，不属于事件循环的任何阶段
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 设置一个定时器，回调将在 Timers 阶段执行
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;setTimeout&lt;/span&gt;(() =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2. 定时器回调执行&amp;#39;&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 由 libuv 的 Timers 阶段处理，V8 执行 JavaScript 回调
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 在定时器回调中设置的 immediate 会在下一次事件循环的 Check 阶段执行
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;setImmediate&lt;/span&gt;(() =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;5. setImmediate 回调执行&amp;#39;&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 由 libuv 的 Check 阶段处理，V8 执行回调
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 在定时器回调中发起的文件读取操作
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;fs&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;readFile&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;example.txt&amp;#39;&lt;/span&gt;, (&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;) =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 文件 I/O 完成后，此回调会被放入 Poll 阶段的队列
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 由 libuv 通过操作系统的 IO 复用机制(epoll/kqueue/IOCP)监控文件描述符
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;6. 文件读取回调执行&amp;#39;&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 由 libuv 的 Poll 阶段处理，V8 执行回调
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 在文件读取回调中设置的定时器
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;setTimeout&lt;/span&gt;(() =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;8. 嵌套定时器回调执行&amp;#39;&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 下一次事件循环的 Timers 阶段执行
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 创建 HTTP 服务器
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;server&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;createServer&lt;/span&gt;((&lt;span style=&#34;color:#a6e22e&#34;&gt;req&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;) =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 网络 I/O 回调，当有 HTTP 请求时，此回调会在 Poll 阶段执行
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;7. HTTP 请求回调执行&amp;#39;&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 由 libuv 的 Poll 阶段处理，V8 执行回调
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;end&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Hello World&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 关闭服务器
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;server&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;close&lt;/span&gt;(() =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 关闭回调会在 Close Callbacks 阶段执行
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;9. 服务器关闭回调执行&amp;#39;&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 由 libuv 的 Close Callbacks 阶段处理，V8 执行回调
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 立即设置的 immediate 会在当前事件循环的 Check 阶段执行
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;setImmediate&lt;/span&gt;(() =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;4. 立即的 setImmediate 回调执行&amp;#39;&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 由 libuv 的 Check 阶段处理，V8 执行回调
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 发起一个网络请求
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;http://localhost:3000&amp;#39;&lt;/span&gt;, (&lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;) =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 网络 I/O 回调，此回调会在 Poll 阶段执行
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 由 libuv 通过操作系统的 IO 复用机制监控网络套接字
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;on&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;data&amp;#39;&lt;/span&gt;, (&lt;span style=&#34;color:#a6e22e&#34;&gt;chunk&lt;/span&gt;) =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;收到数据:&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;chunk&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;toString&lt;/span&gt;());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 启动服务器
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;server&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;listen&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;3000&lt;/span&gt;, () =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;3. 服务器启动回调执行&amp;#39;&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 由 libuv 的 Poll 阶段处理，V8 执行回调
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0. 主线程代码结束&amp;#39;&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 主线程直接执行，不属于事件循环的任何阶段
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;libuv 的角色&lt;/strong&gt;：负责管理事件循环和异步 I/O 操作，使用操作系统的 IO 复用机制（如 epoll、kqueue、IOCP）监控文件描述符和网络套接字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;V8 的角色&lt;/strong&gt;：执行 JavaScript 代码，包括回调函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;回调队列&lt;/strong&gt;：每个阶段都有自己的回调队列，回调按照注册顺序执行&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;主线程执行
├── console.log(&amp;#39;1. 程序开始执行&amp;#39;)
├── 注册 setTimeout 回调
├── 创建 HTTP 服务器
├── 注册 setImmediate 回调
├── 发起 HTTP GET 请求
├── 启动服务器监听
└── console.log(&amp;#39;0. 主线程代码结束&amp;#39;)
    └── 进入事件循环
        │
        ├── 第一次事件循环迭代
        │   ├── Timers 阶段
        │   │   └── 执行 setTimeout 回调
        │   │       ├── console.log(&amp;#39;2. 定时器回调执行&amp;#39;)
        │   │       ├── 注册 setImmediate 回调
        │   │       └── 启动异步文件读取操作
        │   │
        │   ├── I/O 回调阶段
        │   │   └── (无回调执行)
        │   │
        │   ├── Poll 阶段
        │   │   └── 执行服务器启动回调
        │   │       └── console.log(&amp;#39;3. 服务器启动回调执行&amp;#39;)
        │   │
        │   ├── Check 阶段
        │   │   └── 执行 setImmediate 回调
        │   │       └── console.log(&amp;#39;4. 立即的 setImmediate 回调执行&amp;#39;)
        │   │
        │   └── Close Callbacks 阶段
        │       └── (无回调执行)
        │
        ├── 第二次事件循环迭代
        │   ├── Timers 阶段
        │   │   └── (无回调执行)
        │   │
        │   ├── I/O 回调阶段
        │   │   └── (无回调执行)
        │   │
        │   ├── Poll 阶段
        │   │   └── (等待 I/O 事件)
        │   │
        │   ├── Check 阶段
        │   │   └── 执行第一次循环中注册的 setImmediate 回调
        │   │       └── console.log(&amp;#39;5. setImmediate 回调执行&amp;#39;)
        │   │
        │   └── Close Callbacks 阶段
        │       └── (无回调执行)
        │
        ├── 文件读取完成
        │   └── 第三次事件循环迭代
        │       ├── Timers 阶段
        │       │   └── (无回调执行)
        │       │
        │       ├── I/O 回调阶段
        │       │   └── (无回调执行)
        │       │
        │       ├── Poll 阶段
        │       │   └── 执行文件读取回调
        │       │       ├── console.log(&amp;#39;6. 文件读取回调执行&amp;#39;)
        │       │       └── 注册 setTimeout 回调
        │       │
        │       ├── Check 阶段
        │       │   └── (无回调执行)
        │       │
        │       └── Close Callbacks 阶段
        │           └── (无回调执行)
        │
        ├── HTTP 请求到达
        │   └── 第四次事件循环迭代
        │       ├── Timers 阶段
        │       │   └── 执行文件读取回调中注册的 setTimeout 回调
        │       │       └── console.log(&amp;#39;8. 嵌套定时器回调执行&amp;#39;)
        │       │
        │       ├── I/O 回调阶段
        │       │   └── (无回调执行)
        │       │
        │       ├── Poll 阶段
        │       │   └── 执行 HTTP 请求回调
        │       │       ├── console.log(&amp;#39;7. HTTP 请求回调执行&amp;#39;)
        │       │       └── 关闭服务器
        │       │
        │       ├── Check 阶段
        │       │   └── (无回调执行)
        │       │
        │       └── Close Callbacks 阶段
        │           └── (无回调执行)
        │
        └── 服务器关闭
            └── 最终事件循环迭代
                ├── Timers 阶段
                │   └── (无回调执行)
                │
                ├── I/O 回调阶段
                │   └── (无回调执行)
                │
                ├── Poll 阶段
                │   └── (无回调执行)
                │
                ├── Check 阶段
                │   └── (无回调执行)
                │
                └── Close Callbacks 阶段
                    └── 执行服务器关闭回调
                        └── console.log(&amp;#39;9. 服务器关闭回调执行&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;</content>
    </item>
    
    <item>
      <title>数据库查询 随机 IO 的次数</title>
      <link>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/010-%E9%9A%8F%E6%9C%BAio/</link>
      <pubDate>Wed, 23 Apr 2025 20:18:45 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/010-%E9%9A%8F%E6%9C%BAio/</guid>
      <description>&lt;h2 id=&#34;1-随机磁盘-io&#34;&gt;1. 随机磁盘 I/O&lt;/h2&gt;
&lt;h3 id=&#34;11-随机磁盘-io-的定义&#34;&gt;1.1. 随机磁盘 I/O 的定义&lt;/h3&gt;
&lt;p&gt;B + Tree 索引的时候总是提到 随机磁盘 IO, 这是什么意思呢?&lt;/p&gt;
&lt;p&gt;既然查询的主要事件就是 随机 IO 的时间, 一次查询怎么估算进行的随机 IO 的次数呢?&lt;/p&gt;
&lt;p&gt;读取或写入&lt;strong&gt;彼此不连续、位置不可预测&lt;/strong&gt;的物理块（页、扇区）时，就叫随机（Random）I/O&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;访问顺序跳来跳去 → 每次都要重新定位磁头或重新建立闪存地址映射&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在数据库语境里，随机 I/O 通常指 “把单个 4 KB/8 KB/16 KB 页从持久化介质搬进内存” 这一原子动作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与之对立的是&lt;strong&gt;顺序（Sequential）I/O&lt;/strong&gt;：按连续 LBA 逐块读写，一次“拉”大量数据，&lt;strong&gt;定位成本只付一次&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12-为什么随机比顺序慢得多&#34;&gt;1.2. 为什么“随机”比“顺序”慢得多？&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;介质&lt;/th&gt;
          &lt;th&gt;顺序 I/O 吞吐&lt;/th&gt;
          &lt;th&gt;随机 I/O 吞吐&lt;/th&gt;
          &lt;th&gt;随机单次延迟主要来源&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;机械硬盘 (HDD)&lt;/td&gt;
          &lt;td&gt;200 MB/s&lt;/td&gt;
          &lt;td&gt;≈ 1 MB/s (≈ 200×差)&lt;/td&gt;
          &lt;td&gt;寻道 + 旋转等待 (ms)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;SATA SSD&lt;/td&gt;
          &lt;td&gt;550 MB/s&lt;/td&gt;
          &lt;td&gt;40 MB/s&lt;/td&gt;
          &lt;td&gt;闪存块映射、队列对齐 (µs)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;NVMe SSD&lt;/td&gt;
          &lt;td&gt;3 GB/s&lt;/td&gt;
          &lt;td&gt;500 MB/s&lt;/td&gt;
          &lt;td&gt;同上，但控制器更快 (µs)&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;随机 I/O 把&lt;strong&gt;定位成本&lt;/strong&gt;均摊到 16 KB 这种很小的 payload 上, 顺序 I/O 则把定位成本摊到数百 KB ～数 MB, 故单位数据成本悬殊&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-随机磁盘-io&#34;&gt;1. 随机磁盘 I/O&lt;/h2&gt;
&lt;h3 id=&#34;11-随机磁盘-io-的定义&#34;&gt;1.1. 随机磁盘 I/O 的定义&lt;/h3&gt;
&lt;p&gt;B + Tree 索引的时候总是提到 随机磁盘 IO, 这是什么意思呢?&lt;/p&gt;
&lt;p&gt;既然查询的主要事件就是 随机 IO 的时间, 一次查询怎么估算进行的随机 IO 的次数呢?&lt;/p&gt;
&lt;p&gt;读取或写入&lt;strong&gt;彼此不连续、位置不可预测&lt;/strong&gt;的物理块（页、扇区）时，就叫随机（Random）I/O&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;访问顺序跳来跳去 → 每次都要重新定位磁头或重新建立闪存地址映射&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在数据库语境里，随机 I/O 通常指 “把单个 4 KB/8 KB/16 KB 页从持久化介质搬进内存” 这一原子动作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与之对立的是&lt;strong&gt;顺序（Sequential）I/O&lt;/strong&gt;：按连续 LBA 逐块读写，一次“拉”大量数据，&lt;strong&gt;定位成本只付一次&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12-为什么随机比顺序慢得多&#34;&gt;1.2. 为什么“随机”比“顺序”慢得多？&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;介质&lt;/th&gt;
          &lt;th&gt;顺序 I/O 吞吐&lt;/th&gt;
          &lt;th&gt;随机 I/O 吞吐&lt;/th&gt;
          &lt;th&gt;随机单次延迟主要来源&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;机械硬盘 (HDD)&lt;/td&gt;
          &lt;td&gt;200 MB/s&lt;/td&gt;
          &lt;td&gt;≈ 1 MB/s (≈ 200×差)&lt;/td&gt;
          &lt;td&gt;寻道 + 旋转等待 (ms)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;SATA SSD&lt;/td&gt;
          &lt;td&gt;550 MB/s&lt;/td&gt;
          &lt;td&gt;40 MB/s&lt;/td&gt;
          &lt;td&gt;闪存块映射、队列对齐 (µs)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;NVMe SSD&lt;/td&gt;
          &lt;td&gt;3 GB/s&lt;/td&gt;
          &lt;td&gt;500 MB/s&lt;/td&gt;
          &lt;td&gt;同上，但控制器更快 (µs)&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;随机 I/O 把&lt;strong&gt;定位成本&lt;/strong&gt;均摊到 16 KB 这种很小的 payload 上, 顺序 I/O 则把定位成本摊到数百 KB ～数 MB, 故单位数据成本悬殊&lt;/p&gt;
&lt;h3 id=&#34;13-数据库为何经常出现随机-io&#34;&gt;1.3. 数据库为何经常出现随机 I/O？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;B⁺Tree 把整张表拆成很多 16 KB 页, 键值排序后&lt;strong&gt;物理位置不再按主键连续&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一次查询只需要极少量行 ⇒ 只读几个离散页&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并发事务各跑各的语句 ⇒ 访问模式高度交错&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;14-随机-io-在执行计划中的角色&#34;&gt;1.4. 随机 I/O 在执行计划中的角色&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Optimizer 估算“若某条索引路径需 n 个&lt;strong&gt;未命中的页&lt;/strong&gt;” ⇒ 代价 = n × (随机 I/O 单价)&lt;/li&gt;
&lt;li&gt;高度 h = 3 的 B⁺Tree：理论最坏 3 次随机读即可命中目标叶子 ⇒ 成本大幅低于全表顺序扫（需读很多页）&lt;/li&gt;
&lt;li&gt;Buffer Pool 命中 ⇒ 把“随机 I/O”降为“逻辑读”，代价由毫秒/微秒→纳秒级&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;15-典型日志指标中如何看到随机-io&#34;&gt;1.5. 典型日志/指标中如何看到随机 I/O&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;SHOW STATUS LIKE &#39;Innodb_buffer_pool_reads&#39;;&lt;/code&gt; → 物理随机读次数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Performance Schema 表 ⁠file_summary_by_instance.*&lt;/code&gt; → 按文件统计随机 I/O 次数与平均延迟&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;16-一次二级索引等值查找&#34;&gt;1.6. 一次二级索引等值查找&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;索引根页不在缓存 → 随机读取 16 KB&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内部页 miss → 再随机读取 16 KB&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;叶子页 miss → 第三次随机读取&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果页面已缓存, 上述步骤变成 0 次随机 I/O, 仅逻辑读&lt;/p&gt;
&lt;p&gt;取到主键 → 去聚簇索引重走 1～3 步 ⇒ 最多再 3 次随机 I/O&lt;/p&gt;
&lt;p&gt;因此常说 “随机 I/O 次数 ≈ 树高（+回表）”&lt;/p&gt;
&lt;h2 id=&#34;2-磁盘随机-io-次数怎么计算的&#34;&gt;2. 磁盘随机 IO 次数怎么计算的&lt;/h2&gt;
&lt;p&gt;下面只讨论 &lt;strong&gt;InnoDB&lt;/strong&gt;（8.x）+ &lt;strong&gt;B⁺Tree&lt;/strong&gt; 的情形, 重点说明&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;随机 I/O “怎么数”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;影响它的典型因素与估算方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;21-概念对齐&#34;&gt;2.1. 概念对齐&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;名词&lt;/th&gt;
          &lt;th&gt;含义&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;随机 I/O 次数&lt;/td&gt;
          &lt;td&gt;查询执行过程中&lt;strong&gt;不得不从磁盘把某个页读取进 Buffer Pool 的次数&lt;/strong&gt;（若页已命中缓冲，则记作逻辑读，不计入随机 I/O）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;树高 h&lt;/td&gt;
          &lt;td&gt;自根页 → 目标叶子页所需经过的层数；根也算 1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;回表 (bookmark lookup)&lt;/td&gt;
          &lt;td&gt;二级索引命中后, 再去聚簇索引找整行所触发的额外路径&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;22-单条记录查询时的估算公式&#34;&gt;2.2. 单条记录查询时的估算公式&lt;/h3&gt;
&lt;p&gt;假设页都不在缓冲区（最坏情形）&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;查询类型&lt;/th&gt;
          &lt;th&gt;随机 I/O 估算&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;PRIMARY KEY 等值&lt;/td&gt;
          &lt;td&gt;h(PK)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;二级索引等值（唯一）&lt;/td&gt;
          &lt;td&gt;h(Secondary) + h(PK)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;二级索引非唯一，匹配 k 条&lt;/td&gt;
          &lt;td&gt;h(Secondary) + k × h(PK) + (k – 1)（额外叶子页）&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;说明&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根页通常常驻内存，可把最顶层减 1；但在“最坏估算”里仍按 h 计算&lt;/li&gt;
&lt;li&gt;如果同一叶子页内包含多条目标记录，只算 1 次随机 I/O&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;23-range-scan--全表扫描&#34;&gt;2.3. Range-Scan / 全表扫描&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;场景&lt;/th&gt;
          &lt;th&gt;随机 I/O 估算&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;主键顺序扫整表&lt;/td&gt;
          &lt;td&gt;页数 = &lt;strong&gt;⌈行数 ÷ 每页行数⌉&lt;/strong&gt; → 近似顺序 I/O，成本常按“顺序读”估算而非随机&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;二级索引范围 (l ≈ r)&lt;/td&gt;
          &lt;td&gt;h(Secondary) + #命中叶子页 + 回表成本（同上）&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;24-多表-join-时如何累加&#34;&gt;2.4. 多表 JOIN 时如何累加&lt;/h3&gt;
&lt;p&gt;优化器使用**块嵌套循环（BNL）或索引嵌套循环（BKA）**等模型；以下给最常见的“嵌套循环 + 内表走索引”场景：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;随机 I/O ≈ outer_rows_not_in_cache × outer_row_cost + outer_rows × (inner_index_height + inner_pk_height)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;outer_row_cost 指外表行本身的读取成本（可能为 0，若外表已全缓冲）&lt;/li&gt;
&lt;li&gt;inner_index_height 与 inner_pk_height 计算规则同上&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;25-optimizer-如何拿到这些数字&#34;&gt;2.5. Optimizer 如何拿到这些数字&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;统计信息 (⁠ANALYZE TABLE) 告诉它行数、基数、平均每页记录数&lt;/li&gt;
&lt;li&gt;⁠innodb_page_size 决定页大小；结合记录长度可推算每页能放几条&lt;/li&gt;
&lt;li&gt;根页、最热的几层常常假设缓存命中 → 物理 I/O 被扣掉&lt;/li&gt;
&lt;li&gt;剩余部分按一次访问 &lt;em&gt;=&lt;/em&gt; 一次随机 &lt;em&gt;I/O&lt;/em&gt;的假设累加&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;⁠&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SHOW&lt;/span&gt; STATUS &lt;span style=&#34;color:#66d9ef&#34;&gt;LIKE&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;InnoDB_buffer_pool_read%&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;变量&lt;/th&gt;
          &lt;th&gt;含义&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Innodb_buffer_pool_read_requests&lt;/td&gt;
          &lt;td&gt;逻辑读（包括命中）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Innodb_buffer_pool_reads&lt;/td&gt;
          &lt;td&gt;物理随机读（未命中）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Innodb_buffer_pool_pages_flushed&lt;/td&gt;
          &lt;td&gt;物理写&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;26-例子-二级索引等值查询&#34;&gt;2.6. 例子 二级索引等值查询&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; age 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt;   users 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt;  name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Grace&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;已知&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;h(Secondary)=3&lt;/code&gt;，&lt;code&gt;h(PK)=3&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&#39;Grace&#39;&lt;/code&gt; 唯一&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;随机 I/O 估算&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;二级索引：3 页&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;回表：再次走聚簇 3 页&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;==&amp;gt; 总计 6 次（若根页 &amp;amp; 内部页已缓存，可能只剩 1~2 次实际磁盘 I/O）&lt;/p&gt;
&lt;h3 id=&#34;27-例子-索引嵌套循环连接-inlj&#34;&gt;2.7. 例子 索引嵌套循环连接 INLJ&lt;/h3&gt;
&lt;p&gt;假设所有目标页&lt;strong&gt;最开始都不在 Buffer Pool&lt;/strong&gt;（最坏路径）, 介质为 NVMe（一次随机 I/O≈ 20 µs）, 页大小 16 KB&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;表&lt;/th&gt;
          &lt;th&gt;主键聚簇索引&lt;/th&gt;
          &lt;th&gt;辅助索引&lt;/th&gt;
          &lt;th&gt;行数 (N)&lt;/th&gt;
          &lt;th&gt;平均行长&lt;/th&gt;
          &lt;th&gt;行 / 页 (估)&lt;/th&gt;
          &lt;th&gt;页数&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;orders&lt;/td&gt;
          &lt;td&gt;(id)&lt;/td&gt;
          &lt;td&gt;(customer_id, id)&lt;/td&gt;
          &lt;td&gt;1 000 000&lt;/td&gt;
          &lt;td&gt;150 B&lt;/td&gt;
          &lt;td&gt;≈100&lt;/td&gt;
          &lt;td&gt;≈10 000&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;order_items&lt;/td&gt;
          &lt;td&gt;(id)&lt;/td&gt;
          &lt;td&gt;(order_id, id)&lt;/td&gt;
          &lt;td&gt;5 000 000&lt;/td&gt;
          &lt;td&gt;120 B&lt;/td&gt;
          &lt;td&gt;≈120&lt;/td&gt;
          &lt;td&gt;≈41 700&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;两棵 B⁺Tree（聚簇 + 二级）高度都为 3：Root→Internal→Leaf&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;根页常驻内存&lt;/strong&gt;，但在“最坏估算”里仍计 1 次 I/O&lt;/li&gt;
&lt;li&gt;每遇到一层，可能触发一次随机 I/O；一次 miss = 1 次 I/O&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;查询&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SELECT  o.id, oi.product_id
FROM    orders       o
JOIN    order_items  oi  ON oi.order_id = o.id
WHERE   o.customer_id = 123;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;场景参数（假设）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;名称&lt;/th&gt;
          &lt;th&gt;数值&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;orders.customer_id = 123 的订单数&lt;/td&gt;
          &lt;td&gt;100 行&lt;/td&gt;
          &lt;td&gt;外表有 100 行&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;一张订单的明细数&lt;/td&gt;
          &lt;td&gt;5 行&lt;/td&gt;
          &lt;td&gt;内表平均值 5 行&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;B+Tree 高度&lt;/td&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;根 + 内部 + 叶子&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;查询开始时 Buffer Pool 为空&lt;/td&gt;
          &lt;td&gt;最坏路径；所有碰到的页都会 miss&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;访问外表 &lt;code&gt;orders&lt;/code&gt; 的随机 I/O&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;步骤（一次性完成）&lt;/th&gt;
          &lt;th&gt;随机 I/O 次数&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;a. 走二级复合索引 ⁠(customer_id, id)&lt;/td&gt;
          &lt;td&gt;3 页&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;b. 回到聚簇索引拿整行&lt;/td&gt;
          &lt;td&gt;3 页&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;c. 继续扫描叶子页把 100 行都读完&lt;/td&gt;
          &lt;td&gt;1 页（100 行刚好在同一叶子）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;小计&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;&lt;strong&gt;7 次&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;说明&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“走索引 3 页”= 根 1 + 内部 1 + 叶子 1&lt;/li&gt;
&lt;li&gt;“回表再 3 页” 同理&lt;/li&gt;
&lt;li&gt;最后那张叶子页已经在内存，往后读同页不再算随机 I/O&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;查询 customer_id = 123 的所有订单及其订单中包含的商品信息, 这种查询场景 &lt;code&gt;orders&lt;/code&gt; 是外表, &lt;code&gt;order_items oi&lt;/code&gt; 是内表:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;查询从 orders 表（外表）开始&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;WHERE o.customer_id = 123&lt;/code&gt; 条件会先筛选出 &lt;code&gt;orders&lt;/code&gt; 表中所有 &lt;code&gt;customer_id = 123&lt;/code&gt; 的记录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一次成本 IO 次数: 7 次, 这 7 次 加载了一页数据, 假设这一页包含了 100 个订单数据,&lt;/li&gt;
&lt;li&gt;如果 100 个订单需要两页, 则需要 7 + 1 = 8 次 IO, 而不是 7 * 2 = 14, 第二个叶子页只有 &lt;strong&gt;1 I/O&lt;/strong&gt;，而不是再付 7 I/O
&lt;ul&gt;
&lt;li&gt;路径上的根页、内部页已经在内存 → 不再 miss&lt;/li&gt;
&lt;li&gt;只需把第二个叶子页从磁盘搬进来 → 1 I/O&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据库将上一步的 &lt;code&gt;orders&lt;/code&gt; 表结果与 &lt;code&gt;order_items&lt;/code&gt; 表（内表）进行 &lt;code&gt;INNER JOIN&lt;/code&gt;, 根据 &lt;code&gt;ON oi.order_id = o.id&lt;/code&gt; 条件匹配&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一次成本 IO 次数: 同上 7 次, 这只是 对于一个订单, 找出其所有 items 的查询, 平均 5 个 items, 一页肯定放得下, 所以就是 7 次, 不是 上面的那种 可能为 7 + 1 次 或者 7 * 2 次, 即 不会是 2 页, 三页 只用来放了 5 个 item, 当然也有可能,除非 item 很大, 一个就超过 8kb, 2 * 8 &amp;gt;= 16 kb &amp;gt; 一页的大小&lt;/li&gt;
&lt;li&gt;因为有 100 个订单, 查询 100 次, 所以 100 * 7 = 700 次 IO
&lt;ul&gt;
&lt;li&gt;这么计算是错的, 因为 &lt;strong&gt;根页、内部页只在第一次 miss&lt;/strong&gt;, 当处理第 2 ~ 100 张订单时:&lt;/li&gt;
&lt;li&gt;二级索引根 / 内部页 已经在 Buffer Pool&lt;/li&gt;
&lt;li&gt;聚簇索引根 / 内部页 也已在 Buffer Pool&lt;/li&gt;
&lt;li&gt;因此后 99 次只剩：&lt;/li&gt;
&lt;li&gt;索引叶子 1 次 IO + 聚簇叶子 1 次 IO = 2 次, 即 &lt;code&gt;2 IO / 订单&lt;/code&gt; 而不是 7&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第一张订单 7 I/O + 后面 99 张 × 2 I/O ≈ &lt;strong&gt;205 I/O&lt;/strong&gt;, 远小于 700&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总计 内表 order_items 表进行了 205 次 IO + 外表 7 次 IO = 212 次IO&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可见 &lt;strong&gt;真正决定数量级的是：根/内部页是否命中&lt;/strong&gt;, 优化器在成本模型里正是用“根页大概率命中、内部页可能命中、叶子易 miss”这套概率，去预估 I/O 量&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    </item>
    
    <item>
      <title>浅谈序列化</title>
      <link>https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/012-%E6%B5%85%E8%B0%88%E5%BA%8F%E5%88%97%E5%8C%96/</link>
      <pubDate>Tue, 22 Apr 2025 10:03:38 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/012-%E6%B5%85%E8%B0%88%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
      <description>&lt;h2 id=&#34;1-基本定义&#34;&gt;1. 基本定义&lt;/h2&gt;
&lt;p&gt;看看&lt;a href=&#34;https://en.wikipedia.org/wiki/Serialization&#34;&gt;维基百科&lt;/a&gt;的定义:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In computing, serialization is process of translating a data structure or object state into a format that can be stored or transmitted. 序列化是将内存中的数据结构或对象转换为&lt;strong&gt;可存储&lt;/strong&gt;或&lt;strong&gt;传输&lt;/strong&gt;的格式的过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不是很懂, 看来需要一个例子来解释, 下面是我看到的一段话, 有一些疑问:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个表述说: “序列化是将内存中的数据结构或对象转换为可存储或传输的格式（如二进制数据、XML、JSON等）”&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;内存中的数据结构或者对象 已经是二进制数据了  为什么不可以直接传输?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上面的表述说 “如二进制数据、XML、JSON等”, 网络传输不是只能传输 二进制数据吗, 为什么还有 xml 和 json 呢?&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-对象在内存中的样子&#34;&gt;2. 对象在内存中的样子&lt;/h2&gt;
&lt;p&gt;表面上看, 内存中的数据确实是二进制字节（0 和 1）, 但这些字节的组织方式和语义高度依赖于程序的运行时环境, 直接传输这些字节会导致&lt;strong&gt;接收端无法正确解析&lt;/strong&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Student&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Name&lt;/span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Age&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Score&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;float64&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Active&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;student&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Student&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;Name&lt;/span&gt;:   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Alice&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;Age&lt;/span&gt;:    &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;Score&lt;/span&gt;:  &lt;span style=&#34;color:#ae81ff&#34;&gt;95.5&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;Active&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Student: %+v\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;student&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Size of Student: %d bytes\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Sizeof&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;student&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行结果 arm64 系统:&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-基本定义&#34;&gt;1. 基本定义&lt;/h2&gt;
&lt;p&gt;看看&lt;a href=&#34;https://en.wikipedia.org/wiki/Serialization&#34;&gt;维基百科&lt;/a&gt;的定义:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In computing, serialization is process of translating a data structure or object state into a format that can be stored or transmitted. 序列化是将内存中的数据结构或对象转换为&lt;strong&gt;可存储&lt;/strong&gt;或&lt;strong&gt;传输&lt;/strong&gt;的格式的过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不是很懂, 看来需要一个例子来解释, 下面是我看到的一段话, 有一些疑问:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个表述说: “序列化是将内存中的数据结构或对象转换为可存储或传输的格式（如二进制数据、XML、JSON等）”&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;内存中的数据结构或者对象 已经是二进制数据了  为什么不可以直接传输?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上面的表述说 “如二进制数据、XML、JSON等”, 网络传输不是只能传输 二进制数据吗, 为什么还有 xml 和 json 呢?&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-对象在内存中的样子&#34;&gt;2. 对象在内存中的样子&lt;/h2&gt;
&lt;p&gt;表面上看, 内存中的数据确实是二进制字节（0 和 1）, 但这些字节的组织方式和语义高度依赖于程序的运行时环境, 直接传输这些字节会导致&lt;strong&gt;接收端无法正确解析&lt;/strong&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Student&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Name&lt;/span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Age&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Score&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;float64&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Active&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;student&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Student&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;Name&lt;/span&gt;:   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Alice&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;Age&lt;/span&gt;:    &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;Score&lt;/span&gt;:  &lt;span style=&#34;color:#ae81ff&#34;&gt;95.5&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;Active&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Student: %+v\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;student&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Size of Student: %d bytes\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Sizeof&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;student&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行结果 arm64 系统:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Student: {Name:Alice Age:20 Score:95.5 Active:true}
Size of Student: 40 bytes
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了理解为什么不能直接传输, 我们需要看看 &lt;code&gt;Student&lt;/code&gt; 结构体在内存中的实际布局:&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;字段&lt;/th&gt;
          &lt;th&gt;大小&lt;/th&gt;
          &lt;th&gt;内存内容（示例）&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Name (ptr)&lt;/td&gt;
          &lt;td&gt;8 字节&lt;/td&gt;
          &lt;td&gt;指针，指向 &amp;ldquo;Alice&amp;rdquo; 的内存地址（如 &lt;code&gt;0x12345678&lt;/code&gt;）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Name (len)&lt;/td&gt;
          &lt;td&gt;8 字节&lt;/td&gt;
          &lt;td&gt;字符串长度（&lt;code&gt;5&lt;/code&gt;，表示 &amp;ldquo;Alice&amp;rdquo; 的长度）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Age&lt;/td&gt;
          &lt;td&gt;8 字节&lt;/td&gt;
          &lt;td&gt;整数 &lt;code&gt;20&lt;/code&gt;（二进制表示）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Score&lt;/td&gt;
          &lt;td&gt;8 字节&lt;/td&gt;
          &lt;td&gt;浮点数 &lt;code&gt;95.5&lt;/code&gt;（IEEE 754 格式）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Active&lt;/td&gt;
          &lt;td&gt;1 字节&lt;/td&gt;
          &lt;td&gt;布尔值 &lt;code&gt;1&lt;/code&gt;（true）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Padding&lt;/td&gt;
          &lt;td&gt;7 字节&lt;/td&gt;
          &lt;td&gt;填充字节（通常为 0，用于对齐）&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;在 Go 中, string 是一个结构体, 包含两个字段:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指向字符串数据的指针（&lt;code&gt;unsafe.Pointer&lt;/code&gt;, 8 字节）&lt;/li&gt;
&lt;li&gt;字符串长度（&lt;code&gt;int&lt;/code&gt;, 8 字节）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以 string 总共占用 16 字节, 例如，&lt;code&gt;Name: &amp;quot;Alice&amp;quot;&lt;/code&gt; 的实际数据（&lt;code&gt;&amp;quot;Alice&amp;quot;&lt;/code&gt; 的字节 &lt;code&gt;[65, 108, 105, 99, 101]&lt;/code&gt;）存储在内存的某个区域，&lt;code&gt;Name&lt;/code&gt; 字段只保存指向该区域的指针和长度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设 &lt;code&gt;student&lt;/code&gt; 结构体存储在内存地址 &lt;code&gt;0x1000&lt;/code&gt;，其二进制数据可能如下（简化表示）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0x1000 - 0x1007&lt;/code&gt;：&lt;code&gt;Name&lt;/code&gt; 的指针（例如 &lt;code&gt;0x12345678&lt;/code&gt;，指向 &lt;code&gt;&amp;quot;Alice&amp;quot;&lt;/code&gt; 的实际数据的地址）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0x1008 - 0x100F&lt;/code&gt;：&lt;code&gt;Name&lt;/code&gt; 的长度（&lt;code&gt;5&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0x1010 - 0x1017&lt;/code&gt;：&lt;code&gt;Age&lt;/code&gt; 的值（&lt;code&gt;20&lt;/code&gt;，二进制 &lt;code&gt;00000014&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0x1018 - 0x101F&lt;/code&gt;：&lt;code&gt;Score&lt;/code&gt; 的值（&lt;code&gt;95.5&lt;/code&gt;，IEEE 754 格式的二进制）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0x1020&lt;/code&gt;：&lt;code&gt;Active&lt;/code&gt; 的值（&lt;code&gt;1&lt;/code&gt;，表示 &lt;code&gt;true&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0x1021 - 0x1027&lt;/code&gt;：填充字节（&lt;code&gt;0&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;关键点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Name&lt;/code&gt; 字段的指针（&lt;code&gt;0x12345678&lt;/code&gt;）指向内存中 &lt;code&gt;&amp;quot;Alice&amp;quot;&lt;/code&gt; 的实际数据（&lt;code&gt;[65, 108, 105, 99, 101]&lt;/code&gt;）的地址&lt;/li&gt;
&lt;li&gt;这些二进制数据高度依赖 Go 的运行时环境，比如：
&lt;ul&gt;
&lt;li&gt;指针地址（&lt;code&gt;0x12345678&lt;/code&gt;）只在当前程序的内存空间有效&lt;/li&gt;
&lt;li&gt;内存对齐和填充字节依赖于 Go 编译器和 CPU 架构&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;Alice&amp;quot;&lt;/code&gt; 的实际数据存储在堆上，由 Go 的垃圾回收器管理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-内存中的数据结构已经是二进制数据为什么不能直接传输&#34;&gt;3. 内存中的数据结构已经是二进制数据，为什么不能直接传输？&lt;/h2&gt;
&lt;p&gt;现在，假设我们将这 40 字节的二进制数据（从 &lt;code&gt;0x1000&lt;/code&gt; 到 &lt;code&gt;0x1027&lt;/code&gt;）直接传输到另一台机器, 接收端会遇到以下问题:&lt;/p&gt;
&lt;h3 id=&#34;31-指针无效&#34;&gt;3.1. 指针无效&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;问题&lt;/strong&gt;：&lt;code&gt;Name&lt;/code&gt; 字段的指针（&lt;code&gt;0x12345678&lt;/code&gt;）指向当前程序的内存地址, 在接收端的机器上, 这个地址要么无效（指向不存在的内存）, 要么指向完全无关的数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后果&lt;/strong&gt;：接收端无法访问 &lt;code&gt;&amp;quot;Alice&amp;quot;&lt;/code&gt; 的实际数据（&lt;code&gt;[65, 108, 105, 99, 101]&lt;/code&gt;），因为这些数据没有随结构体一起传输&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解决方法&lt;/strong&gt;：序列化（如 JSON）会将 &lt;code&gt;&amp;quot;Alice&amp;quot;&lt;/code&gt; 的实际内容嵌入到序列化数据中, 而不是只传输指针, 例如, JSON 会生成 &lt;code&gt;{&amp;quot;name&amp;quot;:&amp;quot;Alice&amp;quot;,...}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-缺少类型信息&#34;&gt;3.2. 缺少类型信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;问题&lt;/strong&gt;：内存中的二进制数据没有显式的类型信息, 接收端不知道：
&lt;ul&gt;
&lt;li&gt;这 32 字节代表一个 &lt;code&gt;Student&lt;/code&gt; 结构体&lt;/li&gt;
&lt;li&gt;前 16 字节是 &lt;code&gt;string&lt;/code&gt;，接下来的 8 字节是 &lt;code&gt;int&lt;/code&gt;，等等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后果&lt;/strong&gt;：接收端无法正确解析二进制数据，除非它运行完全相同的 Go 程序（相同的结构体定义和编译器）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解决方法&lt;/strong&gt;：序列化格式（如 JSON）通过键值对显式定义字段名和值（&lt;code&gt;{&amp;quot;name&amp;quot;:&amp;quot;Alice&amp;quot;,&amp;quot;age&amp;quot;:20}&lt;/code&gt;），接收端根据字段名重建数据结构&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;33-内存布局不兼容&#34;&gt;3.3. 内存布局不兼容&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;问题&lt;/strong&gt;：不同系统、编译器或 Go 版本可能有不同的内存布局：
&lt;ul&gt;
&lt;li&gt;32 位 vs. 64 位系统：&lt;code&gt;int&lt;/code&gt; 和指针的大小不同（4 字节 vs. 8 字节）&lt;/li&gt;
&lt;li&gt;内存对齐规则：某些系统可能不使用 8 字节对齐，填充字节不同&lt;/li&gt;
&lt;li&gt;字段顺序：编译器可能重新排列字段以优化内存访问（尽管 Go 通常按声明顺序）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后果&lt;/strong&gt;：接收端可能错误解析字段, 例如，接收端可能将 &lt;code&gt;Age&lt;/code&gt; 的 8 字节解析为两个 4 字节字段，导致数据错乱&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解决方法&lt;/strong&gt;：序列化格式（如 JSON）是标准化的，字段顺序和类型由格式定义（如 &lt;code&gt;{&amp;quot;name&amp;quot;:&amp;quot;Alice&amp;quot;,&amp;quot;age&amp;quot;:20}&lt;/code&gt;），与内存布局无关&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;34-跨语言和跨平台问题&#34;&gt;3.4. 跨语言和跨平台问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;问题&lt;/strong&gt;：如果接收端不是 Go 程序（比如 Python 或 Java），它无法理解 Go 的内存布局（指针、字符串结构体、内存对齐等）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后果&lt;/strong&gt;：非 Go 程序无法解析这 32 字节的二进制数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解决方法&lt;/strong&gt;：序列化格式（如 JSON、XML）是语言无关的，Python 和 Java 都能解析 &lt;code&gt;{&amp;quot;name&amp;quot;:&amp;quot;Alice&amp;quot;,&amp;quot;age&amp;quot;:20}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;35-示例直接传输的失败场景&#34;&gt;3.5. 示例：直接传输的失败场景&lt;/h3&gt;
&lt;p&gt;假设我们将 &lt;code&gt;student&lt;/code&gt; 的 32 字节内存数据传输到另一台机器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送端：传输 &lt;code&gt;[0x12345678, 5, 20, 95.5, 1, 0, 0, 0, 0, 0, 0, 0]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;接收端：
&lt;ul&gt;
&lt;li&gt;看到 &lt;code&gt;0x12345678&lt;/code&gt;，但这个地址无效，无法找到 &lt;code&gt;&amp;quot;Alice&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不知道前 16 字节是 &lt;code&gt;string&lt;/code&gt;，可能误以为是两个 &lt;code&gt;int64&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;内存对齐不同，可能将 &lt;code&gt;Age&lt;/code&gt; 的 8 字节解析为其他类型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;结果：数据完全不可用&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;所以我对序列化的理解是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;序列化&lt;/strong&gt;是将内存中的对象转换为一种&lt;strong&gt;约定好的格式&lt;/strong&gt;（如 Protobuf、JSON、Gob、XML 等）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这些格式在网络传输时仍然是&lt;strong&gt;二进制数据&lt;/strong&gt;（字节流）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但这些二进制数据是按照&lt;strong&gt;约定的格式&lt;/strong&gt;组织的，而不是内存中对象的&lt;strong&gt;原始内存格式&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;4-更上一层楼-加深理解&#34;&gt;4. 更上一层楼 (加深理解)&lt;/h2&gt;
&lt;h3 id=&#34;41-序列化是将内存对象转为约定格式&#34;&gt;4.1. 序列化是将内存对象转为约定格式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;内存中的对象（比如 Go 的 &lt;code&gt;struct&lt;/code&gt;）包含复杂的信息：指针、类型元数据、内存对齐填充、运行时状态等&lt;/li&gt;
&lt;li&gt;序列化的目的是将这些对象转换为一种标准化的、平台无关的格式
&lt;ul&gt;
&lt;li&gt;去除指针，直接嵌入实际数据（比如 &lt;code&gt;&amp;quot;Alice&amp;quot;&lt;/code&gt; 的字符），&lt;strong&gt;只保留数据的逻辑内容&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;去除了填充和运行时元数据&lt;/li&gt;
&lt;li&gt;使用标准化的结构（键值对、字段标签等），确保跨平台、跨语言可解析&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;例如：
&lt;ul&gt;
&lt;li&gt;JSON：&lt;code&gt;{&amp;quot;name&amp;quot;:&amp;quot;Alice&amp;quot;,&amp;quot;age&amp;quot;:20}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Protobuf：紧凑的二进制格式，包含字段标签和值&lt;/li&gt;
&lt;li&gt;Gob：Go 专用的二进制格式，包含类型信息和数据&lt;/li&gt;
&lt;li&gt;XML：&lt;code&gt;&amp;lt;person&amp;gt;&amp;lt;name&amp;gt;Alice&amp;lt;/name&amp;gt;&amp;lt;age&amp;gt;20&amp;lt;/age&amp;gt;&amp;lt;/person&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;42-传输时是二进制数据-但按约定格式组织&#34;&gt;4.2. 传输时是二进制数据, 但按约定格式组织：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;网络传输只能传输二进制字节流（0 和 1）&lt;/li&gt;
&lt;li&gt;序列化后的数据（JSON、XML 等）在传输前会被编码为二进制字节流。例如：
&lt;ul&gt;
&lt;li&gt;JSON 字符串 &lt;code&gt;{&amp;quot;name&amp;quot;:&amp;quot;Alice&amp;quot;}&lt;/code&gt; 编码为 UTF-8 字节（&lt;code&gt;[123, 34, 110, 97, 109, 101, 34, ...]&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;Protobuf 直接生成紧凑的二进制字节，包含字段编号和值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;这些字节流的组织方式遵循约定的格式规则（比如 JSON 的键值对结构，Protobuf 的字段标签），&lt;strong&gt;接收端根据相同的规则解析&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;44-代码示例&#34;&gt;4.4. 代码示例&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Student&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Name&lt;/span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Age&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Score&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;float64&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;student&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Student&lt;/span&gt;{&lt;span style=&#34;color:#a6e22e&#34;&gt;Name&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Alice&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;Age&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;Score&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;95.5&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 1. 序列化为 JSON&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;jsonData&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;json&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Marshal&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;student&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fatalf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;JSON 序列化失败: %v&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;JSON 数据:&amp;#34;&lt;/span&gt;, string(&lt;span style=&#34;color:#a6e22e&#34;&gt;jsonData&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;JSON 字节:&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;jsonData&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 2. 序列化为 Gob&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;buf&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bytes&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Buffer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;enc&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;gob&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;NewEncoder&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;buf&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;enc&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Encode&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;student&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fatalf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Gob 序列化失败: %v&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Gob 字节:&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;buf&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Bytes&lt;/span&gt;())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 3. 反序列化 JSON&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;jsonStudent&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Student&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;json&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Unmarshal&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;jsonData&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;jsonStudent&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fatalf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;JSON 反序列化失败: %v&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;JSON 反序列化结果: %+v\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;jsonStudent&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 4. 反序列化 Gob&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;gobStudent&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Student&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;dec&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;gob&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;NewDecoder&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;buf&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;dec&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Decode&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;gobStudent&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fatalf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Gob 反序列化失败: %v&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Gob 反序列化结果: %+v\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;gobStudent&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;输出（部分简化）&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;JSON 数据: {&amp;#34;Name&amp;#34;:&amp;#34;Alice&amp;#34;,&amp;#34;Age&amp;#34;:20,&amp;#34;Score&amp;#34;:95.5}
JSON 字节: [123 34 78 97 109 101 34 58 34 65 108 105 99 101 34 44 ...]
Gob 字节: [40 255 129 3 1 1 7 83 116 117 100 101 110 116 ...]
JSON 反序列化结果: {Name:Alice Age:20 Score:95.5}
Gob 反序列化结果: {Name:Alice Age:20 Score:95.5}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;45-内存数据-vs-序列化数据的对比&#34;&gt;4.5. 内存数据 vs. 序列化数据的对比&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;特性&lt;/th&gt;
          &lt;th&gt;内存中的二进制数据&lt;/th&gt;
          &lt;th&gt;序列化数据（JSON）&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;内容&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;指针、长度、值、填充字节&lt;/td&gt;
          &lt;td&gt;实际数据（&lt;code&gt;&amp;quot;Alice&amp;quot;&lt;/code&gt;、20、95.5、true）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;大小&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;32 字节（固定，含指针和填充）&lt;/td&gt;
          &lt;td&gt;变长（约 50 字节，视数据内容）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;平台依赖&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;高度依赖（指针、内存对齐、架构）&lt;/td&gt;
          &lt;td&gt;平台无关（标准化的文本格式）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;类型信息&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;隐式（依赖 Go 运行时）&lt;/td&gt;
          &lt;td&gt;显式（键值对定义字段和类型）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;跨语言支持&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;不支持（仅 Go 程序可解析）&lt;/td&gt;
          &lt;td&gt;支持（JSON 被广泛支持）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;传输后可用性&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;不可用（指针无效，布局不同）&lt;/td&gt;
          &lt;td&gt;可用（接收端可直接解析）&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;5-常见的序列化库&#34;&gt;5. 常见的序列化库&lt;/h2&gt;
&lt;p&gt;因为不同格式有特定的编码/解码规则和数据结构, 通常每种序列化格式（如 JSON、Gob、Protobuf）都会有对应的库来处理:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JSON 是跨语言的通用格式, 几乎每种语言都有 JSON 库&lt;/li&gt;
&lt;li&gt;Gob 是 Go 特有的二进制格式，仅由 Go 的 encoding/gob 支持&lt;/li&gt;
&lt;li&gt;Protobuf 是一种高效的跨语言二进制格式，需专用库支持&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们分别举例看一下各自怎么做序列化的&lt;/p&gt;
&lt;h3 id=&#34;51-go-序列化&#34;&gt;5.1. Go 序列化&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;JSON 序列化 - 使用 &lt;code&gt;encoding/json&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;encoding/json&lt;/code&gt; 是 Go 标准库提供的 JSON 序列化工具, 最流行且易用:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 创建对象&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Person&lt;/span&gt;{&lt;span style=&#34;color:#a6e22e&#34;&gt;Name&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Alice&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;Age&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 序列化：对象 -&amp;gt; JSON&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;jsonData&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;json&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Marshal&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fatal&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;JSON:&amp;#34;&lt;/span&gt;, string(&lt;span style=&#34;color:#a6e22e&#34;&gt;jsonData&lt;/span&gt;)) &lt;span style=&#34;color:#75715e&#34;&gt;// 输出：JSON: {&amp;#34;name&amp;#34;:&amp;#34;Alice&amp;#34;,&amp;#34;age&amp;#34;:30}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 反序列化：JSON -&amp;gt; 对象&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;p2&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Person&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;json&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Unmarshal&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;jsonData&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;p2&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fatal&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Deserialized:&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;p2&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// 输出：Deserialized: {Alice 30}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Gob 序列化 - 使用 &lt;code&gt;encoding/gob&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;encoding/gob&lt;/code&gt; 是 Go 标准库提供的二进制序列化工具，&lt;strong&gt;仅用于 Go 程序间通信&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-golang&#34; data-lang=&#34;golang&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Person&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Name&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Age&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 创建对象&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Person&lt;/span&gt;{&lt;span style=&#34;color:#a6e22e&#34;&gt;Name&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Alice&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;Age&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 序列化：对象 -&amp;gt; Gob&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;buf&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bytes&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Buffer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;enc&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;gob&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;NewEncoder&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;buf&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;enc&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Encode&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fatal&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Gob bytes:&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;buf&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Bytes&lt;/span&gt;()) &lt;span style=&#34;color:#75715e&#34;&gt;// 输出：Gob bytes: [二进制数据]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 反序列化：Gob -&amp;gt; 对象&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;p2&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Person&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;dec&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;gob&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;NewDecoder&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;buf&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;dec&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Decode&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;p2&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fatal&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Deserialized:&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;p2&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// 输出：Deserialized: {Alice 30}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Protobuf 序列化 - 使用 &lt;code&gt;github.com/golang/protobuf&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Protobuf 是一种高效的跨语言二进制序列化格式, 需定义 &lt;code&gt;.proto&lt;/code&gt; 文件并生成 Go 代码, &lt;code&gt;github.com/golang/protobuf&lt;/code&gt; 是最流行的 Protobuf 实现:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;syntax &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;proto3&amp;#34;&lt;/span&gt;;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; main;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;option&lt;/span&gt; go_package &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;./main&amp;#34;&lt;/span&gt;;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Person&lt;/span&gt; {&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int32&lt;/span&gt; age &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ protoc --go_out&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;. person.proto
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-golang&#34; data-lang=&#34;golang&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 创建 Protobuf 对象&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Person&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;Name&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Alice&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;Age&lt;/span&gt;:  &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 序列化：对象 -&amp;gt; Protobuf&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;protoData&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;proto&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Marshal&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fatal&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Protobuf bytes:&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;protoData&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// 输出：Protobuf bytes: [二进制数据]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 反序列化：Protobuf -&amp;gt; 对象&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;p2&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Person&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;proto&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Unmarshal&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;protoData&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;p2&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fatal&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Deserialized:&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;p2&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// 输出：Deserialized: name:&amp;#34;Alice&amp;#34; age:30&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Protobuf 需要预定义 &lt;code&gt;.proto&lt;/code&gt; 文件，生成 Go 结构体和序列化代码&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;proto.Marshal&lt;/code&gt; 和 &lt;code&gt;proto.Unmarshal&lt;/code&gt; 进行序列化/反序列化&lt;/li&gt;
&lt;li&gt;Protobuf 是高效的二进制格式，适合跨语言、高性能场景&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;52-java-序列化&#34;&gt;5.2. Java 序列化&lt;/h3&gt;
&lt;p&gt;Java 这里只讨论 JSON 序列化, 至于其其他格式, 类似 Golang, 就不讨论了,  &lt;strong&gt;Jackson&lt;/strong&gt; 是 Java 中最流行的 JSON 序列化库&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Main&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 定义 Person 类&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Person&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; String name;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; age;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 构造函数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// Getter 和 Setter&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;@Override&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; String &lt;span style=&#34;color:#a6e22e&#34;&gt;toString&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Person{name=&amp;#39;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; name &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#39;, age=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; age &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;}&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 创建 ObjectMapper&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            ObjectMapper mapper &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ObjectMapper();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 创建对象&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            Person p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Person(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Alice&amp;#34;&lt;/span&gt;, 30);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 序列化：对象 -&amp;gt; JSON&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            String json &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mapper.&lt;span style=&#34;color:#a6e22e&#34;&gt;writeValueAsString&lt;/span&gt;(p);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;JSON: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; json); &lt;span style=&#34;color:#75715e&#34;&gt;// 输出：JSON: {&amp;#34;name&amp;#34;:&amp;#34;Alice&amp;#34;,&amp;#34;age&amp;#34;:30}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 反序列化：JSON -&amp;gt; 对象&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            Person p2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mapper.&lt;span style=&#34;color:#a6e22e&#34;&gt;readValue&lt;/span&gt;(json, Person.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Deserialized: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; p2); &lt;span style=&#34;color:#75715e&#34;&gt;// 输出：Deserialized: Person{name=&amp;#39;Alice&amp;#39;, age=30}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt; (Exception e) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            e.&lt;span style=&#34;color:#a6e22e&#34;&gt;printStackTrace&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ObjectMapper&lt;/code&gt; 是 &lt;code&gt;Jackson&lt;/code&gt; 的核心类，&lt;code&gt;writeValueAsString&lt;/code&gt; 序列化为 JSON 字符串，&lt;code&gt;readValue&lt;/code&gt; 反序列化为对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;53-c-序列化&#34;&gt;5.3. C# 序列化&lt;/h3&gt;
&lt;p&gt;C# 中最流行的 JSON 库是 Json.NET  (&lt;code&gt;Newtonsoft.Json&lt;/code&gt;), 在 .NET 社区中广为人知, 它提供了一组类和方法, 用于:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;序列化&lt;/strong&gt;：将 C# 对象转换为 JSON 字符串&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反序列化&lt;/strong&gt;：将 JSON 字符串转换回 C# 对象&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自定义序列化&lt;/strong&gt;：通过特性（如 &lt;code&gt;[JsonConverter]&lt;/code&gt;）或配置，允许开发者控制 JSON 的格式和行为&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; person = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; { Name = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Alice&amp;#34;&lt;/span&gt;, Age = &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; json = JsonConvert.SerializeObject(person);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 输出: {&amp;#34;Name&amp;#34;:&amp;#34;Alice&amp;#34;,&amp;#34;Age&amp;#34;:30}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; json = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{\&amp;#34;Name\&amp;#34;:\&amp;#34;Alice\&amp;#34;,\&amp;#34;Age\&amp;#34;:30}&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; person = JsonConvert.DeserializeObject&amp;lt;&lt;span style=&#34;color:#66d9ef&#34;&gt;dynamic&lt;/span&gt;&amp;gt;(json);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// person.Name == &amp;#34;Alice&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;JsonConvert&lt;/strong&gt; 是 &lt;strong&gt;Newtonsoft.Json&lt;/strong&gt; 命名空间中的一个静态类, 属于 Json.NET 库&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;6-protobuf-vs-json&#34;&gt;6. &lt;code&gt;protobuf&lt;/code&gt; vs &lt;code&gt;json&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;protobuf&lt;/code&gt; 是用来序列化的, 主要用在进程间通信尤其是 RPC 中, 前面讨论的时候说到:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;序列化是将内存中的数据结构或对象转换为&lt;strong&gt;可存储&lt;/strong&gt;或&lt;strong&gt;传输&lt;/strong&gt;的格式的过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以 &lt;code&gt;protobuf&lt;/code&gt; 也是用来干这个的, 可是为什么要用 &lt;code&gt;protobuf&lt;/code&gt;  呢, 它很快?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;紧凑的二进制格式&lt;/strong&gt;：Protobuf 相比 JSON 的文本格式，数据体积更小（通常比 JSON 小 &lt;strong&gt;3-10 倍&lt;/strong&gt;，具体取决于数据结构）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;高效的序列化/反序列化&lt;/strong&gt;：Protobuf 的编码规则（如变长编码 Varint）优化了 CPU 和内存使用，解析速度比 JSON 快（通常快 &lt;strong&gt;5-100 倍&lt;/strong&gt;，视场景而定）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;61-为什么体积这么小&#34;&gt;6.1. 为什么体积这么小&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Person&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Name&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;#34;Alice&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Age&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 30&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;1-json-的编码&#34;&gt;(1) JSON 的编码&lt;/h4&gt;
&lt;p&gt;JSON 是文本格式，序列化后的结果是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Alice&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;age&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;数据体积&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;{&amp;quot;name&amp;quot;:&amp;quot;Alice&amp;quot;,&amp;quot;age&amp;quot;:30}&lt;/code&gt; 总共 24 个字符（假设 UTF-8 编码，每个字符 1 字节）
&lt;ul&gt;
&lt;li&gt;字段名：&lt;code&gt;&amp;quot;name&amp;quot;&lt;/code&gt;（6 字节，含引号），&lt;code&gt;&amp;quot;age&amp;quot;&lt;/code&gt;（5 字节）&lt;/li&gt;
&lt;li&gt;值：&lt;code&gt;&amp;quot;Alice&amp;quot;&lt;/code&gt;（7 字节，含引号），&lt;code&gt;30&lt;/code&gt;（2 字节）&lt;/li&gt;
&lt;li&gt;分隔符：&lt;code&gt;{&lt;/code&gt;, &lt;code&gt;}&lt;/code&gt;, &lt;code&gt;,&lt;/code&gt;, &lt;code&gt;:&lt;/code&gt;（4 字节）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;总计&lt;/strong&gt;：24 字节&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-protobuf-的编码&#34;&gt;(2) Protobuf 的编码&lt;/h4&gt;
&lt;p&gt;Protobuf 需要先定义 &lt;code&gt;.proto&lt;/code&gt; 文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;syntax &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;proto3&amp;#34;&lt;/span&gt;;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Person&lt;/span&gt; {&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int32&lt;/span&gt; age &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;序列化后的结果是二进制数据（不可读），我们逐步分析其编码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据体积&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;Protobuf 的二进制编码格式为 &lt;code&gt;[field_number][type][value]&lt;/code&gt; 的组合：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;字段 &lt;code&gt;name&lt;/code&gt;（字符串，编号 1）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;字段编号和类型：编号 &lt;code&gt;1&lt;/code&gt;，类型为 &lt;code&gt;string&lt;/code&gt;（长度编码，Wire Type = 2）
&lt;ul&gt;
&lt;li&gt;编号 &lt;code&gt;1&lt;/code&gt; 和 Wire Type 组合编码为 1 字节：&lt;code&gt;00001010&lt;/code&gt;（二进制，&lt;code&gt;0x0A&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;值：字符串 &lt;code&gt;&amp;quot;Alice&amp;quot;&lt;/code&gt;（5 字节）
&lt;ul&gt;
&lt;li&gt;字符串前缀长度：&lt;code&gt;5&lt;/code&gt;（1 字节，Varint 编码）&lt;/li&gt;
&lt;li&gt;字符串内容：&lt;code&gt;Alice&lt;/code&gt;（5 字节）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;小计&lt;/strong&gt;：1（编号+类型） + 1（长度） + 5（内容） = 7 字节&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字段 &lt;code&gt;age&lt;/code&gt;（int32，编号 2）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;字段编号和类型：编号 &lt;code&gt;2&lt;/code&gt;，类型为 &lt;code&gt;int32&lt;/code&gt;（Varint，Wire Type = 0）
&lt;ul&gt;
&lt;li&gt;编号 &lt;code&gt;2&lt;/code&gt; 和 Wire Type 组合编码为 1 字节：&lt;code&gt;00010000&lt;/code&gt;（二进制，&lt;code&gt;0x10&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;值：整数 &lt;code&gt;30&lt;/code&gt;（Varint 编码）
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;30&lt;/code&gt; 在 Varint 中编码为 1 字节：&lt;code&gt;00011110&lt;/code&gt;（二进制，&lt;code&gt;0x1E&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;小计：1（编号+类型） + 1（值） = 2 字节&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;总计：7（name） + 2（age） = 9 字节&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;性能优势&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Varint 编码&lt;/strong&gt;：&lt;code&gt;age = 30&lt;/code&gt; 只用 1 字节，JSON 用 2 字节（文本 &lt;code&gt;&amp;quot;30&amp;quot;&lt;/code&gt;）, 对于小整数，Varint 极大地节省空间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无字段名&lt;/strong&gt;：Protobuf 用编号 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;2&lt;/code&gt;（1 字节）替代 &lt;code&gt;&amp;quot;name&amp;quot;&lt;/code&gt;（6 字节）和 &lt;code&gt;&amp;quot;age&amp;quot;&lt;/code&gt;（5 字节）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无分隔符&lt;/strong&gt;：JSON 的 &lt;code&gt;{&lt;/code&gt;, &lt;code&gt;}&lt;/code&gt;, &lt;code&gt;,&lt;/code&gt; 等占用 4 字节，Protobuf 无需这些&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;硬编码逻辑&lt;/strong&gt;：Protobuf 的生成代码避免了 JSON 的动态解析和反射&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;62-为什么这么快&#34;&gt;6.2. 为什么这么快?&lt;/h3&gt;
&lt;p&gt;JSON序列化本质上是一个&lt;strong&gt;数据转换&lt;/strong&gt;过程，目标是将内存中的数据结构（例如Python的字典、Java的对象、Go的结构体等）转换为符合JSON规范的字符串, &lt;strong&gt;JSON规范定义了数据结构&lt;/strong&gt;，包括对象（&lt;code&gt;{}&lt;/code&gt;）、数组（&lt;code&gt;[]&lt;/code&gt;）、字符串（&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;）、数字、布尔值（&lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;）、&lt;code&gt;null&lt;/code&gt;等, 序列化的底层实现通常涉及:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据结构解析&lt;/strong&gt;：递归遍历输入数据结构的层次结构&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类型映射&lt;/strong&gt;：将编程语言的原生类型映射到JSON支持的类型&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;编码&lt;/strong&gt;：将数据按照JSON语法规则生成字符串，通常使用UTF-8编码&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存管理&lt;/strong&gt;：高效分配和操作字符串缓冲区&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;错误处理&lt;/strong&gt;：处理不支持的类型或循环引用等问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Protobuf 使用 &lt;code&gt;protoc&lt;/code&gt; 生成&lt;strong&gt;静态 Go 代码&lt;/strong&gt;，序列化逻辑是&lt;strong&gt;硬编码&lt;/strong&gt;的，直接访问结构体字段（通过偏移量），无需反射&lt;/p&gt;
&lt;p&gt;&lt;code&gt;protoc&lt;/code&gt; 是 Protobuf 的编译器（Protocol Buffers Compiler），用于将用户定义的 &lt;code&gt;.proto&lt;/code&gt; 文件（描述数据结构的 Schema）转换为特定语言（如 Go）的源代码, &lt;code&gt;.proto&lt;/code&gt; 文件定义了消息（message）的结构，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;User&lt;/span&gt; {&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int32&lt;/span&gt; age &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行命令 protoc &amp;ndash;go_out=. user.proto，protoc 会生成一个 Go 文件（例如 user.pb.go），包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Go 结构体（如 &lt;code&gt;type User struct&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;硬编码:&lt;/strong&gt; 序列化/反序列化方法（如 &lt;code&gt;Marshal 和 Unmarshal&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;其他辅助代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;什么是静态 Go 代码？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“静态”意味着这些代码在&lt;strong&gt;编译时&lt;/strong&gt;生成, 运行时&lt;strong&gt;无需动态解析数据结构&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;生成的代码是针对特定 &lt;code&gt;.proto&lt;/code&gt; 文件的, 包含了所有必要的序列化逻辑, 例如, &lt;code&gt;user.pb.go&lt;/code&gt; 中会为 &lt;code&gt;User&lt;/code&gt; 结构体生成一个 &lt;code&gt;Marshal&lt;/code&gt; 方法，明确知道如何处理 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;age&lt;/code&gt; 字段&lt;/li&gt;
&lt;li&gt;对比 JSON 的 &lt;code&gt;encoding/json&lt;/code&gt;, 后者在运行时通过&lt;strong&gt;反射动态解析任意结构体&lt;/strong&gt;, 生成的 JSON 依赖于运行时的类型信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;.proto&lt;/code&gt; 文件定义了 &lt;code&gt;User&lt;/code&gt; 消息，&lt;code&gt;protoc&lt;/code&gt; 生成的 &lt;code&gt;user.pb.go&lt;/code&gt; 可能包含：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;User&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Name&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;`protobuf:&amp;#34;bytes,1,opt,name=name&amp;#34; json:&amp;#34;name,omitempty&amp;#34;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Age&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;int32&lt;/span&gt;  &lt;span style=&#34;color:#e6db74&#34;&gt;`protobuf:&amp;#34;varint,2,opt,name=age&amp;#34; json:&amp;#34;age,omitempty&amp;#34;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;m&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;User&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;Marshal&lt;/span&gt;() ([]&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 硬编码的序列化逻辑&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;什么是硬编码？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“硬编码”意味着序列化逻辑是直接写死的代码，针对特定的数据结构（如 &lt;code&gt;User&lt;/code&gt; 结构体），而不是通用的解析逻辑&lt;/li&gt;
&lt;li&gt;在 JSON 中，&lt;code&gt;encoding/json&lt;/code&gt; 使用通用的反射逻辑，适用于任何 Go 数据结构（结构体、映射、切片等）它在运行时检查类型、字段名、标签等，逻辑是“通用的”&lt;/li&gt;
&lt;li&gt;在 Protobuf 中，&lt;code&gt;protoc&lt;/code&gt; 生成的 Marshal 方法是针对特定结构体的专用代码, 例如，&lt;code&gt;User.Marshal&lt;/code&gt; 只知道如何序列化 &lt;code&gt;User&lt;/code&gt; 结构体的 &lt;code&gt;Name&lt;/code&gt; 和 &lt;code&gt;Age&lt;/code&gt; 字段，逻辑是固定的&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;综上效率更高是因为 &lt;code&gt;protoc&lt;/code&gt; 根据 预先定义的 &lt;code&gt;.proto&lt;/code&gt; 文件, &lt;strong&gt;专门为 User 结构生成静态的&lt;/strong&gt;  &lt;code&gt;user.pb.go&lt;/code&gt;, 也就是生成 &lt;strong&gt;硬编码的序列化和反序列化方法&lt;/strong&gt;, 而 &lt;strong&gt;JSON 序列化逻辑是通用的,&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    </item>
    
    <item>
      <title>游戏积分榜、直播平台礼物榜、电商热销榜</title>
      <link>https://blog.jiyi27.com/posts/interview/%E7%AE%97%E6%B3%95/007-%E6%B8%B8%E6%88%8F%E7%A7%AF%E5%88%86%E6%A6%9C%E5%90%84%E7%A7%8D%E6%A6%9C%E5%8D%95/</link>
      <pubDate>Fri, 18 Apr 2025 23:27:20 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E7%AE%97%E6%B3%95/007-%E6%B8%B8%E6%88%8F%E7%A7%AF%E5%88%86%E6%A6%9C%E5%90%84%E7%A7%8D%E6%A6%9C%E5%8D%95/</guid>
      <description>&lt;h2 id=&#34;1-游戏积分榜直播平台礼物榜电商热销榜&#34;&gt;1. 游戏积分榜、直播平台礼物榜、电商热销榜&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Game Ranking List&lt;/strong&gt;：通常需要实时更新玩家积分并快速查询前 N 名（如 Top 100）, 积分可能频繁变化，支持动态排序&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Live Streaming Gift Leaderboard&lt;/strong&gt;：主播或用户收到礼物后，礼物价值累加，排行榜需实时反映最新排名，查询 Top N 或某用户排名&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;E-commerce Bestsellers List&lt;/strong&gt;：基于商品销量排序，可能涉及复杂排序规则（如销量+时间权重），更新频率可能稍低，但查询量大&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;共同特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实时或近实时更新&lt;/li&gt;
&lt;li&gt;频繁查询 Top N 或某项排名&lt;/li&gt;
&lt;li&gt;数据量可能较大（几十万到数亿条）&lt;/li&gt;
&lt;li&gt;排序基于单一或复合分数&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Priority Queues&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Best when internal, performance-critical, and simple.&lt;/li&gt;
&lt;li&gt;When implementing low-level logic.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Redis Sorted Sets&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;More frequently used in &lt;strong&gt;real-world, production-level systems&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Leaderboard systems (e.g., scores in games)&lt;/li&gt;
&lt;li&gt;Ranking systems (newsfeeds, social media)&lt;/li&gt;
&lt;li&gt;Expiring content prioritization&lt;/li&gt;
&lt;li&gt;Rate limiting&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-bestsellers&#34;&gt;2. Bestsellers&lt;/h2&gt;
&lt;h3 id=&#34;21-database-design&#34;&gt;2.1. Database Design&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-- Products table
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;CREATE TABLE products (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    product_id INT PRIMARY KEY AUTO_INCREMENT,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    name VARCHAR(&lt;span style=&#34;color:#ae81ff&#34;&gt;255&lt;/span&gt;) NOT NULL,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    description TEXT,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    price DECIMAL(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) NOT NULL,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    inventory_count INT NOT NULL DEFAULT &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-- Orders table
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;CREATE TABLE orders (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    order_id INT PRIMARY KEY AUTO_INCREMENT,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    user_id INT NOT NULL,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    total_amount DECIMAL(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) NOT NULL,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    status VARCHAR(&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;) NOT NULL DEFAULT &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;#39;&lt;/span&gt;pending&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-- Order Items table (&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; tracking individual products &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; orders)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;CREATE TABLE order_items (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    order_item_id INT PRIMARY KEY AUTO_INCREMENT,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    order_id INT NOT NULL,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    product_id INT NOT NULL,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    quantity INT NOT NULL,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    unit_price DECIMAL(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) NOT NULL,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    FOREIGN KEY (order_id) REFERENCES orders(order_id),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    FOREIGN KEY (product_id) REFERENCES products(product_id),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-- Sales statistics table (to track sales &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; bestseller calculations)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;CREATE TABLE product_sales_stats (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    stats_id INT PRIMARY KEY AUTO_INCREMENT,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    product_id INT NOT NULL,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    total_quantity_sold INT NOT NULL DEFAULT &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    total_revenue DECIMAL(&lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) NOT NULL DEFAULT &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    last_sale_at TIMESTAMP NULL,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    FOREIGN KEY (product_id) REFERENCES products(product_id),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Separating orders from order items follows a common &lt;strong&gt;database normalization&lt;/strong&gt; practice
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Reduce data redundancy&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;One-to-Many Relationship
&lt;ul&gt;
&lt;li&gt;A single order typically contains multiple products. The separation represents this one-to-many relationship accurately&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Performance for Order Processing
&lt;ul&gt;
&lt;li&gt;Orders table can be queried quickly for order status checks without loading product details&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Imagine an order with 10 different products. If we combined orders and order items into a single table:&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-游戏积分榜直播平台礼物榜电商热销榜&#34;&gt;1. 游戏积分榜、直播平台礼物榜、电商热销榜&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Game Ranking List&lt;/strong&gt;：通常需要实时更新玩家积分并快速查询前 N 名（如 Top 100）, 积分可能频繁变化，支持动态排序&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Live Streaming Gift Leaderboard&lt;/strong&gt;：主播或用户收到礼物后，礼物价值累加，排行榜需实时反映最新排名，查询 Top N 或某用户排名&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;E-commerce Bestsellers List&lt;/strong&gt;：基于商品销量排序，可能涉及复杂排序规则（如销量+时间权重），更新频率可能稍低，但查询量大&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;共同特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实时或近实时更新&lt;/li&gt;
&lt;li&gt;频繁查询 Top N 或某项排名&lt;/li&gt;
&lt;li&gt;数据量可能较大（几十万到数亿条）&lt;/li&gt;
&lt;li&gt;排序基于单一或复合分数&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Priority Queues&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Best when internal, performance-critical, and simple.&lt;/li&gt;
&lt;li&gt;When implementing low-level logic.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Redis Sorted Sets&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;More frequently used in &lt;strong&gt;real-world, production-level systems&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Leaderboard systems (e.g., scores in games)&lt;/li&gt;
&lt;li&gt;Ranking systems (newsfeeds, social media)&lt;/li&gt;
&lt;li&gt;Expiring content prioritization&lt;/li&gt;
&lt;li&gt;Rate limiting&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-bestsellers&#34;&gt;2. Bestsellers&lt;/h2&gt;
&lt;h3 id=&#34;21-database-design&#34;&gt;2.1. Database Design&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-- Products table
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;CREATE TABLE products (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    product_id INT PRIMARY KEY AUTO_INCREMENT,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    name VARCHAR(&lt;span style=&#34;color:#ae81ff&#34;&gt;255&lt;/span&gt;) NOT NULL,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    description TEXT,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    price DECIMAL(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) NOT NULL,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    inventory_count INT NOT NULL DEFAULT &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-- Orders table
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;CREATE TABLE orders (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    order_id INT PRIMARY KEY AUTO_INCREMENT,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    user_id INT NOT NULL,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    total_amount DECIMAL(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) NOT NULL,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    status VARCHAR(&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;) NOT NULL DEFAULT &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;#39;&lt;/span&gt;pending&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-- Order Items table (&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; tracking individual products &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; orders)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;CREATE TABLE order_items (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    order_item_id INT PRIMARY KEY AUTO_INCREMENT,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    order_id INT NOT NULL,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    product_id INT NOT NULL,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    quantity INT NOT NULL,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    unit_price DECIMAL(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) NOT NULL,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    FOREIGN KEY (order_id) REFERENCES orders(order_id),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    FOREIGN KEY (product_id) REFERENCES products(product_id),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-- Sales statistics table (to track sales &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; bestseller calculations)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;CREATE TABLE product_sales_stats (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    stats_id INT PRIMARY KEY AUTO_INCREMENT,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    product_id INT NOT NULL,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    total_quantity_sold INT NOT NULL DEFAULT &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    total_revenue DECIMAL(&lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) NOT NULL DEFAULT &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    last_sale_at TIMESTAMP NULL,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    FOREIGN KEY (product_id) REFERENCES products(product_id),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Separating orders from order items follows a common &lt;strong&gt;database normalization&lt;/strong&gt; practice
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Reduce data redundancy&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;One-to-Many Relationship
&lt;ul&gt;
&lt;li&gt;A single order typically contains multiple products. The separation represents this one-to-many relationship accurately&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Performance for Order Processing
&lt;ul&gt;
&lt;li&gt;Orders table can be queried quickly for order status checks without loading product details&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Imagine an order with 10 different products. If we combined orders and order items into a single table:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;order_id | user_id | product_id | quantity | price | status | created_at | ...
---------|---------|------------|----------|-------|--------|------------|-----
1        | 42      | 101        | 2        | 19.99 | pending| 2023-01-01 | ...
1        | 42      | 205        | 1        | 29.99 | pending| 2023-01-01 | ...
1        | 42      | 310        | 5        | 5.99  | pending| 2023-01-01 | ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This approach has serious problems:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;User information is &lt;strong&gt;duplicated&lt;/strong&gt; for every product in the order&lt;/li&gt;
&lt;li&gt;Status updates require updating multiple rows&lt;/li&gt;
&lt;li&gt;Calculating order totals is more complex&lt;/li&gt;
&lt;li&gt;Finding basic order information means sorting through product entries&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Make sure your tables are properly indexed:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INDEX&lt;/span&gt; idx_order_items_product_id &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; order_items(product_id);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INDEX&lt;/span&gt; idx_orders_status &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; orders(status);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INDEX&lt;/span&gt; idx_orders_created_at &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; orders(created_at);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;22-query-for-bestsellers&#34;&gt;2.2. Query for Bestsellers&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- Basic bestsellers query (by quantity)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p.product_id,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p.name,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p.price,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;SUM&lt;/span&gt;(oi.quantity) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; total_sold
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    products p
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;JOIN&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    order_items oi &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; p.product_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; oi.product_id
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;JOIN&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    orders o &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; oi.order_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; o.order_id
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    o.status &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;completed&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;-- Optional: Add date range filter, e.g., for weekly bestsellers
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;-- AND o.created_at &amp;gt;= DATE_SUB(NOW(), INTERVAL 7 DAY) 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;GROUP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p.product_id, p.name, p.price
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    total_sold &lt;span style=&#34;color:#66d9ef&#34;&gt;DESC&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;LIMIT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Alternatively, if we maintain the &lt;code&gt;product_sales_stats&lt;/code&gt; table through triggers or scheduled updates:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- Faster bestsellers query using the stats table
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p.product_id,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p.name,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p.price,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ps.total_quantity_sold
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    products p
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;JOIN&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    product_sales_stats ps &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; p.product_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ps.product_id
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ps.total_quantity_sold &lt;span style=&#34;color:#66d9ef&#34;&gt;DESC&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;LIMIT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Multiple joins are expensive&lt;/strong&gt; - The original query joins three tables (products, order_items, and orders), which becomes increasingly costly as these tables grow.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;product_sales_stats&lt;/code&gt; table is actually the better approach for performance reasons. This query &lt;strong&gt;performs much better&lt;/strong&gt; as it only requires &lt;strong&gt;a single join&lt;/strong&gt; and the data is already aggregated.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Instead of updating the sales stats on every order, you could set up a scheduled job that runs periodically (e.g., every 5 minutes or hourly) to update the aggregated data:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- Run in a scheduled job
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; product_sales_stats ps
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;JOIN&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        oi.product_id,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;SUM&lt;/span&gt;(oi.quantity) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; total_quantity,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;SUM&lt;/span&gt;(oi.quantity &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; oi.unit_price) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; total_revenue
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        order_items oi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;JOIN&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        orders o &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; oi.order_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; o.order_id
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        o.status &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;completed&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; o.updated_at &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;MAX&lt;/span&gt;(last_update) &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; stats_update_log)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;GROUP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        oi.product_id
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;) new_data &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; ps.product_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; new_data.product_id
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ps.total_quantity_sold &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ps.total_quantity_sold &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; new_data.total_quantity,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ps.total_revenue &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ps.total_revenue &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; new_data.total_revenue,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ps.updated_at &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NOW();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;23-redis-sorted-sets&#34;&gt;2.3. Redis sorted sets&lt;/h3&gt;
&lt;p&gt;For even better performance, you could &lt;strong&gt;use Redis sorted sets to track bestsellers&lt;/strong&gt; directly:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# When processing an order&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;update_bestseller_ranking&lt;/span&gt;(product_id, quantity_sold):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# Increment the score in a sorted set&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    redis_client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;zincrby(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;bestsellers:by_quantity&amp;#39;&lt;/span&gt;, quantity_sold, product_id)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# Store product details in a hash&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    redis_client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;hset(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;product:&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;product_id&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;, mapping&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;name&amp;#39;&lt;/span&gt;: product_name,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;price&amp;#39;&lt;/span&gt;: product_price
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    })
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# To get top 3 bestsellers&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;get_top_bestsellers&lt;/span&gt;(count&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# Get product IDs with highest scores&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    top_product_ids &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; redis_client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;zrevrange(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;bestsellers:by_quantity&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, count&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, withscores&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    bestsellers &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; product_id, score &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; top_product_ids:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        product_data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; redis_client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;hgetall(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;product:&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;product_id&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        bestsellers&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append({
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;product_id&amp;#39;&lt;/span&gt;: product_id,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;name&amp;#39;&lt;/span&gt;: product_data[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;name&amp;#39;&lt;/span&gt;],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;price&amp;#39;&lt;/span&gt;: product_data[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;price&amp;#39;&lt;/span&gt;],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;total_quantity_sold&amp;#39;&lt;/span&gt;: int(score)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        })
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; bestsellers
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
    </item>
    
    <item>
      <title>面向切面编程 控制反转</title>
      <link>https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/011-%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/</link>
      <pubDate>Wed, 16 Apr 2025 20:32:19 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/011-%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/</guid>
      <description>&lt;h2 id=&#34;1-aspect-oriented-program&#34;&gt;1. Aspect Oriented Program&lt;/h2&gt;
&lt;h3 id=&#34;11-基础概念&#34;&gt;1.1. 基础概念&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;面向切面编程（AOP是Aspect Oriented Program的首字母缩写） ，我们知道，面向对象的特点是继承、多态和封装。而封装就要求将功能分散到不同的对象中去，这在软件设计中往往称为职责分配。实际上也就是说，让不同的类设计不同的方法。这样代码就分散到一个个的类中去了。这样做的好处是降低了代码的复杂程度，使类可重用&lt;/p&gt;
&lt;p&gt;但是人们也发现，在分散代码的同时，也增加了代码的重复性。什么意思呢？比如说，我们在两个类中，可能都需要在每个方法中做日志。按面向对象的设计方法，我们就必须在两个类的方法中都加入日志的内容。也许他们是完全相同的，但就是因为面向对象的设计让类与类之间无法联系，而不能将这些重复的代码统一起来&lt;/p&gt;
&lt;p&gt;也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程&lt;/p&gt;
&lt;p&gt;一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为&lt;/p&gt;
&lt;p&gt;这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的&lt;/p&gt;
&lt;p&gt;AOP在编程历史上可以说是里程碑式的，对OOP编程是一种十分有益的补充&lt;/p&gt;
&lt;p&gt;来源: &lt;a href=&#34;https://www.iteye.com/blog/hejiajunsh-1776569&#34;&gt;https://www.iteye.com/blog/hejiajunsh-1776569&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;12-举例解释&#34;&gt;1.2. 举例解释&lt;/h3&gt;
&lt;p&gt;假设有一个大的项目，包含多个服务类（如UserService、OrderService、ProductService），每个类有多个方法，都需要日志&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;直接写日志的方式&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;UserService&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;saveUser&lt;/span&gt;(String username) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Before saving user&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Saving user: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; username);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;After saving user&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;deleteUser&lt;/span&gt;(String username) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Before deleting user&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Deleting user: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; username);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;After deleting user&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OrderService&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;createOrder&lt;/span&gt;(String orderId) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Before creating order&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Creating order: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; orderId);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;After creating order&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 更多方法...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;如果要改日志格式（比如加时间戳），得改动所有方法&lt;/li&gt;
&lt;li&gt;如果要加新功能（比如记录方法执行时间），又得在每个方法里加代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;用AOP的方式&lt;/strong&gt;&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-aspect-oriented-program&#34;&gt;1. Aspect Oriented Program&lt;/h2&gt;
&lt;h3 id=&#34;11-基础概念&#34;&gt;1.1. 基础概念&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;面向切面编程（AOP是Aspect Oriented Program的首字母缩写） ，我们知道，面向对象的特点是继承、多态和封装。而封装就要求将功能分散到不同的对象中去，这在软件设计中往往称为职责分配。实际上也就是说，让不同的类设计不同的方法。这样代码就分散到一个个的类中去了。这样做的好处是降低了代码的复杂程度，使类可重用&lt;/p&gt;
&lt;p&gt;但是人们也发现，在分散代码的同时，也增加了代码的重复性。什么意思呢？比如说，我们在两个类中，可能都需要在每个方法中做日志。按面向对象的设计方法，我们就必须在两个类的方法中都加入日志的内容。也许他们是完全相同的，但就是因为面向对象的设计让类与类之间无法联系，而不能将这些重复的代码统一起来&lt;/p&gt;
&lt;p&gt;也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程&lt;/p&gt;
&lt;p&gt;一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为&lt;/p&gt;
&lt;p&gt;这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的&lt;/p&gt;
&lt;p&gt;AOP在编程历史上可以说是里程碑式的，对OOP编程是一种十分有益的补充&lt;/p&gt;
&lt;p&gt;来源: &lt;a href=&#34;https://www.iteye.com/blog/hejiajunsh-1776569&#34;&gt;https://www.iteye.com/blog/hejiajunsh-1776569&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;12-举例解释&#34;&gt;1.2. 举例解释&lt;/h3&gt;
&lt;p&gt;假设有一个大的项目，包含多个服务类（如UserService、OrderService、ProductService），每个类有多个方法，都需要日志&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;直接写日志的方式&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;UserService&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;saveUser&lt;/span&gt;(String username) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Before saving user&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Saving user: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; username);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;After saving user&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;deleteUser&lt;/span&gt;(String username) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Before deleting user&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Deleting user: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; username);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;After deleting user&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OrderService&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;createOrder&lt;/span&gt;(String orderId) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Before creating order&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Creating order: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; orderId);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;After creating order&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 更多方法...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;如果要改日志格式（比如加时间戳），得改动所有方法&lt;/li&gt;
&lt;li&gt;如果要加新功能（比如记录方法执行时间），又得在每个方法里加代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;用AOP的方式&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 业务逻辑&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;UserService&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;saveUser&lt;/span&gt;(String username) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Saving user: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; username);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;deleteUser&lt;/span&gt;(String username) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Deleting user: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; username);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OrderService&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;createOrder&lt;/span&gt;(String orderId) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Creating order: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; orderId);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 切面&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Aspect&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Component&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LoggingAspect&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Before&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;execution(* com.example.*Service.*(..))&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;logBefore&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Before method execution&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@After&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;execution(* com.example.*Service.*(..))&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;logAfter&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;After method execution&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;代码简洁&lt;/strong&gt;：业务代码只关注核心逻辑（如保存用户、创建订单），日志逻辑集中在 LoggingAspect&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;一处修改，处处生效&lt;/strong&gt;：改日志格式只需改 LoggingAspect，无需动业务代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-ioc&#34;&gt;2. IoC&lt;/h2&gt;
&lt;h3 id=&#34;21-dependency-inject&#34;&gt;2.1. Dependency Inject&lt;/h3&gt;
&lt;p&gt;ASP.NET Core 通过其内置的&lt;strong&gt;依赖注入容器&lt;/strong&gt;（DI 容器）来管理依赖注入&lt;/p&gt;
&lt;h3 id=&#34;22-通过构造函数注入&#34;&gt;2.2. 通过构造函数注入&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ASP.NET Core 的 DI 容器会检查类的构造函数，判断构造函数中是否有需要注入的依赖&lt;/li&gt;
&lt;li&gt;如果构造函数的参数类型（如 UserService）&lt;strong&gt;已经在 DI 容器中注册&lt;/strong&gt;，容器会在实例化类时自动解析这些依赖并传入&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;public &lt;span style=&#34;color:#a6e22e&#34;&gt;UserController&lt;/span&gt;(UserManageService userManageService, IMapper mapper)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    _mapper &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mapper;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    _userManageService &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; userManageService;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当 ASP.NET Core 需要实例化 UserController（例如处理 HTTP 请求时），DI 容器会检查构造函数的参数类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UserService：一个自定义服务，可能用于处理用户管理逻辑&lt;/li&gt;
&lt;li&gt;如果这些类型已经在 DI 容器中注册，容器会自动解析并提供对应的实例，注入到 &lt;code&gt;UserController&lt;/code&gt; 中&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;23-di容器注册&#34;&gt;2.3. DI容器注册&lt;/h3&gt;
&lt;p&gt;依赖注入的前提是服务必须在 DI 容器中注册, 通常在 &lt;code&gt;Startup.cs&lt;/code&gt; 或 &lt;code&gt;Program.cs&lt;/code&gt; 的 &lt;code&gt;ConfigureServices&lt;/code&gt; 方法中完成注册&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; ConfigureServices(IServiceCollection services)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    services.AddScoped&amp;lt;UserManageService&amp;gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    services.AddSingleton&amp;lt;IMapper&amp;gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; MapperConfiguration(cfg =&amp;gt; { &lt;span style=&#34;color:#75715e&#34;&gt;/* 配置 AutoMapper */&lt;/span&gt; }).CreateMapper());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    services.AddControllers();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AddScoped&amp;lt;UserManageService&amp;gt;()&lt;/code&gt;：注册&lt;code&gt; UserService&lt;/code&gt;，指定其生命周期为 &lt;code&gt;Scoped&lt;/code&gt;（每个 HTTP 请求一个实例）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AddSingleton&amp;lt;IMapper&amp;gt;()&lt;/code&gt;：注册 &lt;code&gt;IMapper&lt;/code&gt;，指定为 &lt;code&gt;Singleton&lt;/code&gt;（整个应用程序共享一个实例）&lt;/li&gt;
&lt;li&gt;DI 容器会记录这些服务及其生命周期，并在需要时解析&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;ASP.NET Core 的依赖注入&lt;strong&gt;不依赖注解&lt;/strong&gt;（如 Java 中的 @Inject 或 @Autowired）, 它通过&lt;strong&gt;构造函数的签名&lt;/strong&gt;和 DI 容器中的服务注册来自动识别和注入依赖&lt;/p&gt;
&lt;p&gt;只要服务在容器中注册，并且构造函数中声明了这些服务作为参数，ASP.NET Core 就会自动进行依赖注入&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;24-控制反转ioc是什么意思&#34;&gt;2.4. 控制反转（IoC）是什么意思？&lt;/h3&gt;
&lt;p&gt;控制反转（Inversion of Control, IoC） 是一种设计原则，用于降低代码之间的耦合度, 它的核心思想是将对象的创建和管理的控制权从类本身转移到外部容器&lt;/p&gt;
&lt;p&gt;Inversion of Control (IoC) is a design principle aimed at &lt;strong&gt;decreasing coupling&lt;/strong&gt; among software components. The fundamental concept involves shifting the responsibility for object creation and lifecycle management away from the components themselves and delegating it to an external container or framework.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;依赖注入（DI）是实现 IoC 的一种具体方式，通过构造函数、属性或方法将依赖传递给类&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;UserController&lt;/code&gt; 中，构造函数注入是 ASP.NET Core 实现 IoC 的方式，DI 容器负责解析和提供 &lt;code&gt;UserService&lt;/code&gt; 和 &lt;code&gt;IMapper&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    </item>
    
    <item>
      <title>Java 多线程 并发编程</title>
      <link>https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/010-juc-%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88/</link>
      <pubDate>Tue, 15 Apr 2025 21:02:20 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/010-juc-%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88/</guid>
      <description>&lt;h2 id=&#34;1-concurrenthashmap-vs-collectionssynchronizedmap&#34;&gt;1. &lt;code&gt;ConcurrentHashMap&lt;/code&gt; vs &lt;code&gt;Collections.synchronizedMap&lt;/code&gt;&lt;/h2&gt;
&lt;h3 id=&#34;11-锁粒度&#34;&gt;1.1. 锁粒度&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;Collections.synchronizedMap&lt;/code&gt;&lt;/strong&gt;  粗粒度 全局锁&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对整个 Map 使用单一的锁（synchronized 块）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任何操作（get、put、remove 等）都需要获取这把锁，导致所有线程串行执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高并发时，线程竞争锁的开销大，性能瓶颈明显&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;&lt;/strong&gt; 细粒度分段锁/CAS&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 Java 7 中使用&lt;strong&gt;分段锁&lt;/strong&gt;（Segment），将哈希表分成多个段，每个段有独立的锁，写操作只锁定相关段，其他段仍可并发访问&lt;/li&gt;
&lt;li&gt;在 Java 8 及以上，放弃分段锁，改用 &lt;strong&gt;CAS（Compare-And-Swap）&lt;/strong&gt; 和 &lt;code&gt;synchronized&lt;/code&gt;（仅锁住桶的头节点），进一步提高并发性&lt;/li&gt;
&lt;li&gt;读操作通常无锁（基于 volatile 保证可见性），允许多线程同时读取&lt;/li&gt;
&lt;li&gt;结果：锁竞争大幅减少，读写并发性能更&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12-collectionssynchronizedmap&#34;&gt;1.2. &lt;code&gt;Collections.synchronizedMap&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Collections.synchronizedMap&lt;/code&gt; 内部将 HashMap 的每个操作都使用了 &lt;code&gt;synchronized&lt;/code&gt; 块&lt;/li&gt;
&lt;li&gt;这意味着所有操作（包括读和读、读和写、写和写）都必须&lt;strong&gt;竞争同一把锁&lt;/strong&gt;，导致高并发下性能较差&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;13-concurrenthashmap&#34;&gt;1.3. &lt;code&gt;ConcurrentHashMap&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Java 7&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt; 使用**分段锁（Segment）**机制，将哈希表分成多个段（默认 16 个），每个段是一个独立的锁&lt;/li&gt;
&lt;li&gt;写操作只锁定对应的段，其他段仍可被其他线程访问&lt;/li&gt;
&lt;li&gt;读操作通常无锁，依赖内存可见性&lt;/li&gt;
&lt;li&gt;优点：比 &lt;code&gt;Collections.synchronizedMap&lt;/code&gt; 的全局锁更细粒度，允许多线程操作不同段&lt;/li&gt;
&lt;li&gt;缺点：分段锁仍有限制（段数固定），内存开销较大，复杂场景下性能未完全优化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Java 8 及以上&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;放弃分段锁，改用更细粒度的机制：&lt;strong&gt;CAS&lt;/strong&gt; + &lt;strong&gt;桶级别的 synchronized&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;什么是 CAS（Compare-And-Swap）？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CAS 是一种原子操作，基于硬件支持（CPU 指令），用于在无锁情况下更新共享变量&lt;/li&gt;
&lt;li&gt;CAS 操作包含三个参数：&lt;strong&gt;内存值（V）&lt;/strong&gt;、&lt;strong&gt;预期值（A）&lt;/strong&gt;、&lt;strong&gt;新值（B）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;逻辑：如果当前内存值 V 等于预期值 A，则将 V 更新为 B；否则不更新&lt;/li&gt;
&lt;li&gt;CAS 是原子性的，保证操作不会被其他线程中断&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;AtomicCounter&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;volatile&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;compareAndSet&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; expected, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; newValue) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 伪代码，实际由 JVM 和硬件实现&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 只有当变量的当前值等于预期值时，才将其更新为新值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (value &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; expected) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 将共享变量 value 的值替换为 newValue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newValue;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;increment&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; oldValue;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;do&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            oldValue &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; value;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;compareAndSet(oldValue, oldValue &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;在真实 CAS 实现中，&lt;code&gt;if (value == expected)&lt;/code&gt; 和 &lt;code&gt;value = newValue&lt;/code&gt; 是原子操作，防止其他线程在比较和更新之间干扰，所以不会出现：线程 A 判断等于期望值 10，还没修改 value，此时线程 B 判断也等于期望值 10，然后出现更新丢失的情况&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-concurrenthashmap-vs-collectionssynchronizedmap&#34;&gt;1. &lt;code&gt;ConcurrentHashMap&lt;/code&gt; vs &lt;code&gt;Collections.synchronizedMap&lt;/code&gt;&lt;/h2&gt;
&lt;h3 id=&#34;11-锁粒度&#34;&gt;1.1. 锁粒度&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;Collections.synchronizedMap&lt;/code&gt;&lt;/strong&gt;  粗粒度 全局锁&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对整个 Map 使用单一的锁（synchronized 块）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任何操作（get、put、remove 等）都需要获取这把锁，导致所有线程串行执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高并发时，线程竞争锁的开销大，性能瓶颈明显&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;&lt;/strong&gt; 细粒度分段锁/CAS&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 Java 7 中使用&lt;strong&gt;分段锁&lt;/strong&gt;（Segment），将哈希表分成多个段，每个段有独立的锁，写操作只锁定相关段，其他段仍可并发访问&lt;/li&gt;
&lt;li&gt;在 Java 8 及以上，放弃分段锁，改用 &lt;strong&gt;CAS（Compare-And-Swap）&lt;/strong&gt; 和 &lt;code&gt;synchronized&lt;/code&gt;（仅锁住桶的头节点），进一步提高并发性&lt;/li&gt;
&lt;li&gt;读操作通常无锁（基于 volatile 保证可见性），允许多线程同时读取&lt;/li&gt;
&lt;li&gt;结果：锁竞争大幅减少，读写并发性能更&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12-collectionssynchronizedmap&#34;&gt;1.2. &lt;code&gt;Collections.synchronizedMap&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Collections.synchronizedMap&lt;/code&gt; 内部将 HashMap 的每个操作都使用了 &lt;code&gt;synchronized&lt;/code&gt; 块&lt;/li&gt;
&lt;li&gt;这意味着所有操作（包括读和读、读和写、写和写）都必须&lt;strong&gt;竞争同一把锁&lt;/strong&gt;，导致高并发下性能较差&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;13-concurrenthashmap&#34;&gt;1.3. &lt;code&gt;ConcurrentHashMap&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Java 7&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt; 使用**分段锁（Segment）**机制，将哈希表分成多个段（默认 16 个），每个段是一个独立的锁&lt;/li&gt;
&lt;li&gt;写操作只锁定对应的段，其他段仍可被其他线程访问&lt;/li&gt;
&lt;li&gt;读操作通常无锁，依赖内存可见性&lt;/li&gt;
&lt;li&gt;优点：比 &lt;code&gt;Collections.synchronizedMap&lt;/code&gt; 的全局锁更细粒度，允许多线程操作不同段&lt;/li&gt;
&lt;li&gt;缺点：分段锁仍有限制（段数固定），内存开销较大，复杂场景下性能未完全优化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Java 8 及以上&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;放弃分段锁，改用更细粒度的机制：&lt;strong&gt;CAS&lt;/strong&gt; + &lt;strong&gt;桶级别的 synchronized&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;什么是 CAS（Compare-And-Swap）？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CAS 是一种原子操作，基于硬件支持（CPU 指令），用于在无锁情况下更新共享变量&lt;/li&gt;
&lt;li&gt;CAS 操作包含三个参数：&lt;strong&gt;内存值（V）&lt;/strong&gt;、&lt;strong&gt;预期值（A）&lt;/strong&gt;、&lt;strong&gt;新值（B）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;逻辑：如果当前内存值 V 等于预期值 A，则将 V 更新为 B；否则不更新&lt;/li&gt;
&lt;li&gt;CAS 是原子性的，保证操作不会被其他线程中断&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;AtomicCounter&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;volatile&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;compareAndSet&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; expected, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; newValue) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 伪代码，实际由 JVM 和硬件实现&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 只有当变量的当前值等于预期值时，才将其更新为新值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (value &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; expected) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 将共享变量 value 的值替换为 newValue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newValue;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;increment&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; oldValue;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;do&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            oldValue &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; value;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;compareAndSet(oldValue, oldValue &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;在真实 CAS 实现中，&lt;code&gt;if (value == expected)&lt;/code&gt; 和 &lt;code&gt;value = newValue&lt;/code&gt; 是原子操作，防止其他线程在比较和更新之间干扰，所以不会出现：线程 A 判断等于期望值 10，还没修改 value，此时线程 B 判断也等于期望值 10，然后出现更新丢失的情况&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设有一个共享变量 value = 10，两个线程尝试用 CAS 更新它：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线程 A&lt;/strong&gt;：希望执行 CAS，将 value 从 10 改为 20（expected = 10, newValue = 20）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程 B&lt;/strong&gt;：希望执行 CAS，将 value 从 10 改为 30（expected = 10, newValue = 30）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;场景 1：线程 A 先执行&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程 A 检查：value == expected（10 == 10），条件满足&lt;/li&gt;
&lt;li&gt;执行 value = newValue，将 value 设为 20&lt;/li&gt;
&lt;li&gt;返回 true，线程 A 更新成功&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;场景 2：线程 B 后执行&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程 B 检查：value == expected（20 == 10），条件不满足（因为线程 A 已将 value 改为 20）&lt;/li&gt;
&lt;li&gt;不执行 value = newValue，value 仍为 20&lt;/li&gt;
&lt;li&gt;返回 false，线程 B 更新失败，可能重试&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;CAS 失败后会发生什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 CAS 操作中，当线程 B 调用 compareAndSet(expected, newValue) 失败（返回 false），意味着共享变量 value 的当前值不再等于 expected，通常是因为其他线程（如线程 A）已经修改了 value。失败后，线程 B 需要决定如何处理，常见的选择包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;重试&lt;/strong&gt;：重新读取 value 的当前值，基于新的值再次尝试 CAS&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;放弃&lt;/strong&gt;：根据业务逻辑，直接返回失败或执行其他操作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进入替代逻辑&lt;/strong&gt;：例如加锁（synchronized）或其他同步机制来完成操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;问题： 线程 B 更新失败，可能重试， 失败了之后怎么办，就算是重试 value 的值也不会是期待的 10 了， 这样就会死循环&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么不会轻易导致死循环？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;初始 value = 10&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程 A 将 value 从 10 改为 20（CAS 成功）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程 B 尝试 CAS（expected = 10, newValue = 30），失败（因为 value 现在是 20）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程 B 重试，读取新的 value = 20，然后尝试 CAS（expected = 20, newValue = 30）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-copyonwritearraylist&#34;&gt;2. &lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;基本原理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;写时复制（Copy-On-Write）&lt;/strong&gt;：每次修改操作（如 &lt;code&gt;add&lt;/code&gt;、&lt;code&gt;remove&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;）时，&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt; 会创建一个底层数组的副本，对副本进行修改，然后将新数组设置为当前数组，这一过程是线程安全的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;读写分离&lt;/strong&gt;：读操作直接访问底层数组，无需加锁，允许多个线程同时读取；写操作通过锁（通常是 ReentrantLock）保证线程安全&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;内部实现&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;volatile&lt;/code&gt; 修饰的数组存储元素，保证读操作的可见性&lt;/li&gt;
&lt;li&gt;写操作
&lt;ul&gt;
&lt;li&gt;**获取锁 **确保同一时刻只有一个线程执行写操作&lt;/li&gt;
&lt;li&gt;复制当前数组&lt;/li&gt;
&lt;li&gt;在新数组上执行修改&lt;/li&gt;
&lt;li&gt;用新数组替换旧数组&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;释放锁&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读操作: 直接访问 volatile 数组，无锁&lt;/li&gt;
&lt;li&gt;锁机制：使用 &lt;code&gt;ReentrantLock&lt;/code&gt;（Java 8 及之前）或内部锁对象（Java 9 及之后）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;**为什么写时复制还需要锁？ **&lt;/p&gt;
&lt;p&gt;保证写操作的原子性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写操作（如 add、remove）涉及多个步骤：复制数组、修改新数组、更新数组引用&lt;/li&gt;
&lt;li&gt;线程 A 和线程 B 同时复制数组并修改，B 的修改可能覆盖 A 的修改&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;是不是说传统的线程安全数组只是读和读之间没有锁，但读和写之间还是有锁的，但是写时复制 就不一样， 读操作一直没有锁，就算是在写的时候，读也可以进行？&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;Vector&lt;/code&gt; 或 &lt;code&gt;Collections.synchronizedList&lt;/code&gt; 中，&lt;strong&gt;读操作是加锁的&lt;/strong&gt;, 虽然读和读本身不修改数据，但读操作需要确保它们访问的数据不受写操作干扰, 如果两个读线程同时运行，且没有锁，写线程可能在它们之间插入修改，导致一个读线程看到旧数据，另一个看到新数据，破坏一致性, 通过给读操作加锁，所有读线程在写操作完成前等待，统一看到一致的状态,&lt;/p&gt;
&lt;p&gt;如果你对读操作加锁有疑问，应该是因为受到数据库的影响，只有写会获得 x锁，而读不会，数据库之所以可以这么做是因为他们使用了 MVVM，快照读，如果使用当前读也是需要加锁的, 综上：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt; 的读操作一直无锁&lt;/strong&gt;, 即使写操作正在进行, 这是因为写时复制机制隔离了读写操作:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写操作复制数组并修改副本，当前数组保持不变&lt;/li&gt;
&lt;li&gt;读操作访问当前数组，无需担心写操作的干扰, 读操作看到的是某一时刻的数组快照（可能是旧的，但始终完整）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;volatile&lt;/code&gt; 确保写操作完成后，读线程最终看到新数组，但读线程不会被阻塞&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;特性&lt;/th&gt;
          &lt;th&gt;Vector / Collections.synchronizedList&lt;/th&gt;
          &lt;th&gt;CopyOnWriteArrayList&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;读和读之间&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;有锁（竞争同一把锁）&lt;/td&gt;
          &lt;td&gt;无锁&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;读和写之间&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;有锁（读等待写，写等待读）&lt;/td&gt;
          &lt;td&gt;无锁（读可并行）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;写和写之间&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;有锁（互斥）&lt;/td&gt;
          &lt;td&gt;有锁（互斥）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;读性能&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;较低（锁竞争）&lt;/td&gt;
          &lt;td&gt;极高（无锁）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;写性能&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;一般（锁开销）&lt;/td&gt;
          &lt;td&gt;较低（复制开销）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;适用场景&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;读写均衡&lt;/td&gt;
          &lt;td&gt;读多写少&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</content>
    </item>
    
    <item>
      <title>消息队列如何保证可靠性</title>
      <link>https://blog.jiyi27.com/posts/interview/%E7%BC%93%E5%AD%98%E5%92%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/004-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7/</link>
      <pubDate>Tue, 15 Apr 2025 19:56:20 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E7%BC%93%E5%AD%98%E5%92%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/004-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7/</guid>
      <description>&lt;h2 id=&#34;1-消息队列如何保证可靠性&#34;&gt;1. 消息队列如何保证可靠性&lt;/h2&gt;
&lt;h3 id=&#34;11-消息持久化&#34;&gt;1.1. 消息持久化&lt;/h3&gt;
&lt;p&gt;确保消息在系统崩溃或重启后不丢失&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为提升性能, broker 可能先写入内存缓冲区, 再异步刷盘（需配置同步刷盘以确保强一致性）&lt;/li&gt;
&lt;li&gt;异步刷盘可能在极短窗口内丢失消息（毫秒级），但吞吐量可提高 10 倍以上，业界常用&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;消息元数据（如 offset、时间戳）也需持久化，防止消费状态丢失&lt;/p&gt;
&lt;p&gt;持久化存储通常结合定期清理（如按时间/大小删除）避免磁盘溢出&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;12-副本机制高可用广泛使用&#34;&gt;1.2. 副本机制（高可用，广泛使用）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;实现原理&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单点故障（如节点宕机）会导致服务不可用或数据丢失，副本机制确保高可用和容错&lt;/li&gt;
&lt;li&gt;消息在多个节点存储副本，主节点（leader）处理读写，从节点（follower）同步数据&lt;/li&gt;
&lt;li&gt;写操作需多数副本确认（quorum，如 3 副本中至少 2 个确认）才算成功&lt;/li&gt;
&lt;li&gt;主节点故障时，从节点选举为新主，自动接管服务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;业界实践&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Kafka 使用分区副本（ISR，In-Sync Replicas），RabbitMQ 使用镜像队列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;副本数通常设为 2-3，兼顾可靠性和存储成本（副本过多增加开销）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同步 vs 异步复制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步复制（如 Kafka 的 acks=all）保证强一致性，但延迟稍高&lt;/li&gt;
&lt;li&gt;异步复制（如 Kafka 的 acks=1）性能更好，但可能丢少量消息，适用于对丢失敏感度低的场景&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;13-消息确认机制生产者与消费者核心机制&#34;&gt;1.3. 消息确认机制（生产者与消费者，核心机制）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;实现原理:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生产者确认&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生产者发送消息后，等待 broker 确认（ack）&lt;/li&gt;
&lt;li&gt;确认级别
&lt;ul&gt;
&lt;li&gt;全程无需确认（火力全开，性能最高，可能丢消息）&lt;/li&gt;
&lt;li&gt;主节点确认（折衷，业界常用）&lt;/li&gt;
&lt;li&gt;多数副本确认（最可靠，延迟稍高）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;消费者确认&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消费者处理消息后，向 broker 发送确认（ack），broker 删除消息&lt;/li&gt;
&lt;li&gt;未收到确认的消息可重新投递（at-least-once 语义）&lt;/li&gt;
&lt;li&gt;自动确认（auto-ack）性能高，但可能丢失；手动确认（manual-ack）可靠，业界更常用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;业界实践&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kafka：使用异步批量确认提高吞吐, 生产者配置 acks（0/1/all），消费者手动提交 offset&lt;/li&gt;
&lt;li&gt;RabbitMQ：生产者用 publisher confirm，消费者用 manual ack&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优化&lt;/strong&gt;：异步批量确认（如 Kafka 缓冲发送）或延迟确认（如 RabbitMQ 批量 ack）提升吞吐。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;重复消息可能因网络抖动或重试产生，需幂等性支持&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-消息队列如何保证可靠性&#34;&gt;1. 消息队列如何保证可靠性&lt;/h2&gt;
&lt;h3 id=&#34;11-消息持久化&#34;&gt;1.1. 消息持久化&lt;/h3&gt;
&lt;p&gt;确保消息在系统崩溃或重启后不丢失&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为提升性能, broker 可能先写入内存缓冲区, 再异步刷盘（需配置同步刷盘以确保强一致性）&lt;/li&gt;
&lt;li&gt;异步刷盘可能在极短窗口内丢失消息（毫秒级），但吞吐量可提高 10 倍以上，业界常用&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;消息元数据（如 offset、时间戳）也需持久化，防止消费状态丢失&lt;/p&gt;
&lt;p&gt;持久化存储通常结合定期清理（如按时间/大小删除）避免磁盘溢出&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;12-副本机制高可用广泛使用&#34;&gt;1.2. 副本机制（高可用，广泛使用）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;实现原理&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单点故障（如节点宕机）会导致服务不可用或数据丢失，副本机制确保高可用和容错&lt;/li&gt;
&lt;li&gt;消息在多个节点存储副本，主节点（leader）处理读写，从节点（follower）同步数据&lt;/li&gt;
&lt;li&gt;写操作需多数副本确认（quorum，如 3 副本中至少 2 个确认）才算成功&lt;/li&gt;
&lt;li&gt;主节点故障时，从节点选举为新主，自动接管服务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;业界实践&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Kafka 使用分区副本（ISR，In-Sync Replicas），RabbitMQ 使用镜像队列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;副本数通常设为 2-3，兼顾可靠性和存储成本（副本过多增加开销）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同步 vs 异步复制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步复制（如 Kafka 的 acks=all）保证强一致性，但延迟稍高&lt;/li&gt;
&lt;li&gt;异步复制（如 Kafka 的 acks=1）性能更好，但可能丢少量消息，适用于对丢失敏感度低的场景&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;13-消息确认机制生产者与消费者核心机制&#34;&gt;1.3. 消息确认机制（生产者与消费者，核心机制）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;实现原理:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生产者确认&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生产者发送消息后，等待 broker 确认（ack）&lt;/li&gt;
&lt;li&gt;确认级别
&lt;ul&gt;
&lt;li&gt;全程无需确认（火力全开，性能最高，可能丢消息）&lt;/li&gt;
&lt;li&gt;主节点确认（折衷，业界常用）&lt;/li&gt;
&lt;li&gt;多数副本确认（最可靠，延迟稍高）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;消费者确认&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消费者处理消息后，向 broker 发送确认（ack），broker 删除消息&lt;/li&gt;
&lt;li&gt;未收到确认的消息可重新投递（at-least-once 语义）&lt;/li&gt;
&lt;li&gt;自动确认（auto-ack）性能高，但可能丢失；手动确认（manual-ack）可靠，业界更常用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;业界实践&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kafka：使用异步批量确认提高吞吐, 生产者配置 acks（0/1/all），消费者手动提交 offset&lt;/li&gt;
&lt;li&gt;RabbitMQ：生产者用 publisher confirm，消费者用 manual ack&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优化&lt;/strong&gt;：异步批量确认（如 Kafka 缓冲发送）或延迟确认（如 RabbitMQ 批量 ack）提升吞吐。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;重复消息可能因网络抖动或重试产生，需幂等性支持&lt;/p&gt;
&lt;p&gt;确认超时需重试，增加系统复杂性，但不可或缺&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;14-幂等性与去重&#34;&gt;1.4. 幂等性与去重&lt;/h3&gt;
&lt;p&gt;消息重试或网络问题可能导致重复发送/消费, 幂等性防止重复处理影响业务逻辑:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当生产者发送消息到消息队列后，如果没有收到确认响应（可能因为网络问题或服务器处理延迟），生产者会认为消息发送失败并重新发送，导致相同消息被发送多次&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;幂等性是指一个操作执行一次和执行多次的结果是一样的, 下面是 &lt;strong&gt;消费者&lt;/strong&gt; 实现代码:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 库存服务处理消息的代码示例&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;processInventoryReduction&lt;/span&gt;(InventoryMessage message) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String messageId &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; message.&lt;span style=&#34;color:#a6e22e&#34;&gt;getMessageId&lt;/span&gt;(); &lt;span style=&#34;color:#75715e&#34;&gt;// 消息唯一ID&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 检查消息是否已处理&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (messageProcessRepository.&lt;span style=&#34;color:#a6e22e&#34;&gt;isProcessed&lt;/span&gt;(messageId)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        log.&lt;span style=&#34;color:#a6e22e&#34;&gt;info&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;消息{}已处理，忽略重复消息&amp;#34;&lt;/span&gt;, messageId);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 执行库存扣减逻辑&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        inventoryService.&lt;span style=&#34;color:#a6e22e&#34;&gt;reduce&lt;/span&gt;(message.&lt;span style=&#34;color:#a6e22e&#34;&gt;getProductId&lt;/span&gt;(), message.&lt;span style=&#34;color:#a6e22e&#34;&gt;getQuantity&lt;/span&gt;());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 标记消息为已处理&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        messageProcessRepository.&lt;span style=&#34;color:#a6e22e&#34;&gt;markAsProcessed&lt;/span&gt;(messageId);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt; (Exception e) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        log.&lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;处理消息{}失败&amp;#34;&lt;/span&gt;, messageId, e);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; e;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;是不是好奇幂等性是怎么实现的? &lt;code&gt;messageProcessRepository&lt;/code&gt; 是全局的仓库吗 也就是说 所有的客户端共享这一个仓库 确保消息被处理一次, 如果每个客户端单独维护一个仓库, 好像无法实现?&lt;/p&gt;
&lt;p&gt;在多个消费者实例的情况下, &lt;code&gt;messageProcessRepository&lt;/code&gt; 必须是全局共享的存储, 最常见的实现是一个数据库表, 记录已处理的消息ID, 而且不要忘了, 消费者也是运行在服务器上的, 而不是客户端&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;幂等性实现的完整架构&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 消息处理记录表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; message_process_record (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    message_id VARCHAR(&lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt;,  &lt;span style=&#34;color:#75715e&#34;&gt;-- 消息唯一ID作为主键确保唯一性
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    consumer_group VARCHAR(&lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt;, &lt;span style=&#34;color:#75715e&#34;&gt;-- 消费者组标识
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    process_time &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt;,     &lt;span style=&#34;color:#75715e&#34;&gt;-- 处理时间
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    process_status VARCHAR(&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;-- 处理状态
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 可选：添加索引优化查询
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INDEX&lt;/span&gt; idx_consumer_message &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; message_process_record(consumer_group, message_id);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;消费者实现&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Service&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;InventoryConsumer&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Autowired&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; JdbcTemplate jdbcTemplate;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Autowired&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; InventoryService inventoryService;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 消费者组标识，通常从配置中获取&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; String CONSUMER_GROUP &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;inventory-service&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@RabbitListener&lt;/span&gt;(queues &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;inventory-queue&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;processInventoryReduction&lt;/span&gt;(InventoryMessage message) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        String messageId &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; message.&lt;span style=&#34;color:#a6e22e&#34;&gt;getMessageId&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 检查消息是否已处理 - 使用共享数据库&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (isMessageProcessed(messageId)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            log.&lt;span style=&#34;color:#a6e22e&#34;&gt;info&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;消息{}已处理，忽略重复消息&amp;#34;&lt;/span&gt;, messageId);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 尝试记录消息处理状态 - 使用数据库唯一约束确保幂等&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;markMessageProcessing(messageId)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                log.&lt;span style=&#34;color:#a6e22e&#34;&gt;info&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;消息{}已被其他实例处理，忽略&amp;#34;&lt;/span&gt;, messageId);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 执行库存扣减逻辑&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            inventoryService.&lt;span style=&#34;color:#a6e22e&#34;&gt;reduce&lt;/span&gt;(message.&lt;span style=&#34;color:#a6e22e&#34;&gt;getProductId&lt;/span&gt;(), message.&lt;span style=&#34;color:#a6e22e&#34;&gt;getQuantity&lt;/span&gt;());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 标记消息为已成功处理&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            markMessageProcessed(messageId);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt; (Exception e) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            log.&lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;处理消息{}失败&amp;#34;&lt;/span&gt;, messageId, e);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 可选：标记消息处理失败，以便后续分析&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            markMessageFailed(messageId, e.&lt;span style=&#34;color:#a6e22e&#34;&gt;getMessage&lt;/span&gt;());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; e;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;isMessageProcessed&lt;/span&gt;(String messageId) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; jdbcTemplate.&lt;span style=&#34;color:#a6e22e&#34;&gt;queryForObject&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;SELECT COUNT(*) FROM message_process_record WHERE message_id = ? AND consumer_group = ?&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            Integer.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;, messageId, CONSUMER_GROUP);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; count &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; 0;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;markMessageProcessing&lt;/span&gt;(String messageId) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            jdbcTemplate.&lt;span style=&#34;color:#a6e22e&#34;&gt;update&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;INSERT INTO message_process_record (message_id, consumer_group, process_time, process_status) &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;VALUES (?, ?, NOW(), &amp;#39;PROCESSING&amp;#39;)&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                messageId, CONSUMER_GROUP);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt; (DuplicateKeyException e) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 如果消息ID已存在，说明已被处理或正在处理&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;markMessageProcessed&lt;/span&gt;(String messageId) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        jdbcTemplate.&lt;span style=&#34;color:#a6e22e&#34;&gt;update&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;UPDATE message_process_record SET process_status = &amp;#39;PROCESSED&amp;#39;, process_time = NOW() &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;WHERE message_id = ? AND consumer_group = ?&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            messageId, CONSUMER_GROUP);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;markMessageFailed&lt;/span&gt;(String messageId, String errorMessage) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        jdbcTemplate.&lt;span style=&#34;color:#a6e22e&#34;&gt;update&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;UPDATE message_process_record SET process_status = &amp;#39;FAILED&amp;#39;, error_message = ?, process_time = NOW() &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;WHERE message_id = ? AND consumer_group = ?&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            errorMessage, messageId, CONSUMER_GROUP);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于需要更强一致性保证的场景，可以结合分布式锁：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Autowired&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; RedissonClient redissonClient;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;processInventoryReduction&lt;/span&gt;(InventoryMessage message) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String messageId &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; message.&lt;span style=&#34;color:#a6e22e&#34;&gt;getMessageId&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String lockKey &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;inventory_msg_lock:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; messageId;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 检查消息是否已处理&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (isMessageProcessed(messageId)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        log.&lt;span style=&#34;color:#a6e22e&#34;&gt;info&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;消息{}已处理，忽略重复消息&amp;#34;&lt;/span&gt;, messageId);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 获取分布式锁，确保同一时间只有一个实例处理该消息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    RLock lock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; redissonClient.&lt;span style=&#34;color:#a6e22e&#34;&gt;getLock&lt;/span&gt;(lockKey);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 尝试获取锁，等待2秒，持有锁10秒&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (lock.&lt;span style=&#34;color:#a6e22e&#34;&gt;tryLock&lt;/span&gt;(2, 10, TimeUnit.&lt;span style=&#34;color:#a6e22e&#34;&gt;SECONDS&lt;/span&gt;)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 再次检查，防止锁等待期间其他实例已处理&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (isMessageProcessed(messageId)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    log.&lt;span style=&#34;color:#a6e22e&#34;&gt;info&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;获取锁后再次检查：消息{}已处理&amp;#34;&lt;/span&gt;, messageId);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 标记为处理中&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                markMessageProcessing(messageId);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 执行业务逻辑&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                inventoryService.&lt;span style=&#34;color:#a6e22e&#34;&gt;reduce&lt;/span&gt;(message.&lt;span style=&#34;color:#a6e22e&#34;&gt;getProductId&lt;/span&gt;(), message.&lt;span style=&#34;color:#a6e22e&#34;&gt;getQuantity&lt;/span&gt;());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 标记为已处理&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                markMessageProcessed(messageId);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            } &lt;span style=&#34;color:#66d9ef&#34;&gt;finally&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                lock.&lt;span style=&#34;color:#a6e22e&#34;&gt;unlock&lt;/span&gt;(); &lt;span style=&#34;color:#75715e&#34;&gt;// 确保释放锁&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            log.&lt;span style=&#34;color:#a6e22e&#34;&gt;info&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;无法获取消息{}的处理锁，跳过处理&amp;#34;&lt;/span&gt;, messageId);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Thread.&lt;span style=&#34;color:#a6e22e&#34;&gt;currentThread&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;interrupt&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        log.&lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;获取锁被中断&amp;#34;&lt;/span&gt;, e);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;2-redis-list-简易消息队列可靠性分析&#34;&gt;2. Redis List 简易消息队列可靠性分析&lt;/h2&gt;
&lt;p&gt;无论什么, 消息队列的可靠性都可以参考上面的规范, 这里我们主要讨论 redis 持久化, 所以上面的很多都没考虑, 保证消息的可靠性分为两个方面:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生产者使用消息持久化&lt;/li&gt;
&lt;li&gt;消费者使用重试确认机制&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;21-生产者-redis-持久化&#34;&gt;2.1. 生产者 (Redis 持久化)&lt;/h3&gt;
&lt;p&gt;启用 Redis 的 AOF（Append-Only File）持久化，确保消息写入 List 后, 即使 Redis 重启也能恢复, AOF 的 &lt;code&gt;everysec&lt;/code&gt; 模式适合大多数场景，若需更高可靠性可改为&lt;code&gt;always&lt;/code&gt;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;appendonly yes
appendfsync everysec  # 每秒同步，平衡性能与可靠性
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;22-消费者&#34;&gt;2.2. 消费者&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;可靠取出&lt;/strong&gt;：使用 RPOPLPUSH（而非简单的 RPOP），将消息从主队列（如 email_queue）原子性地弹出并推入备份队列（如 backup_queue）, 处理成功后再从备份队列移除，确保消息不丢失&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-pyyhon&#34; data-lang=&#34;pyyhon&#34;&gt;def consume_task():
    try:
        order_id = redis_client.rpoplpush(&amp;#34;email_queue&amp;#34;, &amp;#34;backup_queue&amp;#34;)
        if order_id:
            send_email(order_id)
            redis_client.lrem(&amp;#34;backup_queue&amp;#34;, 1, order_id)  # 确认处理成功
    except Exception as e:
        print(f&amp;#34;Error: {e}&amp;#34;)
        # 任务仍在 backup_queue，可重试
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;失败重试&lt;/strong&gt;：如果邮件发送失败（如网络问题），消费者可将任务重新推回主队列或记录到错误队列，稍后重试&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;retry_task&lt;/span&gt;(order_id):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    redis_client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;lpush(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;email_queue&amp;#34;&lt;/span&gt;, order_id)  &lt;span style=&#34;color:#75715e&#34;&gt;# 重新推入主队列&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;使用 ⁠&lt;code&gt;RPOP&lt;/code&gt; 时的主要问题是 一旦任务被弹出，它就从队列中消失了, 使用 RPOPLPUSH 的场景:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;初始状态: 
待处理队列 = [任务1, 任务2, 任务3]
处理中队列 = []

1. 应用程序执行 RPOPLPUSH → 将&amp;#34;任务3&amp;#34;从待处理队列移到处理中队列
   待处理队列 = [任务1, 任务2]
   处理中队列 = [任务3]
   
2. 应用程序开始处理&amp;#34;任务3&amp;#34;
   
3. 在处理过程中，应用程序崩溃
   
结果: &amp;#34;任务3&amp;#34;仍然存在于处理中队列，可以在系统重启后恢复
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;RPOPLPUSH 是一个原子操作，它确保元素从源列表移除并添加到目标列表的过程不会被中断&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    </item>
    
    <item>
      <title>Redis 常见数据类型的使用场景</title>
      <link>https://blog.jiyi27.com/posts/interview/%E7%BC%93%E5%AD%98%E5%92%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/003-redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</link>
      <pubDate>Sun, 13 Apr 2025 21:56:20 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E7%BC%93%E5%AD%98%E5%92%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/003-redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</guid>
      <description>&lt;h2 id=&#34;1-string&#34;&gt;1. String&lt;/h2&gt;
&lt;h3 id=&#34;11-缓存热点数据&#34;&gt;1.1. 缓存热点数据&lt;/h3&gt;
&lt;p&gt;在高并发系统中，频繁查询数据库会导致性能瓶颈，使用 Redis String 缓存数据库查询结果（如用户信息、商品详情）可以显著降低数据库压力：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;user_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1001&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cached_user &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; redis_client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user:&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;user_id&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; cached_user:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; json&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;loads(cached_user)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    user &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; db&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;query(User)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(user_id)  &lt;span style=&#34;color:#75715e&#34;&gt;# 从数据库查询&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    redis_client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;setex(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user:&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;user_id&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3600&lt;/span&gt;, json&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;dumps(user))  &lt;span style=&#34;color:#75715e&#34;&gt;# 缓存 1 小时&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; user
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;Redis 中习惯在 KEY 中通过 &lt;code&gt;:&lt;/code&gt; 连接字符串, 这样可以清晰的表达出含义, 如: &lt;code&gt;page:view:article:1001&lt;/code&gt;, 就是一个字符串, 不是什么高级的东西&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;12-分布式锁&#34;&gt;1.2. 分布式锁&lt;/h3&gt;
&lt;p&gt;在分布式系统中，防止多个服务同时操作同一资源（如库存扣减），Redis String 结合 SETNX（set if not exists）实现简单分布式锁&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SETNX lock:order:12345 &amp;quot;locked&amp;quot;&lt;/code&gt;（如果 key 不存在，则设置成功，表示获取到锁）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EXPIRE lock:order:12345 10&lt;/code&gt;（设置超时时间，防止死锁）&lt;/li&gt;
&lt;li&gt;操作完成后 &lt;code&gt;DEL lock:order:12345&lt;/code&gt;（释放锁）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在 Redis 中，大部分&lt;strong&gt;单个命令&lt;/strong&gt;都是原子操作，像 &lt;code&gt;SET&lt;/code&gt;、&lt;code&gt;INCR&lt;/code&gt;、&lt;code&gt;SETNX&lt;/code&gt;、&lt;code&gt;DEL&lt;/code&gt; 是绝对原子的，因为 Redis 是单线程执行命令的，这意味着 不会有其他操作在命令执行的过程中打断它，当然也有不是原子操作: &lt;code&gt;GETSET&lt;/code&gt;, &lt;code&gt;MGET / MSET&lt;/code&gt;&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-string&#34;&gt;1. String&lt;/h2&gt;
&lt;h3 id=&#34;11-缓存热点数据&#34;&gt;1.1. 缓存热点数据&lt;/h3&gt;
&lt;p&gt;在高并发系统中，频繁查询数据库会导致性能瓶颈，使用 Redis String 缓存数据库查询结果（如用户信息、商品详情）可以显著降低数据库压力：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;user_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1001&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cached_user &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; redis_client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user:&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;user_id&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; cached_user:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; json&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;loads(cached_user)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    user &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; db&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;query(User)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(user_id)  &lt;span style=&#34;color:#75715e&#34;&gt;# 从数据库查询&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    redis_client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;setex(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user:&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;user_id&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3600&lt;/span&gt;, json&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;dumps(user))  &lt;span style=&#34;color:#75715e&#34;&gt;# 缓存 1 小时&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; user
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;Redis 中习惯在 KEY 中通过 &lt;code&gt;:&lt;/code&gt; 连接字符串, 这样可以清晰的表达出含义, 如: &lt;code&gt;page:view:article:1001&lt;/code&gt;, 就是一个字符串, 不是什么高级的东西&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;12-分布式锁&#34;&gt;1.2. 分布式锁&lt;/h3&gt;
&lt;p&gt;在分布式系统中，防止多个服务同时操作同一资源（如库存扣减），Redis String 结合 SETNX（set if not exists）实现简单分布式锁&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SETNX lock:order:12345 &amp;quot;locked&amp;quot;&lt;/code&gt;（如果 key 不存在，则设置成功，表示获取到锁）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EXPIRE lock:order:12345 10&lt;/code&gt;（设置超时时间，防止死锁）&lt;/li&gt;
&lt;li&gt;操作完成后 &lt;code&gt;DEL lock:order:12345&lt;/code&gt;（释放锁）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在 Redis 中，大部分&lt;strong&gt;单个命令&lt;/strong&gt;都是原子操作，像 &lt;code&gt;SET&lt;/code&gt;、&lt;code&gt;INCR&lt;/code&gt;、&lt;code&gt;SETNX&lt;/code&gt;、&lt;code&gt;DEL&lt;/code&gt; 是绝对原子的，因为 Redis 是单线程执行命令的，这意味着 不会有其他操作在命令执行的过程中打断它，当然也有不是原子操作: &lt;code&gt;GETSET&lt;/code&gt;, &lt;code&gt;MGET / MSET&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;13-计数器&#34;&gt;1.3. 计数器&lt;/h3&gt;
&lt;p&gt;记录网站的访问量、文章的点赞数、商品的浏览量等，Redis String 支持原子操作 INCR 和 DECR，非常适合计数场景&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;INCR article:view:2001  # 文章 ID 2001 浏览量 +1
GET article:view:2001   # 获取当前浏览量
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;14-短链存储&#34;&gt;1.4. 短链存储&lt;/h3&gt;
&lt;p&gt;实现短链接功能，如 &lt;code&gt;https://tinyurl.com/abcd&lt;/code&gt; 映射到 &lt;code&gt;https://example.com/long-url&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;generate_short_code&lt;/span&gt;(url):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;生成短链代码（如 6 位随机字符串或基于 URL 的哈希）&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 简单示例：随机 6 位字符&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    characters &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; string&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ascii_letters &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; string&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;digits
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;join(random&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;choice(characters) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;create_short_url&lt;/span&gt;(long_url, expire_seconds&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2592000&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;创建短链并存储&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    short_code &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; generate_short_code(long_url)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 确保 short_code 唯一，实际中可能需要重试或哈希&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; redis_client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;exists(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;short:&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;short_code&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        short_code &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; generate_short_code(long_url)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    redis_client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;setex(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;short:&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;short_code&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, expire_seconds, long_url)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; short_code
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;get_long_url&lt;/span&gt;(short_code):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;根据短链获取原始网址&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    long_url &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; redis_client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;short:&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;short_code&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; long_url&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;decode() &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; long_url &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;2-set&#34;&gt;2. Set&lt;/h2&gt;
&lt;h3 id=&#34;21-数据去重与快速查重&#34;&gt;2.1. 数据去重与快速查重&lt;/h3&gt;
&lt;p&gt;利用 Set 元素不允许重复的特性，可以用来存储用户访问记录或防止重复投票 点赞等场景&lt;/p&gt;
&lt;h3 id=&#34;22-共同关注好友推荐&#34;&gt;2.2. 共同关注/好友推荐&lt;/h3&gt;
&lt;p&gt;社交平台中，查找用户共同关注的人，或基于共同关注推荐新好友&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-redis&#34; data-lang=&#34;redis&#34;&gt;SADD user:1001:follows &amp;#34;user:2001&amp;#34; &amp;#34;user:2002&amp;#34; &amp;#34;user:2003&amp;#34;
SADD user:1002:follows &amp;#34;user:2002&amp;#34; &amp;#34;user:2003&amp;#34; &amp;#34;user:2004&amp;#34;
SINTER user:1001:follows user:1002:follows  # 交集：共同关注 [&amp;#34;user:2002&amp;#34;, &amp;#34;user:2003&amp;#34;]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;23-黑名单白名单管理&#34;&gt;2.3. 黑名单/白名单管理&lt;/h3&gt;
&lt;p&gt;Set 常用于存储黑名单或白名单数据，由于其快速的查找特性，可以高效判断某个元素是否被列入名单，适用于安全控制、IP 屏蔽、广告过滤等场景&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-redis&#34; data-lang=&#34;redis&#34;&gt;# 添加IP到黑名单
SADD blacklist:ips &amp;#34;192.168.1.100&amp;#34; &amp;#34;10.0.0.5&amp;#34;

# 检查IP是否在黑名单中
SISMEMBER blacklist:ips &amp;#34;192.168.1.100&amp;#34;  # 返回 1 表示IP被屏蔽

# 移除IP
SREM blacklist:ips &amp;#34;10.0.0.5&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;3-redis-hash&#34;&gt;3. Redis Hash&lt;/h2&gt;
&lt;h3 id=&#34;31-用户信息存储&#34;&gt;3.1. 用户信息存储&lt;/h3&gt;
&lt;p&gt;Redis Hash 是一个键值对集合，每个 Hash 包含多个字段和对应的值，你可以单独操作某个字段（增、删、改、查），而不必操作整个数据结构,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对比 JSON 字符串&lt;/strong&gt;：如果用 String 类型存储对象（例如用户信息），通常会将整个对象序列化为 JSON 字符串&lt;code&gt;{&amp;quot;id&amp;quot;:&amp;quot;1001&amp;quot;,&amp;quot;name&amp;quot;:&amp;quot;Alice&amp;quot;,&amp;quot;email&amp;quot;:&amp;quot;alice@example.com&amp;quot;}&lt;/code&gt;要修改某个字段（如只改 &lt;code&gt;name&lt;/code&gt;），需要：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取整个 JSON 字符串（GET）&lt;/li&gt;
&lt;li&gt;反序列化解析为对象&lt;/li&gt;
&lt;li&gt;修改字段&lt;/li&gt;
&lt;li&gt;序列化回 JSON&lt;/li&gt;
&lt;li&gt;再存回 Redis, 这会导致额外的 CPU 和内存开销，且操作复杂&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;HMSET user:&lt;span style=&#34;color:#ae81ff&#34;&gt;1001&lt;/span&gt; id &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1001&amp;#34;&lt;/span&gt; name &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Alice&amp;#34;&lt;/span&gt; email &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;alice@example.com&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;HSET user:&lt;span style=&#34;color:#ae81ff&#34;&gt;1001&lt;/span&gt; name &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Bob&amp;#34;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;# 只修改 name 字段&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;HGET user:&lt;span style=&#34;color:#ae81ff&#34;&gt;1001&lt;/span&gt; name       &lt;span style=&#34;color:#75715e&#34;&gt;# 只获取 name 字段&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;32-配置管理&#34;&gt;3.2. 配置管理&lt;/h3&gt;
&lt;p&gt;存储系统配置项（如 API 密钥、开关状态）&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;HMSET config:api rate_limit &amp;#34;100&amp;#34; enabled &amp;#34;true&amp;#34;
HGET config:api rate_limit  # 获取限流配置
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;33-购物车管理&#34;&gt;3.3. 购物车管理&lt;/h3&gt;
&lt;p&gt;存储用户购物车，商品 ID 作为字段，数量作为值&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;HSET cart:user:1001 product:001 2 product:002 1  # 购买 2 件 product:001，1 件 product:002
HINCRBY cart:user:1001 product:001 1  # 增加 1 件
HGETALL cart:user:1001  # 获取购物车内容
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;4-list&#34;&gt;4. List&lt;/h2&gt;
&lt;h3 id=&#34;41-简单的消息队列&#34;&gt;4.1. 简单的消息队列&lt;/h3&gt;
&lt;p&gt;一个电商平台需要处理订单支付后的通知（如发送邮件或短信）， 前端提交订单后，后台将通知任务放入队列，消费者异步处理, 优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;LPUSH 和 BRPOP 提供高效的队列操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BRPOP 的阻塞机制减少轮询，提高性能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;适合轻量级队列，简单易用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;场景&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假设订单支付后，需发送一封确认邮件&lt;/li&gt;
&lt;li&gt;生产者（订单服务）将任务推入 Redis List，消费者（邮件服务）从队列取出任务&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 生产者：订单支付后推送任务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add_notification_task&lt;/span&gt;(order_id, user_email):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    task &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;send_email:&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;order_id&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;user_email&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    r&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;lpush(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;notification_queue&amp;#34;&lt;/span&gt;, task)  &lt;span style=&#34;color:#75715e&#34;&gt;# 推入队列头部&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Task added for order &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;order_id&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 消费者：邮件服务处理任务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;process_notification&lt;/span&gt;():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# 阻塞等待任务，最多等 10 秒&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        task &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; r&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;brpop(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;notification_queue&amp;#34;&lt;/span&gt;, timeout&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; task:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            _, task_data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; task  &lt;span style=&#34;color:#75715e&#34;&gt;# task 是 (key, value) 元组&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Processing: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;task_data&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;decode()&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# 解析任务并发送邮件（伪代码）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            order_id, email &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; task_data&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;decode()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt;)[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;:]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            send_email(email, &lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Order &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;order_id&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; confirmed!&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;思考： 如何保证消息队列的可靠性？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;42-任务堆栈撤销操作&#34;&gt;4.2. 任务堆栈（撤销操作）&lt;/h3&gt;
&lt;p&gt;一个在线文档编辑器需要支持“撤销”功能，记录用户的每次操作（如文本插入、删除），用户点击撤销时回退到上一步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用户每次编辑，操作记录压入 List&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击撤销，从 List 顶部弹出最近的操作并执行反向逻辑&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 记录用户编辑操作&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;record_edit&lt;/span&gt;(user_id, operation):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;edit_history:&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;user_id&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    r&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;lpush(key, operation)  &lt;span style=&#34;color:#75715e&#34;&gt;# 压入操作&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    r&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ltrim(key, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;99&lt;/span&gt;)  &lt;span style=&#34;color:#75715e&#34;&gt;# 限制最多 100 条历史&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Recorded: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;operation&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 撤销操作&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;undo_edit&lt;/span&gt;(user_id):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;edit_history:&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;user_id&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    operation &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; r&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;lpop(key)  &lt;span style=&#34;color:#75715e&#34;&gt;# 弹出最近操作&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; operation:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Undoing: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;operation&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;decode()&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# 执行反向操作（伪代码）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        reverse_operation(operation&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;decode())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;No operations to undo&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 测试&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;record_edit(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user123&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;insert:text:hello&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;record_edit(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user123&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;delete:char:5&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;undo_edit(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user123&amp;#34;&lt;/span&gt;)  &lt;span style=&#34;color:#75715e&#34;&gt;# 输出: Undoing: delete:char:5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;43-时间线&#34;&gt;4.3. 时间线&lt;/h3&gt;
&lt;p&gt;一个社交平台需要展示用户&lt;strong&gt;最新的 10 条动态&lt;/strong&gt;（如朋友圈或微博），按发布时间倒序排列, 优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;LPUSH 保证最新动态在列表头部，天然按时间倒序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LRANGE 高效获取指定范围的数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;适合实时更新和展示有序内容&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;场景：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用户发布动态时，记录动态 ID 和内容到 List&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;前端请求时，取出最新的 N 条动态展示&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 用户发布动态&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;post_update&lt;/span&gt;(user_id, content):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    post_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(time&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;time() &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;)  &lt;span style=&#34;color:#75715e&#34;&gt;# 用时间戳作为 ID&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    post_data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;post_id&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;user_id&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;content&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    r&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;lpush(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;timeline:global&amp;#34;&lt;/span&gt;, post_data)  &lt;span style=&#34;color:#75715e&#34;&gt;# 推入全局时间线&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    r&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ltrim(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;timeline:global&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;999&lt;/span&gt;)  &lt;span style=&#34;color:#75715e&#34;&gt;# 限制 1000 条&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Posted: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;content&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 获取最新动态&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;get_recent_posts&lt;/span&gt;(limit&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    posts &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; r&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;lrange(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;timeline:global&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, limit &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)  &lt;span style=&#34;color:#75715e&#34;&gt;# 取最新 10 条&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; [p&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;decode() &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; p &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; posts]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 测试&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;post_update(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user123&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello, world!&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;post_update(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user456&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Nice day!&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;recent_posts &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; get_recent_posts()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; post &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; recent_posts:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(post)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;注意 List 不适合排行榜, 因为他不会排序, 可以考虑使用堆来实现&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    </item>
    
    <item>
      <title>技术选型 MySQL 还是 MongoDB?</title>
      <link>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/008-mysql%E8%BF%98%E6%98%AFmongodb/</link>
      <pubDate>Sun, 30 Mar 2025 11:09:56 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/008-mysql%E8%BF%98%E6%98%AFmongodb/</guid>
      <description>&lt;p&gt;选 NoSQL 的几个理由, 一定不是多表关联 join 慢, 所以选嵌套, 而是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;想快速启动小专案测试 idea&lt;/li&gt;
&lt;li&gt;资料格式不确定(unstable schema)，而未来很有可能调整&lt;/li&gt;
&lt;li&gt;资料之间没有复杂的关联(无结构, 无组织)、或未来读取资料时不需要使用JOIN 的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;In my 14 years of experience, most. It&amp;rsquo;s not that there&amp;rsquo;s anything wrong with using Mongo if it fits your use case, I&amp;rsquo;ve used it a handful of times, but I find that data, by nature, is almost always relational, or becomes relational very quickly as you start adding features. Then you either have to spend time and effort changing, or use Mongo like it&amp;rsquo;s a relation database, which you should never do as it defeats the point. You&amp;rsquo;d be surprised how many times I&amp;rsquo;ve seen Mongo instances like this. Programs push data around, and it&amp;rsquo;s usually related data.&lt;/p&gt;</description>
      <content>&lt;p&gt;选 NoSQL 的几个理由, 一定不是多表关联 join 慢, 所以选嵌套, 而是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;想快速启动小专案测试 idea&lt;/li&gt;
&lt;li&gt;资料格式不确定(unstable schema)，而未来很有可能调整&lt;/li&gt;
&lt;li&gt;资料之间没有复杂的关联(无结构, 无组织)、或未来读取资料时不需要使用JOIN 的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;In my 14 years of experience, most. It&amp;rsquo;s not that there&amp;rsquo;s anything wrong with using Mongo if it fits your use case, I&amp;rsquo;ve used it a handful of times, but I find that data, by nature, is almost always relational, or becomes relational very quickly as you start adding features. Then you either have to spend time and effort changing, or use Mongo like it&amp;rsquo;s a relation database, which you should never do as it defeats the point. You&amp;rsquo;d be surprised how many times I&amp;rsquo;ve seen Mongo instances like this. Programs push data around, and it&amp;rsquo;s usually related data.&lt;/p&gt;
&lt;p&gt;Tbh Mongo isn&amp;rsquo;t used that much in production from what I&amp;rsquo;ve seen really. The world runs on SQL and that&amp;rsquo;s not going to change. I think Mongo lends itself better to small &amp;ldquo;todo&amp;rdquo; apps and such, so it tends to get used in a lot of tutorials online. When you&amp;rsquo;re starting out and you&amp;rsquo;re watching these, it can give you a false sense that everyone is using it for everything.&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;d say if you think you have a complete picture of all your data requirements and know that they&amp;rsquo;re not going to change, and it&amp;rsquo;s not relational, Mongo is a great choice.&lt;/p&gt;
&lt;p&gt;If you don&amp;rsquo;t have the full picture yet, or something might change, going relational is more future proof. Relational databases can handle not having relations between tables just fine, and you can add them later if needed. Mongo doesn&amp;rsquo;t really handle relational data well at all. &lt;a href=&#34;https://www.reddit.com/r/learnprogramming/comments/gzvyoa/comment/ftiwqzm/?utm_source=share&amp;amp;utm_medium=web3x&amp;amp;utm_name=web3xcss&amp;amp;utm_term=1&amp;amp;utm_content=share_button&#34;&gt;Reddit&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;边缘场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MongoDB is not magically faster. If you store the same data, organised in basically the same fashion, and access it exactly the same way, then you really shouldn&amp;rsquo;t expect your results to be wildly different. After all, MySQL and MongoDB are both GPL, so if Mongo had some magically better IO code in it, then the MySQL team could just incorporate it into their codebase.&lt;/p&gt;
&lt;p&gt;People are seeing real world MongoDB performance largely because MongoDB allows you to query in a different manner that is more sensible to your workload.&lt;/p&gt;
&lt;p&gt;For example, consider a design that persisted a lot of information about a complicated entity in a normalised fashion. This could easily use dozens of tables in MySQL (or any relational db) to store the data in normal form, with many indexes needed to ensure relational integrity between tables.&lt;/p&gt;
&lt;p&gt;Now consider the same design with a document store. If all of those related tables are subordinate to the main table (and they often are), then you might be able to model the data such that the entire entity is stored in a single document. In MongoDB you can store this as a single document, in a single collection. This is where MongoDB starts enabling superior performance.&lt;/p&gt;
&lt;p&gt;In MongoDB, to retrieve the whole entity, you have to perform:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;One index lookup on the collection (assuming the entity is fetched by id)&lt;/li&gt;
&lt;li&gt;Retrieve the contents of one database page (the actual binary json document)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So a b-tree lookup, and a binary page read. Log(n) + 1 IOs. If the indexes can reside entirely in memory, then 1 IO.&lt;/p&gt;
&lt;p&gt;In MySQL with 20 tables, you have to perform:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;One index lookup on the root table (again, assuming the entity is fetched by id)&lt;/li&gt;
&lt;li&gt;With a clustered index, we can assume that the values for the root row are in the index&lt;/li&gt;
&lt;li&gt;20+ range lookups (hopefully on an index) for the entity&amp;rsquo;s pk value&lt;/li&gt;
&lt;li&gt;These probably aren&amp;rsquo;t clustered indexes, so the same 20+ data lookups once we figure out what the appropriate child rows are.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So the total for mysql, even assuming that all indexes are in memory (which is harder since there are 20 times more of them) is about 20 range lookups.&lt;/p&gt;
&lt;p&gt;These range lookups are likely comprised of random IO — different tables will definitely reside in different spots on disk, and it&amp;rsquo;s possible that different rows in the same range in the same table for an entity might not be contiguous (depending on how the entity has been updated, etc).&lt;/p&gt;
&lt;p&gt;So for this example, the final tally is about &lt;em&gt;20 times&lt;/em&gt; more IO with MySQL per logical access, compared to MongoDB.&lt;/p&gt;
&lt;p&gt;This is how MongoDB can boost performance &lt;em&gt;in some use cases&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/a/9703513/16317008&#34;&gt;Stackoverflow&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;1-多表关联查询-mongodb-处于劣势&#34;&gt;1. 多表关联查询 MongoDB 处于劣势&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;MongoDB 不支持原生的 JOIN 操作&lt;/strong&gt;, MongoDB 并不像 MySQL 那样在&lt;strong&gt;引擎层面原生支持 JOIN&lt;/strong&gt;，它是通过聚合管道的 &lt;code&gt;$lookup&lt;/code&gt; 操作符来模拟关联查询的&lt;/p&gt;
&lt;h3 id=&#34;11-mysql-如何做关联查询&#34;&gt;1.1. MySQL 如何做关联查询&lt;/h3&gt;
&lt;p&gt;假设我们有四个数据集合/表：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;users&lt;/code&gt;：存储用户信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;orders&lt;/code&gt;：存储订单信息，关联到用户&lt;/li&gt;
&lt;li&gt;&lt;code&gt;order_items&lt;/code&gt;：存储订单中的商品项，关联到订单和商品&lt;/li&gt;
&lt;li&gt;&lt;code&gt;products&lt;/code&gt;：存储商品信息&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; users (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    user_id INT &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; AUTO_INCREMENT,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    name VARCHAR(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    email VARCHAR(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; orders (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    order_id INT &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; AUTO_INCREMENT,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    user_id INT, &lt;span style=&#34;color:#75715e&#34;&gt;-- Foreign Key to users
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    order_date DATE,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;FOREIGN&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; (user_id) &lt;span style=&#34;color:#66d9ef&#34;&gt;REFERENCES&lt;/span&gt; users(user_id)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; products (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    product_id INT &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; AUTO_INCREMENT,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    name VARCHAR(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    price DECIMAL(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; order_items (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    item_id INT &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; AUTO_INCREMENT,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    order_id INT, &lt;span style=&#34;color:#75715e&#34;&gt;-- Foreign Key to orders
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    product_id INT, &lt;span style=&#34;color:#75715e&#34;&gt;-- Foreign Key to products
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    quantity INT,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;FOREIGN&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; (order_id) &lt;span style=&#34;color:#66d9ef&#34;&gt;REFERENCES&lt;/span&gt; orders(order_id),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;FOREIGN&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; (product_id) &lt;span style=&#34;color:#66d9ef&#34;&gt;REFERENCES&lt;/span&gt; products(product_id)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 假设在所有 Foreign Key 字段上都建立了索引
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INDEX&lt;/span&gt; idx_orders_user &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; orders (user_id);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INDEX&lt;/span&gt; idx_items_order &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; order_items (order_id);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INDEX&lt;/span&gt; idx_items_product &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; order_items (product_id);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;目标:&lt;/strong&gt; 查询用户 &amp;ldquo;Alice&amp;rdquo; 购买过的所有商品的名称和价格，以及对应的订单 ID&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    o.order_id,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p.name &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; product_name,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p.price &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; product_price
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    users u
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;JOIN&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;-- 第 1 次连接: users -&amp;gt; orders
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    orders o &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; u.user_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; o.user_id
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;JOIN&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;-- 第 2 次连接: orders -&amp;gt; order_items
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    order_items oi &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; o.order_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; oi.order_id
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;JOIN&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;-- 第 3 次连接: order_items -&amp;gt; products
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    products p &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; oi.product_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; p.product_id
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    u.name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Alice&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;MySQL 处理过程（概念性）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查询优化器分析阶段&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当你执行一个包含多表 JOIN 的 SQL 语句时，MySQL 不会简单地按照你编写的顺序执行&lt;/li&gt;
&lt;li&gt;优化器会分析表的统计信息，包括：
&lt;ul&gt;
&lt;li&gt;表的大小（行数）&lt;/li&gt;
&lt;li&gt;每个列的数据分布情况&lt;/li&gt;
&lt;li&gt;可用的索引&lt;/li&gt;
&lt;li&gt;条件谓词的选择性（如 &lt;code&gt;WHERE u.name = &#39;Alice&#39;&lt;/code&gt; 会过滤掉多少行）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;执行计划生成&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优化器会评估多种可能的连接顺序&lt;/li&gt;
&lt;li&gt;例如，虽然您编写的是 &lt;code&gt;users → orders → order_items → products&lt;/code&gt;，但优化器可能决定使用 &lt;code&gt;users(过滤Alice) → orders → products → order_items&lt;/code&gt; 或其他顺序&lt;/li&gt;
&lt;li&gt;优化器会选择估计成本最低的执行计划&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;连接算法选择&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据表的大小和索引情况，MySQL 会选择不同的连接算法&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12-mongodb-的实现&#34;&gt;1.2. MongoDB 的实现&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// users collection
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;{ &lt;span style=&#34;color:#a6e22e&#34;&gt;_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user1&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Alice&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;email&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;alice@example.com&amp;#34;&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// orders collection
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;{ &lt;span style=&#34;color:#a6e22e&#34;&gt;_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;order1&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;user_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user1&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;order_date&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ISODate&lt;/span&gt;(...) }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{ &lt;span style=&#34;color:#a6e22e&#34;&gt;_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;order2&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;user_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user1&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;order_date&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ISODate&lt;/span&gt;(...) }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// products collection
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;{ &lt;span style=&#34;color:#a6e22e&#34;&gt;_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;prodA&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Laptop&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;price&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1200&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{ &lt;span style=&#34;color:#a6e22e&#34;&gt;_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;prodB&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Mouse&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;price&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;25&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// order_items collection
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;{ &lt;span style=&#34;color:#a6e22e&#34;&gt;_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;item1&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;order_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;order1&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;product_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;prodA&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;quantity&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{ &lt;span style=&#34;color:#a6e22e&#34;&gt;_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;item2&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;order_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;order1&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;product_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;prodB&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;quantity&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{ &lt;span style=&#34;color:#a6e22e&#34;&gt;_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;item3&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;order_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;order2&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;product_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ObjectId&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;prodA&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;quantity&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 假设在 `orders.user_id`, `order_items.order_id`, `order_items.product_id` 上有索引
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;db&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;orders&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;createIndex&lt;/span&gt;({ &lt;span style=&#34;color:#a6e22e&#34;&gt;user_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;db&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;order_items&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;createIndex&lt;/span&gt;({ &lt;span style=&#34;color:#a6e22e&#34;&gt;order_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;db&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;order_items&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;createIndex&lt;/span&gt;({ &lt;span style=&#34;color:#a6e22e&#34;&gt;product_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; });
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;查询语句 (使用聚合管道和 &lt;code&gt;$lookup&lt;/code&gt;):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;db&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;users&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;aggregate&lt;/span&gt;([
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 阶段 1: 找到用户 Alice
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  { &lt;span style=&#34;color:#a6e22e&#34;&gt;$match&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Alice&amp;#34;&lt;/span&gt; } },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 阶段 2: 关联 orders 集合 (类似 JOIN users ON users._id = orders.user_id)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;$lookup&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;from&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;orders&amp;#34;&lt;/span&gt;,           &lt;span style=&#34;color:#75715e&#34;&gt;// 目标集合
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;localField&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;_id&amp;#34;&lt;/span&gt;,        &lt;span style=&#34;color:#75715e&#34;&gt;// 当前集合 (users) 的字段
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;foreignField&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user_id&amp;#34;&lt;/span&gt;,  &lt;span style=&#34;color:#75715e&#34;&gt;// 目标集合 (orders) 的字段
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;as&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user_orders&amp;#34;&lt;/span&gt;       &lt;span style=&#34;color:#75715e&#34;&gt;// 输出数组的字段名
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 结果: Alice 文档 + user_orders: [ {order1 doc}, {order2 doc} ]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 阶段 3: 展开 user_orders 数组 (每个订单成为一个独立文档)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  { &lt;span style=&#34;color:#a6e22e&#34;&gt;$unwind&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;$user_orders&amp;#34;&lt;/span&gt; },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 结果: { Alice doc, user_orders: {order1 doc} }, { Alice doc, user_orders: {order2 doc} }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 阶段 4: 关联 order_items 集合 (类似 JOIN orders ON orders._id = order_items.order_id)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;$lookup&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;from&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;order_items&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;localField&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user_orders._id&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#75715e&#34;&gt;// 上一阶段展开后的订单 ID
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;foreignField&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;order_id&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;as&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;items&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 结果: { Alice doc, user_orders: {order1}, items: [ {item1}, {item2} ] }, { Alice doc, user_orders: {order2}, items: [ {item3} ] }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 阶段 5: 展开 items 数组
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  { &lt;span style=&#34;color:#a6e22e&#34;&gt;$unwind&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;$items&amp;#34;&lt;/span&gt; },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 结果: {..., items: {item1}}, {..., items: {item2}}, {..., items: {item3}}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 阶段 6: 关联 products 集合 (类似 JOIN order_items ON order_items.product_id = products._id)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;$lookup&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;from&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;products&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;localField&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;items.product_id&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#75715e&#34;&gt;// 上一阶段展开后的商品 ID
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;foreignField&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;_id&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;as&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;product_details&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 结果: {..., items: {item1}, product_details: [{prodA}]}, {..., items: {item2}, product_details: [{prodB}]}, {..., items: {item3}, product_details: [{prodA}]}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 阶段 7: 展开 product_details 数组
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  { &lt;span style=&#34;color:#a6e22e&#34;&gt;$unwind&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;$product_details&amp;#34;&lt;/span&gt; },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 结果: {..., product_details: {prodA}}, {..., product_details: {prodB}}, {..., product_details: {prodA}}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 阶段 8: 投影 (选择最终需要的字段)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;$project&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#75715e&#34;&gt;// 不显示 user 的 _id
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;order_id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;$user_orders._id&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;product_name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;$product_details.name&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;product_price&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;$product_details.price&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 最终结果: { order_id: &amp;#34;order1&amp;#34;, product_name: &amp;#34;Laptop&amp;#34;, price: 1200 }, { order_id: &amp;#34;order1&amp;#34;, product_name: &amp;#34;Mouse&amp;#34;, price: 25 }, { order_id: &amp;#34;order2&amp;#34;, product_name: &amp;#34;Laptop&amp;#34;, price: 1200 }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;MongoDB 处理过程及潜在性能问题分析：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;阶段式执行：&lt;/strong&gt; 聚合管道是按顺序执行每个阶段的, 每个阶段的输出是下一个阶段的输入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$lookup&lt;/code&gt; 的代价：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;阶段 2 (&lt;code&gt;$lookup&lt;/code&gt; orders):&lt;/strong&gt; 找到 Alice 后，拿着 Alice 的 &lt;code&gt;_id&lt;/code&gt; 去 &lt;code&gt;orders&lt;/code&gt; 集合查询, 如果 &lt;code&gt;orders.user_id&lt;/code&gt; 有索引，这一步通常很快&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;阶段 4 (&lt;code&gt;$lookup&lt;/code&gt; order_items):&lt;/strong&gt; 经过 &lt;code&gt;$unwind&lt;/code&gt; 后，假设 Alice 有 M 个订单, MongoDB 需要对这 M 个文档&lt;strong&gt;分别&lt;/strong&gt;执行 &lt;code&gt;lookup&lt;/code&gt; 操作, 即，拿着每个订单的 &lt;code&gt;_id&lt;/code&gt; 去 &lt;code&gt;order_items&lt;/code&gt; 集合中查询, 相当于 M 次对 &lt;code&gt;order_items&lt;/code&gt; 的查询&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;阶段 6 (&lt;code&gt;$lookup&lt;/code&gt; products):&lt;/strong&gt; 假设 Alice 的 M 个订单总共有 N 个商品项（经过 &lt;code&gt;$unwind&lt;/code&gt; 后产生 N 个文档）MongoDB 需要对这 N 个文档&lt;strong&gt;分别&lt;/strong&gt;执行 &lt;code&gt;lookup&lt;/code&gt; 操作，拿着每个商品项的 &lt;code&gt;product_id&lt;/code&gt; 去 &lt;code&gt;products&lt;/code&gt; 集合查询。这相当于 N 次对 &lt;code&gt;products&lt;/code&gt; 的查询&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;$unwind&lt;/code&gt; 的代价：&lt;/strong&gt; &lt;code&gt;$unwind&lt;/code&gt; 操作会增加管道中流动的文档数量, 如果一个用户有很多订单，每个订单有很多商品，那么中间阶段的文档数量会急剧膨胀，加大了后续阶段的处理负担&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重复查询：&lt;/strong&gt; 注意在阶段 6，如果 Alice 多次购买了同一个商品 &lt;code&gt;prodA&lt;/code&gt;（来自不同订单或同一订单的不同 &lt;code&gt;item&lt;/code&gt; 记录），&lt;code&gt;$lookup&lt;/code&gt; 可能会多次去 &lt;code&gt;products&lt;/code&gt; 集合查找 &lt;code&gt;prodA&lt;/code&gt; 的信息（虽然缓存可能有所帮助，但查询动作本身是针对每个输入文档触发的）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优化限制：&lt;/strong&gt; 虽然 MongoDB 的聚合框架和 &lt;code&gt;$lookup&lt;/code&gt; 也在不断优化，但这种&lt;strong&gt;按文档流逐步处理和多次独立查询外部集合&lt;/strong&gt;的模式，相比于关系型数据库&lt;strong&gt;全局优化、基于集合的连接算法&lt;/strong&gt;，在多层关联、数据量大的情况下，更容易遇到性能瓶颈, 优化器很难像 SQL 那样进行彻底的连接顺序重排或选择根本不同的连接算法（如 Hash Join）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;对比之下性能明显低于 MySQL 的 JOIN 操作&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-join-算法&#34;&gt;2. join 算法&lt;/h2&gt;
&lt;h3 id=&#34;21-什么是表连接&#34;&gt;2.1. 什么是表连接？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;users 表&lt;/strong&gt;：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;id&lt;/th&gt;
          &lt;th&gt;name&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;Alice&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;Bob&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;Charlie&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;orders 表&lt;/strong&gt;：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;id&lt;/th&gt;
          &lt;th&gt;user_id&lt;/th&gt;
          &lt;th&gt;amount&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;100&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;200&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;150&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;查询每个用户的所有订单：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; u.name, o.amount &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; users u &lt;span style=&#34;color:#66d9ef&#34;&gt;JOIN&lt;/span&gt; orders o &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; u.id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; o.user_id;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;22-索引嵌套循环连接index-nested-loop-join-inlj&#34;&gt;2.2. 索引嵌套循环连接（Index Nested-Loop Join, INLJ）&lt;/h3&gt;
&lt;h4 id=&#34;221-基本思想&#34;&gt;2.2.1. 基本思想&lt;/h4&gt;
&lt;p&gt;索引嵌套循环连接利用&lt;strong&gt;索引&lt;/strong&gt;来加速连接过程, 当连接列（比如 &lt;code&gt;orders.user_id&lt;/code&gt;）上有索引时，这种方式非常高效&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一般建立外键约束的时候, 就应该手动在该列上建立索引, 因为外键基本上都是 一对多 关系中用来连接查询的, 比如 用户 - 订单, 一个用户对应多个订单, 那订单表中就应该放一个用户 id, 建立外键约束和索引, 因为未来一定会用到查找某个用户的订单&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;222-工作原理&#34;&gt;2.2.2. 工作原理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;MySQL 选择一个表作为&lt;strong&gt;外层表&lt;/strong&gt;（通常是行数较少的表），比如 &lt;code&gt;users&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;对于 &lt;code&gt;users&lt;/code&gt; 表的每一行，MySQL 用 &lt;code&gt;id&lt;/code&gt; 的值在 &lt;code&gt;orders&lt;/code&gt; 表的 &lt;code&gt;user_id&lt;/code&gt; 索引上查找匹配的行&lt;/li&gt;
&lt;li&gt;因为有索引，查找速度很快（接近 O(1)）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;为什么索引的查询速度接近 O(1) ?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;B+ Tree 的高度很小（即使数据量很大 几百万,可能高度就3~4）, 所以查找的实际时间几乎是个很小的常数, 注意  B+ Tree 和 二叉搜索树不是一个东西, 后面会详细讨论这部分&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;223-举例&#34;&gt;2.2.3. 举例&lt;/h4&gt;
&lt;p&gt;假设 &lt;code&gt;orders.user_id&lt;/code&gt; 列上有索引：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从 &lt;code&gt;users&lt;/code&gt; 表取第一行：&lt;code&gt;id = 1, name = Alice&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;id = 1&lt;/code&gt; 在 &lt;code&gt;orders&lt;/code&gt; 表的 &lt;code&gt;user_id&lt;/code&gt; 索引中查找，找到两行：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;user_id = 1, amount = 100&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;user_id = 1, amount = 150&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;移动到 &lt;code&gt;users&lt;/code&gt; 表的第二行：&lt;code&gt;id = 2, name = Bob&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;id = 2&lt;/code&gt; 在索引中查找，找到一行：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;user_id = 2, amount = 200&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;继续，直到处理完所有行&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;就像是 for 循环:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 模拟索引：把 orders 按 user_id 分组（类似哈希索引）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;order_index &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; order &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; orders:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    uid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; order[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user_id&amp;#34;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; uid &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; order_index:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        order_index[uid] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    order_index[uid]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(order)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 模拟 JOIN 查询：users 是驱动表&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; user &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; users:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    uid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; user[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;id&amp;#34;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 利用“索引”直接查找匹配的订单&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; uid &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; order_index:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; order &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; order_index[uid]:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;user[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;name&amp;#39;&lt;/span&gt;]&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; bought &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;order[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;item&amp;#39;&lt;/span&gt;]&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;h4 id=&#34;224-特点&#34;&gt;2.2.4. 特点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;当有良好索引支持时最快，因为索引让查找变得高效&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果 &lt;code&gt;orders.user_id&lt;/code&gt; 上没有索引，MySQL 不会选择这种方式&lt;/strong&gt;, 可能会选择其他连接方式
&lt;ul&gt;
&lt;li&gt;哈希连接（Hash Join）：构建哈希表来加速匹配，适合大表无索引的场景&lt;/li&gt;
&lt;li&gt;块嵌套循环连接（Block Nested-Loop Join, BNLJ）：扫描两表，分块处理以减少 I/O&lt;/li&gt;
&lt;li&gt;简单嵌套循环连接（Simple Nested-Loop Join, SNLJ）：最慢，通常不会选&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;23-哈希连接hash-join&#34;&gt;2.3 哈希连接（Hash Join）&lt;/h3&gt;
&lt;h4 id=&#34;231-基本思想&#34;&gt;2.3.1. 基本思想&lt;/h4&gt;
&lt;p&gt;哈希连接使用&lt;strong&gt;哈希表&lt;/strong&gt;来加速连接过程，特别适合&lt;strong&gt;大表且没有合适索引&lt;/strong&gt;的情况&lt;/p&gt;
&lt;h4 id=&#34;232-工作原理&#34;&gt;2.3.2. 工作原理&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;MySQL 选择一个表（通常较小的表）作为&lt;strong&gt;构建表&lt;/strong&gt;，比如 &lt;code&gt;users&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;为 &lt;code&gt;users&lt;/code&gt; 表的连接列 &lt;code&gt;id&lt;/code&gt; 创建一个哈希表：
&lt;ul&gt;
&lt;li&gt;键是 &lt;code&gt;id&lt;/code&gt;，值是对应的行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对另一个表（&lt;strong&gt;探针表&lt;/strong&gt;，比如 &lt;code&gt;orders&lt;/code&gt;）的每一行，计算 &lt;code&gt;user_id&lt;/code&gt; 的哈希值，在哈希表中查找匹配的行&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;233-举例&#34;&gt;2.3.3. 举例&lt;/h4&gt;
&lt;p&gt;假设 &lt;code&gt;orders.user_id&lt;/code&gt; 没有索引：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;构建阶段&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;从 &lt;code&gt;users&lt;/code&gt; 表创建哈希表：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 -&amp;gt; {id = 1, name = Alice}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2 -&amp;gt; {id = 2, name = Bob}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;3 -&amp;gt; {id = 3, name = Charlie}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;探针阶段&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;取 &lt;code&gt;orders&lt;/code&gt; 第一行：&lt;code&gt;user_id = 1, amount = 100&lt;/code&gt;，哈希表中找到 &lt;code&gt;name = Alice&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;取 &lt;code&gt;orders&lt;/code&gt; 第二行：&lt;code&gt;user_id = 2, amount = 200&lt;/code&gt;，哈希表中找到 &lt;code&gt;name = Bob&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;取 &lt;code&gt;orders&lt;/code&gt; 第三行：&lt;code&gt;user_id = 1, amount = 150&lt;/code&gt;，哈希表中找到 &lt;code&gt;name = Alice&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;234-特点&#34;&gt;2.3.4. 特点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：对于大表且无适合索引时最佳选择，哈希表查找速度是 O(1)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：需要内存存储哈希表，如果表太大可能内存不足&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;24-其他连接方式&#34;&gt;2.4. 其他连接方式&lt;/h3&gt;
&lt;h4 id=&#34;241-块嵌套循环连接block-nested-loop-join-bnlj&#34;&gt;2.4.1. 块嵌套循环连接（Block Nested-Loop Join, BNLJ）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基本思想&lt;/strong&gt;：这是嵌套循环的优化版，一次读取多行（一个块）来减少 I/O&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：是简单嵌套循环连接的改进版本，但通常不如哈希连接或索引嵌套循环连接快&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;举例&lt;/strong&gt;：MySQL 从 &lt;code&gt;users&lt;/code&gt; 读取一组行（比如 2 行），然后扫描 &lt;code&gt;orders&lt;/code&gt; 找匹配，效率比逐行扫描高&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;BNLJ的基本思想是将外表（Outer Table）的数据分块读取到内存中，然后对每个块内的元组与内表（Inner Table）的所有元组进行比较，从而减少对内表的重复扫描&lt;/p&gt;
&lt;p&gt;比如每次 从 users 表中 拿出 多行数据 而不是 1个, 每次分别把多行数据跟内表进行比较,  虽然 比较次数没变, 但内表加载次数变少了, 减少了 磁盘 IO, 因为内表只需要为每个外表块加载一次，而不是为每行外表记录加载一次, 所以更高效一些&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;242-简单嵌套循环连接simple-nested-loop-join-snlj&#34;&gt;2.4.2. 简单嵌套循环连接（Simple Nested-Loop Join, SNLJ）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;基本思想：最原始的方式，对 &lt;code&gt;users&lt;/code&gt; 的每一行，扫描 &lt;code&gt;orders&lt;/code&gt; 的所有行&lt;/li&gt;
&lt;li&gt;特点：最慢，时间复杂度 &lt;strong&gt;O(N * M)&lt;/strong&gt;，通常被优化为其他形式&lt;/li&gt;
&lt;li&gt;举例：对 &lt;code&gt;users&lt;/code&gt; 的 &lt;code&gt;id = 1&lt;/code&gt;，扫描 &lt;code&gt;orders&lt;/code&gt; 所有行找 &lt;code&gt;user_id = 1&lt;/code&gt;，重复此过程，效率极低&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;25-mysql-如何选择连接方式&#34;&gt;2.5. MySQL 如何选择连接方式？&lt;/h3&gt;
&lt;p&gt;MySQL 的查询优化器会根据以下因素选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;索引情况&lt;/strong&gt;：有索引时优先用索引嵌套循环连接。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;表大小&lt;/strong&gt;：大表无索引时可能用哈希连接。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存和 I/O&lt;/strong&gt;：内存不足时可能用块嵌套循环连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-mysql-中-索引的查找速度是否接近-o1&#34;&gt;3. MySQL 中, 索引的查找速度是否“接近 O(1)”&lt;/h2&gt;
&lt;h3 id=&#34;31-最常见的索引b-tree-索引&#34;&gt;3.1. 最常见的索引：B+ Tree 索引&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MySQL InnoDB 引擎默认的索引类型是 B+ Tree&lt;/li&gt;
&lt;li&gt;B+ Tree 是一种自平衡树结构, 它的查找时间复杂度是 &lt;strong&gt;O(log n)&lt;/strong&gt;, 其中 n 是数据的条数&lt;/li&gt;
&lt;li&gt;为什么是 &lt;code&gt;O(log n)&lt;/code&gt;？因为 B-Tree 的查找过程依赖于树的高度，而树的高度通常是 &lt;code&gt;O(log n)&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;即使存储数百万条记录，B+ Tree 的高度也不会超过几层&lt;/li&gt;
&lt;li&gt;每次查找只需要沿着树的高度走几步，所以实际耗时非常短&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;为什么常说“接近 O(1)”？&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;在实际应用中, 由于 B+ Tree 的高度很小（即使数据量很大），查找的实际时间几乎是个很小的常数&lt;/li&gt;
&lt;li&gt;因此，虽然理论上是 O(log n)，但表现上“感觉”像是接近 O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在理想情况下（即完全平衡的二叉搜索树）一棵满二叉树的节点总数是：&lt;/p&gt;
&lt;p&gt;$$
n = 2^0 + 2^1 + 2^2 + \cdots + 2^h = \sum_{i=0}^{h} 2^i
$$&lt;/p&gt;
&lt;p&gt;这是一个等比数列，求和公式为：&lt;/p&gt;
&lt;p&gt;$$
n = 2^{h+1} - 1
$$&lt;/p&gt;
&lt;p&gt;两边取对数，解出高度 &lt;code&gt;h&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;$$
n + 1 = 2^{h+1}
$$&lt;/p&gt;
&lt;p&gt;$$
\log_2(n + 1) = h + 1
$$&lt;/p&gt;
&lt;p&gt;$$
h = \log_2(n + 1) - 1
$$&lt;/p&gt;
&lt;p&gt;因此，在最理想的情况下，树的高度近似为：&lt;/p&gt;
&lt;p&gt;$$
h \approx \log_2 n
$$&lt;/p&gt;
&lt;p&gt;这说明，在平衡的二叉搜索树中，查找、插入、删除等操作的时间复杂度为：&lt;/p&gt;
&lt;p&gt;$$
O(\log n)
$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;32-哈希索引真正的-o1&#34;&gt;3.2. &lt;strong&gt;哈希索引：真正的 O(1)&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MySQL 也支持 哈希索引，它的查找时间复杂度在理想情况下是 O(1)&lt;/li&gt;
&lt;li&gt;但是，哈希索引的使用场景非常有限
&lt;ul&gt;
&lt;li&gt;它主要用于 &lt;strong&gt;MEMORY 存储引擎&lt;/strong&gt;, 而 InnoDB 默认不支持哈希索引（除非通过特殊配置）&lt;/li&gt;
&lt;li&gt;哈希索引不支持范围查询（比如 &amp;gt;、&amp;lt;），所以适用性不如 B+ Tree&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;因此，在大多数情况下，说“有索引”时，指的并不是哈希索引，而是 B+ Tree 索引&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>窗口函数 聚合函数</title>
      <link>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/007-%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0-%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 30 Mar 2025 11:09:56 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/007-%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0-%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;h2 id=&#34;1-聚合函数&#34;&gt;1. 聚合函数&lt;/h2&gt;
&lt;p&gt;聚合函数 Aggregate Functions 用于对一组数据进行计算, 它们会将多行数据“聚合成”一个单一的结果, 常用于 SQL 查询 如 &lt;code&gt;GROUP BY&lt;/code&gt; 搭配使用:&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;函数名&lt;/th&gt;
          &lt;th&gt;功能说明&lt;/th&gt;
          &lt;th&gt;示例&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;COUNT()&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;统计数量&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;COUNT(*)&lt;/code&gt; 统计总行数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;SUM()&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;求总和&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;SUM(price)&lt;/code&gt; 计算价格总和&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;AVG()&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;求平均值&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;AVG(score)&lt;/code&gt; 计算平均分数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;MAX()&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;返回最大值&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;MAX(age)&lt;/code&gt; 查找最大年龄&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;MIN()&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;返回最小值&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;MIN(height)&lt;/code&gt; 查找最小身高&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;11-统计数据&#34;&gt;1.1. 统计数据&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;order_id&lt;/th&gt;
          &lt;th&gt;user_id&lt;/th&gt;
          &lt;th&gt;total_price&lt;/th&gt;
          &lt;th&gt;order_date&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;101&lt;/td&gt;
          &lt;td&gt;99.9&lt;/td&gt;
          &lt;td&gt;2025-03-01&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;102&lt;/td&gt;
          &lt;td&gt;149.5&lt;/td&gt;
          &lt;td&gt;2025-03-01&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;101&lt;/td&gt;
          &lt;td&gt;20.0&lt;/td&gt;
          &lt;td&gt;2025-03-02&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;统计每天的销售额&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; order_date, &lt;span style=&#34;color:#66d9ef&#34;&gt;SUM&lt;/span&gt;(total_price) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; daily_revenue
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; orders
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;GROUP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; order_date;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;第一步 扫描表 FROM, 数据库先把整个 &lt;code&gt;grades&lt;/code&gt; 表读一遍, 拿到所有原始数据&lt;/li&gt;
&lt;li&gt;第二步 分组 GROUP BY, 数据库根据 &lt;code&gt;student_id&lt;/code&gt; 把数据拆成几组
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;student_id = 1&lt;/code&gt; 的组: &lt;code&gt;(1, Math, 85)&lt;/code&gt;, &lt;code&gt;(1, English, 90)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;student_id = 2&lt;/code&gt; 的组: &lt;code&gt;(2, Math, 78)&lt;/code&gt;,  &lt;code&gt;(2, English, 92)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第三步 每组上应用聚合函数:
&lt;ul&gt;
&lt;li&gt;组1：&lt;code&gt;(85 + 90) / 2 = 87.5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;组2：&lt;code&gt;(78 + 92) / 2 = 85&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最终输出 student_id = 1, avg_score = 87.5; student_id = 2, avg_score = 85&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如果查询语句没有加 &lt;code&gt;WHERE&lt;/code&gt; 条件, 数据库&lt;strong&gt;通常会全表扫描&lt;/strong&gt;, 因为它必须读取表中所有的行才能正确地分组和聚合, 哪怕你 &lt;code&gt;student_id&lt;/code&gt; 上有索引, 它也必须读出所有行的 score 值&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-聚合函数&#34;&gt;1. 聚合函数&lt;/h2&gt;
&lt;p&gt;聚合函数 Aggregate Functions 用于对一组数据进行计算, 它们会将多行数据“聚合成”一个单一的结果, 常用于 SQL 查询 如 &lt;code&gt;GROUP BY&lt;/code&gt; 搭配使用:&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;函数名&lt;/th&gt;
          &lt;th&gt;功能说明&lt;/th&gt;
          &lt;th&gt;示例&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;COUNT()&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;统计数量&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;COUNT(*)&lt;/code&gt; 统计总行数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;SUM()&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;求总和&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;SUM(price)&lt;/code&gt; 计算价格总和&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;AVG()&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;求平均值&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;AVG(score)&lt;/code&gt; 计算平均分数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;MAX()&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;返回最大值&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;MAX(age)&lt;/code&gt; 查找最大年龄&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;MIN()&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;返回最小值&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;MIN(height)&lt;/code&gt; 查找最小身高&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;11-统计数据&#34;&gt;1.1. 统计数据&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;order_id&lt;/th&gt;
          &lt;th&gt;user_id&lt;/th&gt;
          &lt;th&gt;total_price&lt;/th&gt;
          &lt;th&gt;order_date&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;101&lt;/td&gt;
          &lt;td&gt;99.9&lt;/td&gt;
          &lt;td&gt;2025-03-01&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;102&lt;/td&gt;
          &lt;td&gt;149.5&lt;/td&gt;
          &lt;td&gt;2025-03-01&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;101&lt;/td&gt;
          &lt;td&gt;20.0&lt;/td&gt;
          &lt;td&gt;2025-03-02&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;统计每天的销售额&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; order_date, &lt;span style=&#34;color:#66d9ef&#34;&gt;SUM&lt;/span&gt;(total_price) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; daily_revenue
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; orders
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;GROUP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; order_date;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;第一步 扫描表 FROM, 数据库先把整个 &lt;code&gt;grades&lt;/code&gt; 表读一遍, 拿到所有原始数据&lt;/li&gt;
&lt;li&gt;第二步 分组 GROUP BY, 数据库根据 &lt;code&gt;student_id&lt;/code&gt; 把数据拆成几组
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;student_id = 1&lt;/code&gt; 的组: &lt;code&gt;(1, Math, 85)&lt;/code&gt;, &lt;code&gt;(1, English, 90)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;student_id = 2&lt;/code&gt; 的组: &lt;code&gt;(2, Math, 78)&lt;/code&gt;,  &lt;code&gt;(2, English, 92)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第三步 每组上应用聚合函数:
&lt;ul&gt;
&lt;li&gt;组1：&lt;code&gt;(85 + 90) / 2 = 87.5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;组2：&lt;code&gt;(78 + 92) / 2 = 85&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最终输出 student_id = 1, avg_score = 87.5; student_id = 2, avg_score = 85&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如果查询语句没有加 &lt;code&gt;WHERE&lt;/code&gt; 条件, 数据库&lt;strong&gt;通常会全表扫描&lt;/strong&gt;, 因为它必须读取表中所有的行才能正确地分组和聚合, 哪怕你 &lt;code&gt;student_id&lt;/code&gt; 上有索引, 它也必须读出所有行的 score 值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;本质上 SQL 的执行顺序差不多就是:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FROM → WHERE → GROUP BY → 聚合函数（AVG, SUM 等）→ HAVING → SELECT → ORDER BY&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;12-计算平均值&#34;&gt;1.2. 计算平均值&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;student_id&lt;/th&gt;
          &lt;th&gt;subject&lt;/th&gt;
          &lt;th&gt;score&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;Math&lt;/td&gt;
          &lt;td&gt;85&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;English&lt;/td&gt;
          &lt;td&gt;90&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;Math&lt;/td&gt;
          &lt;td&gt;78&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;English&lt;/td&gt;
          &lt;td&gt;92&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;计算每个学生所有科目的平均分&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; student_id, &lt;span style=&#34;color:#66d9ef&#34;&gt;AVG&lt;/span&gt;(score) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; avg_score
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; grades
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;GROUP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; student_id;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;13-计算最大值&#34;&gt;1.3. 计算最大值&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;id&lt;/th&gt;
          &lt;th&gt;name&lt;/th&gt;
          &lt;th&gt;department&lt;/th&gt;
          &lt;th&gt;salary&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;Alice&lt;/td&gt;
          &lt;td&gt;HR&lt;/td&gt;
          &lt;td&gt;5000&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;Bob&lt;/td&gt;
          &lt;td&gt;IT&lt;/td&gt;
          &lt;td&gt;7000&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;Tom&lt;/td&gt;
          &lt;td&gt;IT&lt;/td&gt;
          &lt;td&gt;7200&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;Lisa&lt;/td&gt;
          &lt;td&gt;HR&lt;/td&gt;
          &lt;td&gt;5200&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;查出每个部门里工资最高的员工薪资&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; department, &lt;span style=&#34;color:#66d9ef&#34;&gt;MAX&lt;/span&gt;(salary) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; max_salary
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; employees
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;GROUP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; department;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;2-窗口函数&#34;&gt;2. 窗口函数&lt;/h2&gt;
&lt;p&gt;窗口函数也是一种聚合函数的增强版, 但它不压缩多行成一行, 而是为每一行保留原始结构, 并计算“周围的一组数据”的统计值:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;函数名&lt;/span&gt;() OVER (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [PARTITION &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;列名&lt;/span&gt;]  &lt;span style=&#34;color:#75715e&#34;&gt;-- 可选，分组
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    [&lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;列名&lt;/span&gt;]      &lt;span style=&#34;color:#75715e&#34;&gt;-- 可选，排序
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    [&lt;span style=&#34;color:#66d9ef&#34;&gt;ROWS&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;或&lt;/span&gt; RANGE &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;子句&lt;/span&gt;] &lt;span style=&#34;color:#75715e&#34;&gt;-- 可选，定义窗口范围
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;21-排名&#34;&gt;2.1. 排名&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;student_id&lt;/th&gt;
          &lt;th&gt;subject&lt;/th&gt;
          &lt;th&gt;score&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;Math&lt;/td&gt;
          &lt;td&gt;85&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;Math&lt;/td&gt;
          &lt;td&gt;90&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;Math&lt;/td&gt;
          &lt;td&gt;78&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;Math&lt;/td&gt;
          &lt;td&gt;90&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;每行都有&lt;/span&gt; rank &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;字段，表示这位学生在&lt;/span&gt; Math &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;科目中的排名&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; student_id, score,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       RANK() OVER (&lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; score &lt;span style=&#34;color:#66d9ef&#34;&gt;DESC&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; rank
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; grades
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; subject &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Math&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;注意: 虽然写了 &lt;code&gt;RANK() OVER (ORDER BY score DESC)&lt;/code&gt;, 这只是窗口函数内部使用排序, 结果集本身的输出顺序还是无序的（除非你显式加上 &lt;code&gt;ORDER BY&lt;/code&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;第一步 &lt;code&gt;FROM&lt;/code&gt; + &lt;code&gt;WHERE&lt;/code&gt; 过滤筛选 &lt;code&gt;WHERE subject = &#39;Math&#39;&lt;/code&gt; 的记录&lt;/li&gt;
&lt;li&gt;第二步 窗口函数准备 &lt;code&gt;OVER()&lt;/code&gt;, 这一步, 数据库不会排序筛选出的记录, 而是&lt;strong&gt;在内存中为窗口函数排序一份数据副本&lt;/strong&gt;（根据 &lt;code&gt;score DESC&lt;/code&gt;）, 准备做排名&lt;/li&gt;
&lt;li&gt;第三步 对每行应用 &lt;code&gt;RANK()&lt;/code&gt; 排名函数, 数据库逐行执行这个函数, 这时候每一行&lt;strong&gt;都保留原始数据&lt;/strong&gt;, 并加上一列新的 rank 值&lt;/li&gt;
&lt;li&gt;第四步 结果集准备好, 但顺序可能不是你想要的, 除非你加 ORDER BY&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果想让结果集按分数顺序排序:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; student_id, score,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       RANK() OVER (&lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; score &lt;span style=&#34;color:#66d9ef&#34;&gt;DESC&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; rank
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; grades
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; subject &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Math&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; score &lt;span style=&#34;color:#66d9ef&#34;&gt;DESC&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;22-使用窗口函数计算累计总和&#34;&gt;2.2. 使用窗口函数计算累计总和&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;日期&lt;/th&gt;
          &lt;th&gt;产品&lt;/th&gt;
          &lt;th&gt;销售额&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-01&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;100&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-02&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;150&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-03&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;200&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-01&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;50&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-02&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;75&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-03&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;125&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;使用聚合函数 SUM()&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;产品&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;SUM&lt;/span&gt;(&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;销售额&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;总销售额&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;销售表&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;GROUP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;产品&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;产品&lt;/th&gt;
          &lt;th&gt;总销售额&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;450&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;250&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;使用窗口函数 SUM() OVER()&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;日期&lt;/span&gt;, &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;产品&lt;/span&gt;, &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;销售额&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       &lt;span style=&#34;color:#66d9ef&#34;&gt;SUM&lt;/span&gt;(&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;销售额&lt;/span&gt;) OVER(PARTITION &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;产品&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;产品总销售额&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;销售表&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;日期&lt;/th&gt;
          &lt;th&gt;产品&lt;/th&gt;
          &lt;th&gt;销售额&lt;/th&gt;
          &lt;th&gt;产品总销售额&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-01&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;100&lt;/td&gt;
          &lt;td&gt;450&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-02&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;150&lt;/td&gt;
          &lt;td&gt;450&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-03&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;200&lt;/td&gt;
          &lt;td&gt;450&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-01&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;50&lt;/td&gt;
          &lt;td&gt;250&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-02&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;75&lt;/td&gt;
          &lt;td&gt;250&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-03&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;125&lt;/td&gt;
          &lt;td&gt;250&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;使用窗口函数计算累计总和&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;日期&lt;/span&gt;, &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;产品&lt;/span&gt;, &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;销售额&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       &lt;span style=&#34;color:#66d9ef&#34;&gt;SUM&lt;/span&gt;(&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;销售额&lt;/span&gt;) OVER(PARTITION &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;产品&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;日期&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;累计销售额&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;销售表&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;日期&lt;/th&gt;
          &lt;th&gt;产品&lt;/th&gt;
          &lt;th&gt;销售额&lt;/th&gt;
          &lt;th&gt;累计销售额&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-01&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;100&lt;/td&gt;
          &lt;td&gt;100&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-02&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;150&lt;/td&gt;
          &lt;td&gt;250&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-03&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;200&lt;/td&gt;
          &lt;td&gt;450&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-01&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;50&lt;/td&gt;
          &lt;td&gt;50&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-02&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;75&lt;/td&gt;
          &lt;td&gt;125&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-03&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;125&lt;/td&gt;
          &lt;td&gt;250&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;23-执行过程&#34;&gt;2.3. 执行过程&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;日期&lt;/span&gt;, &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;产品&lt;/span&gt;, &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;销售额&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       &lt;span style=&#34;color:#66d9ef&#34;&gt;SUM&lt;/span&gt;(&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;销售额&lt;/span&gt;) OVER(PARTITION &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;产品&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;日期&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;累计销售额&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;销售表&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;1. 数据扫描阶段&lt;/strong&gt; 首先, 数据库引擎扫描⁠销售表中的所有行：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;日期&lt;/th&gt;
          &lt;th&gt;产品&lt;/th&gt;
          &lt;th&gt;销售额&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-01&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;100&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-02&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;150&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-03&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;200&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-01&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;50&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-02&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;75&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-03&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;125&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;2. 分区处理阶段&lt;/strong&gt; 根据⁠PARTITION BY 产品子句, 数据库将数据分成不同的分区：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;产品 A 的分区：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;日期&lt;/th&gt;
          &lt;th&gt;产品&lt;/th&gt;
          &lt;th&gt;销售额&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-01&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;100&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-02&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;150&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-03&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;200&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;产品 B 的分区：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;日期&lt;/th&gt;
          &lt;th&gt;产品&lt;/th&gt;
          &lt;th&gt;销售额&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-01&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;50&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-02&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;75&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-03&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;125&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;3. 分区内排序阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于有⁠ORDER BY 日期子句，数据库会在每个分区内按日期排序。在本例中，数据已经是按日期排序的，所以排序后的结果与原始分区相同。但这一步在逻辑上是必要的，因为它会影响窗口函数的计算方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 窗口函数计算阶段 - 累计求和&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于添加了⁠ORDER BY 日期，⁠SUM()函数不再计算整个分区的总和，而是计算&lt;strong&gt;累计总和&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于每个分区内的每一行，数据库会计算当前行及之前所有行的销售额总和：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;产品 A 的分区计算过程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	1.	第一行（2025-01-01）：累计销售额 = 100&lt;/p&gt;
&lt;p&gt;​	2.	第二行（2025-01-02）：累计销售额 = 100 + 150 = 250&lt;/p&gt;
&lt;p&gt;​	3.	第三行（2025-01-03）：累计销售额 = 100 + 150 + 200 = 450&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;产品 B 的分区计算过程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	1.	第一行（2025-01-01）：累计销售额 = 50&lt;/p&gt;
&lt;p&gt;​	2.	第二行（2025-01-02）：累计销售额 = 50 + 75 = 125&lt;/p&gt;
&lt;p&gt;​	3.	第三行（2025-01-03）：累计销售额 = 50 + 75 + 125 = 250&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 结果组装阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据库将原始行数据与计算得到的累计销售额结果组合起来：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. 返回最终结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最终返回的结果集：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;日期&lt;/th&gt;
          &lt;th&gt;产品&lt;/th&gt;
          &lt;th&gt;销售额&lt;/th&gt;
          &lt;th&gt;累计销售额&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-01&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;100&lt;/td&gt;
          &lt;td&gt;100&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-02&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;150&lt;/td&gt;
          &lt;td&gt;250&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-03&lt;/td&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;200&lt;/td&gt;
          &lt;td&gt;450&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-01&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;50&lt;/td&gt;
          &lt;td&gt;50&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-02&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;75&lt;/td&gt;
          &lt;td&gt;125&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2025-01-03&lt;/td&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;125&lt;/td&gt;
          &lt;td&gt;250&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;3-窗口函数-vs-聚合函数&#34;&gt;3. 窗口函数 vs 聚合函数&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;聚合函数&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把多行数据聚合成一行输出一个结果（比如 SUM、AVG、COUNT 等）&lt;/li&gt;
&lt;li&gt;通常与 GROUP BY 配合使用, 结果是&lt;strong&gt;每个组一个值&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;输出行数通常会减少&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;窗口函数&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在每行数据上基于一个“窗口”（由 OVER 子句定义的范围）计算结果&lt;/li&gt;
&lt;li&gt;不会减少行数，每行都会保留并附带计算结果&lt;/li&gt;
&lt;li&gt;常用于需要保留原始数据细节同时进行分析的场景&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设我们有一个 sales 表，记录销售员的销售情况：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;salesperson &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; sale_date  &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; amount
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;------------|------------|--------
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;Alice      &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2025&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;01&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;01&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;500&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Alice      &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2025&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;01&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;02&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;300&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Bob        &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2025&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;01&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;01&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;400&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Bob        &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2025&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;01&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;03&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;600&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Charlie    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2025&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;01&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;02&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;700&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Charlie    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2025&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;01&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;04&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;31-计算总销售额并排名&#34;&gt;3.1. 计算总销售额并排名&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;聚合函数方案&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; salesperson, &lt;span style=&#34;color:#66d9ef&#34;&gt;SUM&lt;/span&gt;(amount) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; total_sales
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; sales
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;GROUP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; salesperson
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; total_sales &lt;span style=&#34;color:#66d9ef&#34;&gt;DESC&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;-- 需额外处理排名
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;salesperson | total_sales
------------|-------------
Bob        | 1000
Charlie    | 900
Alice      | 800
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;聚合函数将多行聚合成一行, 适合只需要汇总结果的场景, 但无法直接生成排名, 需要额外子查询或手工处理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;窗口函数方案&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DISTINCT&lt;/span&gt; salesperson, 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       &lt;span style=&#34;color:#66d9ef&#34;&gt;SUM&lt;/span&gt;(amount) OVER (PARTITION &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; salesperson) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; total_sales,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       RANK() OVER (&lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;SUM&lt;/span&gt;(amount) &lt;span style=&#34;color:#66d9ef&#34;&gt;DESC&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; sales_rank
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; sales;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;salesperson | total_sales | sales_rank
------------|-------------|------------
Bob        | 1000        | 1
Charlie    | 900         | 2
Alice      | 800         | 3
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;窗口函数直接计算总和并排名, DISTINCT 避免重复行, 如果需要保留每笔销售记录, 只需去掉 DISTINCT, 更灵活&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-截止到某一天的累计销售额排名&#34;&gt;3.2. 截止到某一天的累计销售额排名&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;需求: 计算截止到 2025 年 1 月 2 日的累计销售额，并排名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; salesperson, &lt;span style=&#34;color:#66d9ef&#34;&gt;SUM&lt;/span&gt;(amount) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; cumulative_sales
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; sales
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; sale_date &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2025-01-02&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;GROUP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; salesperson
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; cumulative_sales &lt;span style=&#34;color:#66d9ef&#34;&gt;DESC&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;salesperson | cumulative_sales
------------|------------------
Alice      | 800
Charlie    | 700
Bob        | 400
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;聚合函数简洁地汇总截止日期的数据，Alice (500+300)、Charlie (700)、Bob (400), 但排名需额外处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;33-按日期显示每天的累计销售额排名&#34;&gt;3.3. 按日期显示每天的累计销售额排名&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; salesperson, sale_date,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       &lt;span style=&#34;color:#66d9ef&#34;&gt;SUM&lt;/span&gt;(amount) OVER (PARTITION &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; salesperson &lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; sale_date) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; cumulative_sales,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       RANK() OVER (PARTITION &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; sale_date &lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;SUM&lt;/span&gt;(amount) &lt;span style=&#34;color:#66d9ef&#34;&gt;DESC&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; daily_rank
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; sales
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; sale_date &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2025-01-02&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; sale_date, daily_rank;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;salesperson | sale_date  | cumulative_sales | daily_rank
------------|------------|------------------|------------
Alice      | 2025-01-01 | 500              | 1
Bob        | 2025-01-01 | 400              | 2
Alice      | 2025-01-02 | 800              | 1
Charlie    | 2025-01-02 | 700              | 2
Bob        | 2025-01-02 | 400              | 3
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;窗口函数轻松实现累计值和每天的排名, 保留每行数据, 逻辑清晰&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>事件驱动 异步编程的概念</title>
      <link>https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/009-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Sat, 29 Mar 2025 13:43:26 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/009-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</guid>
      <description>&lt;h2 id=&#34;1-事件驱动-event-driven&#34;&gt;1. 事件驱动 Event-Driven&lt;/h2&gt;
&lt;p&gt;事件驱动编程是一种设计模式, 其中程序的执行流程由事件（如用户操作、数据到达、定时器到期等）决定, 程序会等待事件发生, 然后触发相应的处理函数或回调函数, 事件可以理解为系统中发生的某种状态变化或动作, 比如用户点击操作, 数据库读取完成、网络请求返回结果、文件读取完成等, 这些事件发生的时间是不确定的, 程序无法提前知道什么时候会触发, 所以我们需要一个监听器 (也就是事件循环) , 它不断地检查是否有事件发生, 如果有, 就调用对应的处理函数, 那这里你可能有个疑问, 为什么事件循环这个组件会知道在事件发生时调用其对应的函数呢?&lt;/p&gt;
&lt;p&gt;当然是因为我们写代码的时候会注册, 比如 写 JS 的时候, 我们可以通过下面的方式为一个事件注册一个回调函数, 告诉事件循环, 当此事件发生时, 执行这个函数:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// DOM事件处理
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 方式1：使用addEventListener
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;document.&lt;span style=&#34;color:#a6e22e&#34;&gt;getElementById&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;myButton&amp;#39;&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;addEventListener&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;click&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;按钮被点击了&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 方式2：使用on属性
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;document.&lt;span style=&#34;color:#a6e22e&#34;&gt;getElementById&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;myButton&amp;#39;&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;onclick&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;按钮被点击了&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 创建自定义事件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;eventEmitter&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;EventTarget&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 注册事件监听器
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;eventEmitter&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;addEventListener&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;customEvent&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;event&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;自定义事件被触发:&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;event&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;detail&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 触发自定义事件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;event&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CustomEvent&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;customEvent&amp;#39;&lt;/span&gt;, { &lt;span style=&#34;color:#a6e22e&#34;&gt;detail&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;message&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;这是自定义数据&amp;#39;&lt;/span&gt; } });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;eventEmitter&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;dispatchEvent&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;event&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;2-异步编程&#34;&gt;2. 异步编程&lt;/h2&gt;
&lt;p&gt;异步编程在处理 &lt;strong&gt;I/O 密集型任务&lt;/strong&gt;（如网络请求、文件操作、数据库查询）时特别有用, 可以显著提高程序的响应性和吞吐量:&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-事件驱动-event-driven&#34;&gt;1. 事件驱动 Event-Driven&lt;/h2&gt;
&lt;p&gt;事件驱动编程是一种设计模式, 其中程序的执行流程由事件（如用户操作、数据到达、定时器到期等）决定, 程序会等待事件发生, 然后触发相应的处理函数或回调函数, 事件可以理解为系统中发生的某种状态变化或动作, 比如用户点击操作, 数据库读取完成、网络请求返回结果、文件读取完成等, 这些事件发生的时间是不确定的, 程序无法提前知道什么时候会触发, 所以我们需要一个监听器 (也就是事件循环) , 它不断地检查是否有事件发生, 如果有, 就调用对应的处理函数, 那这里你可能有个疑问, 为什么事件循环这个组件会知道在事件发生时调用其对应的函数呢?&lt;/p&gt;
&lt;p&gt;当然是因为我们写代码的时候会注册, 比如 写 JS 的时候, 我们可以通过下面的方式为一个事件注册一个回调函数, 告诉事件循环, 当此事件发生时, 执行这个函数:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// DOM事件处理
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 方式1：使用addEventListener
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;document.&lt;span style=&#34;color:#a6e22e&#34;&gt;getElementById&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;myButton&amp;#39;&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;addEventListener&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;click&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;按钮被点击了&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 方式2：使用on属性
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;document.&lt;span style=&#34;color:#a6e22e&#34;&gt;getElementById&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;myButton&amp;#39;&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;onclick&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;按钮被点击了&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 创建自定义事件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;eventEmitter&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;EventTarget&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 注册事件监听器
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;eventEmitter&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;addEventListener&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;customEvent&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;event&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;自定义事件被触发:&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;event&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;detail&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 触发自定义事件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;event&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CustomEvent&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;customEvent&amp;#39;&lt;/span&gt;, { &lt;span style=&#34;color:#a6e22e&#34;&gt;detail&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;message&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;这是自定义数据&amp;#39;&lt;/span&gt; } });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;eventEmitter&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;dispatchEvent&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;event&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;2-异步编程&#34;&gt;2. 异步编程&lt;/h2&gt;
&lt;p&gt;异步编程在处理 &lt;strong&gt;I/O 密集型任务&lt;/strong&gt;（如网络请求、文件操作、数据库查询）时特别有用, 可以显著提高程序的响应性和吞吐量:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python 通过 &lt;code&gt;asyncio&lt;/code&gt; 库和 &lt;code&gt;async/await&lt;/code&gt; 语法实现异步编程&lt;/li&gt;
&lt;li&gt;JavaScript 使用 &lt;code&gt;Promise/.then().then()&lt;/code&gt;、&lt;code&gt;async/await&lt;/code&gt; 和回调函数来处理异步操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Promise 是 JavaScript 中处理异步操作的一种机制, 它&lt;strong&gt;本质上是一个对象&lt;/strong&gt;, 代表一个异步操作的最终完成（或失败）及其结果值, Promise 有三种状态：pending（等待）、fulfilled（成功）、rejected（失败）, 通过 .then() 和 .catch() 方法, 你可以注册回调函数来处理成功或失败的结果: 虽然 Promise 使用回调函数, 但它和上面的注册事件并不是一回事, 事件驱动通常是通过事件监听器（比如 addEventListener）注册回调函数, 当特定事件触发时执行, 而 Promise 更像是一种“一次性的异步任务封装”, 它的回调是在异步操作完成时由 Promise 自身调度, 而不是依赖外部事件触发&lt;/p&gt;
&lt;p&gt;Javascript 中的 &lt;code&gt;async/await&lt;/code&gt; 是建立在 Promise 之上的语法糖, 目的是让异步代码看起来更像同步代码, &lt;code&gt;async&lt;/code&gt; 函数返回一个 &lt;code&gt;Promise&lt;/code&gt;, 而 &lt;code&gt;await&lt;/code&gt; 暂停函数执行, 直到 &lt;code&gt;Promise&lt;/code&gt; 解析完成, 它的核心仍然是 Promise, 因此它本质上也是异步编程的一种实现方式&lt;/p&gt;
&lt;h2 id=&#34;3-事件驱动-vs-异步编程&#34;&gt;3. 事件驱动 vs 异步编程&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;事件驱动&lt;/strong&gt;：强调通过事件监听器注册回调，等待外部事件（如用户点击、定时器触发、网络响应）来驱动程序执行。典型例子是 DOM 事件监听或 Node.js 中的 EventEmitter&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异步编程&lt;/strong&gt;：关注如何处理耗时操作（如 I/O、网络请求），不阻塞主线程 (非阻塞 IO), Promise 和 async/await 是异步编程的工具，解决的是“等待结果”的问题，而不是“监听事件”的问题&lt;/p&gt;
&lt;h2 id=&#34;4-为什么事件驱动模型适合做高并发web服务器&#34;&gt;4. 为什么事件驱动模型适合做高并发web服务器&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;高效的资源利用&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件驱动模型通常采用非阻塞 I/O（non-blocking I/O）和 I/O 多路复用（如 epoll, kqueue）, 使得：&lt;/li&gt;
&lt;li&gt;一个线程就可以同时处理成千上万个连接&lt;/li&gt;
&lt;li&gt;不需要为每个连接分配一个线程或进程, 避免线程上下文切换的开销和内存资源浪费&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;降低线程切换成本&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;传统多线程模型中，每个连接一个线程，大量并发连接时会产生&lt;strong&gt;线程调度开销&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事件驱动模型通常是&lt;strong&gt;单线程 + 事件循环&lt;/strong&gt;，避免频繁线程切换，性能更稳定&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;天然适配网络 I/O 特性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络 I/O 操作大多是&lt;strong&gt;I/O 密集型&lt;/strong&gt;且具有等待特性（如等待客户端数据、写入响应等）&lt;/li&gt;
&lt;li&gt;事件驱动模型能在等待 I/O 的同时继续处理其他任务，大幅提高吞吐量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实际验证的成功案例&lt;/strong&gt; 很多高性能 Web 服务器或框架都采用事件驱动模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Nginx&lt;/strong&gt;：采用 epoll + 非阻塞 I/O，单线程支持上万连接&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Node.js&lt;/strong&gt;：基于 libuv 的事件驱动模型，适合处理高并发的 I/O 请求&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Netty（Java）&lt;/strong&gt;：事件驱动网络编程框架，广泛应用于高性能 Java 服务&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Netty 是一个基于 Java NIO 的 异步、事件驱动的网络应用框架，用于快速开发高性能、高可靠性的网络服务器和客户端程序,&lt;/p&gt;
&lt;p&gt;Spring Boot 管理业务逻辑 (封装了 Web、MVC、数据库、安全等功能), Netty 负责高性能通信 (负责 TCP/UDP 网络通信): 当你使用 &lt;code&gt;spring-boot-starter-webflux&lt;/code&gt; 时, 底层默认就是用 Reactor Netty 实现的服务器, 而不是 Tomcat, 所以如果你用了 WebFlux, 其实你已经在用 Netty 了,&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;5-nodejs-事件驱动-vs-spring-boot-tomcat-多线程&#34;&gt;5. Node.js 事件驱动 vs Spring Boot Tomcat 多线程&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;在处理并发请求时，Spring Boot 和 Node.js 的运行机制有什么不同？你觉得这些差异会如何影响它们的表现？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spring Boot 通常用多线程, 每个请求分配一个线程, Node.js 是单线程靠事件循环处理, Spring Boot 可能更适合需要并行计算的任务, Node.js 适合网络请求多的场景&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果请求量突然增加到 10 倍，这些机制会有什么变化？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spring Boot 可能会受限于线程池大小, 队列堆积
&lt;ul&gt;
&lt;li&gt;当线程池的线程都忙不过来了, 新来的请求就被放进 &lt;strong&gt;等待队列&lt;/strong&gt;, 这就是“堆积”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Node.js 如果都是 I/O 操作还能应付, 但如果都是 CPU 任务就会卡住,
&lt;ul&gt;
&lt;li&gt;因为 CPU 任务 不是 IO 操作, 在发送网络请求之后, 或者文件IO 这些操作期间, CPU 并不需要做什么计算, 就是相当于派个任务给别人, 别人去处理了, 只用呆在那里等待结果&lt;/li&gt;
&lt;li&gt;所以 如果 都是 IO 操作, 事件驱动的 Node.js 并不会出什么问题, 但如果都是 CPU 密集型任务, 那就会导致主线程一直执行该任务, 不能完成其他任务了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Node.js 里, &lt;strong&gt;主线程是唯一能运行 JavaScript 的线程&lt;/strong&gt;, 也是处理回调和用户请求的核心, 所以:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只要主线程还“自由”，Node.js 就能持续处理新请求&lt;/li&gt;
&lt;li&gt;一旦主线程“被卡住”，哪怕是 1 秒，所有用户请求都得等那 1 秒过去，才轮得到执行&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么文件IO 适合非阻塞 IO, 而不属于计算密集型任务, 读取文件难道不是一直需要 CPU 把文件加载到内存吗?&lt;/p&gt;
&lt;p&gt;文件IO被归类为IO密集型而非计算密集型任务, 这是因为文件读写操作的瓶颈主要在于存储设备的访问速度, 而非CPU处理能力, 当程序需要读取文件时, 实际过程包含多个步骤:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;程序发起文件读取请求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作系统接收请求并传递给存储设备控制器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储设备从磁盘读取数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据通过DMA(直接内存访问)传输到内存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作系统通知程序数据已就绪&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;FastAPI 本身是一个 Web 框架, 它的核心是处理 HTTP 请求, 而不是管理事件, 它的异步能力依赖 asyncio, 而 asyncio 是事件驱动的（通过事件循环实现）, 但如果你用同步方式写 FastAPI 代码（def 而不是 async def）, 它就完全不涉及事件驱动, 而是阻塞式执行&lt;/p&gt;
&lt;p&gt;Node.js 的 事件循环 组件是由 libuv 库提供的, 当然 libuv 库也有自己的线程池, Node.js 使用单线程运行  libuv 库的事件循环 处理事件的回调函数, I/O 操作（如读写文件、数据库查询、网络请求）会被交给底层（如 libuv 的线程池）异步处理, 主线程不阻塞, 一直监听处理回调函数&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 示例：文件读取操作
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fs&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;require&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;fs&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 1. JavaScript 代码在主线程执行
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;开始读取文件&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 2. fs.readFile 委托给 libuv
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fs&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;readFile&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;large-file.txt&amp;#39;&lt;/span&gt;, (&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;) =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 4. 当文件读取完成后，这个回调被放入事件循环队列
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 然后在主线程上执行
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;文件读取完成&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 3. 主线程继续执行，不会被阻塞
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;继续执行其他代码&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;6-浏览器-js-异步执行的原理&#34;&gt;6. 浏览器 JS 异步执行的原理&lt;/h2&gt;
&lt;p&gt;JavaScript V8 引擎本身的设计是以单线程方式执行 JavaScript 代码, 这与 Python 和 Java 等语言的执行模型有根本区别,&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;语言&lt;/th&gt;
          &lt;th&gt;执行模型&lt;/th&gt;
          &lt;th&gt;线程支持&lt;/th&gt;
          &lt;th&gt;并发处理&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;JavaScript (V8)&lt;/td&gt;
          &lt;td&gt;单线程执行&lt;/td&gt;
          &lt;td&gt;不直接支持原生多线程&lt;/td&gt;
          &lt;td&gt;事件循环、回调、Promise&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Python&lt;/td&gt;
          &lt;td&gt;多线程支持&lt;/td&gt;
          &lt;td&gt;原生 ⁠threading 模块&lt;/td&gt;
          &lt;td&gt;线程、进程、协程&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Java&lt;/td&gt;
          &lt;td&gt;多线程支持&lt;/td&gt;
          &lt;td&gt;原生 ⁠Thread 类&lt;/td&gt;
          &lt;td&gt;线程、线程池、并发工具&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;既然 JavaScript 的主执行线程是单线程的, 为什么浏览器可以同时执行多个任务呢？&lt;/p&gt;
&lt;p&gt;因为 JavaScript 宿主环境（浏览器、Node.js）可以是多线程的, 也就是说, “JS 是单线程的”指的是执行 JS 代码的线程只有一个, 以 Chrome 为例, 浏览器不仅有多个线程, 还有多个进程, 如渲染进程、GPU 进程和插件进程等, 而每个 tab 标签页都是一个独立的渲染进程, 所以一个 tab 异常崩溃后, 其他 tab 基本不会被影响, 作为前端开发者, 主要重点关注其渲染进程, 渲染进程下包含了 JS 引擎线程、HTTP 请求线程和定时器线程等, 这些线程为 JS 在浏览器中完成异步任务提供了基础&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>二叉树和堆</title>
      <link>https://blog.jiyi27.com/posts/interview/%E7%AE%97%E6%B3%95/005-%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Thu, 20 Mar 2025 18:08:52 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E7%AE%97%E6%B3%95/005-%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>&lt;h2 id=&#34;1-表达式树-expression-tree&#34;&gt;1. 表达式树 Expression Tree&lt;/h2&gt;
&lt;p&gt;树的叶子节点通常是操作数（例如数字或变量）, 而非叶子节点是运算符（例如 +、-、*、/）, 通过遍历表达式树（例如前序、中序或后序遍历），可以重新生成表达式或计算其结果, 表达式 (3 + 5) * 2 可以表示为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    *
   / \
  +   2
 / \
3   5
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;计算器程序：实现复杂数学计算时，表达式树可以帮助按正确的顺序执行运算（尊重运算优先级和括号）&lt;/li&gt;
&lt;li&gt;数据库查询优化：在 SQL 查询引擎中，表达式树可以表示查询条件，帮助优化执行计划&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-决策树-decision-tree&#34;&gt;2. 决策树 Decision Tree&lt;/h2&gt;
&lt;p&gt;决策树是一种树形结构, 用于表示决策过程或分类/回归问题, 树的每个节点代表一个决策点（基于某个条件）, 分支代表可能的决策路径, 叶子节点通常表示最终的决策结果或类别:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;       [天气]
      /      \
  [晴天]    [下雨]
  /           \
[外出]      [待在家]
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;机器学习：决策树是经典的监督学习算法，用于分类和回归任务。例如，判断用户是否会购买某产品（基于年龄、收入等特征）&lt;/li&gt;
&lt;li&gt;游戏开发：在 AI 行为设计中，决策树用于控制 NPC（非玩家角色）的行为，例如决定是否攻击或逃跑&lt;/li&gt;
&lt;li&gt;医疗诊断：基于症状、体征等条件，决策树可以帮助医生判断疾病类型&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-二叉搜索树-binary-search-tree-bst&#34;&gt;3. 二叉搜索树 Binary Search Tree, BST&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;利用 BST 的性质：若目标值小于当前节点，向左子树查找；若大于，向右子树查找&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间复杂度：平均 O(log n)，最坏 O(n)（退化为链表时）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Node find(Node root, int value) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (root &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; null &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; root&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;value &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; value) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; root;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (value &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; root&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;value) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; find(root&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;left, value);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; find(root&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right, value);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;延伸&lt;/strong&gt;：提到退化问题，并引出平衡树（如 AVL 或红黑树）&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-表达式树-expression-tree&#34;&gt;1. 表达式树 Expression Tree&lt;/h2&gt;
&lt;p&gt;树的叶子节点通常是操作数（例如数字或变量）, 而非叶子节点是运算符（例如 +、-、*、/）, 通过遍历表达式树（例如前序、中序或后序遍历），可以重新生成表达式或计算其结果, 表达式 (3 + 5) * 2 可以表示为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    *
   / \
  +   2
 / \
3   5
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;计算器程序：实现复杂数学计算时，表达式树可以帮助按正确的顺序执行运算（尊重运算优先级和括号）&lt;/li&gt;
&lt;li&gt;数据库查询优化：在 SQL 查询引擎中，表达式树可以表示查询条件，帮助优化执行计划&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-决策树-decision-tree&#34;&gt;2. 决策树 Decision Tree&lt;/h2&gt;
&lt;p&gt;决策树是一种树形结构, 用于表示决策过程或分类/回归问题, 树的每个节点代表一个决策点（基于某个条件）, 分支代表可能的决策路径, 叶子节点通常表示最终的决策结果或类别:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;       [天气]
      /      \
  [晴天]    [下雨]
  /           \
[外出]      [待在家]
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;机器学习：决策树是经典的监督学习算法，用于分类和回归任务。例如，判断用户是否会购买某产品（基于年龄、收入等特征）&lt;/li&gt;
&lt;li&gt;游戏开发：在 AI 行为设计中，决策树用于控制 NPC（非玩家角色）的行为，例如决定是否攻击或逃跑&lt;/li&gt;
&lt;li&gt;医疗诊断：基于症状、体征等条件，决策树可以帮助医生判断疾病类型&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-二叉搜索树-binary-search-tree-bst&#34;&gt;3. 二叉搜索树 Binary Search Tree, BST&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;利用 BST 的性质：若目标值小于当前节点，向左子树查找；若大于，向右子树查找&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间复杂度：平均 O(log n)，最坏 O(n)（退化为链表时）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Node find(Node root, int value) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (root &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; null &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; root&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;value &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; value) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; root;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (value &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; root&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;value) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; find(root&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;left, value);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; find(root&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right, value);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;延伸&lt;/strong&gt;：提到退化问题，并引出平衡树（如 AVL 或红黑树）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;如何判断一棵树是否是二叉搜索树？&lt;/p&gt;
&lt;p&gt;中序遍历检查是否升序&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;bool isBST(Node root, int min, int max) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (root &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; null) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; true;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (root&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;value &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; min &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; root&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;value &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; max) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; isBST(root&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;left, min, root&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;value) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; isBST(root&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right, root&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;value, max);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;4-遍历二叉树---dfs&#34;&gt;4. 遍历二叉树 - DFS&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Recursion 三步&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确定终止条件&lt;/li&gt;
&lt;li&gt;确定单层逻辑&lt;/li&gt;
&lt;li&gt;确定返回值和参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实&lt;strong&gt;首先要确定的应该是遍历顺序&lt;/strong&gt;, 因为遍历顺序决定了递归的顺序, 递归的顺序决定了返回值和参数, 且听我慢慢说来&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution104&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; __init__(self):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;current_depth &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;max_depth &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;maxDepth&lt;/span&gt;(self, root):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;preorder&lt;/span&gt;(node):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; node:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# 前序遍历 中左右&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;current_depth &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;max_depth &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;current_depth:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;max_depth &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;current_depth
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; node&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;left:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                preorder(node&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;left)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;current_depth &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; node&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                preorder(node&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;current_depth &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        preorder(root)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;current_depth
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;前序遍历使用场景: 函数处理当前节点再进行递归处理其他子节点 中左右 递归函数的单层逻辑都是处理当前节点, 一般我们通过一个&lt;strong&gt;全局变量&lt;/strong&gt; (比如上面的 &lt;code&gt;max_depth&lt;/code&gt;) 来作为参数来传递 (积累) 每次 recursion 的影响&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而后序遍历适合通过返回值的方式来传递信息, 因为当前节点最后处理, 通过下面的例子可以看出:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;maxDepth&lt;/span&gt;(root):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; root:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 后序遍历 左右中&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;maxDepth(root&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;left)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;maxDepth(root&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; max(left, right) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;DFS 是 &amp;ldquo;Depth-First Search&amp;rdquo; 的缩写，中文翻译为“深度优先搜索”&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;深度优先：指的是在搜索过程中，优先沿着一条路径尽可能深入，直到无法继续深入为止（到达尽头或满足某个条件），然后回溯到上一个节点，再探索其他路径&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;搜索过程：从起点开始，选择一个方向深入探索，访问完一个节点后，继续访问它的子节点，而不是立即访问同一层的其他节点&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在二叉树遍历的上下文中，DFS 通常表现为递归调用，因为递归天然具有“深入到底再回溯”的特性:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;前序遍历：先访问根节点，然后深度优先遍历左子树，再遍历右子树&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中序遍历：先深度优先遍历左子树，然后访问根节点，再遍历右子树&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后序遍历：先深度优先遍历左子树，再遍历右子树，最后访问根节点&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;DFS 的特点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以用递归&lt;/li&gt;
&lt;li&gt;也可以用栈&lt;/li&gt;
&lt;li&gt;空间复杂度：O(h)，h 是树的高度或图的最大深度，因为需要存储递归调用栈或显式栈&lt;/li&gt;
&lt;li&gt;时间复杂度：O(n)，n 是节点数，因为每个节点都会被访问一次&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;BFS（广度优先搜索，Breadth-First Search）：一层一层地探索，先访问所有同一层的节点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;5-平衡二叉树-balanced-binary-tree如-avl-树红黑树&#34;&gt;5. 平衡二叉树 Balanced Binary Tree，如 AVL 树、红黑树&lt;/h2&gt;
&lt;p&gt;如何平衡一棵二叉搜索树？&lt;strong&gt;问题变种&lt;/strong&gt;：AVL 树和红黑树的区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AVL 树：通过旋转（左旋、右旋）保持高度差 ≤ 1，插入/删除后严格平衡，适合读多写少的场景&lt;/li&gt;
&lt;li&gt;红黑树：通过颜色规则和旋转维持近似平衡，插入/删除效率更高，适合写多读少的场景（如标准库实现）&lt;/li&gt;
&lt;li&gt;区别：AVL 树更严格，查找更快（O(log n) 更稳定）；红黑树更宽松，插入/删除更快&lt;/li&gt;
&lt;li&gt;延伸：可以提到自底向上或自顶向下的平衡过程&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>优先队列 vs Redis Sorted Sets</title>
      <link>https://blog.jiyi27.com/posts/interview/%E7%AE%97%E6%B3%95/006-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-redis-sorted-set/</link>
      <pubDate>Thu, 20 Mar 2025 18:08:52 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E7%AE%97%E6%B3%95/006-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-redis-sorted-set/</guid>
      <description>&lt;h2 id=&#34;1-priority-queues&#34;&gt;1. Priority Queues&lt;/h2&gt;
&lt;p&gt;堆分为最大最小堆, 插入和删除复杂度都是 &lt;code&gt;O(log n)&lt;/code&gt;, 通常通过数组实现, 平时的用法比如 heap sort, priority queues, 今天我们说的优先队列就是最小堆实现的, 一般优先队列就像&lt;code&gt;array&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;hashmap&lt;/code&gt; 每个语言内都内置了, 平时用于开发系统级别, 比较 low-level 的系统会用到, 而 redis sorted sets 一般都是用在后端开发业务逻辑中, 而且本质上, 它也是优先队列, 这里对比一下, 毕竟都是和排序有关系&lt;/p&gt;
&lt;h3 id=&#34;21-默认排序规则自然顺序&#34;&gt;2.1. 默认排序规则（自然顺序）&lt;/h3&gt;
&lt;p&gt;默认情况下，PriorityQueue 是一个&lt;strong&gt;最小堆&lt;/strong&gt;，即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自然顺序要求元素实现 &lt;code&gt;Comparable&lt;/code&gt; 接口，并在其 &lt;code&gt;compareTo&lt;/code&gt; 方法中定义比较逻辑&lt;/li&gt;
&lt;li&gt;队列的队首（&lt;code&gt;peek/poll&lt;/code&gt; 获取的元素）始终是最小的元素（根据 &lt;code&gt;compareTo&lt;/code&gt; 的结果）&lt;/li&gt;
&lt;li&gt;例如，对于整数，PriorityQueue 会将最小的整数放在队首；对于字符串，会按字典序（ lexicographical order）排序&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; java.util.PriorityQueue;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Main&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        PriorityQueue&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Integer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; pq &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; PriorityQueue&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        pq.&lt;span style=&#34;color:#a6e22e&#34;&gt;offer&lt;/span&gt;(5);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        pq.&lt;span style=&#34;color:#a6e22e&#34;&gt;offer&lt;/span&gt;(2);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        pq.&lt;span style=&#34;color:#a6e22e&#34;&gt;offer&lt;/span&gt;(8);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(pq.&lt;span style=&#34;color:#a6e22e&#34;&gt;poll&lt;/span&gt;()); &lt;span style=&#34;color:#75715e&#34;&gt;// 输出: 2（最小值）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(pq.&lt;span style=&#34;color:#a6e22e&#34;&gt;poll&lt;/span&gt;()); &lt;span style=&#34;color:#75715e&#34;&gt;// 输出: 5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(pq.&lt;span style=&#34;color:#a6e22e&#34;&gt;poll&lt;/span&gt;()); &lt;span style=&#34;color:#75715e&#34;&gt;// 输出: 8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;这里，&lt;code&gt;Integer&lt;/code&gt; 实现了 &lt;code&gt;Comparable&lt;/code&gt;，&lt;code&gt;compareTo&lt;/code&gt; 按数值大小比较，因此 &lt;code&gt;PriorityQueue&lt;/code&gt; 按升序排列，队首是最小值&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22-自定义排序规则使用-comparator&#34;&gt;2.2. 自定义排序规则（使用 Comparator）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;你可以通过在构造 &lt;code&gt;PriorityQueue&lt;/code&gt; 时传入一个 &lt;code&gt;Comparator&lt;/code&gt; 对象来自定义排序规则&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-priority-queues&#34;&gt;1. Priority Queues&lt;/h2&gt;
&lt;p&gt;堆分为最大最小堆, 插入和删除复杂度都是 &lt;code&gt;O(log n)&lt;/code&gt;, 通常通过数组实现, 平时的用法比如 heap sort, priority queues, 今天我们说的优先队列就是最小堆实现的, 一般优先队列就像&lt;code&gt;array&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;hashmap&lt;/code&gt; 每个语言内都内置了, 平时用于开发系统级别, 比较 low-level 的系统会用到, 而 redis sorted sets 一般都是用在后端开发业务逻辑中, 而且本质上, 它也是优先队列, 这里对比一下, 毕竟都是和排序有关系&lt;/p&gt;
&lt;h3 id=&#34;21-默认排序规则自然顺序&#34;&gt;2.1. 默认排序规则（自然顺序）&lt;/h3&gt;
&lt;p&gt;默认情况下，PriorityQueue 是一个&lt;strong&gt;最小堆&lt;/strong&gt;，即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自然顺序要求元素实现 &lt;code&gt;Comparable&lt;/code&gt; 接口，并在其 &lt;code&gt;compareTo&lt;/code&gt; 方法中定义比较逻辑&lt;/li&gt;
&lt;li&gt;队列的队首（&lt;code&gt;peek/poll&lt;/code&gt; 获取的元素）始终是最小的元素（根据 &lt;code&gt;compareTo&lt;/code&gt; 的结果）&lt;/li&gt;
&lt;li&gt;例如，对于整数，PriorityQueue 会将最小的整数放在队首；对于字符串，会按字典序（ lexicographical order）排序&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; java.util.PriorityQueue;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Main&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        PriorityQueue&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Integer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; pq &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; PriorityQueue&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        pq.&lt;span style=&#34;color:#a6e22e&#34;&gt;offer&lt;/span&gt;(5);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        pq.&lt;span style=&#34;color:#a6e22e&#34;&gt;offer&lt;/span&gt;(2);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        pq.&lt;span style=&#34;color:#a6e22e&#34;&gt;offer&lt;/span&gt;(8);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(pq.&lt;span style=&#34;color:#a6e22e&#34;&gt;poll&lt;/span&gt;()); &lt;span style=&#34;color:#75715e&#34;&gt;// 输出: 2（最小值）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(pq.&lt;span style=&#34;color:#a6e22e&#34;&gt;poll&lt;/span&gt;()); &lt;span style=&#34;color:#75715e&#34;&gt;// 输出: 5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(pq.&lt;span style=&#34;color:#a6e22e&#34;&gt;poll&lt;/span&gt;()); &lt;span style=&#34;color:#75715e&#34;&gt;// 输出: 8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;这里，&lt;code&gt;Integer&lt;/code&gt; 实现了 &lt;code&gt;Comparable&lt;/code&gt;，&lt;code&gt;compareTo&lt;/code&gt; 按数值大小比较，因此 &lt;code&gt;PriorityQueue&lt;/code&gt; 按升序排列，队首是最小值&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22-自定义排序规则使用-comparator&#34;&gt;2.2. 自定义排序规则（使用 Comparator）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;你可以通过在构造 &lt;code&gt;PriorityQueue&lt;/code&gt; 时传入一个 &lt;code&gt;Comparator&lt;/code&gt; 对象来自定义排序规则&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Comparator&lt;/code&gt; 的 compare 方法定义了元素的优先级顺序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果提供了 &lt;code&gt;Comparator&lt;/code&gt;，&lt;code&gt;PriorityQueue&lt;/code&gt; 会根据它来决定元素的顺序，&lt;strong&gt;而不是依赖 &lt;code&gt;Comparable&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;仍然默认是最小堆，队首是根据 &lt;code&gt;Comparator&lt;/code&gt; 定义的“最小”元素&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; java.util.PriorityQueue;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; java.util.Comparator;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Main&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 自定义 Comparator，按降序排序（大的值优先）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        PriorityQueue&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Integer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; pq &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; PriorityQueue&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;(Comparator.&lt;span style=&#34;color:#a6e22e&#34;&gt;reverseOrder&lt;/span&gt;());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        pq.&lt;span style=&#34;color:#a6e22e&#34;&gt;offer&lt;/span&gt;(5);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        pq.&lt;span style=&#34;color:#a6e22e&#34;&gt;offer&lt;/span&gt;(2);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        pq.&lt;span style=&#34;color:#a6e22e&#34;&gt;offer&lt;/span&gt;(8);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(pq.&lt;span style=&#34;color:#a6e22e&#34;&gt;poll&lt;/span&gt;()); &lt;span style=&#34;color:#75715e&#34;&gt;// 输出: 8（最大值）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(pq.&lt;span style=&#34;color:#a6e22e&#34;&gt;poll&lt;/span&gt;()); &lt;span style=&#34;color:#75715e&#34;&gt;// 输出: 5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(pq.&lt;span style=&#34;color:#a6e22e&#34;&gt;poll&lt;/span&gt;()); &lt;span style=&#34;color:#75715e&#34;&gt;// 输出: 2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;23-排队服务-任务调度系统&#34;&gt;2.3. 排队服务 任务调度系统&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用户上传视频后，系统会排队转码（比如压缩、加字幕等）&lt;/li&gt;
&lt;li&gt;有的用户是普通用户，优先级低&lt;/li&gt;
&lt;li&gt;有的用户是 VIP，优先级高&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;建一个「优先队列」来排这些转码任务：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; java.util.PriorityQueue;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 转码任务类&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TranscodeTask&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;implements&lt;/span&gt; Comparable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;TranscodeTask&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; String videoId;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; priority; &lt;span style=&#34;color:#75715e&#34;&gt;// 优先级：数字越小优先级越高&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; isVip;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TranscodeTask&lt;/span&gt;(String videoId, &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; isVip) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;videoId&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; videoId;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;isVip&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; isVip;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// VIP用户优先级为1，普通用户优先级为2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;priority&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; isVip &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; 1 : 2;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 实现Comparable接口，用于优先队列排序&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Override&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;compareTo&lt;/span&gt;(TranscodeTask other) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 按优先级排序，数字小的在前&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; Integer.&lt;span style=&#34;color:#a6e22e&#34;&gt;compare&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;priority&lt;/span&gt;, other.&lt;span style=&#34;color:#a6e22e&#34;&gt;priority&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Override&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; String &lt;span style=&#34;color:#a6e22e&#34;&gt;toString&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;视频: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; videoId &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; [&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; (isVip &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;VIP用户&amp;#34;&lt;/span&gt; : &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;普通用户&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;, 优先级: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; priority &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;]&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 视频转码服务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TranscodingService&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; PriorityQueue&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;TranscodeTask&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; queue;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; maxConcurrentTasks;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TranscodingService&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; maxConcurrentTasks) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;queue&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; PriorityQueue&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;maxConcurrentTasks&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; maxConcurrentTasks;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 添加任务到队列&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;addTask&lt;/span&gt;(String videoId, &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; isVip) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        TranscodeTask task &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; TranscodeTask(videoId, isVip);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        queue.&lt;span style=&#34;color:#a6e22e&#34;&gt;offer&lt;/span&gt;(task); &lt;span style=&#34;color:#75715e&#34;&gt;// 添加到优先队列&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;任务已添加: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; task);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 处理队列中的任务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;processTasks&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\n开始处理队列中的任务，最多同时处理&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; maxConcurrentTasks &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;个任务&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 模拟处理maxConcurrentTasks个任务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; maxConcurrentTasks &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;queue.&lt;span style=&#34;color:#a6e22e&#34;&gt;isEmpty&lt;/span&gt;(); i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            TranscodeTask task &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; queue.&lt;span style=&#34;color:#a6e22e&#34;&gt;poll&lt;/span&gt;(); &lt;span style=&#34;color:#75715e&#34;&gt;// 取出优先级最高的任务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;正在处理: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; task);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;队列中剩余任务数: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; queue.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 测试优先队列&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;VideoTranscodingDemo&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        TranscodingService service &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; TranscodingService(2); &lt;span style=&#34;color:#75715e&#34;&gt;// 最多同时处理2个任务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 添加任务，普通用户和VIP用户混合&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        service.&lt;span style=&#34;color:#a6e22e&#34;&gt;addTask&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;video1&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 普通用户&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        service.&lt;span style=&#34;color:#a6e22e&#34;&gt;addTask&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;video2&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;);  &lt;span style=&#34;color:#75715e&#34;&gt;// VIP用户&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        service.&lt;span style=&#34;color:#a6e22e&#34;&gt;addTask&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;video3&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 普通用户&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        service.&lt;span style=&#34;color:#a6e22e&#34;&gt;addTask&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;video4&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;);  &lt;span style=&#34;color:#75715e&#34;&gt;// VIP用户&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        service.&lt;span style=&#34;color:#a6e22e&#34;&gt;addTask&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;video5&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 普通用户&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 处理任务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        service.&lt;span style=&#34;color:#a6e22e&#34;&gt;processTasks&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 再次处理剩余任务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        service.&lt;span style=&#34;color:#a6e22e&#34;&gt;processTasks&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;2-redis-sorted-set&#34;&gt;2. Redis Sorted Set&lt;/h2&gt;
&lt;p&gt;A &lt;strong&gt;Redis Sorted Set&lt;/strong&gt; is a data type where each element is associated with a score, and elements are automatically sorted by that score. It behaves &lt;em&gt;like&lt;/em&gt; a priority queue — but it’s &lt;strong&gt;persistent, distributed&lt;/strong&gt;, and accessible over the network.&lt;/p&gt;
&lt;h3 id=&#34;21-redis-sorted-set-的特点&#34;&gt;2.1. Redis Sorted Set 的特点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;每个元素都有一个关联的分数，用于排序&lt;/li&gt;
&lt;li&gt;元素按分数从小到大排序（可以使用 ZREVRANGE 等命令反向获取）&lt;/li&gt;
&lt;li&gt;相同分数的元素按字典序排序&lt;/li&gt;
&lt;li&gt;支持范围查询、&lt;strong&gt;取 top-N 等操作&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;元素不可重复，但分数可以重复&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-二者对比&#34;&gt;3. 二者对比&lt;/h2&gt;
&lt;h3 id=&#34;31-实现原理&#34;&gt;3.1. 实现原理&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;特性&lt;/th&gt;
          &lt;th&gt;Redis Sorted Set&lt;/th&gt;
          &lt;th&gt;优先队列&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;数据结构&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;基于跳表实现&lt;/td&gt;
          &lt;td&gt;通常基于二叉堆、斐波那契堆等实现&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;元素唯一性&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;元素必须唯一&lt;/td&gt;
          &lt;td&gt;允许重复元素&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;排序依据&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;按分数(score)排序&lt;/td&gt;
          &lt;td&gt;按优先级排序&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;访问方式&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;可随机访问任意范围的元素&lt;/td&gt;
          &lt;td&gt;通常只能访问队头元素(最高/最低优先级)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;操作复杂度&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;大多数操作 O(log(N))&lt;/td&gt;
          &lt;td&gt;插入/删除通常为 O(log(N))&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;分布式支持&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;原生支持分布式环境&lt;/td&gt;
          &lt;td&gt;通常为单机内存数据结构&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;持久化&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;支持&lt;/td&gt;
          &lt;td&gt;通常不支持&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;内存占用&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;相对较高&lt;/td&gt;
          &lt;td&gt;相对较低&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;同分数/优先级处理&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;同分数按字典序排序&lt;/td&gt;
          &lt;td&gt;实现决定(通常不保证顺序)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;范围查询&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;支持高效的范围查询&lt;/td&gt;
          &lt;td&gt;通常不支持&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;跳表（Skip List）是一种基于链表的数据结构, 通过在原始链表上构建多层索引来加速查找操作, 从而提供高效的动态集合实现, 它支持快速的查找、插入和删除操作, 在某些场景下性能可以媲美平衡树（如红黑树）, 但实现上更为简单&lt;/p&gt;
&lt;p&gt;跳表由以下几个部分组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;原始链表：最底层是一个有序的链表，包含所有元素&lt;/li&gt;
&lt;li&gt;索引层：在原始链表之上有多层索引，每一层是从下一层中随机选择部分节点构成的“稀疏”版本&lt;/li&gt;
&lt;li&gt;头节点：每层都有一个头节点，用于从顶部开始查找&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;跳表的工作原理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查找：从最高层的头节点开始, 沿着每一层的指针向右移动, 如果当前层的下一个节点键值大于目标键, 则下降到下一层继续查找, 直到找到目标元素或确认其不存在&lt;/li&gt;
&lt;li&gt;插入：先查找插入位置，然后随机决定新节点的层数，并在对应层中插入节点&lt;/li&gt;
&lt;li&gt;删除：先找到要删除的节点，然后在每一层中移除该节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;跳表的层数选择是随机的, 这种随机化保证了结构的平衡性, 使查找、插入和删除的平均时间复杂度达到 &lt;strong&gt;O(log n)&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;32-使用场景&#34;&gt;3.2. 使用场景&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;场景&lt;/th&gt;
          &lt;th&gt;Redis Sorted Set&lt;/th&gt;
          &lt;th&gt;优先队列&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;排行榜系统&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;✅ 适合：&lt;!-- raw HTML omitted --&gt;- 范围查询支持获取前N名&lt;!-- raw HTML omitted --&gt;- 分数更新自动重排序&lt;!-- raw HTML omitted --&gt;- 持久化保证数据不丢失&lt;/td&gt;
          &lt;td&gt;❌ 不适合：&lt;!-- raw HTML omitted --&gt;- 无法高效获取范围数据&lt;!-- raw HTML omitted --&gt;- 通常无持久化能力&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;任务调度&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;✅ 适合：&lt;!-- raw HTML omitted --&gt;- 分布式环境下多服务共享队列&lt;!-- raw HTML omitted --&gt;- score可用时间戳表示执行时间&lt;!-- raw HTML omitted --&gt;- 支持任务更新和取消&lt;/td&gt;
          &lt;td&gt;✅ 适合：&lt;!-- raw HTML omitted --&gt;- 单机环境下内存效率高&lt;!-- raw HTML omitted --&gt;- 操作延迟低&lt;!-- raw HTML omitted --&gt;- 适合实时系统&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;延迟队列&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;✅ 非常适合：&lt;!-- raw HTML omitted --&gt;- score设为执行时间&lt;!-- raw HTML omitted --&gt;- ZRANGEBYSCORE可查询该执行的任务&lt;!-- raw HTML omitted --&gt;- 分布式环境可靠&lt;/td&gt;
          &lt;td&gt;⚠️ 有限支持：&lt;!-- raw HTML omitted --&gt;- 需要额外的定时器机制&lt;!-- raw HTML omitted --&gt;- 分布式环境需要额外协调&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;社交网络关系&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;✅ 适合：&lt;!-- raw HTML omitted --&gt;- 可存储用户关系并按亲密度排序&lt;!-- raw HTML omitted --&gt;- 支持查询Top N好友&lt;!-- raw HTML omitted --&gt;- 支持范围查询&lt;/td&gt;
          &lt;td&gt;❌ 不适合：&lt;!-- raw HTML omitted --&gt;- 无法进行复杂的关系查询&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;实时分析系统&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;✅ 适合：&lt;!-- raw HTML omitted --&gt;- 可用于时间序列数据存储&lt;!-- raw HTML omitted --&gt;- 支持时间范围查询&lt;!-- raw HTML omitted --&gt;- 分布式环境下的数据共享&lt;/td&gt;
          &lt;td&gt;⚠️ 部分适合：&lt;!-- raw HTML omitted --&gt;- 处理速度快但功能有限&lt;!-- raw HTML omitted --&gt;- 不支持复杂查询&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;图算法&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;❌ 不适合：&lt;!-- raw HTML omitted --&gt;- 网络延迟影响性能&lt;!-- raw HTML omitted --&gt;- API不适合图算法需求&lt;/td&gt;
          &lt;td&gt;✅ 非常适合：&lt;!-- raw HTML omitted --&gt;- Dijkstra等算法的核心组件&lt;!-- raw HTML omitted --&gt;- 快速获取最小/最大元素&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;地理位置应用&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;✅ 适合：&lt;!-- raw HTML omitted --&gt;- 结合GEO命令可存储位置并按距离排序&lt;!-- raw HTML omitted --&gt;- 支持范围查询附近的POI&lt;/td&gt;
          &lt;td&gt;❌ 不适合：&lt;!-- raw HTML omitted --&gt;- 无地理位置特性支持&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;限流系统&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;✅ 适合：&lt;!-- raw HTML omitted --&gt;- score设为时间戳&lt;!-- raw HTML omitted --&gt;- ZREMRANGEBYSCORE删除过期令牌&lt;!-- raw HTML omitted --&gt;- 原子操作保证一致性&lt;/td&gt;
          &lt;td&gt;⚠️ 有限支持：&lt;!-- raw HTML omitted --&gt;- 需要额外逻辑处理过期&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;大数据处理&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;✅ 支持：&lt;!-- raw HTML omitted --&gt;- 可处理大量数据(内存限制)&lt;!-- raw HTML omitted --&gt;- 支持集群扩展&lt;/td&gt;
          &lt;td&gt;⚠️ 受限：&lt;!-- raw HTML omitted --&gt;- 受单机内存限制&lt;!-- raw HTML omitted --&gt;- 扩展性差&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;分布式应用&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;✅ 原生支持：&lt;!-- raw HTML omitted --&gt;- 多客户端可并发访问&lt;!-- raw HTML omitted --&gt;- 支持主从复制和集群&lt;/td&gt;
          &lt;td&gt;❌ 需要额外实现：&lt;!-- raw HTML omitted --&gt;- 需要自行处理分布式一致性&lt;!-- raw HTML omitted --&gt;- 需要额外的服务协调&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</content>
    </item>
    
    <item>
      <title>MySQL 基础八股文</title>
      <link>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/000-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</link>
      <pubDate>Tue, 18 Mar 2025 21:03:20 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/000-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</guid>
      <description>&lt;h2 id=&#34;1-数据库设计-规范化&#34;&gt;1. 数据库设计 规范化&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;有了解过数据库设计范式吗?&lt;/p&gt;
&lt;p&gt;范式的目的是减少冗余, 确保数据的一致性和完整性, 但并不是说表的设计必须严格按照所有范式 (比如帖子点赞表), 要根据业务逻辑和性能做出取舍&lt;/p&gt;
&lt;p&gt;平时开发中如何设计数据库表?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先分析应该有的实体, 每个实体应该有哪些字段, 在考虑这些的时候其实也是进行拆表, 减少冗余或用冗余换性能的过程, 而这一过程的理论依据就是三大范式&lt;/li&gt;
&lt;li&gt;第二步考虑主键, 建立索引, 具体有单个索引 查询频率高的字段 或 或 Join 查询考虑外键, 复合索引 多条件查询, 覆盖索引 减少回表查询&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设计数据表的时候 减少数据库冗余 是如何做的?&lt;/p&gt;
&lt;p&gt;回答思路: 第二范式 消除部分依赖, 第三范式尽量减少传递依赖&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;11-第一范式&#34;&gt;1.1. 第一范式&lt;/h3&gt;
&lt;p&gt;第一范式: 数据表中的所有字段都必须是&lt;strong&gt;原子&lt;/strong&gt;的, 不能存储多个值 即每个字段只能存储单一信息&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;post
--------------------------------------
| id | title     | author | tags      |
--------------------------------------
| 1  | Golang入门 | 张三   | Go, 后端   |
| 2  | React教程  | 李四   | 前端, React|
--------------------------------------
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tags&lt;/code&gt; 字段存储了多个值, 违反了原子性, 要符合 1NF, 我们需要拆分表, 将 &lt;code&gt;tags&lt;/code&gt; 字段拆成独立的行:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;post
--------------------------------------
| id | title       | author |
--------------------------------------
| 1  | Golang入门   | 张三   |
| 2  | React教程    | 李四   |
--------------------------------------
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;post_tags
-----------------------
| post_id | tag   |
-----------------------
| 1       | Go    |
| 1       | 后端   |
| 2       | 前端   |
| 2       | React |
-----------------------
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;12-第二范式---数据冗余&#34;&gt;1.2. 第二范式 - 数据冗余&lt;/h3&gt;
&lt;p&gt;第二范式: 非主键字段必须完全依赖于整个主键, 不能只依赖于主键的一部分, 如果一个表中没有&lt;strong&gt;复合主键&lt;/strong&gt; 即只有单字段作为主键, 那么它天然符合第二范式, 因为所有非主键字段只能依赖于整个主键, 没有“部分依赖”的问题&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-数据库设计-规范化&#34;&gt;1. 数据库设计 规范化&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;有了解过数据库设计范式吗?&lt;/p&gt;
&lt;p&gt;范式的目的是减少冗余, 确保数据的一致性和完整性, 但并不是说表的设计必须严格按照所有范式 (比如帖子点赞表), 要根据业务逻辑和性能做出取舍&lt;/p&gt;
&lt;p&gt;平时开发中如何设计数据库表?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先分析应该有的实体, 每个实体应该有哪些字段, 在考虑这些的时候其实也是进行拆表, 减少冗余或用冗余换性能的过程, 而这一过程的理论依据就是三大范式&lt;/li&gt;
&lt;li&gt;第二步考虑主键, 建立索引, 具体有单个索引 查询频率高的字段 或 或 Join 查询考虑外键, 复合索引 多条件查询, 覆盖索引 减少回表查询&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设计数据表的时候 减少数据库冗余 是如何做的?&lt;/p&gt;
&lt;p&gt;回答思路: 第二范式 消除部分依赖, 第三范式尽量减少传递依赖&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;11-第一范式&#34;&gt;1.1. 第一范式&lt;/h3&gt;
&lt;p&gt;第一范式: 数据表中的所有字段都必须是&lt;strong&gt;原子&lt;/strong&gt;的, 不能存储多个值 即每个字段只能存储单一信息&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;post
--------------------------------------
| id | title     | author | tags      |
--------------------------------------
| 1  | Golang入门 | 张三   | Go, 后端   |
| 2  | React教程  | 李四   | 前端, React|
--------------------------------------
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tags&lt;/code&gt; 字段存储了多个值, 违反了原子性, 要符合 1NF, 我们需要拆分表, 将 &lt;code&gt;tags&lt;/code&gt; 字段拆成独立的行:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;post
--------------------------------------
| id | title       | author |
--------------------------------------
| 1  | Golang入门   | 张三   |
| 2  | React教程    | 李四   |
--------------------------------------
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;post_tags
-----------------------
| post_id | tag   |
-----------------------
| 1       | Go    |
| 1       | 后端   |
| 2       | 前端   |
| 2       | React |
-----------------------
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;12-第二范式---数据冗余&#34;&gt;1.2. 第二范式 - 数据冗余&lt;/h3&gt;
&lt;p&gt;第二范式: 非主键字段必须完全依赖于整个主键, 不能只依赖于主键的一部分, 如果一个表中没有&lt;strong&gt;复合主键&lt;/strong&gt; 即只有单字段作为主键, 那么它天然符合第二范式, 因为所有非主键字段只能依赖于整个主键, 没有“部分依赖”的问题&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;post_comment
-------------------------------------
| post_id | user_id | user_name    | comment |
-------------------------------------
| 1       | 101     | david12      | 很有帮助  |
| 2       | 102     | chikawa      | 学到了   |
-------------------------------------
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;该表的主键为复合主键: &lt;code&gt;(post_id, user_id)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;user_name&lt;/code&gt; 明显只依赖 &lt;code&gt;user_id&lt;/code&gt;, 而不是只依赖 &lt;code&gt;(post_id, user_id)&lt;/code&gt;, 这就违反 2NF&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;冗余数据&lt;/strong&gt;：如果david12 (&lt;code&gt;user_id = 101&lt;/code&gt;) 评论了 100 条帖子, 那 &lt;code&gt;david12&lt;/code&gt; 这个名字就会存 100 次&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据一致性问题&lt;/strong&gt;：如果王五改名字, 就得修改 100 条记录, 容易出错&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在数据库设计中, 数据冗余指的是在数据库中存储了重复或不必要的数据, 这些数据可以通过其他数据表连接查询出来, 而不是必须单独存储, 假设我们正在设计一个论坛网站的数据库, 包含以下几个表:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户表 (Users)：存储用户信息，如用户ID、用户名、邮箱&lt;/li&gt;
&lt;li&gt;帖子表 (Posts)：存储帖子内容，如帖子ID、标题、正文、作者ID&lt;/li&gt;
&lt;li&gt;评论表 (Comments)：存储评论内容，如评论ID、帖子ID、评论者ID、评论正文&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果我们在 帖子表 (Posts) 中不仅存储了 作者ID, 还额外存储了 作者用户名（如“张三”）, 这就产生了数据冗余, 因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作者用户名 已经存在于 用户表 (Users) 中, 通过 作者ID 可以关联查询到&lt;/li&gt;
&lt;li&gt;在 帖子表 中重复存储 作者用户名, 属于不必要的数据重复&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;13-第三范式---传递依赖&#34;&gt;1.3. 第三范式 - 传递依赖&lt;/h3&gt;
&lt;p&gt;传递依赖和第二范式的部分依赖很像, 因为它们都涉及到数据库中非主属性与主键之间的依赖关系问题, 第二范式要求非主属性必须完全依赖于整个主键, 而不能只依赖主键的一部分, 部分依赖通常出现在复合主键的表中, 第三范式（3NF）要求在满足 2NF 的基础上, 非主属性不能通过其他非主属性间接依赖于主键, 即不存在传递依赖:&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;UserID&lt;/th&gt;
          &lt;th&gt;Username&lt;/th&gt;
          &lt;th&gt;City&lt;/th&gt;
          &lt;th&gt;CityPopulation&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;张三&lt;/td&gt;
          &lt;td&gt;北京&lt;/td&gt;
          &lt;td&gt;2000万&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;李四&lt;/td&gt;
          &lt;td&gt;上海&lt;/td&gt;
          &lt;td&gt;2400万&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;王五&lt;/td&gt;
          &lt;td&gt;北京&lt;/td&gt;
          &lt;td&gt;2000万&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;主键：UserID&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非主属性：Username、City、CityPopulation&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传递依赖：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;UserID → City（用户决定城市）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;City → CityPopulation（城市决定人口）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因此，CityPopulation 通过 City 间接依赖 UserID，即 UserID → City → CityPopulation&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这违反了 3NF, 因为 CityPopulation 不是直接依赖主键, 而是通过非主属性 City 传递依赖, “北京” 和 “2000万” 在第1行和第3行出现了两次, 如果有更多用户住在北京, 这个信息(2000万)会重复更多次, 这种重复存储就是&lt;strong&gt;数据冗余&lt;/strong&gt;, 解决办法拆分为两个表:&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;UserID&lt;/th&gt;
          &lt;th&gt;Username&lt;/th&gt;
          &lt;th&gt;City&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;张三&lt;/td&gt;
          &lt;td&gt;北京&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;李四&lt;/td&gt;
          &lt;td&gt;上海&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;王五&lt;/td&gt;
          &lt;td&gt;北京&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;City&lt;/th&gt;
          &lt;th&gt;CityPopulation&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;北京&lt;/td&gt;
          &lt;td&gt;2000万&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;上海&lt;/td&gt;
          &lt;td&gt;2400万&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可以看出用户表中不用存储多个 2000 万 数据, 只用存个城市北京就行, 然后具体人口可以通过连表查询, 其实这个传递依赖和部分依赖很像, 引起的问题也一样, 就是数据冗余, 当然数据冗余又会造成 插入更新 麻烦, 如果北京的人口变为 2100 万, 需要修改表中所有包含“北京”的行,&lt;/p&gt;
&lt;p&gt;综上, 第二第三范式主要解决 部分依赖 和 传递依赖的问题, 这两个问题会引起数据冗余, 而数据冗余又会导致 插入 更新 效率低的问题, 当然这些问题我们可以通过拆表来解决, 但是并不是说满足三个范式一定是好的设计, 有时候在高并发场景下, 就需要一定的数据冗余来换取性能, 当然代价是更新起来麻烦, 且数据发生了冗余, 比如帖子点赞的场景, 我们一般设计 post 表:&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;字段&lt;/th&gt;
          &lt;th&gt;类型&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;PostID&lt;/td&gt;
          &lt;td&gt;INT&lt;/td&gt;
          &lt;td&gt;主键，帖子ID&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;UserID&lt;/td&gt;
          &lt;td&gt;INT&lt;/td&gt;
          &lt;td&gt;外键，作者ID&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Title&lt;/td&gt;
          &lt;td&gt;VARCHAR&lt;/td&gt;
          &lt;td&gt;帖子标题&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Content&lt;/td&gt;
          &lt;td&gt;TEXT&lt;/td&gt;
          &lt;td&gt;帖子内容&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;CreateTime&lt;/td&gt;
          &lt;td&gt;DATETIME&lt;/td&gt;
          &lt;td&gt;创建时间&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;用一个表记录点赞关系：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;字段&lt;/th&gt;
          &lt;th&gt;类型&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;LikeID&lt;/td&gt;
          &lt;td&gt;INT&lt;/td&gt;
          &lt;td&gt;主键，点赞ID&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;UserID&lt;/td&gt;
          &lt;td&gt;INT&lt;/td&gt;
          &lt;td&gt;外键，点赞者ID&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;TargetID&lt;/td&gt;
          &lt;td&gt;INT&lt;/td&gt;
          &lt;td&gt;目标ID（帖子或评论ID）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;CreateTime&lt;/td&gt;
          &lt;td&gt;CreateTime&lt;/td&gt;
          &lt;td&gt;点赞时间&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这样确实复合数据库设计的三个范式, 没有部分依赖, 没有传递依赖, 可是代价每次获取帖子信息以及其被点赞次数时, 需要关联点赞表做一个统计:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p.PostID,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p.UserID,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p.Title,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p.Content,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;COUNT&lt;/span&gt;(l.LikeID) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; LikeCount
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Posts p
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;LEFT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;JOIN&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Likes l 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p.PostID &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; l.TargetID 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; l.TargetType &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Post&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;GROUP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p.PostID, p.UserID, p.Title, p.Content;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;小网站还好, 高并发的话, 这样是不行的, 我们可以直接在 posts 表增加新字段 &lt;code&gt;LikeCount&lt;/code&gt;, 这就造成了冗余存储, 因为 LikeCount 是从 Likes 表统计得来的, 理论上可以不存储, 直接通过查询计算, 冗余就代表更新操作更麻烦, 在修改数据的时候就造成了问题, 需要多步操作:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用户点赞时，插入 Likes 表记录，同时更新对应 Post  的 LikeCount&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这时候涉及到了多表操作, 在业务逻辑层就要用事务保证数据一致性, 即要么都成功要么都失败, 回滚机制&lt;/li&gt;
&lt;li&gt;在 Redis 层面可以使用 Lua 脚本, Lua 脚本作为一个整体在 Redis 内部执行, 中间不会被打断, 是完全原子性的, Lua 脚本没有显式的“回滚”机制, 单若 Lua 脚本失败时整个脚本不生效, 因此无需回滚&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户取消点赞时，删除 Likes 表记录，同时减少 LikeCount&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从三个范式分析的话, 这样设计不符合第三范式, 造成了存储冗余和更新操作的麻烦, 但是带来了高性能:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 Posts 表中，LikeCount 表示帖子的点赞数，它依赖于 Likes 表中针对该 PostID 的记录数，而不是直接依赖 Posts 表的主键 PostID&lt;/li&gt;
&lt;li&gt;因此, LikeCount 是冗余字段，存在传递依赖: PostID → Likes 表中的记录 → LikeCount&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-数据库设计-外键-join&#34;&gt;2. 数据库设计 外键 Join&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;平时用到的查询, 如果关联表过多怎么办?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保 所有 &lt;code&gt;JOIN&lt;/code&gt; 字段上都有索引（尤其是外键）&lt;/li&gt;
&lt;li&gt;数据冗余（适度反范式化）&lt;/li&gt;
&lt;li&gt;使用 NoSQL, 比如 MongoDB 的文档嵌入&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;外键 Foreign Key 是数据库中用来建立和强化两个表之间联系的关键字段, 简单来说, 它是一个表中的某个字段, 这个字段的值来源于另一个表的主键 Primary Key, 默认不会创建外键, 需要自己指定, 当然主键也可以自己指定, 但外键更像是一个确保数据一致性约束, 比如下面两个表的结构和建表语句:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;users 表
user_id | username
--------+----------
1       | 张三
2       | 李四

orders 表
order_id | user_id | order_date
---------+---------+------------
101      | 1       | 2025-03-01
102      | 2       | 2025-03-02
103      | 1       | 2025-03-15
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;显然 orders 表中的 &lt;code&gt;user_id&lt;/code&gt; 和 &lt;code&gt;order_date&lt;/code&gt; 就是一个普通字段, 但是我们知道, 在处理用户和订单一对多的关系时 (一个用户可以拥有多个订单, 一个订单只能属于一个用户), 订单表里的外键设置为用户表里的主键就可以了, 不需要额外分表, 但是我们需要告诉订单表, 并不是说把字段设置成 &lt;code&gt;user_id&lt;/code&gt;, 订单表就知道了&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; users (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    user_id INT &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; AUTO_INCREMENT,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    username VARCHAR(&lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; orders (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    order_id INT &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; AUTO_INCREMENT,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    user_id INT &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    order_date DATE &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;FOREIGN&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; (user_id) &lt;span style=&#34;color:#66d9ef&#34;&gt;REFERENCES&lt;/span&gt; users(user_id) &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DELETE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CASCADE&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;ON DELETE CASCADE&lt;/code&gt; 是 外键约束 中的一种行为, 当 父表（即主键表）的某一行被删除时, 所有引用该行的 子表 记录也会被自动删除, 看到这不难理解, 外键就是一种约束手段, 没有什么特殊的, 和主键不一样(自动创建索引), 大部分数据库并不会为 外键 自动创建索引, 但 外键查询经常涉及 &lt;code&gt;user_id&lt;/code&gt;, 如果不加索引, 查询效率会变低:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INDEX&lt;/span&gt; idx_orders_user_id &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; orders(user_id);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样可以提高查询性能, 比如单表查询或者连接查询：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; orders &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; user_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 &lt;code&gt;JOIN&lt;/code&gt; 查询中，数据库需要在 &lt;code&gt;users&lt;/code&gt; 和 &lt;code&gt;orders&lt;/code&gt; 之间匹配 &lt;code&gt;user_id&lt;/code&gt;，如果 &lt;code&gt;orders.user_id&lt;/code&gt; 没有索引，数据库就不得不进行全表扫描（&lt;code&gt;Full Table Scan&lt;/code&gt;），从而导致查询变慢:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 查询 用户 &amp;#34;1&amp;#34; 的所有订单, 包括用户名
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; o.order_id, o.order_date, u.username
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; orders o
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;JOIN&lt;/span&gt; users u &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; o.user_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; u.user_id
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; u.user_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 查询 每个用户下的订单总数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; u.username, &lt;span style=&#34;color:#66d9ef&#34;&gt;COUNT&lt;/span&gt;(o.order_id) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; order_count
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; users u
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;LEFT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;JOIN&lt;/span&gt; orders o &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; u.user_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; o.user_id
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;GROUP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; u.username;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;拓展:&lt;/strong&gt; 除此之外, 在&lt;a href=&#34;https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/003-%E6%AD%BB%E9%94%81/#13-%E5%A4%96%E9%94%AE%E5%BC%95%E8%B5%B7&#34;&gt;数据库死锁以及排查&lt;/a&gt;文章中我们提到过, 死锁的一个原因就是外键导致的, 原因是删除主表(用户表)的一行记录时, 因为订单表的外键约束, 数据库需要去检查订单表中的外键 是不是引用的该行记录的 主键, 在检查扫表的过程会加锁, 如果有 &lt;code&gt;ON DELETE CASCADE&lt;/code&gt;, 那还会删除 订单表中 对应的记录, 这更要加锁, 这就可能导致加锁顺序不一致而造成的循环等待死锁问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;3-分库分表&#34;&gt;3. 分库分表&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;平时怎么做分表?&lt;/p&gt;
&lt;p&gt;分表是通过减少单表数据量或宽度, 提升查询性能, 例如水平分表后, 扫描的行数减少, 垂直分表后, 读取的字段减少&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于&lt;strong&gt;水平分表&lt;/strong&gt;, 选择&lt;strong&gt;合适的分片键&lt;/strong&gt;非常关键, 分片键要保证数据分布均匀, 避免某些表过热（如按时间分片可能导致最新表负载过高）, 常见的键包括ID哈希、范围（如时间、地域）等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;垂直分表&lt;/strong&gt;不需要分片键，而是基于业务逻辑拆分字段&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将一张大表拆成多张关联表 (如user和address通过外键关联), 目的是消除冗余、保持数据一致性, 这是数据库设计中的&lt;strong&gt;规范化Normalization&lt;/strong&gt;, 所以分表和数据库规范化设计不一样&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;31-垂直分库&#34;&gt;3.1. 垂直分库&lt;/h3&gt;
&lt;p&gt;“垂直分库”通常是指按照业务功能或业务模块进行数据库层面的拆分, 也可以理解为“业务维度”的拆分, 比如把用户相关的数据放在 &lt;code&gt;user_db&lt;/code&gt;, 订单相关的数据放在 &lt;code&gt;order_db&lt;/code&gt;, 支付相关的数据放在 &lt;code&gt;payment_db&lt;/code&gt; 等等, 各个库之间相互独立, 分别部署到不同的数据库实例上, 缺点也很明显 &lt;strong&gt;跨库事务复杂&lt;/strong&gt;, 可能需要分布式事务支持&lt;/p&gt;
&lt;h3 id=&#34;32-垂直分表&#34;&gt;3.2. 垂直分表&lt;/h3&gt;
&lt;p&gt;“垂直分表”指的是在同一个数据库实例内，把一张表中按列拆分成多张表，也就是把一个大而“宽”的表变成几个更“窄”的表，通常是将热点字段或常用字段与冷门或低频字段分开&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提高查询效率，减少 I/O 开销（因为主表变“窄”）&lt;/li&gt;
&lt;li&gt;需要多表关联查询，增加了复杂性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原始表：用户表 (id, name, age, address, biography, photo)&lt;/p&gt;
&lt;p&gt;拆分后：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主表：用户表 (id, name, age, address)&lt;/li&gt;
&lt;li&gt;附表：用户扩展表 (id, biography, photo)&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;查询通常依赖索引来定位数据, 垂直分表并不会减少记录行数, 为什么但垂直分表可以提高查询效率 减少 I/O 开销?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库（特别是关系型数据库，如 MySQL）将数据存储在磁盘上的&lt;strong&gt;数据页&lt;/strong&gt;（Page）中, 一个数据页的大小是固定的（比如 MySQL InnoDB 默认 16KB）&lt;/li&gt;
&lt;li&gt;每行数据（记录）占用一定空间，行的宽度（即所有字段的总字节大小）决定了单个数据页能存储多少行&lt;/li&gt;
&lt;li&gt;当执行查询时，数据库并不是只读取目标字段，而是会将包含目标行的整个数据页加载到内存中（这就是 I/O 操作）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设你经常执行的查询是 SELECT id, name, age FROM 用户表 WHERE age &amp;gt; 18，只涉及主表的部分字段&lt;/p&gt;
&lt;p&gt;未分表前:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每行数据包含所有字段（包括 biography 和 photo），行宽很大, 一个数据页存的行数少（比如 16 行），查询 1000 行可能需要加载 62 个数据页（1000 ÷ 16）&lt;/li&gt;
&lt;li&gt;加载的数据页中包含大量无关字段（biography, photo），而页数越多，磁盘 I/O 操作就越多，效率就越低&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;分表后&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主表只包含 id, name, age，行变窄&lt;/li&gt;
&lt;li&gt;一个数据页存的行数多（比如 160 行），查询 1000 行只需加载 7 个数据页（1000 ÷ 160）&lt;/li&gt;
&lt;li&gt;加载的数据页只包含需要的字段，I/O 开销显著减少&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;确实索引能快速定位到目标行, 但定位后, 数据库仍需从数据页中读取整行数据, 如果行很宽, 读取的无关数据多, I/O 效率就低, 垂直分表让主表的行变窄, 索引定位后的数据读取成本降低&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;33-水平分库-horizontal-database-sharding&#34;&gt;3.3. 水平分库 Horizontal Database Sharding&lt;/h3&gt;
&lt;p&gt;“水平分库”指的是把同一个逻辑表中的数据按行分散到多个不同的数据库实例中，每个实例上的表结构相同，但存储的数据范围（或子集）不同，比如根据订单 ID、用户 ID、时间等进行切分，每台库只负责一部分数据:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如订单数据体量巨大、访问频率非常高，此时单台数据库的扩容成本太高或已经接近物理瓶颈，需要多个数据库实例并行承担负载&lt;/li&gt;
&lt;li&gt;提高整体吞吐量，降低单库故障对全局的影响&lt;/li&gt;
&lt;li&gt;可以将不同分片布置在不同的机房或不同节点上，实现一定程度上的容灾与负载均衡&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;分片键 sharding key 的选择&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;分片键水平分库的核心, 常见的做法是选择访问量最高的查询条件作为分片键, 比如用户 ID、订单 ID、时间等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要保证分片后的数据分布尽量均匀，避免热点分片（如大量订单都集中在某几个用户）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果经常做范围查询（如时间区间），还需要考虑是否采用 Range Sharding，与 Hash Sharding 各有利弊（Range 容易出现数据倾斜，但查询方便；Hash 数据分布均匀，但跨分片查询复杂）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;跨库查询、跨库事务，需要在中间件或应用层做聚合处理，或者通过最终一致性解决事务问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;34-水平分表&#34;&gt;3.4. 水平分表&lt;/h3&gt;
&lt;p&gt;水平分表在同一个数据库实例中, 将同一逻辑大表的数据按行划分到多张结构相同的小表里, 比如 &lt;code&gt;user_001&lt;/code&gt;, &lt;code&gt;user_002&lt;/code&gt;…&lt;code&gt;user_016&lt;/code&gt;, 这些分表依旧在同一个数据库实例中, 只是物理上拆成多个表, 以减少单表容量、索引体量、DDL 风险等&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在数据库水平拆分的讨论中, 经常会出现“水平分库”与“水平分表”这两个概念, 有时也会听到“分库分表”都统称为“水平分片”或“水平切分”:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;水平分表是“拆表”，但依然在单个数据库实例内&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;水平分库是“拆库”，把数据分散到多台数据库服务器（实例）上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在大规模、高并发场景下，往往先从“水平分表”演进到“水平分库”，或者直接做“分库+分表”以获得更大的水平扩展能力&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;35-不同类型的分片键及其适用场景&#34;&gt;3.5. 不同类型的分片键及其适用场景&lt;/h3&gt;
&lt;p&gt;常见的分片策略包括 Range（区间/范围）、Hash（哈希）、Modulo（取模）、业务逻辑（地理、时间等）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Range Sharding&lt;/strong&gt; 根据分片键的值所处的区间来决定存储位置。例如常见的按“时间范围”或按“ID 范围”来切分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;按时间：每个月/每季度/每年创建一张新表或新库，比如 &lt;code&gt;orders_202301&lt;/code&gt;，&lt;code&gt;orders_202302&lt;/code&gt;…&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按 ID 范围：假如用户 ID 范围 &lt;code&gt;[0, 99999]&lt;/code&gt; 放在库/表 1，&lt;code&gt;[100000, 199999]&lt;/code&gt; 放在库/表 2，依此类推&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优点 区间查询友好&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点 易出现数据倾斜和热点, 如果大量写入发生在最新时间段, 或某些 ID 段比较热门, 就会导致某一个或少数几个分区负载极高, 而其他分区相对空闲&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Hash Sharding&lt;/strong&gt;  对分片键进行哈希计算, 然后将哈希结果映射到不同的分片中, 常见的方案是 &lt;code&gt;shard_id = hash(key) mod N&lt;/code&gt;, 其中 N 是分片数:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点 数据分布更均匀相比按范围分片，哈希分片能够平衡各个分区的存储与访问压力，避免单点或单区过热&lt;/li&gt;
&lt;li&gt;缺点 对于点查（基于主键或唯一键查询）非常友好，但对于范围扫描不太友好, 如果需要按时间区间查询或多条件查询，很可能要扫描所有分片，增加了负载和逻辑复杂度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;业务逻辑分片（地理、业务域等）&lt;/strong&gt; 根据业务属性对数据进行划分，如国家/地区、渠道、业务模块等。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;地区分片&lt;/strong&gt;：&lt;code&gt;用户(中国)&lt;/code&gt; 放在一个分片，&lt;code&gt;用户(北美)&lt;/code&gt; 放在另一个分片&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;业务域分片&lt;/strong&gt;：A 产品线所有订单进 A 库，B 产品线所有订单进 B 库&lt;/li&gt;
&lt;li&gt;缺点 数据分布不一定均匀&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>Tomcat Nginx Gateway LoadBalancer</title>
      <link>https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/008-tomcat-nginx-gateway/</link>
      <pubDate>Mon, 17 Mar 2025 12:08:20 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/008-tomcat-nginx-gateway/</guid>
      <description>&lt;h2 id=&#34;1-写在前面&#34;&gt;1. 写在前面&lt;/h2&gt;
&lt;p&gt;好多网关路由转发的功能, 感觉有的都重复了, 在这里讨论一下, 主要目的是明白各自存在的意义, 首先是 Tomcat, 这是个 Servlet 容器, 至于 Servlet 是什么, umm, 如果你以前写过 JSP 那一套肯定是了解的, 但现在基本上直接学习 Spring Boot, 不会接触到 Servlet, JSP, 最多也是调试看日志的时候看到一些比如 DispatcherServlet 相关的错误, 可以说 Spring MVC 就是基于 Servlet 的 Web 框架, 它通过一个核心的 DispatcherServlet 来分发请求到不同的控制器, 但底层仍然依赖 Tomcat 这样的容器来运行&lt;/p&gt;
&lt;h3 id=&#34;11-从最基础的-java-web-servlet--jsp-说起&#34;&gt;1.1. 从最基础的 Java Web Servlet + JSP 说起&lt;/h3&gt;
&lt;p&gt;Servlet 是 JavaEE 体系里定义的一套 接口/规范, 最初的目标是取代 CGI 处理 HTTP 请求, Tomcat 是一个 Servlet 容器, 它实现了 Servlet 规范, 因此, 只要你编写的代码符合 Servlet 规范, 就可以直接部署在 Tomcat 上跑&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-写在前面&#34;&gt;1. 写在前面&lt;/h2&gt;
&lt;p&gt;好多网关路由转发的功能, 感觉有的都重复了, 在这里讨论一下, 主要目的是明白各自存在的意义, 首先是 Tomcat, 这是个 Servlet 容器, 至于 Servlet 是什么, umm, 如果你以前写过 JSP 那一套肯定是了解的, 但现在基本上直接学习 Spring Boot, 不会接触到 Servlet, JSP, 最多也是调试看日志的时候看到一些比如 DispatcherServlet 相关的错误, 可以说 Spring MVC 就是基于 Servlet 的 Web 框架, 它通过一个核心的 DispatcherServlet 来分发请求到不同的控制器, 但底层仍然依赖 Tomcat 这样的容器来运行&lt;/p&gt;
&lt;h3 id=&#34;11-从最基础的-java-web-servlet--jsp-说起&#34;&gt;1.1. 从最基础的 Java Web Servlet + JSP 说起&lt;/h3&gt;
&lt;p&gt;Servlet 是 JavaEE 体系里定义的一套 接口/规范, 最初的目标是取代 CGI 处理 HTTP 请求, Tomcat 是一个 Servlet 容器, 它实现了 Servlet 规范, 因此, 只要你编写的代码符合 Servlet 规范, 就可以直接部署在 Tomcat 上跑&lt;/p&gt;
&lt;h4 id=&#34;111-如何操作&#34;&gt;1.1.1. 如何操作&lt;/h4&gt;
&lt;p&gt;开发者编写一个继承 HttpServlet 的类，重写 &lt;code&gt;doGet()&lt;/code&gt; 或 &lt;code&gt;doPost()&lt;/code&gt; 方法:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MyServlet&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; HttpServlet {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Override&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;protected&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;doGet&lt;/span&gt;(HttpServletRequest req, HttpServletResponse resp) &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; ServletException, IOException {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        resp.&lt;span style=&#34;color:#a6e22e&#34;&gt;setContentType&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;text/html&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        PrintWriter out &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; resp.&lt;span style=&#34;color:#a6e22e&#34;&gt;getWriter&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        out.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;Hello, World!&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 &lt;code&gt;web.xml&lt;/code&gt; 中配置 URL 映射：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;servlet&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;servlet-name&amp;gt;&lt;/span&gt;MyServlet&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/servlet-name&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;servlet-class&amp;gt;&lt;/span&gt;com.example.MyServlet&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/servlet-class&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/servlet&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;servlet-mapping&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;servlet-name&amp;gt;&lt;/span&gt;MyServlet&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/servlet-name&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;url-pattern&amp;gt;&lt;/span&gt;/hello&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/url-pattern&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/servlet-mapping&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;112-tomcat-做了什么&#34;&gt;1.1.2. Tomcat 做了什么&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;打开一个 ServerSocket，监听某个端口（默认 8080）&lt;/li&gt;
&lt;li&gt;当有 HTTP 请求进来时，会将请求解析成 HttpServletRequest / HttpServletResponse 对象&lt;/li&gt;
&lt;li&gt;根据配置（如 &lt;code&gt;web.xml&lt;/code&gt; 中的 &lt;code&gt;&amp;lt;servlet&amp;gt;&lt;/code&gt; / &lt;code&gt;&amp;lt;servlet-mapping&amp;gt;&lt;/code&gt;）, Tomcat 会将请求分发给对应的 Servlet&lt;/li&gt;
&lt;li&gt;Tomcat 接收到 &lt;code&gt;/hello&lt;/code&gt; 请求后，调用 &lt;code&gt;MyServlet&lt;/code&gt; 的 &lt;code&gt;doGet()&lt;/code&gt; 方法&lt;/li&gt;
&lt;li&gt;Servlet 接口定义了一系列生命周期方法，比如 &lt;code&gt;init()&lt;/code&gt;, &lt;code&gt;service()&lt;/code&gt;, &lt;code&gt;destroy()&lt;/code&gt; 等，最核心的就是 &lt;code&gt;service()&lt;/code&gt; 方法(或 doGet/doPost&amp;hellip;)，用来处理请求并写出响应&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;113-现存问题&#34;&gt;1.1.3. 现存问题&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个功能（如登录、列表页）都需要一个 Servlet, 代码重复严重（比如每次都要设置响应类型、获取参数）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置繁琐, 所有 Servlet 都要在 &lt;code&gt;web.xml&lt;/code&gt; 中手动映射&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12-spring-mvc在-servlet-基础上的进一步抽象&#34;&gt;1.2. Spring MVC：在 Servlet 基础上的进一步抽象&lt;/h3&gt;
&lt;p&gt;Spring MVC 出现是为了解决 Servlet + JSP 的问题, 它引入了 MVC（Model-View-Controller）模式, 通过一个核心 Servlet（DispatcherServlet）统一处理请求, 并将逻辑分层,&lt;/p&gt;
&lt;h4 id=&#34;121-两个核心组件&#34;&gt;1.2.1. 两个核心组件&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DispatcherServlet&lt;/strong&gt;：Spring MVC 的入口, 是一个特殊的 Servlet，配置为拦截所有请求 &lt;code&gt;/*&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Controller&lt;/strong&gt;：替代了分散的 Servlet，集中处理业务逻辑&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Controller&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;HelloController&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@RequestMapping&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/hello&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; String &lt;span style=&#34;color:#a6e22e&#34;&gt;sayHello&lt;/span&gt;(Model model) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        model.&lt;span style=&#34;color:#a6e22e&#34;&gt;addAttribute&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;message&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello, World!&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 逻辑视图名&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;servlet&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;servlet-name&amp;gt;&lt;/span&gt;dispatcher&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/servlet-name&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;servlet-class&amp;gt;&lt;/span&gt;org.springframework.web.servlet.DispatcherServlet&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/servlet-class&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/servlet&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;servlet-mapping&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;servlet-name&amp;gt;&lt;/span&gt;dispatcher&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/servlet-name&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;url-pattern&amp;gt;&lt;/span&gt;/*&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/url-pattern&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/servlet-mapping&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;122-请求步骤&#34;&gt;1.2.2. 请求步骤&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;用户访问 http://localhost:8080/myapp/hello&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tomcat 接收请求，根据 web.xml 路由到 DispatcherServlet&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DispatcherServlet：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;根据 @RequestMapping(&amp;quot;/hello&amp;quot;) 找到 HelloController 的 sayHello 方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行方法，生成 Model 数据（&amp;ldquo;message&amp;rdquo;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 ViewResolver 将 &amp;ldquo;hello&amp;rdquo; 解析为 hello.jsp&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;渲染 JSP，返回 HTML 响应&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;123-优缺点&#34;&gt;1.2.3. 优缺点&lt;/h4&gt;
&lt;p&gt;优点: 请求分发自动化, 不需要为每个 URL 写一个 Servlet&lt;/p&gt;
&lt;p&gt;缺点: 配置复杂（XML 或注解）部署仍需手动打包 WAR 文件, 放入 Tomcat&lt;/p&gt;
&lt;h3 id=&#34;13-spring-boot进一步简化部署与配置&#34;&gt;1.3. Spring Boot：进一步简化部署与配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在传统的 Spring MVC 项目中, 你需要单独安装 Tomcat, 然后把打好的 &lt;code&gt;.war&lt;/code&gt; 包部署到 Tomcat 的 &lt;code&gt;webapps&lt;/code&gt; 目录下&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Spring Boot 则自带一个 嵌入式 Tomcat, 你只要在 &lt;code&gt;pom.xml&lt;/code&gt; 里加上依赖, Spring Boot 会自动把 Tomcat 打包进来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 Spring MVC 时代，为了让 DispatcherServlet 工作，你往往需要在 &lt;code&gt;web.xml&lt;/code&gt; 配置 &lt;code&gt;&amp;lt;servlet&amp;gt;&lt;/code&gt; + &lt;code&gt;&amp;lt;servlet-mapping&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 Spring Boot 中, 几乎可以“零配置”——因为 Spring Boot Starter 以及 自动配置(Auto Configuration) 会帮你自动注册 DispatcherServlet、自动扫描 &lt;code&gt;@Controller&lt;/code&gt;、自动创建上下文等等&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;要记住：尽管我们用 Spring Boot，但底层还是 &lt;strong&gt;Tomcat + DispatcherServlet&lt;/strong&gt; 在跑，只不过这一切都被 Boot 帮我们封装好了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;你用 &lt;code&gt;SpringApplication.run(...);&lt;/code&gt; 启动项目时, Spring Boot会：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建一个 Spring 上下文(ApplicationContext)，加载各种自动配置类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化并启动一个 Tomcat 容器（默认监听 8080 端口）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注册 DispatcherServlet 并进行 URL 映射(默认 &lt;code&gt;/*&lt;/code&gt;)，使它成为整个应用的前端控制器&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当请求进入时, Tomcat 依旧会解析 HTTP 消息头、消息体，生成 &lt;code&gt;HttpServletRequest / HttpServletResponse&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tomcat 将请求分发给对应的 Servlet；在 Spring Boot 里，几乎所有请求都指向 DispatcherServlet&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DispatcherServlet 查找对应的 Handler（&lt;code&gt;@Controller&lt;/code&gt; / &lt;code&gt;@RestController&lt;/code&gt; 上的各种映射），执行相关方法，得到返回值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果返回的是视图名，就会交给视图解析器去找模板进行渲染；如果是 &lt;code&gt;@ResponseBody&lt;/code&gt; 或 &lt;code&gt;@RestController&lt;/code&gt;，就会把返回对象序列化为 JSON 响应&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最终 Tomcat 将响应通过网络发回给客户端&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以可以看到, 本质上还是 Servlet 容器 + Servlet 规范在支撑所有这些流程, Spring Boot 并没有发明新的东西, 只是封装集成得更紧密, 让我们省去了许多“手动调度、配置、部署”的繁琐步骤&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以 Spring Boot 本质就是构建于 Spring MVC 之上基于 Spring 生态的“快速开发框架”, 它帮我们集成了 Spring MVC 所有的基础配置, 包括 Servlet 路径, 视图, 以及 Servlet 容器 Tomcat, 除此之外还提前定义了 Spring 核心组件的依赖版本, 我们只要在 &lt;code&gt;pom.xml&lt;/code&gt; 引入了 &lt;code&gt;&amp;lt;parent&amp;gt;...&amp;lt;/parent&amp;gt;&lt;/code&gt;, 当我们使用一些依赖比如 Spring Security, Spring Data JPA 等, 直接加到 &lt;code&gt;pom.xml&lt;/code&gt; 中就行, 不用指定版本号或者担心以后更新引起版本冲突,&lt;/p&gt;
&lt;h2 id=&#34;2-tomcat-vs-nginx&#34;&gt;2. Tomcat vs Nginx&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Tomcat&lt;/strong&gt;: Apache Tomcat 是一个开源的 Java Servlet 容器, 主要用于运行 Java 应用程序, 支持 Java Servlet、JavaServer Pages (JSP) 和 WebSocket 等技术，常用于处理动态内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Nginx&lt;/strong&gt;: 用于提供静态内容（如 HTML、CSS、图片等）, 或者作为反向代理将请求分发到后端服务器, 它的核心职责是接收客户端请求、分发流量、管理静态资源，以及将动态请求代理到后端服务&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-为什么有了-nginx-还需要-spring-cloud-gateway&#34;&gt;3. 为什么有了 Nginx 还需要 Spring Cloud Gateway&lt;/h2&gt;
&lt;p&gt;Gateway 可以与 Spring Cloud Eureka, Spring Cloud Loadbalancer 合作使用, 可以用来通过 请求路径 如 &lt;code&gt;Path=/product/**&lt;/code&gt;  和 &lt;code&gt;uri: lb://product-service&lt;/code&gt; 来找到服务位置, 而 Nginx 不可以,&lt;/p&gt;
&lt;p&gt;Gateway 专为微服务设计，与 Spring 生态深度集成；Nginx 是通用工具，集成微服务生态麻烦&lt;/p&gt;
&lt;h3 id=&#34;31-服务发现与动态路由&#34;&gt;3.1. 服务发现与动态路由&lt;/h3&gt;
&lt;p&gt;Gateway 可以与 Spring Cloud Eureka 集成, 通过 &lt;code&gt;uri: lb://product-service&lt;/code&gt; 这样的配置, 自动从 Eureka 中查找 &lt;code&gt;product-service&lt;/code&gt; 的实例 IP 和端口, 结合 Spring Cloud LoadBalancer, 它还能动态选择一个健康的实例发送请求:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;spring&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;cloud&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;gateway&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;routes&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        - &lt;span style=&#34;color:#f92672&#34;&gt;id&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;product_route&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;uri&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;lb://product-service &lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# 动态找到服务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;predicates&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            - &lt;span style=&#34;color:#ae81ff&#34;&gt;Path=/product/**&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Gateway 不需要知道具体的服务地址，服务实例增加或减少时，它会自动适应, 在微服务架构中，服务地址经常变化，Gateway 的动态性非常适合这种场景, Nginx 是一个独立的 Web 服务器，需要在配置文件中手动指定后端地址, 如果服务地址变了比如新增实例或实例宕机, 你得手动更新配置并重载 Nginx:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;upstream product_service {
    server 192.168.1.10:8080;
    server 192.168.1.11:8081;
}
location /product {
    proxy_pass http://product_service;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;32-灵活的路由与业务逻辑&#34;&gt;3.2. 灵活的路由与业务逻辑&lt;/h2&gt;
&lt;p&gt;Spring Cloud Gateway 可以基于路径 &lt;code&gt;Path=/product/**&lt;/code&gt;、请求方法&lt;code&gt;Method=GET&lt;/code&gt; 等条件定义路由规则, 通过过滤器 Filter，可以轻松实现认证、添加请求头、限流等功能:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;spring&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;cloud&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;gateway&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;routes&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        - &lt;span style=&#34;color:#f92672&#34;&gt;id&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;product_route&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;uri&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;lb://product-service&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;predicates&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            - &lt;span style=&#34;color:#ae81ff&#34;&gt;Path=/product/**&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;filters&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            - &lt;span style=&#34;color:#ae81ff&#34;&gt;AddRequestHeader=X-Authenticated, true &lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# 添加请求头&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            - &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;AuthenticationFilter &lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# 自定义认证逻辑&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;4-nginx-使用场景&#34;&gt;4. Nginx 使用场景&lt;/h2&gt;
&lt;p&gt;假设你想搭建一个简单的 Web 服务器，监听 80 端口，并根据路径转发请求：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;http {
    server {
        listen 80;                  # 监听 80 端口
        server_name example.com;    # 域名

        location / {                # 根路径返回欢迎信息
            return 200 &amp;#34;Welcome to Nginx!&amp;#34;;
        }

        location /api {             # /api 路径代理到后端
            proxy_pass http://backend:8080;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;假设你有两台后端服务器，想实现简单的负载均衡：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;http {
    upstream backend_servers {
        server 192.168.1.10:8080;   # 第一台后端服务器
        server 192.168.1.11:8080;   # 第二台后端服务器
    }

    server {
        listen 80;
        server_name example.com;

        location / {
            proxy_pass http://backend_servers;  # 转发到 upstream
            proxy_set_header Host $host;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;默认情况下, 当 Nginx 代理请求到后端服务器时, 它可能会使用后端服务器的 IP 地址作为 &lt;code&gt;Host&lt;/code&gt;，例如 &lt;code&gt;192.168.1.10:8080&lt;/code&gt;，而不是 &lt;code&gt;example.com&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;proxy_set_header Host $host;&lt;/code&gt; 主要用于保持客户端请求的 &lt;code&gt;Host&lt;/code&gt; 头不变, 让后端服务器知道用户访问的是哪个域名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设你想将所有 /old-page 的请求重定向到 /new-page：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;http {
    server {
        listen 80;
        server_name example.com;

        location /old-page {
            rewrite ^/old-page(.*)$ /new-page$1 permanent;  # 永久重定向 (301)
        }

        location /new-page {
            return 200 &amp;#34;This is the new page!&amp;#34;;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用户访问 example.com/old-page 时，Nginx 将其重定向到 example.com/new-page，并返回 &amp;ldquo;This is the new page!&amp;rdquo;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;permanent 表示使用 301 重定向，告诉浏览器永久更新地址&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;限制请求速率, 防止服务器过载或抵御 DDoS 攻击, 限制每个 IP 每秒只能发送 2 个请求:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;http {
    limit_req_zone $binary_remote_addr zone=mylimit:10m rate=2r/s;

    server {
        listen 80;
        server_name example.com;

        location / {
            limit_req zone=mylimit burst=5;  # 允许突发 5 个请求
            return 200 &amp;#34;Hello, Nginx!&amp;#34;;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为网站启用 HTTPS，并将 HTTP 请求重定向到 HTTPS：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;http {
    server {
        listen 80;
        server_name example.com;
        return 301 https://$host$request_uri;  # 重定向到 HTTPS
    }

    server {
        listen 443 ssl;
        server_name example.com;

        ssl_certificate /etc/nginx/ssl/cert.pem;      # 证书文件
        ssl_certificate_key /etc/nginx/ssl/key.pem;   # 私钥文件

        location / {
            return 200 &amp;#34;Secure Page!&amp;#34;;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;5-有了-gateway-还需要-nginx-吗&#34;&gt;5. 有了 Gateway 还需要 Nginx 吗?&lt;/h2&gt;
&lt;p&gt;尽管 Gateway 功能强大，但在某些场景下，Nginx 仍然有不可替代的优势。以下是几个需要 Nginx 的理由和示例：&lt;/p&gt;
&lt;h3 id=&#34;51-理由-1高性能和外部流量处理&#34;&gt;5.1. &lt;strong&gt;理由 1：高性能和外部流量处理&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;场景：你的系统需要应对高并发外部流量（如网站有 10 万 QPS）&lt;/li&gt;
&lt;li&gt;问题：Gateway 运行在 JVM 上, 性能受限于 Java 的内存管理和线程模型, 在高并发场景下, 容易成为瓶颈, 性能不如 Nginx（C 语言实现，异步非阻塞 I/O）在高并发场景下，Gateway 可能成为瓶颈&lt;/li&gt;
&lt;li&gt;解决方案：用 Nginx 作为最外层入口，分担流量压力&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;upstream gateway_cluster {
    server gateway1:8080;
    server gateway2:8080;
    server gateway3:8080;
}

server {
    listen 80;
    server_name example.com;
    location / {
        proxy_pass http://gateway_cluster;  # 负载均衡到多个 Gateway
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;在没有 Nginx 的情况下，Gateway（如果它直接对外提供 HTTPS 接口）就需要自行完成整个 TLS 协议的握手和加解密工作，这部分本身会消耗一定的 CPU 资源，并且会让 Gateway 直接面对海量外部连接；而有了 Nginx 以后：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当客户端发起 HTTPS 请求时，Nginx 负责完成 SSL/TLS 握手和加解密的全过程，然后再将解密后的明文流量转发给 Gateway&lt;/li&gt;
&lt;li&gt;Gateway 只需要处理已经解密的流量，不再承担这部分 CPU 与网络资源负担，能专注于业务层面的路由或规则处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;流量削峰: Nginx 可以同时保持 10 万个前端连接 client -&amp;gt; Nginx, Nginx 并不“一对一”地为这 10 万前端连接都新建一个后端连接, 而是维持一组「后端连接池」, 例如 500 条（实际可配置）与 Gateway 的 TCP 连接, 这些连接都处于 Keep-Alive 状态, 当 Nginx 收到前端请求时, 会在这个连接池里“找一个”空闲连接, 发给 Gateway, 如果所有后端连接都暂时在忙, 那剩下的新请求可以在 Nginx 层面进行排队或等待, 不至于一股脑儿挤给 Gateway,&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 定义后端（上游）服务器组
upstream gateway_servers {
    server gateway1:8080;
    server gateway2:8080;

    # 保持最多 64 条保持存活的后端连接（示例数字）
    keepalive 64;  
}

server {
    listen 80;
    server_name example.com;

    location / {
        # 代理到定义好的上游
        proxy_pass http://gateway_servers;

        # 使用HTTP/1.1并开启keep-alive
        proxy_http_version 1.1;
        proxy_set_header Connection &amp;#34;&amp;#34;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;proxy_http_version 1.1&lt;/code&gt; 这个设置告诉 Nginx 在把 HTTP 请求转发给后端服务器 比如你的 gateway1:8080 和 gateway2:8080时, 使用 HTTP/1.1 协议, HTTP/1.1 有一个重要特点, 它支持持久连接, 意思是 TCP 连接建立后不会立刻关闭, 可以重复使用来处理多个 HTTP 请求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;keepalive 64&lt;/code&gt; 这个设置告诉 Nginx：在和后端服务器通信时, 尽量保持最多 64 个连接处于“存活”状态, 也就是说, 这些 TCP 连接不会在请求完成后马上关闭, 而是留着待命, 方便下次处理 HTTP 请求直接复用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;想象 Nginx 和后端服务器之间像打电话：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果没有 &lt;code&gt;keepalive&lt;/code&gt;, 每次 Nginx 要找后端服务器, 就得重新拨号、接通、说完挂断, 下次请求又得重复这个过程，很费时间&lt;/li&gt;
&lt;li&gt;加了 &lt;code&gt;keepalive 64&lt;/code&gt;, Nginx 就像跟后端说：“我们别挂电话，我留 64 条线开着，有新请求直接用这些线聊&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;持久连接（Keep-Alive）：HTTP/1.1 默认支持持久连接，允许在同一个 TCP 连接上处理多个 HTTP 请求，而无需每次请求都重新建立连接, 这减少了连接建立的开销，提高了性能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;52-理由-2静态资源分发&#34;&gt;5.2. 理由 2：静态资源分发&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;场景：你的应用需要提供大量静态资源（如图片、CSS、JS 文件）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;问题：Gateway 不是为静态资源分发设计的，效率不如 Nginx&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决方案：用 Nginx 直接处理静态资源，动态请求交给 Gateway&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;server {
    listen 80;
    server_name example.com;

    location /static {
        root /var/www/static;  # 直接提供静态文件
    }

    location / {
        proxy_pass http://gateway:8080;  # 动态请求给 Gateway
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;53-理由-3https-和安全&#34;&gt;5.3. 理由 3：HTTPS 和安全&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;场景&lt;/strong&gt;：需要为网站启用 HTTPS 或抵御 DDoS 攻击&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：Gateway 可以配置 HTTPS，但 Nginx 在 SSL 终止和安全防护（如限流、IP 黑名单）方面更成熟&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;：用 Nginx 处理 HTTPS 和安全，再转发到 Gateway&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;server {
    listen 443 ssl;
    server_name example.com;
    ssl_certificate /etc/nginx/ssl/cert.pem;
    ssl_certificate_key /etc/nginx/ssl/key.pem;

    location / {
        proxy_pass http://gateway:8080;
    }
}
&lt;/code&gt;&lt;/pre&gt;</content>
    </item>
    
    <item>
      <title>Spring Cloud 组件理解</title>
      <link>https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/007-spring-cloud-arch/</link>
      <pubDate>Mon, 17 Mar 2025 12:01:20 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/007-spring-cloud-arch/</guid>
      <description>&lt;h2 id=&#34;1-spring-cloud-loadbalancer&#34;&gt;1. Spring Cloud Loadbalancer&lt;/h2&gt;
&lt;p&gt;Spring Cloud Loadbalancer 并不是一个独立运行的服务 比如监听某个端口的进程, 而是一个 JAR 包, 集成到你的应用 比如 Gateway 或微服务 中, 在你的应用进程内部运行, 作为一个功能模块, Spring Cloud Loadbalancer 的工作原理是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;依赖服务注册中心&lt;/strong&gt;: 它从服务注册中心（如 Eureka）获取服务实例列表&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行负载均衡逻辑&lt;/strong&gt;: 在客户端本地（即你的应用进程中），根据配置的算法选择一个实例（通常是 IP + 端口）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回实例地址&lt;/strong&gt;: 将选中的实例地址交给调用方（比如 Gateway 或 RestTemplate），由调用方发起实际请求&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;它不需要监听端口，因为它不是服务端，而是客户端逻辑的一部分&lt;/p&gt;
&lt;h2 id=&#34;2-spring-cloud-gateway&#34;&gt;2. Spring Cloud Gateway&lt;/h2&gt;
&lt;p&gt;职责: Spring Cloud Gateway 是一个 API 网关, 它是整个系统的边界层, 面对外部客户端, 负责请求的分配和转发, 核心功能:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;路由：将外部请求转发到对应的微服务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;过滤：对请求进行预处理（如认证、限流）或响应处理（如添加头信息）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;负载均衡：内置支持负载均衡 (通过调用 Spring Cloud Loadbalancer 实现)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如果 Gateway 可以负载均衡，为什么还需要 Spring Cloud Loadbalancer？&lt;/p&gt;
&lt;p&gt;虽然 Gateway 可以做负载均衡, 但它只是“使用者”, 而 Spring Cloud Loadbalancer 是“提供者”, Loadbalancer 的存在是为了解耦负载均衡逻辑, 使其可以被多个组件复用, 而不仅仅局限于 Gateway,&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-spring-cloud-loadbalancer&#34;&gt;1. Spring Cloud Loadbalancer&lt;/h2&gt;
&lt;p&gt;Spring Cloud Loadbalancer 并不是一个独立运行的服务 比如监听某个端口的进程, 而是一个 JAR 包, 集成到你的应用 比如 Gateway 或微服务 中, 在你的应用进程内部运行, 作为一个功能模块, Spring Cloud Loadbalancer 的工作原理是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;依赖服务注册中心&lt;/strong&gt;: 它从服务注册中心（如 Eureka）获取服务实例列表&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行负载均衡逻辑&lt;/strong&gt;: 在客户端本地（即你的应用进程中），根据配置的算法选择一个实例（通常是 IP + 端口）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回实例地址&lt;/strong&gt;: 将选中的实例地址交给调用方（比如 Gateway 或 RestTemplate），由调用方发起实际请求&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;它不需要监听端口，因为它不是服务端，而是客户端逻辑的一部分&lt;/p&gt;
&lt;h2 id=&#34;2-spring-cloud-gateway&#34;&gt;2. Spring Cloud Gateway&lt;/h2&gt;
&lt;p&gt;职责: Spring Cloud Gateway 是一个 API 网关, 它是整个系统的边界层, 面对外部客户端, 负责请求的分配和转发, 核心功能:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;路由：将外部请求转发到对应的微服务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;过滤：对请求进行预处理（如认证、限流）或响应处理（如添加头信息）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;负载均衡：内置支持负载均衡 (通过调用 Spring Cloud Loadbalancer 实现)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如果 Gateway 可以负载均衡，为什么还需要 Spring Cloud Loadbalancer？&lt;/p&gt;
&lt;p&gt;虽然 Gateway 可以做负载均衡, 但它只是“使用者”, 而 Spring Cloud Loadbalancer 是“提供者”, Loadbalancer 的存在是为了解耦负载均衡逻辑, 使其可以被多个组件复用, 而不仅仅局限于 Gateway,&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;21-loadbalancer-在-gateway-中工作方式&#34;&gt;2.1. Loadbalancer 在 Gateway 中工作方式&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;spring&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;cloud&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;gateway&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;routes&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        - &lt;span style=&#34;color:#f92672&#34;&gt;id&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;order-service-route&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;uri&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;lb://order-service&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;predicates&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            - &lt;span style=&#34;color:#ae81ff&#34;&gt;Path=/orders/**&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当 Spring Cloud Gateway 配置了 &lt;code&gt;lb://service-name&lt;/code&gt; 时, 背后依赖 Spring Cloud Loadbalancer 来完成实例选择:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端发送请求 GET /orders/list 到 Gateway&lt;/li&gt;
&lt;li&gt;Gateway 解析 lb://order-service，识别这是一个需要负载均衡的路由&lt;/li&gt;
&lt;li&gt;Gateway 调用 Spring Cloud Loadbalancer&lt;/li&gt;
&lt;li&gt;Loadbalancer 从服务注册中心获取 order-service 的实例列表（比如 192.168.1.1:8081、192.168.1.2:8082、192.168.1.3:8083）&lt;/li&gt;
&lt;li&gt;Loadbalancer 根据算法（默认轮询）选择一个实例，比如 192.168.1.2:8082&lt;/li&gt;
&lt;li&gt;Gateway 拿到这个地址，将请求转发到 http://192.168.1.2:8082/orders/list&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22-loadbalancer-在微服务间调用中的工作方式&#34;&gt;2.2. Loadbalancer 在微服务间调用中的工作方式&lt;/h3&gt;
&lt;p&gt;在微服务直接调用（不经过 Gateway）时，比如使用 &lt;code&gt;@LoadBalanced&lt;/code&gt; 的 &lt;code&gt;RestTemplate&lt;/code&gt; 客户端，Loadbalancer 的作用也是一样的:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@RestController&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OrderController&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Autowired&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; RestTemplate restTemplate;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@GetMapping&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/pay&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; String &lt;span style=&#34;color:#a6e22e&#34;&gt;pay&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 注意这里是通过服务名称访问&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        String url &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://payment-service/pay&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; restTemplate.&lt;span style=&#34;color:#a6e22e&#34;&gt;getForObject&lt;/span&gt;(url, String.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Bean&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@LoadBalanced&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; RestTemplate &lt;span style=&#34;color:#a6e22e&#34;&gt;restTemplate&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; RestTemplate();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;这里的 &lt;code&gt;&amp;quot;http://payment-service/pay&amp;quot;&lt;/code&gt; 不是 具体的 IP 地址，而是一个 服务名称&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@LoadBalanced&lt;/code&gt;：启用 Spring Cloud 负载均衡功能, 让 &lt;code&gt;RestTemplate&lt;/code&gt; 去注册中心查询 &lt;code&gt;payment-service&lt;/code&gt; 的真实地址&lt;/li&gt;
&lt;li&gt;获取所有可用实例, 可能有多个, 启动负载均衡策略, RestTemplate 发送 HTTP 请求 到选定的 &lt;code&gt;payment-service&lt;/code&gt; 实例&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring Cloud Gateway 的负载均衡功能（lb:// 前缀）依赖于 Spring Cloud 生态中的负载均衡机制，而这个机制默认由 Spring Cloud Loadbalancer 提供, 但这种依赖并不是 Gateway 项目直接引入的，而是通过 Spring Cloud 依赖管理间接实现的,&lt;/p&gt;
&lt;p&gt;在 Spring Boot 和 Spring Cloud 项目中，依赖管理通常通过 &lt;strong&gt;Spring Cloud BOM（Bill of Materials）&lt;/strong&gt; 来统一处理版本和组件集成。Spring Cloud Gateway 和 Spring Cloud Loadbalancer 都属于 Spring Cloud 生态的一部分，当你引入 spring-cloud-starter-gateway 时，负载均衡相关的依赖会通过依赖链条隐式引入&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;3-spring-cloud-circuit-breaker&#34;&gt;3. Spring Cloud Circuit Breaker&lt;/h2&gt;
&lt;h3 id=&#34;31-如何使用&#34;&gt;3.1. 如何使用&lt;/h3&gt;
&lt;p&gt;熔断 Circuit Breaker 是一种用于提高系统稳定性和容错能力的设计模式, 当服务调用失败率过高或响应时间过长时, 熔断器会切断请求, 防止系统雪崩, 并提供降级逻辑, Resilience4j 本质上是 一个独立的熔断库, 并不属于 Spring Cloud, 但 Spring Cloud 已经将 Resilience4j 集成到 Spring Cloud Circuit Breaker 组件中, 作为 Hystrix 的替代方案,&lt;/p&gt;
&lt;p&gt;添加 Spring Cloud Resilience4j 依赖:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-cloud-starter-circuitbreaker-resilience4j&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 &lt;code&gt;application.yml&lt;/code&gt; 配置熔断器规则：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;resilience4j&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;circuitbreaker&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;instances&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;externalService&lt;/span&gt;: &lt;span style=&#34;color:#75715e&#34;&gt;# 熔断器名称，对应 @CircuitBreaker(name = &amp;#34;externalService&amp;#34;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;failureRateThreshold&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# 失败率达到 50% 触发熔断&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;slowCallRateThreshold&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# 100% 慢调用视为失败&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;slowCallDurationThreshold&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;2s&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# 超过 2 秒的调用视为慢调用&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;waitDurationInOpenState&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;5s&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# 熔断后 5 秒进入半开状态&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;permittedNumberOfCallsInHalfOpenState&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# 半开状态下允许 3 次测试请求&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;slidingWindowSize&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# 统计 10 次请求&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;minimumNumberOfCalls&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# 至少 5 次请求后才计算熔断&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Spring Cloud 提供 &lt;code&gt;@CircuitBreaker&lt;/code&gt;，但建议使用 &lt;code&gt;@Retryable&lt;/code&gt; 或 &lt;code&gt;@TimeLimiter&lt;/code&gt; 结合 &lt;code&gt;@CircuitBreaker&lt;/code&gt; 以支持异步调用:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Service&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ExternalApiService&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; RestTemplate restTemplate &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; RestTemplate();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@CircuitBreaker&lt;/span&gt;(name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;externalService&amp;#34;&lt;/span&gt;, fallbackMethod &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fallback&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@TimeLimiter&lt;/span&gt;(name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;externalService&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Retryable&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; CompletableFuture&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fetchData&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; CompletableFuture.&lt;span style=&#34;color:#a6e22e&#34;&gt;supplyAsync&lt;/span&gt;(() &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            ResponseEntity&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; response &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; restTemplate.&lt;span style=&#34;color:#a6e22e&#34;&gt;getForEntity&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://some-external-api.com/data&amp;#34;&lt;/span&gt;, String.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; response.&lt;span style=&#34;color:#a6e22e&#34;&gt;getBody&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; CompletableFuture&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fallback&lt;/span&gt;(Throwable ex) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; CompletableFuture.&lt;span style=&#34;color:#a6e22e&#34;&gt;completedFuture&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Fallback response&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@CircuitBreaker(name = &amp;quot;externalService&amp;quot;, fallbackMethod = &amp;quot;fallback&amp;quot;)&lt;/code&gt; 进行熔断&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@TimeLimiter(name = &amp;quot;externalService&amp;quot;)&lt;/code&gt; 处理超时&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@Retryable&lt;/code&gt; 进行重试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;fetchData()&lt;/code&gt; 异步调用 API&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring Cloud Circuit Breaker 是一个 抽象层, 它允许开发者使用不同的熔断实现，例如：Resilience4j, Sentinel, Hystrix（已经被废弃）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;32-解决的问题&#34;&gt;3.2. 解决的问题&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;防止雪崩效应（Cascading Failure）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在微服务架构中，服务之间通常是链式调用，如果某个服务（比如订单服务）响应变慢或不可用，所有依赖它的服务（比如支付、推荐）都会受影响，最终可能导致整个系统瘫痪,&lt;/p&gt;
&lt;p&gt;在高并发环境下，如果一个服务响应变慢，大量线程会阻塞等待返回，导致线程池被耗尽，影响其他正常请求&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;**为什么大量流量会冲垮服务器? ** 答案: CPU &amp;amp; 内存负载过高，导致崩溃&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程池 &amp;amp; 连接池耗尽:&lt;/strong&gt; 现代 Web 服务器（如 Tomcat、Spring Boot 内置 Netty）在处理 HTTP 请求时，通常会使用&lt;strong&gt;线程池&lt;/strong&gt;，而不是无限制创建新线程, 当请求量超出线程池或连接池的限制，服务器可能会崩溃或严重降级:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于线程池满了, 新请求只能等待，或者直接被拒绝&lt;/li&gt;
&lt;li&gt;如果请求等待时间过长, 大量超时会导致请求积压, 最终服务器负载飙升, 崩溃&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;数据库 &amp;amp; 依赖服务承受不住&lt;/strong&gt;: 现代 Web 应用通常会依赖数据库、缓存（Redis）、第三方 API, 如果大量请求涌入, 这些依赖服务可能也会被压垮, 假设数据库可以承受 每秒 500 次查询（QPS）, 如果流量稳定, 数据库可以正常处理, 假设一秒内突然有 10,000 次查询，数据库无法处理, 数据库连接池满了，新请求需要等待连接释放, 超时 &amp;amp; 失败请求会导致更多重试，形成恶性循环，最终数据库崩溃,&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;4-有了-gateway-还需要-nginx-吗&#34;&gt;4. 有了 Gateway 还需要 Nginx 吗&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果你的所有服务都经过 Spring Cloud Gateway 进行流量管理，并且不涉及&lt;strong&gt;静态资源托管&lt;/strong&gt;，Nginx 的作用可能较小&lt;/li&gt;
&lt;li&gt;通过 Nginx 实现 WAF（Web 应用防火墙）、DDoS 保护、IP 黑名单、限流等安全策略，减轻 Spring Cloud Gateway 的负担&lt;/li&gt;
&lt;li&gt;如果 Spring Cloud Gateway 由于重启或崩溃导致短暂不可用，Nginx 仍能提供基本的流量调度（比如返回静态页面）&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>Java 多线程 并发编程</title>
      <link>https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/010-java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Tue, 11 Mar 2025 12:30:20 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/010-java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description>&lt;h2 id=&#34;1-并行-并发&#34;&gt;1. 并行 并发&lt;/h2&gt;
&lt;p&gt;并行：多核 CPU 上的多任务处理，多个任务在同一时间真正地同时执行&lt;/p&gt;
&lt;p&gt;并发：单核 CPU 上的多任务处理，多个任务在同一时间段内交替执行，通过时间片轮转实现交替执行&lt;/p&gt;
&lt;h2 id=&#34;2-进程和线程&#34;&gt;2. 进程和线程&lt;/h2&gt;
&lt;p&gt;线程是进程的一个执行单位, 进程就是启用的一个程序, 比如本地启动 MySQL 服务, MySQL 服务创建和管理多个线程来分别处理客户端连接、查询解析、后端IO操作、缓存管理等，借此提升性能和响应能力&lt;/p&gt;
&lt;h2 id=&#34;3-线程安全的理解&#34;&gt;3. 线程安全的理解&lt;/h2&gt;
&lt;p&gt;线程安全主要涉及到多个线程同时尝试访问同一个共享数据, 能否正确处理共享数据的问题, 就是线程安全的关键:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先通过的就是锁机制, 互斥锁, 保证同一时刻只有一个线程修改共享数据&lt;/li&gt;
&lt;li&gt;而锁机制就会引起锁的强占, 所以要确保线程不会因为死锁问题导致无法继续执行&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;协程更轻量, 不属于操作系统级别, 而是属于更高一层对线程的包装, 不涉及系统调用, 因此等待到执行状态也不需要上下文切换, 或者说很代价很小, 因此也不用使用线程池这种东西了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;4-java-线程间通信方式---共享内存&#34;&gt;4. Java 线程间通信方式 - 共享内存&lt;/h2&gt;
&lt;p&gt;线程之间想要进行通信, 可以通过消息传递和共享内存两种方法来完成, 那 Java 采用的是共享内存的并发模型, 而 Golang 使用的就是前者 CSP, 利用 Channel 传递消息, 正如他的 Slogan: Don&amp;rsquo;t communicate by sharing memory, share memory by communicating.&lt;/p&gt;
&lt;p&gt;各有优缺点吧, 前者不需要锁机制了, 所有消息数据串行发送, 后者则需要锁来控制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CSP 避免了共享内存带来的竞争条件, 天然线程安全, 缺点是 Channel 通信需要额外的同步和数据拷贝, 在某些低延迟场景下可能不如共享内存高效&lt;/li&gt;
&lt;li&gt;CSP 适合 适合高并发、事件驱动的场景, 如 Web 服务器、微服务, 用 goroutine 处理 HTTP 请求，通过 Channel 传递任务结果&lt;/li&gt;
&lt;li&gt;共享内存模型数据不一致的风险较高, 需要使用锁来实现线程安全问题, 比较复杂, 容易出 bug&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;共享内存模型如何保证线程安全:&lt;/strong&gt; Java 的并发主要依赖线程和共享内存, 线程通过访问共享对象（如变量、集合等）来进行通信, 为了避免竞争条件和数据不一致问题, Java 提供了同步机制 ,如 synchronized 关键字、锁（Lock）、以及并发工具类（java.util.concurrent 包，例如 ConcurrentHashMap、ExecutorService 等）&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-并行-并发&#34;&gt;1. 并行 并发&lt;/h2&gt;
&lt;p&gt;并行：多核 CPU 上的多任务处理，多个任务在同一时间真正地同时执行&lt;/p&gt;
&lt;p&gt;并发：单核 CPU 上的多任务处理，多个任务在同一时间段内交替执行，通过时间片轮转实现交替执行&lt;/p&gt;
&lt;h2 id=&#34;2-进程和线程&#34;&gt;2. 进程和线程&lt;/h2&gt;
&lt;p&gt;线程是进程的一个执行单位, 进程就是启用的一个程序, 比如本地启动 MySQL 服务, MySQL 服务创建和管理多个线程来分别处理客户端连接、查询解析、后端IO操作、缓存管理等，借此提升性能和响应能力&lt;/p&gt;
&lt;h2 id=&#34;3-线程安全的理解&#34;&gt;3. 线程安全的理解&lt;/h2&gt;
&lt;p&gt;线程安全主要涉及到多个线程同时尝试访问同一个共享数据, 能否正确处理共享数据的问题, 就是线程安全的关键:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先通过的就是锁机制, 互斥锁, 保证同一时刻只有一个线程修改共享数据&lt;/li&gt;
&lt;li&gt;而锁机制就会引起锁的强占, 所以要确保线程不会因为死锁问题导致无法继续执行&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;协程更轻量, 不属于操作系统级别, 而是属于更高一层对线程的包装, 不涉及系统调用, 因此等待到执行状态也不需要上下文切换, 或者说很代价很小, 因此也不用使用线程池这种东西了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;4-java-线程间通信方式---共享内存&#34;&gt;4. Java 线程间通信方式 - 共享内存&lt;/h2&gt;
&lt;p&gt;线程之间想要进行通信, 可以通过消息传递和共享内存两种方法来完成, 那 Java 采用的是共享内存的并发模型, 而 Golang 使用的就是前者 CSP, 利用 Channel 传递消息, 正如他的 Slogan: Don&amp;rsquo;t communicate by sharing memory, share memory by communicating.&lt;/p&gt;
&lt;p&gt;各有优缺点吧, 前者不需要锁机制了, 所有消息数据串行发送, 后者则需要锁来控制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CSP 避免了共享内存带来的竞争条件, 天然线程安全, 缺点是 Channel 通信需要额外的同步和数据拷贝, 在某些低延迟场景下可能不如共享内存高效&lt;/li&gt;
&lt;li&gt;CSP 适合 适合高并发、事件驱动的场景, 如 Web 服务器、微服务, 用 goroutine 处理 HTTP 请求，通过 Channel 传递任务结果&lt;/li&gt;
&lt;li&gt;共享内存模型数据不一致的风险较高, 需要使用锁来实现线程安全问题, 比较复杂, 容易出 bug&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;共享内存模型如何保证线程安全:&lt;/strong&gt; Java 的并发主要依赖线程和共享内存, 线程通过访问共享对象（如变量、集合等）来进行通信, 为了避免竞争条件和数据不一致问题, Java 提供了同步机制 ,如 synchronized 关键字、锁（Lock）、以及并发工具类（java.util.concurrent 包，例如 ConcurrentHashMap、ExecutorService 等）&lt;/p&gt;
&lt;p&gt;线程间同步实现方式: 各种锁, 互斥锁, 读写锁, 信号量, 注意互斥锁和读写锁不同&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;5-线程创建方式&#34;&gt;5. 线程创建方式&lt;/h2&gt;
&lt;p&gt;Java 中创建线程主要有三种方式，分别为继承 Thread 类、实现 Runnable 接口、实现 Callable 接口&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ThreadTask&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; Thread {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;看完二哥的 Java 进阶之路，上岸了!&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ThreadTask task &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ThreadTask();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        task.&lt;span style=&#34;color:#a6e22e&#34;&gt;start&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;RunnableTask&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;implements&lt;/span&gt; Runnable {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;看完二哥的 Java 进阶之路，上岸了!&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        RunnableTask task &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; RunnableTask();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Thread thread &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Thread(task);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        thread.&lt;span style=&#34;color:#a6e22e&#34;&gt;start&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;调用 start()方法时会执行 run()方法，那怎么不直接调用 run()方法？&lt;/p&gt;
&lt;p&gt;当调用&lt;code&gt;start()&lt;/code&gt;方法时, 会&lt;strong&gt;启动一个新的线程&lt;/strong&gt;, 并让这个新线程调用&lt;code&gt;run()&lt;/code&gt;方法, 如果直接调用&lt;code&gt;run()&lt;/code&gt;方法, 那么&lt;code&gt;run()&lt;/code&gt;方法就在当前线程中运行, 没有新的线程被创建, 也就没有实现多线程的效果&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;6-java-线程安全如何实现&#34;&gt;6. Java 线程安全如何实现&lt;/h2&gt;
&lt;p&gt;使用共享对象, 多个线程可以访问和修改同一个对象, 从而实现信息的传递, 但是我们需要有锁的机制来保证线程安全, 在多线程编程中, 线程之间共享变量时可能会出现问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可见性问题：一个线程改了变量，其他线程看不到最新值&lt;/li&gt;
&lt;li&gt;原子性问题：多个线程同时改变量，导致结果出错&lt;/li&gt;
&lt;li&gt;原子性问题还有一个体现, 就是指令重新排序, 创建一个对象并赋值给一个变量, 其实包含三个步骤, 若第一步和第二步交换了顺序, 若是多线程访问这个对象, 则可能出现问题, 单线程没问题:
&lt;ul&gt;
&lt;li&gt;分配内存&lt;/li&gt;
&lt;li&gt;在分配的内存上初始化对象(调用构造方法)&lt;/li&gt;
&lt;li&gt;讲变量指向这个内内存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面说的两个问题: 指令重新排序, 可见性问题, 都可以由 &lt;code&gt;volatile&lt;/code&gt; 解决, 至于数据竞争, 则只能由锁 &lt;code&gt;lock&lt;/code&gt;,  &lt;code&gt;synchronized&lt;/code&gt; 来避免了&lt;/p&gt;
&lt;h3 id=&#34;61-volatile&#34;&gt;6.1. &lt;code&gt;volatile&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;首先看第一个问题 可见性问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为 JMM 允许线程使用缓存作为自己的本地内存, 以提高性能, 缓存是寄存器, 比主内存还要快, 普通变量的读写可能发生以下情况&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;线程 A 读取变量 x 到自己的本地内存（缓存），后续操作可能直接访问缓存，而不是主内存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果线程 B 修改了主内存中的 x，线程 A 的缓存可能仍持有旧值，导致线程 A 看不到最新的修改&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这种现象称为缓存不一致，因为线程 A 和线程 B 对 x 的值有不同的视图&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt; 修饰的变量强制线程绕过本地内存，直接操作主内存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读操作：线程每次读取 volatile 变量时，直接从主内存获取最新值，忽略本地缓存&lt;/li&gt;
&lt;li&gt;写操作：线程修改 volatile 变量时，立即将新值写入主内存，并使其他线程的本地缓存失效（通过缓存一致性协议，如 MESI）&lt;/li&gt;
&lt;li&gt;效果：所有线程对 volatile 变量的读写始终看到一致的最新值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;然后看第三个问题, 指令重新排序&lt;/strong&gt;, &lt;code&gt;volatile&lt;/code&gt; 关键字的一个重要作用是禁止指令重排序, 并确保变量的读写操作按照程序员预期的顺序执行, 同时保证内存可见性 (一个线程改了变量，其他线程立刻能看到, 上面已经说了) 禁止指令重排序的场景单例模式的双重检查锁:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Singleton&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton instance;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Singleton&lt;/span&gt;() {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton &lt;span style=&#34;color:#a6e22e&#34;&gt;getInstance&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (instance &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) { &lt;span style=&#34;color:#75715e&#34;&gt;// 第一次检查&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; (Singleton.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (instance &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) { &lt;span style=&#34;color:#75715e&#34;&gt;// 第二次检查&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    instance &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Singleton(); &lt;span style=&#34;color:#75715e&#34;&gt;// 创建实例&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; instance;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在上面的代码中 &lt;code&gt;instance = new Singleton()&lt;/code&gt; 看似是一行简单的赋值，但实际上 JVM 会将其分解为以下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分配内存空间&lt;/li&gt;
&lt;li&gt;初始化对象（调用构造方法）&lt;/li&gt;
&lt;li&gt;将 instance 引用指向这块内存&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于指令重排序的存在，JVM 和 CPU 可能会将步骤 3（赋值）提前到步骤 2（初始化）之前, 假设有两个线程 A 和 B：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程 A 执行 getInstance()，进入同步块，开始创建对象&lt;/li&gt;
&lt;li&gt;线程 A 执行到“分配内存并赋值”（步骤 1 和 3），但还未完成初始化（步骤 2）&lt;/li&gt;
&lt;li&gt;此时线程 B 调用 getInstance()，看到 instance 不为 null（因为已经被赋值），直接返回未初始化的对象&lt;/li&gt;
&lt;li&gt;结果：线程 B 拿到了一个未完全初始化的 Singleton 对象，可能导致空指针异常或逻辑错误&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Singleton&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;volatile&lt;/span&gt; Singleton instance; &lt;span style=&#34;color:#75715e&#34;&gt;// 添加 volatile&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Singleton&lt;/span&gt;() {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton &lt;span style=&#34;color:#a6e22e&#34;&gt;getInstance&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (instance &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; (Singleton.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (instance &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    instance &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Singleton();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; instance;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;volatile 如何解决问题？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;禁止指令重排序&lt;/strong&gt;：volatile 确保 instance = new Singleton(); 的三个步骤（分配内存、初始化、赋值）按照代码顺序执行，不会将赋值提前到初始化之前&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存可见性&lt;/strong&gt;：线程 A 修改 instance 后，线程 B 能立即看到最新的值&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;结果：线程 B 要么看到 instance 是 null（等待初始化），要么看到一个完全初始化的对象，不会出现“半初始化”状态,&lt;/p&gt;
&lt;p&gt;虽然 &lt;code&gt;volatile&lt;/code&gt; 可以禁止指令重排序，但它不能保证操作的原子性，比如 &lt;code&gt;++&lt;/code&gt; 操作仍然不是线程安全的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;volatile&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; counter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;threadFunc&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    counter&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 这个操作不是原子的&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;如果 Singleton 只在单线程环境中使用，则&lt;strong&gt;不需要使用 volatile&lt;/strong&gt;，因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单线程环境中不存在线程间的竞争，不会有可见性或重排序导致的问题&lt;/li&gt;
&lt;li&gt;JVM 的内存操作顺序对单线程程序是透明的，程序的行为总是符合代码的逻辑顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;62-synchronized&#34;&gt;6.2. &lt;code&gt;synchronized&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;保证&lt;strong&gt;互斥性&lt;/strong&gt;：同一时间只有一个线程能执行锁住的代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保证&lt;strong&gt;可见性&lt;/strong&gt;：进入锁时加载最新值，退出锁时刷新修改&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保证&lt;strong&gt;原子性&lt;/strong&gt;：锁内的操作不会被打断&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CounterExample&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;increment&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        count&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 线程安全&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getCount&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; count; &lt;span style=&#34;color:#75715e&#34;&gt;// 线程安全&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;两种用法&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;同步方法&lt;/strong&gt;：锁住整个方法（例子如上）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;同步块&lt;/strong&gt;：锁住部分代码，灵活性更高&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;BlockExample&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; Object lock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Object();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;increment&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; (lock) { &lt;span style=&#34;color:#75715e&#34;&gt;// 只锁关键部分&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            count&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;前面说到 进入 &lt;code&gt;synchronized&lt;/code&gt; 块时, 线程会从主内存加载变量的最新值, 退出时，会将修改后的值刷新回主内存, 为什么有时需要一起用？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为 synchronized 只保证锁内代码的可见性，而锁外的代码仍然可能依赖线程本地缓存的旧值&lt;/li&gt;
&lt;li&gt;volatile 可以确保即使在无锁的情况下，读线程也能立即看到变量的最新值&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TaskQueue&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; taskCount &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; &lt;span style=&#34;color:#75715e&#34;&gt;// 任务计数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; hasNewTask &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 是否有新任务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; Object lock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Object();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 生产者：添加任务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;produceTask&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; (lock) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            taskCount&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 增加任务数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            hasNewTask &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 标记有新任务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 消费者：检查是否有新任务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hasNewTask&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; hasNewTask; &lt;span style=&#34;color:#75715e&#34;&gt;// 无锁读取，可能看不到最新值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 消费者：获取任务数并处理&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;consumeTask&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; (lock) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (hasNewTask) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                hasNewTask &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 重置标志&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; taskCount; &lt;span style=&#34;color:#75715e&#34;&gt;// 返回任务数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; 0;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;7-reentrantlock-vs-readwritelock&#34;&gt;7. ReentrantLock vs ReadWriteLock&lt;/h2&gt;
&lt;h3 id=&#34;71-reentrantlock&#34;&gt;7.1. ReentrantLock&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt; Java &lt;code&gt;java.util.concurrent.locks&lt;/code&gt; 包中的显式锁，提供比 &lt;code&gt;synchronized&lt;/code&gt; 更灵活的功能,&lt;/p&gt;
&lt;p&gt;在锁竞争激烈时，可以通过 &lt;code&gt;tryLock(timeout)&lt;/code&gt; 避免线程无限等待:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ReentrantLock lock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ReentrantLock();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;tryMethod&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; InterruptedException {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (lock.&lt;span style=&#34;color:#a6e22e&#34;&gt;tryLock&lt;/span&gt;(1, TimeUnit.&lt;span style=&#34;color:#a6e22e&#34;&gt;SECONDS&lt;/span&gt;)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 获取锁成功&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#66d9ef&#34;&gt;finally&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            lock.&lt;span style=&#34;color:#a6e22e&#34;&gt;unlock&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 超时未获取锁&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当需要按照线程请求顺序分配锁（避免线程饥饿）时，可以配置公平锁&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ReentrantLock lock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ReentrantLock(&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 公平锁&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;实际示例对比:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Counter&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;increment&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        count&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Counter&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; ReentrantLock lock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ReentrantLock();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;increment&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        lock.&lt;span style=&#34;color:#a6e22e&#34;&gt;lock&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            count&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#66d9ef&#34;&gt;finally&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            lock.&lt;span style=&#34;color:#a6e22e&#34;&gt;unlock&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;72-readwritelock&#34;&gt;7.2. ReadWriteLock&lt;/h3&gt;
&lt;p&gt;在 Java 中，ReadWriteLock（通常通过其实现类 ReentrantReadWriteLock 使用）是一种&lt;strong&gt;专门为读多写少场景&lt;/strong&gt;设计的锁机制。与 ReentrantLock 相比，它提供了更细粒度的并发控制，允许多个线程同时读取，但写操作是独占的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ReentrantReadWriteLock rwLock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ReentrantReadWriteLock();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Map&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String, String&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; cache &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; HashMap&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; String &lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(String key) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    rwLock.&lt;span style=&#34;color:#a6e22e&#34;&gt;readLock&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;lock&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; cache.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(key);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#66d9ef&#34;&gt;finally&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        rwLock.&lt;span style=&#34;color:#a6e22e&#34;&gt;readLock&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;unlock&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;put&lt;/span&gt;(String key, String value) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    rwLock.&lt;span style=&#34;color:#a6e22e&#34;&gt;writeLock&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;lock&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cache.&lt;span style=&#34;color:#a6e22e&#34;&gt;put&lt;/span&gt;(key, value);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#66d9ef&#34;&gt;finally&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        rwLock.&lt;span style=&#34;color:#a6e22e&#34;&gt;writeLock&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;unlock&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
    </item>
    
    <item>
      <title>属性不固定如何设计 MySQL MongoDB -- 软件开发一面</title>
      <link>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/005-%E5%B1%9E%E6%80%A7%E4%B8%8D%E5%9B%BA%E5%AE%9A%E8%A1%A8%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Mon, 10 Mar 2025 09:50:19 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/005-%E5%B1%9E%E6%80%A7%E4%B8%8D%E5%9B%BA%E5%AE%9A%E8%A1%A8%E8%AE%BE%E8%AE%A1/</guid>
      <description>&lt;h2 id=&#34;1-mysql&#34;&gt;1. MySQL&lt;/h2&gt;
&lt;p&gt;首先来看看 MySQL 的实现, 当时没有想到这个实现方式, 只说了会用 MongoDB 来做存储, 问为什么也没能说出个所以然, 于是研究一下, 简单讨论一下, 假设我们需要设计一个系统来存储“商品信息”。商品的基本属性包括“名称”和“价格”，但不同类型的商品可能会有额外的属性（比如衣服有“尺码”和“颜色”，电子产品有“电压”和“功率”），而且这些属性可能会随着业务需求频繁增加或修改。&lt;/p&gt;
&lt;h3 id=&#34;11-eav-模型-entity-attribute-value&#34;&gt;1.1. EAV 模型 Entity-Attribute-Value&lt;/h3&gt;
&lt;p&gt;products 表：存储商品基本信息&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;id | name       | price
---|------------|-------
1  | T-shirt    | 20.00
2  | Laptop     | 999.99
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;product_attributes 表：存储动态属性&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;product_id | attribute_name | attribute_value
-----------|----------------|-----------------
1          | size          | M
1          | color         | Blue
2          | voltage       | 220V
2          | power         | 65W
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;获取 T-shirt 的所有属性：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; attribute_name, attribute_value 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; product_attributes 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; product_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-mysql&#34;&gt;1. MySQL&lt;/h2&gt;
&lt;p&gt;首先来看看 MySQL 的实现, 当时没有想到这个实现方式, 只说了会用 MongoDB 来做存储, 问为什么也没能说出个所以然, 于是研究一下, 简单讨论一下, 假设我们需要设计一个系统来存储“商品信息”。商品的基本属性包括“名称”和“价格”，但不同类型的商品可能会有额外的属性（比如衣服有“尺码”和“颜色”，电子产品有“电压”和“功率”），而且这些属性可能会随着业务需求频繁增加或修改。&lt;/p&gt;
&lt;h3 id=&#34;11-eav-模型-entity-attribute-value&#34;&gt;1.1. EAV 模型 Entity-Attribute-Value&lt;/h3&gt;
&lt;p&gt;products 表：存储商品基本信息&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;id | name       | price
---|------------|-------
1  | T-shirt    | 20.00
2  | Laptop     | 999.99
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;product_attributes 表：存储动态属性&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;product_id | attribute_name | attribute_value
-----------|----------------|-----------------
1          | size          | M
1          | color         | Blue
2          | voltage       | 220V
2          | power         | 65W
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;获取 T-shirt 的所有属性：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; attribute_name, attribute_value 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; product_attributes 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; product_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;需要通过多表连接或多次查询来获取完整信息，当数据量很大时，EAV 表的查询效率较低&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;attribute_value&lt;/code&gt; 通常是 &lt;code&gt;TEXT&lt;/code&gt; 或 &lt;code&gt;VARCHAR&lt;/code&gt;, 而不是更具体的数据类型, 原因是不同属性的数据类型可能不同:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;| user_id | attr_name  | attr_value  |
|---------|-----------|------------|
| 1       | age       | 25         |  (应为 INT)
| 1       | phone     | &amp;#34;1234567890&amp;#34; |  (应为 STRING)
| 2       | birthdate | &amp;#34;1995-10-20&amp;#34; |  (应为 DATE)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;attr_value&lt;/code&gt; 只能选择 一个 数据类型&lt;/p&gt;
&lt;h3 id=&#34;12-预留扩展列&#34;&gt;1.2. 预留扩展列&lt;/h3&gt;
&lt;p&gt;在表中预留一些通用列（如 extra1, extra2），用于存储不确定的属性&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;id &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; name       &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; price  &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; extra1 &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; extra2 &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; extra3
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;---|------------|--------|--------|--------|-------
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;shirt    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;.&lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; M      &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; Blue   &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; Laptop     &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;999&lt;/span&gt;.&lt;span style=&#34;color:#ae81ff&#34;&gt;99&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;220&lt;/span&gt;V   &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;65&lt;/span&gt;W    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;扩展性差&lt;/strong&gt;：预留列数量有限，如果属性超过预留列数，需要修改表结构&lt;/p&gt;
&lt;h3 id=&#34;13-为什么-mysql-不支持属性经常变化直接修改-schema-不就行了吗&#34;&gt;1.3. 为什么 MySQL 不支持属性经常变化？直接修改 &lt;code&gt;schema&lt;/code&gt; 不就行了吗？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果每次新属性都 &lt;code&gt;ALTER TABLE&lt;/code&gt;，很快表结构会变得难以维护，每次新增字段都要修改数据库代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MySQL 在 InnoDB 引擎下，某些 &lt;code&gt;ALTER TABLE&lt;/code&gt; 操作（如 &lt;code&gt;ADD COLUMN&lt;/code&gt;）可能会导致表锁，阻止其他写操作，特别是对 大表 影响更明显&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果表里有 百万级数据，&lt;code&gt;ALTER TABLE&lt;/code&gt; 可能需要 几秒甚至几分钟，在生产环境中这会阻塞业务操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-mongodb-文档型数据库&#34;&gt;2. MongoDB 文档型数据库&lt;/h2&gt;
&lt;p&gt;每个商品存储为一个文档, 属性以键值对的形式直接嵌入文档中, 文档结构无固定 schema，可以随时添加或删除字段&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;_id&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;T-shirt&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;price&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;20.00&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;size&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;M&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;color&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Blue&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;_id&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Laptop&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;price&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;999.99&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;voltage&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;220V&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;power&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;65W&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储空间开销：重复的字段名会增加存储成本 比如每个文档都存储 size 的键名&lt;/li&gt;
&lt;li&gt;事务支持较弱，如果需要 ACID 事务，MongoDB 不如 MySQL&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-分析优缺点&#34;&gt;3. 分析优缺点&lt;/h2&gt;
&lt;h3 id=&#34;31-mysql-分析&#34;&gt;3.1. MySQL 分析&lt;/h3&gt;
&lt;p&gt;首先对方给定的场景是大模型开发训练, 存储信息, 如果在这个场景下,&lt;/p&gt;
&lt;p&gt;EAV 显然不可以采用了, 因为其缺点就是查询效率低, 大模型训练, 应该会经常查询, 数据量也不低, 所以 EAV 不可以采用, 当然如果数据量不大, 也可以采用&lt;/p&gt;
&lt;p&gt;直接采用每次增加列也不太好, 因为每次增加列, 就要修改表的 schema, 修改表的 shcema 倒也没什么问题, 毕竟我们不是电商平台, 宕机一会维护也没什么问题, 可是表结构的频繁变化也意味着业务逻辑代码跟着变, 这就很麻烦了, 所以不能推荐,&lt;/p&gt;
&lt;p&gt;那采用预留扩展列呢, 预留列数量有限, 如果属性超过预留列数, 需要修改表结构, 另外我们也不知道预留的列的数据类型, 另外表的 shcema 一旦确定, 修改就需要修改对应的业务代码, 比如刚开始的列名 extra1, extra2, 写了就不能改了, 想改, 就得连着业务代码一起改, 还是麻烦,&lt;/p&gt;
&lt;p&gt;所以如果数据量不大, 且数据类型都相同, 可以选 EAV, 如果修改不频繁, 直接增加列也行,&lt;/p&gt;
&lt;h3 id=&#34;32-mongodb-的文档等于-mysql-中的行吗&#34;&gt;3.2. MongoDB 的文档等于 MySQL 中的行吗?&lt;/h3&gt;
&lt;p&gt;在很多常见场景下, “文档”与“行”的概念可能看起来很像——一个文档对应数据库里的一行, 但是在 MongoDB 中, 文档可以远比传统数据库的一条“行”更大、更复杂, 例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你可能把用户信息、历史订单、偏好、嵌套数组等全都存在同一个文档里&lt;/li&gt;
&lt;li&gt;在 MySQL 中，通常会拆成多张表，分别管理用户基本信息、订单信息、偏好设置等等&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;33--mongodb-的文档锁为何在冲突场景下开销更大&#34;&gt;3.3.  MongoDB 的“文档锁”为何在冲突场景下开销更大？&lt;/h3&gt;
&lt;p&gt;如果多个并发操作同时想要修改同一个文档，就会发生锁冲突——MongoDB 必须保证多字段更新的原子性和一致性，只能让一个事务/请求在同一时刻对文档进行写操作。所以它要申请&lt;strong&gt;文档锁&lt;/strong&gt;，其他请求只能等待该锁释放。假如这个文档非常大，或者更新的字段非常多，整个更新流程持续时间就会更长，导致等待的其他请求排队更久。在高并发时，这种排队/等待就会累积，拖慢响应。&lt;/p&gt;
&lt;p&gt;MongoDB 的文档锁其实对应的就是 MySQL 的行锁 x锁, 只是 InnoDB 的行通常更“轻量” 就是某张表里的一条记录, MVCC（多版本并发控制）在很多场景下可以让读和写“并行”工作：写事务锁住行在做更新时，读事务可以去读取旧版本，不被阻塞, 这就使得 InnoDB 对单行更新的“锁持有时间”通常较短, 也更容易并发执行其他事务, 换句话说, 在竞争同一个行时, MySQL 能更有效地减少彼此等待&lt;/p&gt;
&lt;h3 id=&#34;34--事务日志与回滚机制为什么-mongodb-在多文档事务下会更重&#34;&gt;3.4.  事务日志与回滚机制：为什么 MongoDB 在多文档事务下会更“重”？&lt;/h3&gt;
&lt;p&gt;当 MongoDB 开启多文档事务时, 需要在内部维护更多的事务上下文、事务标识、和分布式复制信息, 具体来讲：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;事务边界的记录&lt;/strong&gt;：开始事务时，需要标记事务 ID、会话 ID 等信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;执行过程中&lt;/strong&gt;：每次写操作，除了写入数据，还要在 oplog 中添加相应的操作（以便其他副本集节点重放），并且加上事务相关的标记&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提交/回滚时&lt;/strong&gt;：需要把事务提交的边界或回滚动作写到 oplog，其他节点才能正确得知某个事务是提交成功了还是被回滚了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;35-mongodb-事务不如-mysql&#34;&gt;3.5. MongoDB 事务不如 MySQL?&lt;/h3&gt;
&lt;p&gt;首先 MongoDB 事务不如  MySQL, MySQL 支持 ACID 事务, 事务可以跨多张表、多个行, 事务操作完成后, 可以 &lt;code&gt;COMMIT&lt;/code&gt; 提交, 也可以 &lt;code&gt;ROLLBACK&lt;/code&gt; 回滚, 当然 MongoDB 也支持这些, 但 MongoDB 的事务性能开销较大, 相比 MySQL 事务要慢,&lt;/p&gt;
&lt;p&gt;但是我们训练大模型, 又不是金融, 支付, 多文档事务好像不是那么经常发生(涉及多表操作), 当然如果多文档事务经常发生, 那可能就要选择 MySQL 了, 这里假设多文档事务不经常发生,&lt;/p&gt;
&lt;p&gt;所以虽然 MySQL 事务优于 MongoDB, 但是对于我们不是那么重要,&lt;/p&gt;
&lt;h3 id=&#34;36-mongodb-和-mysql-写入性能对比&#34;&gt;3.6. MongoDB 和 MySQL 写入性能对比&lt;/h3&gt;
&lt;p&gt;业务场景：如日志系统、埋点数据收集、IoT（物联网）设备数据上报、大量实时写入操作等&lt;/p&gt;
&lt;p&gt;需求特征：数据量增长速度快、数据结构可能较为灵活、对写入延迟较敏感但对强一致性要求相对一般&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;文档型存储，易于水平扩展：MongoDB 天生支持集群（Sharding），对高并发写入时能够通过分片策略进行分布式水平扩展，扩容相对容易，整体吞吐量可以有效提升&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模式灵活，数据模型简化：MongoDB 不需要进行严格的表结构变更操作，写入时对新字段的兼容成本较低；在开发层面减少了重复的 DDL 操作，通常能更快地进行数据落地&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;批量插入：MongoDB 提供了批量插入 API，在高并发批量写场景下也有很好的表现&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务完整性：在需要强事务、一致性写入保证时，MySQL 通常有更完善的方案。事务隔离级别控制在写入并发和一致性之间做取舍&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MySQL：适合关系复杂、需要强一致性事务、结构化并发读写的元数据场景&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;简单/灵活数据写入，大规模水平扩展，MongoDB 往往更方便；如海量日志、传感器数据写入等，MongoDB 倾向能“跑”得更快、更灵活。对强事务、高度结构化要求高的场景，或单机性能调优等，MySQL 依旧具备非常成熟的写入能力&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;37-mongodb-和-mysql-常见场景和选择建议&#34;&gt;3.7. MongoDB 和 MySQL 常见场景和选择建议&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;海量日志/传感器/埋点数据收集&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;典型特征：超大规模写入、数据结构灵活、查询方式主要以“根据 ID、时间区间”读取为主&lt;/li&gt;
&lt;li&gt;推荐：MongoDB 更方便进行水平扩展，文档模式灵活，更适合存储不固定或变动的字段。MySQL 也可用，但需要分库分表、NoSQL 化设计，运维成本相对大一些&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;内容管理系统（CMS）、电商商品信息、用户个人资料&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;典型特征：字段较灵活，如商品的规格属性不统一、用户资料字段可变；还需要快速的查询和更新&lt;/li&gt;
&lt;li&gt;推荐：MongoDB 文档化存储更省事，支持嵌套结构；若查询需要多维度或嵌套索引，一定要事先规划好索引&lt;/li&gt;
&lt;li&gt;补充：如果业务需要强事务（比如订单管理、支付流水等），则核心交易部分依旧通常采用 MySQL&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;传统的财务系统、银行、订单管理系统&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;典型特征：强事务、多表之间有严密的关系和复杂的 JOIN、对数据一致性要求极高&lt;/li&gt;
&lt;li&gt;推荐：MySQL 等关系型数据库。MongoDB 近年也在提升事务能力，但在这种极度依赖关系型操作的场景中，MySQL 的成熟度和生态更具优势&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>Redis 和 MySQL 如何实现数据一致性</title>
      <link>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/004-mysql-redis-%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/</link>
      <pubDate>Sat, 08 Mar 2025 09:50:19 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/004-mysql-redis-%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/</guid>
      <description>&lt;h2 id=&#34;1-mysql-的数据一致性&#34;&gt;1. MySQL 的数据一致性&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;事务（Transaction）&lt;/strong&gt;：MySQL 支持 ACID（原子性、一致性、隔离性、持久性）事务。通过 BEGIN、COMMIT 和 ROLLBACK，可以确保一组操作要么全部成功，要么全部回滚&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;锁机制&lt;/strong&gt;：MySQL 使用行锁、表锁或 MVCC（多版本并发控制）来处理并发访问，保证数据一致性。例如，InnoDB 引擎通过 MVCC 避免脏读和不可重复读&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主从复制&lt;/strong&gt;：在主从架构中，MySQL 通过 binlog（二进制日志）记录所有写操作，主库将 binlog 同步到从库。虽然可能存在主从延迟（异步复制），可以通过配置半同步复制或同步复制来提高一致性&lt;/p&gt;
&lt;h2 id=&#34;2-redis-的数据一致性&#34;&gt;2. Redis 的数据一致性&lt;/h2&gt;
&lt;h3 id=&#34;21-单线程模型---天然原子性&#34;&gt;2.1. 单线程模型 - 天然原子性&lt;/h3&gt;
&lt;p&gt;Redis 的核心特性之一是单线程执行命令, 所有命令按顺序执行, 不存在并发竞争问题, 天然保证了操作的原子性和一致性,&lt;/p&gt;
&lt;p&gt;假设有两个客户端同时对同一个键 counter 执行 INCR（自增）操作, 由于单线程模型，Redis 会顺序处理这两个请求，最终结果一定是 counter 增加 2，而不是出现并发覆盖导致的错误值&lt;/p&gt;
&lt;h3 id=&#34;22-超卖-秒杀系统---分布式锁--lua脚本&#34;&gt;2.2. 超卖 秒杀系统 - 分布式锁 / Lua脚本&lt;/h3&gt;
&lt;p&gt;分布式锁 如基于 Redis 的 &lt;code&gt;SETNX&lt;/code&gt; 或 ZooKeeper, &lt;code&gt;SETNX&lt;/code&gt; 是 Redis 中的一个&lt;strong&gt;字符串操作命令&lt;/strong&gt;, 全称是 &amp;ldquo;SET if Not eXists&amp;rdquo;, 常见流程:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;获取分布式锁（比如 &lt;code&gt;Redis SETNX lock_key 1&lt;/code&gt;）&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-mysql-的数据一致性&#34;&gt;1. MySQL 的数据一致性&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;事务（Transaction）&lt;/strong&gt;：MySQL 支持 ACID（原子性、一致性、隔离性、持久性）事务。通过 BEGIN、COMMIT 和 ROLLBACK，可以确保一组操作要么全部成功，要么全部回滚&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;锁机制&lt;/strong&gt;：MySQL 使用行锁、表锁或 MVCC（多版本并发控制）来处理并发访问，保证数据一致性。例如，InnoDB 引擎通过 MVCC 避免脏读和不可重复读&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主从复制&lt;/strong&gt;：在主从架构中，MySQL 通过 binlog（二进制日志）记录所有写操作，主库将 binlog 同步到从库。虽然可能存在主从延迟（异步复制），可以通过配置半同步复制或同步复制来提高一致性&lt;/p&gt;
&lt;h2 id=&#34;2-redis-的数据一致性&#34;&gt;2. Redis 的数据一致性&lt;/h2&gt;
&lt;h3 id=&#34;21-单线程模型---天然原子性&#34;&gt;2.1. 单线程模型 - 天然原子性&lt;/h3&gt;
&lt;p&gt;Redis 的核心特性之一是单线程执行命令, 所有命令按顺序执行, 不存在并发竞争问题, 天然保证了操作的原子性和一致性,&lt;/p&gt;
&lt;p&gt;假设有两个客户端同时对同一个键 counter 执行 INCR（自增）操作, 由于单线程模型，Redis 会顺序处理这两个请求，最终结果一定是 counter 增加 2，而不是出现并发覆盖导致的错误值&lt;/p&gt;
&lt;h3 id=&#34;22-超卖-秒杀系统---分布式锁--lua脚本&#34;&gt;2.2. 超卖 秒杀系统 - 分布式锁 / Lua脚本&lt;/h3&gt;
&lt;p&gt;分布式锁 如基于 Redis 的 &lt;code&gt;SETNX&lt;/code&gt; 或 ZooKeeper, &lt;code&gt;SETNX&lt;/code&gt; 是 Redis 中的一个&lt;strong&gt;字符串操作命令&lt;/strong&gt;, 全称是 &amp;ldquo;SET if Not eXists&amp;rdquo;, 常见流程:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;获取分布式锁（比如 &lt;code&gt;Redis SETNX lock_key 1&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查库存（&lt;code&gt;SELECT stock FROM inventory WHERE id = 1&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果库存足够，更新库存（&lt;code&gt;UPDATE inventory SET stock = stock - 1 WHERE id = 1 AND stock &amp;gt; 0&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;释放锁（&lt;code&gt;DEL lock_key&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设库存存储在 MySQL 中, 初始值为 10:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 线程 1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;SETNX lock_key &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;-- 获取锁成功
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; stock &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; inventory &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;-- 返回 10
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; inventory &lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; stock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; stock &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; stock &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;-- 更新为 9
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;DEL lock_key  &lt;span style=&#34;color:#75715e&#34;&gt;-- 释放锁
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 线程 2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;SETNX lock_key &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;-- 获取锁失败，等待
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 锁释放后重试上述步骤
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;分布式锁是传统解决方案, 而 Lua 脚本是一种更高效的替代方案, 需要注意的是 Lua 脚本只能在 Redis 服务器内部执行, 操作的数据必须是 Redis 中的键值对, 因此, 库存数据必须存储在 Redis 中, 更新也仅发生在 Redis 层面, 如果业务需要更新 MySQL 等持久化存储, 还需要额外的同步机制（比如将 Redis 更新结果异步写入 MySQL）, 如果宕机或数据未及时同步到 MySQL, 可能丢失更新&lt;/p&gt;
&lt;p&gt;而分布式锁的方案中, 我们只需要在业务逻辑获取分布式锁, 然后直接操作 MySQL 就行了&lt;/p&gt;
&lt;p&gt;Lua 脚本可以实现的原因是 Redis 是单线程模型, 而 Lua 脚本在 Redis 作为一个整体执行, 所以根本不存在数据竞争问题, 每个 Lua 脚本都是按顺序执行的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;23-lua-脚本---类似回滚&#34;&gt;2.3. Lua 脚本 - 类似回滚&lt;/h3&gt;
&lt;p&gt;Redis 的 Lua 脚本作为一个整体在 Redis 内部执行, 中间不会被打断, 是完全原子性的, Lua 脚本没有显式的“回滚”机制, 单若 Lua 脚本失败时整个脚本不生效, 因此无需回滚&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- Lua 脚本&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;local&lt;/span&gt; key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; KEYS[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;redis.call(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;SET&amp;#39;&lt;/span&gt;, key, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;value1&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;redis.call(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;SET&amp;#39;&lt;/span&gt;, key&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;x&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;value2&amp;#39;&lt;/span&gt;)  &lt;span style=&#34;color:#75715e&#34;&gt;-- 假设这里会失败&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;done&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果 &lt;code&gt;redis.call(&#39;SET&#39;, key..&#39;x&#39;, &#39;value2&#39;)&lt;/code&gt; 失败, 整个脚本中止, &lt;code&gt;key&lt;/code&gt; 的值不会被设置为 &lt;code&gt;value1&lt;/code&gt;, &lt;strong&gt;这不是回滚，而是脚本整体未提交&lt;/strong&gt;,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Redis 通过 MULTI 和 EXEC 提供有限的事务支持, 仅保证一组命令原子执行, 但&lt;strong&gt;不支持回滚&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;MULTI
DECRBY account:A 100
INCRBY account:B 100
EXEC
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;24-持久化-主从复制&#34;&gt;2.4. 持久化 主从复制&lt;/h3&gt;
&lt;p&gt;Redis 支持异步主从复制, 主节点将写操作异步同步到从节点, 虽然简单高效, 但可能导致&lt;strong&gt;短暂的数据不一致&lt;/strong&gt;,&lt;/p&gt;
&lt;p&gt;Redis 通过持久化（RDB 和 AOF）和主从复制来增强数据一致性和可靠性，虽然这更多是针对数据持久性而非实时一致性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;RDB&lt;/strong&gt;：通过生成数据库的快照来实现持久化, 它会将某个时间点 Redis 内存中的数据以二进制格式保存到一个 .rdb 文件中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果服务器在两次快照之间崩溃，可能会丢失部分数据（取决于快照频率）&lt;/li&gt;
&lt;li&gt;数据丢失可接受的场景&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;AOF&lt;/strong&gt;：记录每条写命令, 当 Redis 宕机并重启时, 读取 AOF 文件, 从头到尾&lt;strong&gt;重新执行这些命令&lt;/strong&gt;, 从而重建内存中的数据状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AOF 记录每条写命令，配合 appendfsync always 几乎不会丢失数据，即使是 everysec 也只可能丢失 1 秒的数据&lt;/li&gt;
&lt;li&gt;写命令需要追加到文件，同步策略（如 always）会增加磁盘 I/O，影响性能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;主从复制&lt;/strong&gt;：主节点将写操作同步到从节点，保证多副本一致性（最终一致性）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-mysql-和-redis-数据不同步&#34;&gt;3. MySQL 和 Redis 数据不同步&lt;/h2&gt;
&lt;p&gt;当 MySQL 数据更新（插入、修改、删除）时，Redis 中的缓存未及时更新或未更新，导致查询 Redis 时返回旧数据&lt;/p&gt;
&lt;h3 id=&#34;31-缓存失效策略&#34;&gt;3.1. &lt;strong&gt;缓存失效策略&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;方法&lt;/strong&gt;：在更新 MySQL 时，主动删除 Redis 中的对应缓存（而不是直接更新）&lt;/li&gt;
&lt;li&gt;步骤
&lt;ol&gt;
&lt;li&gt;更新 MySQL 数据&lt;/li&gt;
&lt;li&gt;删除 Redis 中对应的缓存键（DEL key）&lt;/li&gt;
&lt;li&gt;下次查询时，从 MySQL 重新加载数据到 Redis&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：避免了更新 Redis 的复杂逻辑，适合&lt;strong&gt;读多写少&lt;/strong&gt;的场景&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-使用事务或消息队列&#34;&gt;3.2. &lt;strong&gt;使用事务或消息队列&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;方法&lt;/strong&gt;：通过事务或消息队列（如 Kafka、RabbitMQ）确保 MySQL 和 Redis 的更新顺序一致&lt;/li&gt;
&lt;li&gt;步骤
&lt;ol&gt;
&lt;li&gt;将 MySQL 更新操作写入事务&lt;/li&gt;
&lt;li&gt;更新成功后，通过消息队列通知 Redis 更新&lt;/li&gt;
&lt;li&gt;消费消息并更新 Redis&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：解耦 MySQL 和 Redis 操作，支持分布式系统，容错性高&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;33-双写一致性cache-aside-模式&#34;&gt;3.3. 双写一致性（Cache Aside 模式）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;读数据：先查 Redis，若命中则返回；若未命中，从 MySQL 查询并写入 Redis&lt;/li&gt;
&lt;li&gt;写数据：先更新 MySQL, 再删除 Redis 缓存&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;为什么先更新 MySQL, 再删除或更新 Redis 缓存?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 MySQL 和 Redis 的组合中，MySQL 保存的是“权威数据”（source of truth），而 Redis 是缓存，用于提升性能。缓存的数据本质上是 MySQL 的副本。如果先更新 Redis 而 MySQL 更新失败（例如事务回滚、数据库宕机），会导致 Redis 中的数据是“脏数据”，与 MySQL 不一致。用户后续从缓存读取到错误数据，影响业务逻辑&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;双写一致性可能导致的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;T1&lt;/strong&gt;: 线程 A 更新 MySQL, 将 balance 改为 200&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;T2&lt;/strong&gt;: 线程 B 查询 Redis, 发现缓存中 balance 还是 100（因为线程 A 还没来得及删除缓存）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;T3&lt;/strong&gt;: 线程 B 返回旧值 100 给客户端&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;T4&lt;/strong&gt;: 线程 A 删除 Redis 缓存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 T2 到 T4 这段时间，Redis 返回的是旧值 100，而 MySQL 已经是新值 200，出现了短暂的数据不一致&lt;/li&gt;
&lt;li&gt;不一致通常只存在于“更新 MySQL”和“删除 Redis”之间的短暂时间（通常是&lt;strong&gt;毫秒级&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;根本原因: 更新 MySQL 和删除 Redis 是两个独立的操作，无法保证原子性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解决方案1：配合分布式锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;思路：通过锁机制（例如分布式锁）确保更新操作和读取操作不会同时发生，避免并发竞争&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在更新操作时，获取一个针对该数据的锁（例如 Redis 分布式锁）&lt;/li&gt;
&lt;li&gt;更新 MySQL 和删除 Redis 完成后释放锁&lt;/li&gt;
&lt;li&gt;读取操作也需要检查锁，若被占用则等待&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解决方案 2：先删除 Redis, 再更新 MySQL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以先删除 Redis, 再更新 MySQL, 但更新 MySQL 之后 需要再删一次缓存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;线程 A 删除 Redis 缓存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程 B 查询时未命中缓存, 从 MySQL 读取旧值并写回 Redis&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程 A 更新 MySQL 为新值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结果：Redis 又变成了旧值 (与 MySQL 不一致)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;延迟双删的目的正是为了在后续操作中纠正这种不一致, 确保系统最终达到一致性, 在 “先删除 Redis，再更新 MySQL” 的基础上, 更新 MySQL 后再延迟一段时间再次删除 Redis 缓存, 以清理可能被其他线程回写的脏数据:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;T1&lt;/strong&gt;: 线程 A 删除 Redis 缓存&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;T2&lt;/strong&gt;: 线程 B 查询, 未命中缓存, 从 MySQL 读取旧值 100 并写回 Redis&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;T3&lt;/strong&gt;: 线程 A 更新 MySQL 为 200&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;T4&lt;/strong&gt;: 线程 A 延迟 500ms 后再次删除 Redis 缓存&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;T5&lt;/strong&gt;: 下次查询从 MySQL 加载新值 200&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：仍然存在短暂不一致的风险（T2 到 T4 的窗口）&lt;/p&gt;
&lt;h2 id=&#34;4-综合实践-秒杀系统&#34;&gt;4. 综合实践 秒杀系统&lt;/h2&gt;
&lt;p&gt;延迟双删是为了保证缓存和数据库的一致性, 而 分布式锁机制 是为了 保证数据库的数据一致性, 在秒杀系统中, 商品库存是一个核心数据, 假设某个商品初始库存为100件, 用户通过秒杀活动购买, 每次购买会减少库存, 我们需要确保:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据库的数据一致性：库存不会超卖, 即高并发下不会出现多个线程同时扣减库存导致负值的情况&lt;/li&gt;
&lt;li&gt;缓存与数据库的一致性：Redis缓存中的库存数据与MySQL数据库中的库存数据最终一致&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;系统架构&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库（MySQL）：存储商品的实际库存&lt;/li&gt;
&lt;li&gt;缓存（Redis）：存储库存的缓存数据，用于快速查询&lt;/li&gt;
&lt;li&gt;分布式锁：通过Redis（如SETNX命令）实现分布式锁，确保高并发下对数据库的操作是串行化的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;操作流程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;线程 A&lt;/strong&gt; 尝试获取商品 1001 的分布式锁（例如 &lt;code&gt;lock_{1001}&lt;/code&gt;），抢锁成功&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程 A&lt;/strong&gt; 删除 Redis 缓存（Key = &lt;code&gt;product_stock_{1001}&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程 A&lt;/strong&gt; 从数据库查询当前库存（假设查到的是 100），进行库存检查 → 大于 0，则更新库存为 99（&lt;code&gt;UPDATE ... SET stock = 99 WHERE product_id = 1001&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程 A&lt;/strong&gt; 提交事务，数据库此时真正更新为库存 99&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程 A&lt;/strong&gt; 处理完数据库更新后，开启一个线程或通过定时任务，&lt;strong&gt;延迟&lt;/strong&gt;一段时间（比如 500ms~1000ms）后，再执行一次“删除 Redis 缓存（Key = &lt;code&gt;product_stock_{1001}&lt;/code&gt;）”的操作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程 A&lt;/strong&gt; 释放分布式锁&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此时，如果在 A 更新完数据库与“延迟删除缓存”之间，有&lt;strong&gt;线程 B&lt;/strong&gt;进来要操作库存，会发生什么呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程 B 试图抢锁，如果抢锁成功了（说明 A 已经释放了锁）：
&lt;ul&gt;
&lt;li&gt;线程 B 也会先删缓存，然后去读数据库，此时读到的已经是更新后的库存 &lt;code&gt;99&lt;/code&gt;，并做后续检查 + 更新操作&lt;/li&gt;
&lt;li&gt;同理，B 更新完也会再延迟双删，以保证缓存后续查询一定能用到最新数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于有分布式锁的存在，在“检查 + 更新”整个过程&lt;strong&gt;都是串行化&lt;/strong&gt;的，不会出现两条并发写操作抢数据库，导致超卖或脏写。同时，“延迟双删”依然起到确保“缓存最终一致”的作用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当我们使用了分布式锁, 延迟双删 还有必要吗?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为我的想法是, 线程A获取分布式锁, 然后检查 + 更新, 而更新由 (比如删除缓存 + 更新数据库)组成, 之后 A 释放锁, 为什么 线程B 会读取到缓存里的旧数据?&lt;/p&gt;
&lt;p&gt;我忽略了一个情况, 我们的分布式锁一般都是在业务逻辑上实现的, 比如某个方法, 比如用户购买, 我们为了防止 检查 + 更新 操作造成的数据不一致, 可是, 我忽略了有的方法可能只是为了读数据 (读缓存, 如不存在, 读取数据库, 然后写入缓存), 这样的情况分布式锁是避免不了的, 因为我们不可能所有操作读写都加锁, 这样会限制性能, 所以为了防止 在 线程 A 删除缓存 和 更新数据库 这个时间之间, 有其他线程因 仅读取数据造成 旧数据 又重新写会 缓存, 线程 A 在执行 删除缓存 + 庚勋数据库操作之后, 需要再进行一次删除, 即延迟双删,&lt;/p&gt;
&lt;p&gt;除此之外, 当 A 删除缓存后更新数据库 → &lt;strong&gt;与&lt;/strong&gt; → B 抢锁失败 / 等待 → &lt;strong&gt;与&lt;/strong&gt; → A 延迟再删缓存期间，假如出现一些读请求（比如线程 C），可能读到的还是旧值——如果在线程A第二次删除缓存后, 线程C才进行旧数据回写, 又出现缓存旧数据问题了, 不过这概率很小&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Spring Cloud 核心组件和配置</title>
      <link>https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/006-spring-cloud-building/</link>
      <pubDate>Fri, 07 Mar 2025 08:28:52 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/006-spring-cloud-building/</guid>
      <description>&lt;h2 id=&#34;1-两个配置文件&#34;&gt;1. 两个配置文件&lt;/h2&gt;
&lt;p&gt;在 Spring Cloud 项目中, 配置文件分为两类:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bootstrap.yml&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：用于指定 Spring Cloud Config Server 的地址, 帮助服务从远程拉取具体配置&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;存放位置&lt;/strong&gt;：每个服务的本地项目中（src/main/resources 目录下）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;application.yml&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：包含服务的具体配置信息, 如端口、Eureka 注册地址、数据库连接等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;存放位置&lt;/strong&gt;：集中存储在 GitHub 仓库中, 由 Config Server 管理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般 Config Server 只用配置 &lt;code&gt;application.yml&lt;/code&gt; 文件, 指定监听端口, 不用向 Eureka 注册, 因为它属于一个独立运行的服务, 负责为其他服务如用户认证, 订单服务, Eureka Server, Gateway 等提供配置文件,&lt;/p&gt;
&lt;p&gt;所以 Config Server 的配置文件  &lt;code&gt;application.yml&lt;/code&gt;  内容大致如下, 不需要 &lt;code&gt;bootstrap.yml&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;spring&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;application&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;skymates-config-server&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;cloud&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;config&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;server&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;git&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;uri&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;https://github.com/jiyi27/skymates.git&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;search-paths&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;configs&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;default-label&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;master&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;server&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;port&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;8888&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其他微服务&lt;strong&gt;只需要在本地配置 &lt;code&gt;bootstrap.yml&lt;/code&gt; 文件, 用于指定 Config Server 服务器位置 和 自己需要的配置文件名字&lt;/strong&gt;, 这也是为什么 Config Server 不需要向 Eureka Server 注册的原因, 因为其他微服务已经知道他的位置, 每个微服务直接从 Config Server 动态拉取自己的配置文件, Eureka Server 的  &lt;code&gt;bootstrap.yml&lt;/code&gt; 文件内容:&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-两个配置文件&#34;&gt;1. 两个配置文件&lt;/h2&gt;
&lt;p&gt;在 Spring Cloud 项目中, 配置文件分为两类:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bootstrap.yml&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：用于指定 Spring Cloud Config Server 的地址, 帮助服务从远程拉取具体配置&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;存放位置&lt;/strong&gt;：每个服务的本地项目中（src/main/resources 目录下）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;application.yml&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：包含服务的具体配置信息, 如端口、Eureka 注册地址、数据库连接等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;存放位置&lt;/strong&gt;：集中存储在 GitHub 仓库中, 由 Config Server 管理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般 Config Server 只用配置 &lt;code&gt;application.yml&lt;/code&gt; 文件, 指定监听端口, 不用向 Eureka 注册, 因为它属于一个独立运行的服务, 负责为其他服务如用户认证, 订单服务, Eureka Server, Gateway 等提供配置文件,&lt;/p&gt;
&lt;p&gt;所以 Config Server 的配置文件  &lt;code&gt;application.yml&lt;/code&gt;  内容大致如下, 不需要 &lt;code&gt;bootstrap.yml&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;spring&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;application&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;skymates-config-server&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;cloud&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;config&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;server&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;git&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;uri&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;https://github.com/jiyi27/skymates.git&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;search-paths&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;configs&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;default-label&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;master&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;server&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;port&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;8888&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其他微服务&lt;strong&gt;只需要在本地配置 &lt;code&gt;bootstrap.yml&lt;/code&gt; 文件, 用于指定 Config Server 服务器位置 和 自己需要的配置文件名字&lt;/strong&gt;, 这也是为什么 Config Server 不需要向 Eureka Server 注册的原因, 因为其他微服务已经知道他的位置, 每个微服务直接从 Config Server 动态拉取自己的配置文件, Eureka Server 的  &lt;code&gt;bootstrap.yml&lt;/code&gt; 文件内容:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;spring&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;cloud&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;config&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;uri&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;http://localhost:8888&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;# 当你配置了 name: eureka-server 时，Config Server 会尝试加载类似于 eureka-server.yml、&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;# eureka-server.properties 或其他符合命名规则的配置文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;eureka-server&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;profile&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;default&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;label&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;master&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Gateway  &lt;code&gt;bootstrap.yml&lt;/code&gt; 文件内容:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;spring&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;cloud&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;config&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;uri&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;http://localhost:8888&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;# 指定 name: gateway 时, 当在 Config Server 加载配置文件的时候&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;# Config Server 尝试加载类似于 gateway.yml、gateway.properties 或其他符合命名规则的配置文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;gateway&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;profile&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;default&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;label&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;master&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;User-Service  &lt;code&gt;bootstrap.yml&lt;/code&gt; 文件内容:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;spring&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;cloud&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;config&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;uri&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;http://localhost:8888&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;# 指定 name: content-service 时, 当在 Config Server 加载配置文件的时候&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;# Config Server 尝试加载类似于 content-service.yml、content-service.properties 或其他符合命名规则的配置文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;content-service&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;profile&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;default&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;label&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;master&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后我们需要单独为这些服务创建具体的配置文件,  指定如端口、Eureka 注册地址、数据库连接, 把这些文件放到 &lt;code&gt;github.com/jiyi27/skymates/configs&lt;/code&gt; 目录下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ls configs
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;eureka-server.yml   gateway.yml         user-service.yml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中 &lt;code&gt;eureka-server.yml&lt;/code&gt; 内容:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;spring&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;application&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;skymates-eureka-server&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;server&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;port&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;8761&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;eureka&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;client&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;register-with-eureka&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;fetch-registry&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 这个 URL 不是直接在浏览器访问的页面, 直接访问地址是 http://localhost:8761&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 它是一个 RESTful API 端点, 返回的数据通常是 JSON 或 XML 格式, 供其它微服务客户端解析服务信息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;service-url&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;defaultZone&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;http://localhost:8761/eureka/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;gateway.yml&lt;/code&gt; 内容:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;spring&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;application&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;skymates-gateway&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;cloud&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;gateway&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;routes&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        - &lt;span style=&#34;color:#f92672&#34;&gt;id&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;user-service-route&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;uri&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;lb://skymates-user-service&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;predicates&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            - &lt;span style=&#34;color:#ae81ff&#34;&gt;Path=/user/**&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;filters&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            - &lt;span style=&#34;color:#ae81ff&#34;&gt;StripPrefix=1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        - &lt;span style=&#34;color:#f92672&#34;&gt;id&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;content-service-route&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;uri&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;lb://skymates-content-service&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;predicates&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            - &lt;span style=&#34;color:#ae81ff&#34;&gt;Path=/content/**&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;filters&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            - &lt;span style=&#34;color:#ae81ff&#34;&gt;StripPrefix=1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;server&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;port&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;8083&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;eureka&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;client&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;service-url&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;defaultZone&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;http://localhost:8761/eureka/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;user-service.yml&lt;/code&gt; 内容:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;spring&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;application&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 定义当前应用程序的名, 会被发送到 Eureka 服务器, 作为服务注册时的服务名&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 这样 Eureka 就知道了有一个 skymates-user-service 服务, ip地址为 xxx, 服务端口为server.port&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# Gateway 就可以进行负载均衡路由转发: uri: lb://skymates-user-service&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;skymates-user-service&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;datasource&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;url&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;jdbc:mysql://localhost:3306/skymates?serverTimezone=UTC&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;username&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;root&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;password&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;778899&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;driver-class-name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;com.mysql.cj.jdbc.Driver&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;jpa&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;database-platform&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;org.hibernate.dialect.MySQL8Dialect&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;hibernate&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;ddl-auto&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;update&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;jwt&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;secret&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;MY_JWT_SECRET_KEY_EXAMPLE_123456&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;expiration&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;86400000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;server&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;port&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;8081&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;eureka&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;client&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;service-url&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;defaultZone&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;http://localhost:8761/eureka/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;注意一般有  &lt;code&gt;bootstrap.yml&lt;/code&gt; 文件的服务 需要添加依赖:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!-- 注册 Eureka --&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-cloud-starter-netflix-eureka-client&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!-- 从 Config Server 拉配置 --&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-cloud-starter-config&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!-- 解析 bootstrap.yml 配置文件 --&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-cloud-starter-bootstrap&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果依赖 spring-cloud-starter-netflix-eureka-client 没有加, 尽管你在 &lt;code&gt;application.yml&lt;/code&gt; 中写了 &lt;code&gt;eureka.client.service-url.defaultZone&lt;/code&gt;, 也不会真的注册&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-核心组件-启动步骤&#34;&gt;2. 核心组件 启动步骤&lt;/h2&gt;
&lt;h3 id=&#34;21-启动步骤&#34;&gt;2.1. 启动步骤&lt;/h3&gt;
&lt;p&gt;根据以上配置, 我们可以按照下面顺序启动各个微服务:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;启动 Config Server&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行 skymates-config-server 项目&lt;/li&gt;
&lt;li&gt;Config Server 从 GitHub 仓库的 configs 目录拉取所有配置文件，监听端口 8888&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;启动 Eureka Server&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行 skymates-eureka-server 项目&lt;/li&gt;
&lt;li&gt;从 Config Server 拉取 eureka-server.yml，启动服务发现功能，监听端口 8761&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;启动 Gateway&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行 skymates-gateway 项目&lt;/li&gt;
&lt;li&gt;从 Config Server 拉取 gateway.yml，注册到 Eureka Server，监听端口 8080&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;启动 User Service&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行 skymates-user-service 项目&lt;/li&gt;
&lt;li&gt;从 Config Server 拉取 user-service.yml，注册到 Eureka Server，监听端口 8081&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22-gateway-运行过程&#34;&gt;2.2. Gateway 运行过程&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Gateway 启动&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加载本地 &lt;code&gt;bootstrap.yml&lt;/code&gt;，读取 Config Server 地址 http://localhost:8888&lt;/li&gt;
&lt;li&gt;向 Config Server 请求 &lt;code&gt;gateway.yml&lt;/code&gt;（基于 &lt;code&gt;bootstrap.yml&lt;/code&gt; 中的 &lt;code&gt;name: gateway&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;Config Server 从 GitHub 仓库的 configs 目录返回 &lt;code&gt;gateway.yml&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Gateway 加载 &lt;code&gt;gateway.yml&lt;/code&gt;, 获取路由规则和 Eureka 注册地址 http://localhost:8761/eureka/&lt;/li&gt;
&lt;li&gt;Gateway 向 Eureka Server 注册自己, 服务名为 skymates-gateway (基于 &lt;code&gt;gateway.yml&lt;/code&gt; 中的 &lt;code&gt;name: skymates-gateway&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Gateway 开始监听端口 8080，准备接收请求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;请求转发&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端发送请求 http://localhost:8080/user/profile&lt;/li&gt;
&lt;li&gt;Gateway 根据  &lt;code&gt;gateway.yml&lt;/code&gt; 中定义的路由规则&lt;code&gt;Path=/user/**&lt;/code&gt; 匹配到 user-service-route&lt;/li&gt;
&lt;li&gt;使用 lb://skymates-user-service, 从 Eureka Server 获取 User Service 的实例地址（例如 http://localhost:8081）&lt;/li&gt;
&lt;li&gt;Gateway 将请求转发到 http://localhost:8081/profile, 完成路由&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;你可能会疑惑, Eureka Server 是怎么知道每个服务的名字的, 其实每个服务的配置文件中都有自己的名字, 当它们向 Eureka Server 注册的时候, Eureka Server 会根据他们提供的名字并解析出他们的 host ip 地址和对方提供的端口号, 比如 &lt;code&gt;user-service.yml&lt;/code&gt; 有相关定义:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;spring&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;application&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;skymates-user-service&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;
</content>
    </item>
    
    <item>
      <title>数据库死锁以及排查</title>
      <link>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/003-%E6%AD%BB%E9%94%81/</link>
      <pubDate>Thu, 06 Mar 2025 12:56:19 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/003-%E6%AD%BB%E9%94%81/</guid>
      <description>&lt;h2 id=&#34;1-导致死锁的原因&#34;&gt;1. 导致死锁的原因&lt;/h2&gt;
&lt;p&gt;在 MySQL（尤其是 InnoDB 存储引擎）里，常见的死锁往往与行锁（Row Lock）、间隙锁（Gap Lock）、Next-Key Lock 等锁机制的细节紧密相关。要理解为什么会出现死锁，需要先明白 InnoDB 是如何在事务中为数据上锁的，以及不同类型的锁是如何导致冲突的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;行锁（Row Lock）：对索引记录本身加的锁（Record Lock）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;间隙锁（Gap Lock）：对索引记录之间的间隙加的锁，用于防止幻读（Phantom Read）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Next-Key Lock：它实际上是“记录锁 + 间隙锁”的组合锁，会锁住“当前索引记录”以及紧邻的一段间隙&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MySQL InnoDB 的默认隔离级别是 &lt;strong&gt;REPEATABLE READ&lt;/strong&gt;。在该隔离级别下，对索引进行范围查询时，为了避免幻读，InnoDB 通常会通过 Next-Key Lock 把记录本身和相邻间隙一起锁定。正是因为这种锁定方式，当多事务并发执行时，如果它们的锁定范围出现交叠或顺序不一致，就比较容易引发死锁。&lt;/p&gt;
&lt;h3 id=&#34;11-更新操作顺序不一致-普通行x锁&#34;&gt;1.1. 更新操作顺序不一致 普通行x锁&lt;/h3&gt;
&lt;p&gt;这是最直观的死锁场景之一, 也是很多人最先想到的场景, 本质原因是两个事务以不同的顺序加锁, 从而彼此等待。先来举一个简单的例子（无 Gap Lock 干扰）, 只用普通行x锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景:&lt;/strong&gt; 事务 A 先更新 &lt;code&gt;id=1&lt;/code&gt; 的记录，再更新 &lt;code&gt;id=2&lt;/code&gt; 的记录；事务 B 先更新 &lt;code&gt;id=2&lt;/code&gt; 的记录，再更新 &lt;code&gt;id=1&lt;/code&gt; 的记录。&lt;/p&gt;
&lt;p&gt;如果两个事务并行执行，就可能出现这样的顺序：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;事务 A： &lt;code&gt;UPDATE t_user SET balance = balance - 10 WHERE id = 1;&lt;/code&gt; 成功锁住 &lt;code&gt;id=1&lt;/code&gt; 行&lt;/li&gt;
&lt;li&gt;事务 B： &lt;code&gt;UPDATE t_user SET balance = balance - 20 WHERE id = 2;&lt;/code&gt; 成功锁住 &lt;code&gt;id=2&lt;/code&gt; 行&lt;/li&gt;
&lt;li&gt;事务 A： &lt;code&gt;UPDATE t_user SET balance = balance + 10 WHERE id = 2;&lt;/code&gt; 要锁 &lt;code&gt;id=2&lt;/code&gt;，但是这把锁被事务 B 占用，需要等待&lt;/li&gt;
&lt;li&gt;事务 B： &lt;code&gt;UPDATE t_user SET balance = balance + 20 WHERE id = 1;&lt;/code&gt; 要锁 &lt;code&gt;id=1&lt;/code&gt;，但是这把锁被事务 A 占用，需要等待&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此时 A 等 B 释放锁，B 等 A 释放锁，形成死锁, 由于 InnoDB 检测到死锁，会自动回滚其中一个事务, 这种多发生在批量更新的情况, 可以标准化更新顺序，例如按 id 升序更新：&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-导致死锁的原因&#34;&gt;1. 导致死锁的原因&lt;/h2&gt;
&lt;p&gt;在 MySQL（尤其是 InnoDB 存储引擎）里，常见的死锁往往与行锁（Row Lock）、间隙锁（Gap Lock）、Next-Key Lock 等锁机制的细节紧密相关。要理解为什么会出现死锁，需要先明白 InnoDB 是如何在事务中为数据上锁的，以及不同类型的锁是如何导致冲突的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;行锁（Row Lock）：对索引记录本身加的锁（Record Lock）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;间隙锁（Gap Lock）：对索引记录之间的间隙加的锁，用于防止幻读（Phantom Read）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Next-Key Lock：它实际上是“记录锁 + 间隙锁”的组合锁，会锁住“当前索引记录”以及紧邻的一段间隙&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MySQL InnoDB 的默认隔离级别是 &lt;strong&gt;REPEATABLE READ&lt;/strong&gt;。在该隔离级别下，对索引进行范围查询时，为了避免幻读，InnoDB 通常会通过 Next-Key Lock 把记录本身和相邻间隙一起锁定。正是因为这种锁定方式，当多事务并发执行时，如果它们的锁定范围出现交叠或顺序不一致，就比较容易引发死锁。&lt;/p&gt;
&lt;h3 id=&#34;11-更新操作顺序不一致-普通行x锁&#34;&gt;1.1. 更新操作顺序不一致 普通行x锁&lt;/h3&gt;
&lt;p&gt;这是最直观的死锁场景之一, 也是很多人最先想到的场景, 本质原因是两个事务以不同的顺序加锁, 从而彼此等待。先来举一个简单的例子（无 Gap Lock 干扰）, 只用普通行x锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景:&lt;/strong&gt; 事务 A 先更新 &lt;code&gt;id=1&lt;/code&gt; 的记录，再更新 &lt;code&gt;id=2&lt;/code&gt; 的记录；事务 B 先更新 &lt;code&gt;id=2&lt;/code&gt; 的记录，再更新 &lt;code&gt;id=1&lt;/code&gt; 的记录。&lt;/p&gt;
&lt;p&gt;如果两个事务并行执行，就可能出现这样的顺序：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;事务 A： &lt;code&gt;UPDATE t_user SET balance = balance - 10 WHERE id = 1;&lt;/code&gt; 成功锁住 &lt;code&gt;id=1&lt;/code&gt; 行&lt;/li&gt;
&lt;li&gt;事务 B： &lt;code&gt;UPDATE t_user SET balance = balance - 20 WHERE id = 2;&lt;/code&gt; 成功锁住 &lt;code&gt;id=2&lt;/code&gt; 行&lt;/li&gt;
&lt;li&gt;事务 A： &lt;code&gt;UPDATE t_user SET balance = balance + 10 WHERE id = 2;&lt;/code&gt; 要锁 &lt;code&gt;id=2&lt;/code&gt;，但是这把锁被事务 B 占用，需要等待&lt;/li&gt;
&lt;li&gt;事务 B： &lt;code&gt;UPDATE t_user SET balance = balance + 20 WHERE id = 1;&lt;/code&gt; 要锁 &lt;code&gt;id=1&lt;/code&gt;，但是这把锁被事务 A 占用，需要等待&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此时 A 等 B 释放锁，B 等 A 释放锁，形成死锁, 由于 InnoDB 检测到死锁，会自动回滚其中一个事务, 这种多发生在批量更新的情况, 可以标准化更新顺序，例如按 id 升序更新：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 事务 A 和 B 都按 order_id 升序更新
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; orders &lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; status &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;xxx&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; order_id &lt;span style=&#34;color:#66d9ef&#34;&gt;IN&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; order_id;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;12-间隙锁导致的死锁&#34;&gt;1.2. 间隙锁导致的死锁&lt;/h3&gt;
&lt;p&gt;下面这个场景更具代表性, 也更体现出 MySQL Next-Key Lock 如何导致死锁, 很多开发者在进行范围查询或插入时, 会因为不理解 Gap Lock 的触发条件而踩坑:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; products (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id INT &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; AUTO_INCREMENT,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    name VARCHAR(&lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    price DECIMAL(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;-- 间隙锁只会加在索引上, 如果不是索引则退化为全表扫描, 索引也分为唯一和不唯一索引
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;UNIQUE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; (price)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;假设现在我们的表里有四条记录, price 分别是 1.00, 2.50, 3.00, 4.00,&lt;/p&gt;
&lt;p&gt;假设有两个事务, 它们都使用了范围查询, 由于 MySQL 默认隔离级别是 REPEATABLE READ, 所以&lt;strong&gt;范围查询 当前读&lt;/strong&gt;会触发 Next-Key Lock, 导致锁住记录本身以及相邻的“间隙”:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;T1 执行 &lt;code&gt;SELECT * FROM products WHERE price BETWEEN 2.00 AND 3.00 FOR UPDATE;&lt;/code&gt;
这是一个&lt;strong&gt;当前读&lt;/strong&gt; &lt;code&gt;FOR UPDATE&lt;/code&gt;, 虽然 price 唯一, 但这是范围查询, 所以会加  Next-Key Lock&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;锁定范围：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;price = 2.50：Record Lock&lt;/li&gt;
&lt;li&gt;price = 3.00：Record Lock&lt;/li&gt;
&lt;li&gt;间隙：(1.00, 2.50) 和 (2.50, 3.00) 和 (3.00, 4.00)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;T2 执行 &lt;code&gt;SELECT * FROM products WHERE price BETWEEN 3.00 AND 4.00 FOR UPDATE;&lt;/code&gt;
尝试锁住 &lt;code&gt;price=3.00&lt;/code&gt;、&lt;code&gt;price=4.00&lt;/code&gt; 以及与其相邻的间隙&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于 T1 已经锁住了 &lt;code&gt;price=3.00&lt;/code&gt;, T2 在尝试加锁 &lt;code&gt;price=3.00&lt;/code&gt; 时会被阻塞，等待 T1 释放&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果这时候 T1 在同一个事务里又做了其他操作（例如插入一条 &lt;code&gt;price=3.50&lt;/code&gt; 的记录）, 因为插入需要先获得插入意向锁即 &lt;code&gt;(3.00, 4.00)&lt;/code&gt; 这个间隙锁，而这个间隙锁已经被 T2 拿到了一部分，也会等待&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样两边都在等对方释放锁, 就会出现死锁,&lt;/p&gt;
&lt;h3 id=&#34;13-外键引起&#34;&gt;1.3. 外键引起&lt;/h3&gt;
&lt;p&gt;假设我们有两个表：Parent 和 Child, Child 表有一个外键引用 Parent 表的主键,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;事务 A&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;启动事务后，执行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;DELETE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; Parent &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;InnoDB 对 &lt;code&gt;Parent&lt;/code&gt; 表中 &lt;code&gt;id = 1&lt;/code&gt; 这条记录加上 &lt;strong&gt;排它锁(X 锁)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为有外键约束，删除时必须确认 &lt;code&gt;Child&lt;/code&gt; 表中是否还存在引用 &lt;code&gt;Parent(id=1)&lt;/code&gt; 的行；如果存在并且外键约束是不允许删除(例如 &lt;code&gt;ON DELETE RESTRICT&lt;/code&gt;)，那就会报错阻止删除；如果是 &lt;code&gt;ON DELETE CASCADE&lt;/code&gt;，则要继续删除 &lt;code&gt;Child&lt;/code&gt; 表里相应的记录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无论哪种外键策略，InnoDB 都会去扫描 &lt;code&gt;Child&lt;/code&gt; 表是否有 &lt;code&gt;parentId = 1&lt;/code&gt; 的记录，并尝试对这些子记录（或相应索引）加锁&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;事务 B&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;事务 A 还没结束时，事务 B 执行插入：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;INSERT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INTO&lt;/span&gt; Child (id, parentId, ...) &lt;span style=&#34;color:#66d9ef&#34;&gt;VALUES&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;101&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, ...);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;InnoDB 在往 &lt;code&gt;Child&lt;/code&gt; 表里插入新行之前，会先在 &lt;code&gt;Child&lt;/code&gt; 表对应的索引上加 &lt;strong&gt;插入意向锁(或间隙锁)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接着，为了保证外键引用的有效性，需要去 &lt;code&gt;Parent&lt;/code&gt; 表里确认 &lt;code&gt;id=1&lt;/code&gt; 存在，这就要去给 &lt;code&gt;Parent(id=1)&lt;/code&gt; 这条记录请求 &lt;strong&gt;锁(通常是 S 锁或者意向锁)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但是由于事务 A 已经对 &lt;code&gt;Parent(id=1)&lt;/code&gt; 持有了 X 锁，事务 B 在此时会被阻塞&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;进入相互等待&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要注意的点是, 在现实里要形成上述场景, 往往是因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务 A 删除 &lt;code&gt;Parent&lt;/code&gt; 的时候，&lt;code&gt;ON DELETE RESTRICT&lt;/code&gt; 或者 &lt;code&gt;ON DELETE NO ACTION&lt;/code&gt; 外键策略没有立即报错, 而是先尝试获取 &lt;code&gt;Child&lt;/code&gt; 那边的锁去检查/删除，这时刚好被另一个事务 B 插入或更新冲突；或者&lt;/li&gt;
&lt;li&gt;事务 A 是 “先删父，再删子” 但中间不小心被打断，事务 B 恰好要插入/更新同样引用的父记录从而引发冲突。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-如何排查死锁&#34;&gt;2. 如何排查死锁&lt;/h2&gt;
&lt;p&gt;在 MySQL（InnoDB 引擎）中，当 InnoDB 检测到死锁时，会主动回滚其中一个事务，并将死锁相关信息记录到 &lt;code&gt;SHOW ENGINE INNODB STATUS&lt;/code&gt; 命令输出中。&lt;/p&gt;
&lt;h3 id=&#34;21-查看异常日志&#34;&gt;2.1. 查看异常日志&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Spring Boot 日志&lt;/strong&gt;：在 Spring Boot 的运行日志中，通常会看到类似 &lt;code&gt;Deadlock found when trying to get lock; try restarting transaction&lt;/code&gt; 的异常信息，这意味着某条 SQL 在执行时被 MySQL 判定发生死锁，从而回滚&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MySQL 错误日志&lt;/strong&gt;：有时还可以在 MySQL 服务器的错误日志中找到死锁相关信息（如果有开启记录）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22-使用-show-engine-innodb-status-命令&#34;&gt;2.2. 使用 &lt;code&gt;SHOW ENGINE INNODB STATUS&lt;/code&gt; 命令&lt;/h3&gt;
&lt;p&gt;在 MySQL 客户端或者其他数据库管理工具中，执行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SHOW&lt;/span&gt; ENGINE INNODB STATUS &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;\&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;G&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;------------------------
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;LATEST DETECTED DEADLOCK
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;------------------------
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2025&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;03&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;06&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;14&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;37&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;07&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;x7f9bd9513700
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;***&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;TRANSACTION&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;TRANSACTION&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;598373&lt;/span&gt;, ACTIVE &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt; sec
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;lock&lt;/span&gt; struct(s), heap &lt;span style=&#34;color:#66d9ef&#34;&gt;size&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1136&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;row&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;lock&lt;/span&gt;(s), undo log entries &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;MySQL thread id &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;, OS thread handle &lt;span style=&#34;color:#ae81ff&#34;&gt;140309172537088&lt;/span&gt;, query id &lt;span style=&#34;color:#ae81ff&#34;&gt;225&lt;/span&gt; server &lt;span style=&#34;color:#ae81ff&#34;&gt;127&lt;/span&gt;.&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;.&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;.&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;user&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;update&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;INSERT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INTO&lt;/span&gt; log_record (account_id, &lt;span style=&#34;color:#66d9ef&#34;&gt;operation&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;VALUES&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;minus 100&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;***&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) WAITING &lt;span style=&#34;color:#66d9ef&#34;&gt;FOR&lt;/span&gt; THIS &lt;span style=&#34;color:#66d9ef&#34;&gt;LOCK&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TO&lt;/span&gt; BE &lt;span style=&#34;color:#66d9ef&#34;&gt;GRANTED&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;RECORD LOCKS &lt;span style=&#34;color:#66d9ef&#34;&gt;space&lt;/span&gt; id &lt;span style=&#34;color:#ae81ff&#34;&gt;63&lt;/span&gt; page &lt;span style=&#34;color:#66d9ef&#34;&gt;no&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; n bits &lt;span style=&#34;color:#ae81ff&#34;&gt;72&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;index&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;of&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;test&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;.&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;log_record&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;trx id &lt;span style=&#34;color:#ae81ff&#34;&gt;598373&lt;/span&gt; lock_mode X locks rec but &lt;span style=&#34;color:#66d9ef&#34;&gt;not&lt;/span&gt; gap waiting
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Record &lt;span style=&#34;color:#66d9ef&#34;&gt;lock&lt;/span&gt;, heap &lt;span style=&#34;color:#66d9ef&#34;&gt;no&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; PHYSICAL RECORD: n_fields &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;; compact format; info bits &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;***&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;TRANSACTION&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;TRANSACTION&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;598374&lt;/span&gt;, ACTIVE &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; sec
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;lock&lt;/span&gt; struct(s), heap &lt;span style=&#34;color:#66d9ef&#34;&gt;size&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1136&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;row&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;lock&lt;/span&gt;(s), undo log entries &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;MySQL thread id &lt;span style=&#34;color:#ae81ff&#34;&gt;101&lt;/span&gt;, OS thread handle &lt;span style=&#34;color:#ae81ff&#34;&gt;140309172538112&lt;/span&gt;, query id &lt;span style=&#34;color:#ae81ff&#34;&gt;226&lt;/span&gt; server &lt;span style=&#34;color:#ae81ff&#34;&gt;127&lt;/span&gt;.&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;.&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;.&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;user&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;update&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; account &lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; balance &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; balance &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;***&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) HOLDS THE &lt;span style=&#34;color:#66d9ef&#34;&gt;LOCK&lt;/span&gt;(S):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;RECORD LOCKS &lt;span style=&#34;color:#66d9ef&#34;&gt;space&lt;/span&gt; id &lt;span style=&#34;color:#ae81ff&#34;&gt;62&lt;/span&gt; page &lt;span style=&#34;color:#66d9ef&#34;&gt;no&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; n bits &lt;span style=&#34;color:#ae81ff&#34;&gt;80&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;index&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;of&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;test&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;.&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;account&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;trx id &lt;span style=&#34;color:#ae81ff&#34;&gt;598374&lt;/span&gt; lock_mode X
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Record &lt;span style=&#34;color:#66d9ef&#34;&gt;lock&lt;/span&gt;, heap &lt;span style=&#34;color:#66d9ef&#34;&gt;no&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; PHYSICAL RECORD: n_fields &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;; compact format; info bits &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;***&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) WAITING &lt;span style=&#34;color:#66d9ef&#34;&gt;FOR&lt;/span&gt; THIS &lt;span style=&#34;color:#66d9ef&#34;&gt;LOCK&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TO&lt;/span&gt; BE &lt;span style=&#34;color:#66d9ef&#34;&gt;GRANTED&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;RECORD LOCKS &lt;span style=&#34;color:#66d9ef&#34;&gt;space&lt;/span&gt; id &lt;span style=&#34;color:#ae81ff&#34;&gt;63&lt;/span&gt; page &lt;span style=&#34;color:#66d9ef&#34;&gt;no&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; n bits &lt;span style=&#34;color:#ae81ff&#34;&gt;72&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;index&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;of&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;test&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;.&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;log_record&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;trx id &lt;span style=&#34;color:#ae81ff&#34;&gt;598374&lt;/span&gt; lock_mode X locks rec but &lt;span style=&#34;color:#66d9ef&#34;&gt;not&lt;/span&gt; gap waiting
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;***&lt;/span&gt; WE ROLL BACK &lt;span style=&#34;color:#66d9ef&#34;&gt;TRANSACTION&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这条命令可以查看最近一次死锁的详细信息，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;具体冲突的表、行、&lt;strong&gt;SQL 语句&lt;/strong&gt;等&lt;/li&gt;
&lt;li&gt;形成死锁的事务&lt;strong&gt;持有哪些锁&lt;/strong&gt;、在&lt;strong&gt;等待哪些锁&lt;/strong&gt;（Record lock、Gap lock、Next-key lock）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据这些信息, 我们可以判断代码中的 SQL 执行顺序, 因为多个事务以不同顺序申请锁而导致的死锁, 可以在业务层确保所有事务对资源的加锁顺序一致（例如，按主键 ID 升序加锁）&lt;/p&gt;
&lt;p&gt;也可以使用使用 &lt;code&gt;EXPLAIN&lt;/code&gt; 分析 SQL 的执行计划, 检查 SQL 是否命中索引, 因为死锁也有可能是由于缺少合适的索引可能导致锁范围扩大(整张表)进而提高死锁概率,&lt;/p&gt;
&lt;p&gt;根据上面输出:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;*** (1) TRANSACTION:
TRANSACTION 598373, ACTIVE 7 sec
3 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 1
MySQL thread id 100, OS thread handle 140309172537088, query id 225 server 127.0.0.1 user update
INSERT INTO log_record (account_id, operation) VALUES (1, &amp;#39;minus 100&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;该事务(1) 持有 3 个锁结构, 其中包括 2 个行锁: &lt;code&gt;3 lock struct(s)&lt;/code&gt;, &lt;code&gt;2 row lock(s)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;正在对表 ⁠&lt;code&gt;log_record&lt;/code&gt; 进行 INSERT 操作&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 63 page no 4 n bits 72 index `PRIMARY` of table `test`.`log_record`
trx id 598373 lock_mode X locks rec but not gap waiting
Record lock, heap no 3 PHYSICAL RECORD: n_fields 5; compact format; info bits 0
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;当前事务正在等待获取一个锁，但锁还未被授予, 换句话说，有另一个事务持有锁，导致当前事务被阻塞&lt;/li&gt;
&lt;li&gt;&lt;code&gt;index PRIMARY of table test.log_record&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;index PRIMARY: 锁的目标是表的主键索引（primary key index）&lt;/li&gt;
&lt;li&gt;table test.log_record: 锁发生在数据库 test 中的表 log_record 上&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lock_mode X locks rec but not gap waiting&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lock_mode X&lt;/code&gt;: 表示这是一个排他锁&lt;/li&gt;
&lt;li&gt;&lt;code&gt;locks rec but not gap&lt;/code&gt;: 表示这是一个记录锁 record lock, 而不是 间隙锁 gap lock, 记录锁锁定特定的行, 间隙锁锁定行之间的范围（常用于防止幻读）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;waiting&lt;/code&gt;: 当前事务正在等待, 因为另一个事务已经持有了锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-避免死锁&#34;&gt;3. 避免死锁&lt;/h2&gt;
&lt;p&gt;统一加锁顺序&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如：如果业务逻辑需要在一笔交易中更新 &lt;code&gt;A 表&lt;/code&gt; 和 &lt;code&gt;B 表&lt;/code&gt;，就应&lt;strong&gt;统一&lt;/strong&gt;先更新 &lt;code&gt;A 表&lt;/code&gt; 再更新 &lt;code&gt;B 表&lt;/code&gt;（或者反之），避免在不同事务中出现“先 A 后 B”与“先 B 后 A”的交叉&lt;/li&gt;
&lt;li&gt;这种统一顺序减少了在数据库级别发生环形等待的可能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尽量缩短事务执行时间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在事务中只放真正需要保证原子性和一致性的 SQL 操作，把其他耗时操作（如外部 HTTP 调用、文件操作）放在事务外执行&lt;/li&gt;
&lt;li&gt;事务持有锁的时间越短，发生死锁的窗口就越小&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查看执行计划并监控慢查询&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;除了使用 &lt;code&gt;EXPLAIN&lt;/code&gt; 分析单条 SQL 的执行计划外，可配合开启 MySQL 慢查询日志，关注是否存在长时间占用锁的慢 SQL&lt;/li&gt;
&lt;li&gt;如果出现大量慢查询，也意味着事务执行时间变长，更容易导致死锁和高锁等待&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>MySQL 中的事务隔离界别和各种锁</title>
      <link>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/002-%E5%90%84%E7%A7%8D%E9%94%81/</link>
      <pubDate>Thu, 06 Mar 2025 09:39:22 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/002-%E5%90%84%E7%A7%8D%E9%94%81/</guid>
      <description>&lt;h2 id=&#34;1-行级锁记录锁&#34;&gt;1. 行级锁/记录锁&lt;/h2&gt;
&lt;h3 id=&#34;11-排它锁-x-锁---解决脏写&#34;&gt;1.1. 排它锁 X 锁 - 解决脏写&lt;/h3&gt;
&lt;p&gt;相同数据行上的 X 锁会阻塞其它加共享锁或排他锁的操作&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; my_table &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FOR&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;在任何事务隔离级别下, 删改操作都需要先获得 x 锁, 目的是避免脏写, 也就是说即使没有显示使用 &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt;, 进行删改操作时, 数据库都会自动尝试获得相应行的 x锁, 然后再进行写操作, 否则阻塞等待锁释放或当作死锁处理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;12-共享锁-s-锁---解决不可重复读&#34;&gt;1.2. 共享锁 S 锁 - 解决不可重复读&lt;/h3&gt;
&lt;p&gt;允许多个事务同时读取同一数据, 但不允许修改, 也就是说与 X 锁互斥&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; my_table &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;LOCK&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;IN&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;SHARE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;MODE&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;在 所有事务隔离级别 下, s锁都不会默认添加, 只有当显式使用 &lt;code&gt;SELECT ... LOCK IN SHARE MODE&lt;/code&gt; 时才会加 s锁&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;拓展&lt;/strong&gt; 在  InnoDB 可重复读 隔离级别下, 普通的 &lt;code&gt;SELECT&lt;/code&gt; 语句不会默认加 s共享锁, 它使用的是一致性读, 即通过MVCC 机制读取数据的快照, 而不是加锁读取, 来避免不可重复读问题的, 当然你也可以显示加上 s共享锁, 使用锁来避免不可重复读问题,&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-行级锁记录锁&#34;&gt;1. 行级锁/记录锁&lt;/h2&gt;
&lt;h3 id=&#34;11-排它锁-x-锁---解决脏写&#34;&gt;1.1. 排它锁 X 锁 - 解决脏写&lt;/h3&gt;
&lt;p&gt;相同数据行上的 X 锁会阻塞其它加共享锁或排他锁的操作&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; my_table &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FOR&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;在任何事务隔离级别下, 删改操作都需要先获得 x 锁, 目的是避免脏写, 也就是说即使没有显示使用 &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt;, 进行删改操作时, 数据库都会自动尝试获得相应行的 x锁, 然后再进行写操作, 否则阻塞等待锁释放或当作死锁处理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;12-共享锁-s-锁---解决不可重复读&#34;&gt;1.2. 共享锁 S 锁 - 解决不可重复读&lt;/h3&gt;
&lt;p&gt;允许多个事务同时读取同一数据, 但不允许修改, 也就是说与 X 锁互斥&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; my_table &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;LOCK&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;IN&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;SHARE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;MODE&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;在 所有事务隔离级别 下, s锁都不会默认添加, 只有当显式使用 &lt;code&gt;SELECT ... LOCK IN SHARE MODE&lt;/code&gt; 时才会加 s锁&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;拓展&lt;/strong&gt; 在  InnoDB 可重复读 隔离级别下, 普通的 &lt;code&gt;SELECT&lt;/code&gt; 语句不会默认加 s共享锁, 它使用的是一致性读, 即通过MVCC 机制读取数据的快照, 而不是加锁读取, 来避免不可重复读问题的, 当然你也可以显示加上 s共享锁, 使用锁来避免不可重复读问题,&lt;/p&gt;
&lt;p&gt;不可重复读: 发生在同一行数据被更新, 导致同一查询多次执行返回不同的具体数值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-next-key-lock---解决幻读&#34;&gt;2. Next-Key Lock - 解决幻读&lt;/h2&gt;
&lt;p&gt;注意 InnoDB &lt;code&gt;可重复读&lt;/code&gt; 或更高隔离级别才会有 Next-Key 锁, Next-Key 锁 = 记录锁 + 间隙锁,&lt;/p&gt;
&lt;p&gt;Next-Key 锁的目的是解决幻读问题, 幻读是指事务读取一个范围的数据时, 另一个事务插入或删除行, 导致再次读取范围时结果不一致, 所以我们在进行范围查询时, 通过 &lt;code&gt;SELECT ... FOR UPDATE &lt;/code&gt; 自动添加间隙锁, 这样就可以避免在间隙锁释放之前, 其他事务在查询范围内插入新纪录, 至于如何避免的, 我们下面会讲到,&lt;/p&gt;
&lt;h3 id=&#34;21-范围查询&#34;&gt;2.1. 范围查询&lt;/h3&gt;
&lt;p&gt;当执行涉及范围条件的查询且使用 &lt;code&gt;SELECT ... FOR UPDATE &lt;/code&gt;时, InnoDB 会使用 Next-Key Lock 锁定查询范围内的记录及其间隙&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;table_name&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FOR&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;注意上面的 SQL 语句格式 &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt;, 若是普通查询 &lt;code&gt;SELECT ...&lt;/code&gt;, 无论是否是范围查询 InnoDB 采用的都是 MVCC 多版本并发控制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;22-非唯一索引上的等值查询&#34;&gt;2.2. 非唯一索引上的等值查询&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;START&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TRANSACTION&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; employees &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; salary &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4000&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FOR&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果 &lt;code&gt;salary&lt;/code&gt; 列上存在索引, 并且是&lt;strong&gt;非唯一索引&lt;/strong&gt;, InnoDB 会在查找到的记录上加锁, 同时加锁该记录与相邻记录之间的间隙, 即使这不是范围查询, 这保证了其他事务不能在锁定区间内插入新记录，从而避免幻读问题。因为若 salary 不唯一, 我们查到的结果可能是多个, 此时必须使用 Next-Key Lock 来防止其他事务插入相同的 salary 导致幻读,&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;salary&lt;/code&gt; 唯一, 通常不会触发间隙锁, 只会加记录锁, 因为等值查询可以精确定位到一条记录, 不需要保护范围,&lt;/p&gt;
&lt;p&gt;如果  &lt;code&gt;salary&lt;/code&gt;  唯一, 但若是范围查询, 则需要防止其他事务在查询范围之间插入新记录, 因此仍会触发间隙锁,&lt;/p&gt;
&lt;p&gt;如果  &lt;code&gt;salary&lt;/code&gt;   列上不存在索引（无论是唯一索引还是非唯一索引），MySQL 的 InnoDB 在执行涉及   &lt;code&gt;salary&lt;/code&gt;    的查询或修改操作时，会&lt;strong&gt;因为无法利用索引而退化为全表扫描&lt;/strong&gt;, 在这种情况下，锁的机制和范围会发生显著变化，尤其是在默认隔离级别下，可能会导致更广泛的锁范围，甚至锁住整个表。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;记录锁 Record Lock：锁定具体的索引记录, x 锁或 s 锁&lt;/p&gt;
&lt;p&gt;间隙锁 Gap Lock：锁定索引记录之间的间隙, 防止其他事务在该范围内插入新记录, 间隙锁只在 &lt;strong&gt;可重复读&lt;/strong&gt; 和 &lt;strong&gt;串行化&lt;/strong&gt; 隔离级别下生效, 且只作用于 &lt;strong&gt;索引&lt;/strong&gt;（包括主键索引和二级索引）, 如果表没有索引（例如纯堆表）, InnoDB 会退化为锁全表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;3-插入意向锁-insert-intention-lock&#34;&gt;3. 插入意向锁 Insert Intention Lock&lt;/h2&gt;
&lt;p&gt;在 InnoDB 中，插入操作本身并不会直接获取行上的 X 锁, 因为插入的目标是新记录, 尚未存在于表中, 所以没有“行”可以加锁,&lt;/p&gt;
&lt;p&gt;当执行 INSERT 操作时，InnoDB 不直接在数据行上加锁，而是先在目标 gap 上加上插入意向锁, 插入意向锁是 MySQL InnoDB 存储引擎中一种特殊的间隙锁变种, 属于意向锁的一种, 插入意向锁本身并不直接锁定具体的行, 而是表明一个事务“打算”在某个间隙中插入数据, 它会等待现有的间隙锁（如果有）释放, 从而避免冲突,&lt;/p&gt;
&lt;p&gt;插入意向锁通常出现在使用 &lt;strong&gt;可重复读 隔离级别&lt;/strong&gt;时, 因为在这个隔离级别下, MySQL 会&lt;strong&gt;使用间隙锁来防止幻读问题&lt;/strong&gt;,&lt;/p&gt;
&lt;p&gt;我们来看一下例子, 现在有两个事务同时尝试插入记录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务 A 想插入 id = 2&lt;/li&gt;
&lt;li&gt;事务 B 想插入 id = 3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设事务 C &lt;strong&gt;先执行&lt;/strong&gt;了一条查询 &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt;, 锁定了间隙 (1, 4)：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;事务 A 请求插入 id = 2, 发现间隙 (1, 4) 被间隙锁占用, 插入意向锁被阻塞&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务 A 必须等待事务 C 提交或回滚, 释放间隙锁后才能继续插入&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这就完美避免了幻读问题, 看看上面的内容, 前后呼应&lt;/p&gt;
&lt;h2 id=&#34;4-记录锁-多版本并发控制&#34;&gt;4. 记录锁 多版本并发控制&lt;/h2&gt;
&lt;p&gt;普通 &lt;code&gt;SELECT&lt;/code&gt; 语句：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 MVCC 多版本并发控制&lt;/li&gt;
&lt;li&gt;读取的是事务开始时的快照数据, 不会加 &lt;code&gt;S&lt;/code&gt; 锁, 也不会阻塞其他事务的更新或插入&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;SELECT ... LOCK IN SHARE MODE&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;会显式对读取的行加 &lt;code&gt;S&lt;/code&gt; 锁，其他事务仍可读取，但不能 &lt;code&gt;UPDATE&lt;/code&gt; 或 &lt;code&gt;DELETE&lt;/code&gt; 这些被锁的行&lt;/li&gt;
&lt;li&gt;适用于确保数据在事务执行期间不会被修改，但仍允许读取&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;会显式对读取的行加 &lt;code&gt;X&lt;/code&gt; 锁，阻止其他事务对这些行进行 &lt;code&gt;UPDATE&lt;/code&gt; 或 &lt;code&gt;DELETE&lt;/code&gt;，但仍允许读取（非锁定读）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;记录锁 Record Lock：锁定具体的索引记录, x 锁或 s 锁&lt;/li&gt;
&lt;li&gt;间隙锁 Gap Loc：锁定索引记录之间的间隙，防止其他事务在该范围内插入新记录&lt;/li&gt;
&lt;li&gt;Next-Key 锁 = 记录锁 + 间隙锁&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注意上面讨论的是在 InnoDB &lt;code&gt;可重复读&lt;/code&gt; 隔离级别下的情况, InnoDB 的默认隔离级别也是 &lt;code&gt;可重复读&lt;/code&gt;, 更低级别比如 &lt;code&gt;已提交读&lt;/code&gt;, &lt;code&gt;已提交读&lt;/code&gt; 并不支持 MVCC 快照读 或者 Next-Key 锁, 它们都是 &lt;code&gt;可重复读&lt;/code&gt; 和 &lt;code&gt;序列化&lt;/code&gt; 隔离级别下的机制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;5--快照读-vs-当前读&#34;&gt;5.  快照读 vs 当前读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;快照读&lt;/strong&gt;: 普通的 SELECT, 不会加锁, 只依赖快照读 MVCC&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当前读&lt;/strong&gt;: &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt; 或 &lt;code&gt;SELECT ... LOCK IN SHARE MODE&lt;/code&gt;, 触发 x 锁 或 s 锁, 范围查询会触发 Next-Key Lock&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无范围查询时, &lt;strong&gt;当前读&lt;/strong&gt;触发记录锁( x 锁 或 s 锁)&lt;/li&gt;
&lt;li&gt;存在范围查询, 触发 Next-Key Lock, 也就是 记录锁 + 间隙锁&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注释上面讨论的是 InnoDB  “可重复读” 隔离级别下的情况&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    </item>
    
    <item>
      <title>缓存击穿 缓存穿透 缓存雪崩</title>
      <link>https://blog.jiyi27.com/posts/interview/%E7%BC%93%E5%AD%98%E5%92%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/002-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/</link>
      <pubDate>Wed, 05 Mar 2025 09:28:20 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E7%BC%93%E5%AD%98%E5%92%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/002-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/</guid>
      <description>&lt;h2 id=&#34;1-缓存击穿-cache-breakdown&#34;&gt;1. 缓存击穿 (Cache Breakdown)&lt;/h2&gt;
&lt;p&gt;缓存击穿是指在高并发场景下，某个热点数据（经常被访问的数据）的缓存突然失效（例如过期），导致大量请求同时直接访问数据库或其他后端服务。由于数据库的处理能力有限，这种突发的高并发请求可能会压垮数据库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;怎么避免？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;热点缓存延长有效期或不过期&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于访问频率很高的热点数据，可以设置缓存永不过期，或者延长缓存时间，避免频繁失效&lt;/li&gt;
&lt;li&gt;通过后台异步任务定期更新缓存数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;异步刷新缓存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在缓存即将过期时，提前异步刷新缓存，而不是等到失效再加载&lt;/li&gt;
&lt;li&gt;例如，设置一个后台任务，在缓存过期前 1 分钟主动刷新&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-缓存穿透-cache-penetration&#34;&gt;2. 缓存穿透 (Cache Penetration)&lt;/h2&gt;
&lt;p&gt;缓存穿透是指查询一个不存在的数据，由于缓存中没有该数据（即缓存未命中），请求会直接穿透到数据库。而数据库中也没有该数据，大量的这种请求会导致数据库压力过大。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户查询一个不存在的商品 ID（如 ID = -1）&lt;/li&gt;
&lt;li&gt;缓存中没有这个 ID，请求直接访问数据库，数据库返回空&lt;/li&gt;
&lt;li&gt;高并发下，大量无效查询直接打到数据库，导致性能问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;怎么避免？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;缓存空结果&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于查询不存在的数据，将“空结果”也缓存起来，并设置一个较短的过期时间（如 1 分钟）&lt;/li&gt;
&lt;li&gt;这样后续相同请求会直接命中缓存，不会穿透到数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;加强参数校验&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 API 层对 key 进行校验，如 ID 是否符合格式、是否在合理范围内，避免无效请求进入数据库。&lt;/li&gt;
&lt;/ul&gt;</description>
      <content>&lt;h2 id=&#34;1-缓存击穿-cache-breakdown&#34;&gt;1. 缓存击穿 (Cache Breakdown)&lt;/h2&gt;
&lt;p&gt;缓存击穿是指在高并发场景下，某个热点数据（经常被访问的数据）的缓存突然失效（例如过期），导致大量请求同时直接访问数据库或其他后端服务。由于数据库的处理能力有限，这种突发的高并发请求可能会压垮数据库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;怎么避免？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;热点缓存延长有效期或不过期&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于访问频率很高的热点数据，可以设置缓存永不过期，或者延长缓存时间，避免频繁失效&lt;/li&gt;
&lt;li&gt;通过后台异步任务定期更新缓存数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;异步刷新缓存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在缓存即将过期时，提前异步刷新缓存，而不是等到失效再加载&lt;/li&gt;
&lt;li&gt;例如，设置一个后台任务，在缓存过期前 1 分钟主动刷新&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-缓存穿透-cache-penetration&#34;&gt;2. 缓存穿透 (Cache Penetration)&lt;/h2&gt;
&lt;p&gt;缓存穿透是指查询一个不存在的数据，由于缓存中没有该数据（即缓存未命中），请求会直接穿透到数据库。而数据库中也没有该数据，大量的这种请求会导致数据库压力过大。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户查询一个不存在的商品 ID（如 ID = -1）&lt;/li&gt;
&lt;li&gt;缓存中没有这个 ID，请求直接访问数据库，数据库返回空&lt;/li&gt;
&lt;li&gt;高并发下，大量无效查询直接打到数据库，导致性能问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;怎么避免？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;缓存空结果&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于查询不存在的数据，将“空结果”也缓存起来，并设置一个较短的过期时间（如 1 分钟）&lt;/li&gt;
&lt;li&gt;这样后续相同请求会直接命中缓存，不会穿透到数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;加强参数校验&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 API 层对 key 进行校验，如 ID 是否符合格式、是否在合理范围内，避免无效请求进入数据库。&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>Spring MVC, Spring Boot, Spring Cloud 区别和联系</title>
      <link>https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/005-spring-mvc-boot-cloud/</link>
      <pubDate>Tue, 04 Mar 2025 08:32:22 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/005-spring-mvc-boot-cloud/</guid>
      <description>&lt;h2 id=&#34;1-spring-boot-依赖管理&#34;&gt;1. Spring Boot 依赖管理&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;parent&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-parent&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;3.1.2&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!-- 这里指定 Spring Boot 版本 --&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/parent&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-security&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当你在使用 Spring Boot 开发项目时, 通常会在 ⁠pom.xml 文件中指定一个父 POM, 上面我们的代码 &lt;code&gt;&amp;lt;parent&amp;gt;...&amp;lt;/parent&amp;gt;&lt;/code&gt; 就是干的这个事的,&lt;/p&gt;
&lt;p&gt;可以发现我们不用指定 &lt;code&gt;spring-boot-starter-security&lt;/code&gt; 的版本, 就是因为我们引入了 Spring Boot 的父 POM, 而它又继承了&lt;code&gt;spring-boot-dependencies&lt;/code&gt; 这个 BOM, 在这个 BOM 文件中, Spring Boot 定义了所有核心组件的版本号, 比如 Spring Security、Spring MVC、Spring Data,&lt;/p&gt;
&lt;p&gt;所以当我们添加一个 Spring Boot 的核心组件, 比如:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-security&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;并不需要写 &lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt;, 因为 &lt;code&gt;spring-boot-dependencies&lt;/code&gt; 已经预先定义了与 Spring Boot 3.1.2 兼容的 Spring Security 版本(比如 6.2.1), Maven 会自动从父 POM 中读取这些版本号,&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-spring-boot-依赖管理&#34;&gt;1. Spring Boot 依赖管理&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;parent&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-parent&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;3.1.2&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!-- 这里指定 Spring Boot 版本 --&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/parent&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-security&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当你在使用 Spring Boot 开发项目时, 通常会在 ⁠pom.xml 文件中指定一个父 POM, 上面我们的代码 &lt;code&gt;&amp;lt;parent&amp;gt;...&amp;lt;/parent&amp;gt;&lt;/code&gt; 就是干的这个事的,&lt;/p&gt;
&lt;p&gt;可以发现我们不用指定 &lt;code&gt;spring-boot-starter-security&lt;/code&gt; 的版本, 就是因为我们引入了 Spring Boot 的父 POM, 而它又继承了&lt;code&gt;spring-boot-dependencies&lt;/code&gt; 这个 BOM, 在这个 BOM 文件中, Spring Boot 定义了所有核心组件的版本号, 比如 Spring Security、Spring MVC、Spring Data,&lt;/p&gt;
&lt;p&gt;所以当我们添加一个 Spring Boot 的核心组件, 比如:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-security&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;并不需要写 &lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt;, 因为 &lt;code&gt;spring-boot-dependencies&lt;/code&gt; 已经预先定义了与 Spring Boot 3.1.2 兼容的 Spring Security 版本(比如 6.2.1), Maven 会自动从父 POM 中读取这些版本号,&lt;/p&gt;
&lt;p&gt;即使你不继承 ⁠spring-boot-starter-parent, 你仍然可以通过导入 ⁠spring-boot-dependencies BOM 来管理依赖版本:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependencyManagement&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-dependencies&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;3.0.0&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;type&amp;gt;&lt;/span&gt;pom&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/type&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;import&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependencyManagement&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这个例子中，我们通过 ⁠&lt;code&gt;dependencyManagement&lt;/code&gt; 导入了 ⁠spring-boot-dependencies，这使得我们可以在 ⁠dependencies 中添加 ⁠spring-boot-starter-web 时不需要指定版本号，因为版本已经在 BOM 中定义好了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;dependencyManagement&amp;gt;...&amp;lt;/dependencyManagement&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;parent&amp;gt;...&amp;lt;/parent&amp;gt;&lt;/code&gt; 分别用来导入 BOM 和 POM, 他们两个导入一个就行了, Spring Boot BOM 被 Spring Boot POM 继承, 所以导入后者的目的也是导入前者,&lt;/p&gt;
&lt;p&gt;&lt;code&gt;spring-boot-dependencies&lt;/code&gt; 是一个巨大的依赖清单, 里面列出了所有 Spring Boot 生态中&lt;strong&gt;常用依赖&lt;/strong&gt;的版本, 当 Maven 解析 &lt;code&gt;pom.xml&lt;/code&gt; 时, 它会优先使用父 POM 中定义的版本号, 这样就避免了加入新的组件时手动指定版本的麻烦, 也保证了所有组件的兼容性,&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般组件 artifactId 为 &lt;code&gt;spring-boot-starter-xxx&lt;/code&gt; 格式, 都是 Spring Boot 核心组件, 不用再刻意指定版本号了, 而其他的组件仍需要指定, 比如:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!-- MySQL 数据库驱动 --&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;mysql&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;mysql-connector-java&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;8.0.33&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!-- 确保这里是最新版本 --&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!-- Lombok 在 编译时 生成 getter/setter，但 运行时不需要 Lombok 依赖，所以 provided 是合适的 --&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.projectlombok&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;lombok&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.18.36&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;provided&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;2-spring-cloud-依赖管理&#34;&gt;2. Spring Cloud 依赖管理&lt;/h2&gt;
&lt;p&gt;Spring Cloud 建立在 Spring Boot 之上, 但特殊的地方是它也有自己的组件, 与 Spring Boot 类似, 需要引入 &lt;code&gt;spring-cloud-dependencies&lt;/code&gt; 进行版本管理, &lt;code&gt;spring-cloud-dependencies&lt;/code&gt; 是一个独立的 BOM 文件, 里面定义了 Spring Cloud 所有组件（比如 Eureka、Feign、Config Server 等）的版本号。&lt;/p&gt;
&lt;p&gt;当我们同时使用 Spring Boot 和 Spring Cloud 的时候, 大致的 &lt;code&gt;pom.xml&lt;/code&gt; 文件:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!-- 使用 Spring Boot 父 POM --&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;parent&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-parent&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;3.4.3&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;relativePath/&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!-- lookup parent from repository --&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/parent&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!-- 引入 Spring Cloud BOM 来统一管理 Spring Cloud 相关组件的版本 --&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependencyManagement&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-cloud-dependencies&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;2024.0.0&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;type&amp;gt;&lt;/span&gt;pom&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/type&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;import&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependencyManagement&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!-- Spring Boot Web 依赖 --&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!-- Spring Cloud Config，用于集中化配置管理 --&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-cloud-starter-config&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!-- Spring Cloud Netflix Eureka Client，用于服务注册与发现 --&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-cloud-starter-netflix-eureka-client&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!-- 根据需要还可以添加其他 Spring Cloud 或 Spring Boot 组件 --&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;当我们说使用 Spring Boot 和 Spring Cloud 的时候, 使用的并不是他们本身, 而是他们的核心组件&lt;/p&gt;
&lt;p&gt;Spring Boot 管理自己的核心组件（Spring Security、Spring Data、Spring Web 等
Spring Boot 不管理 Spring Cloud 相关组件（Eureka、Feign、Gateway、Sleuth 等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;3-总结&#34;&gt;3. 总结&lt;/h2&gt;
&lt;p&gt;上面我们讨论了 Spring Boot 和 Spring Cloud 在配置依赖方面的区别和联系, 显然 Spring Cloud 是一个单独的框架, 有自己的组件, 我们可以在 Spring Boot 中使用 Spring Cloud, 但是 Spring Boot 的 BOM 只是管理了它自己核心组件的版本, 并不会管理 Spring Cloud 核心组件, 因此我们在使用他们两个的时候, 同时在 &lt;code&gt;pom.xml&lt;/code&gt; 指定各自的 BOM 才是最佳实践, 方便他们各自管理各自组件的版本,&lt;/p&gt;
&lt;p&gt;所以 Spring Boot 本质就是构建于 Spring MVC 之上基于 Spring 生态的“快速开发框架”, 它帮我们集成了 Spring MVC 所有的基础配置, 包括 Servlet 路径, 视图, 以及 Servlet 容器 Tomcat, 除此之外还提前定义了 Spring 核心组件的依赖版本, 我们只要在 &lt;code&gt;pom.xml&lt;/code&gt; 引入了 &lt;code&gt;&amp;lt;parent&amp;gt;...&amp;lt;/parent&amp;gt;&lt;/code&gt;, 当我们使用一些依赖比如 Spring Security, Spring Data JPA 等, 直接加到 &lt;code&gt;pom.xml&lt;/code&gt; 中就行, 不用指定版本号或者担心以后更新引起版本冲突&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Redis 五种数据类型</title>
      <link>https://blog.jiyi27.com/posts/interview/%E7%BC%93%E5%AD%98%E5%92%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/001-redis-data-structure/</link>
      <pubDate>Fri, 21 Feb 2025 11:28:58 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E7%BC%93%E5%AD%98%E5%92%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/001-redis-data-structure/</guid>
      <description>&lt;h2 id=&#34;1-redis--仅仅是缓存吗&#34;&gt;1. Redis  仅仅是缓存吗&lt;/h2&gt;
&lt;p&gt;Redis 最广为人知的用途是&lt;strong&gt;缓存&lt;/strong&gt;, 它通过内存存储提供超高的读写性能, 常用于减轻数据库压力:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存热点数据&lt;/li&gt;
&lt;li&gt;会话存储&lt;/li&gt;
&lt;li&gt;页面缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但 Redis 的功能远不止缓存：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据结构存储：支持字符串、列表、集合、哈希等，类似一个内存数据库&lt;/li&gt;
&lt;li&gt;消息队列：通过 Pub/Sub 或 List 实现轻量级消息传递&lt;/li&gt;
&lt;li&gt;分布式锁：在分布式系统中用于同步&lt;/li&gt;
&lt;li&gt;高可用与分布式：通过主从复制、哨兵模式、集群模式支持分布式架构&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-string&#34;&gt;2. String&lt;/h2&gt;
&lt;h3 id=&#34;21-常见操作&#34;&gt;2.1. 常见操作&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SET user:001 &amp;#34;Alice&amp;#34;
SET user:001 &amp;#39;{&amp;#34;name&amp;#34;: &amp;#34;Alice&amp;#34;, &amp;#34;age&amp;#34;: 25}&amp;#39;
SET counter 10
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;user:001&lt;/code&gt; 和 &lt;code&gt;counter&lt;/code&gt; 是 Key, 后面的 字符串 &lt;code&gt;&amp;quot;Alice&amp;quot;&lt;/code&gt;, &lt;code&gt;{&amp;quot;name&amp;quot;: &amp;quot;Alice&amp;quot;, &amp;quot;age&amp;quot;: 25}&lt;/code&gt;, 还有数字 &lt;code&gt;10&lt;/code&gt; 是 Value, Redis 中的 String 有点像哈希表, 但不是&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;GET user:001 &lt;span style=&#34;color:#75715e&#34;&gt;# 获取 key user:001 值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;INCR counter &lt;span style=&#34;color:#75715e&#34;&gt;# 自增1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;DECR counter &lt;span style=&#34;color:#75715e&#34;&gt;# 自减1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;INCRBY counter &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# 自增5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;虽然 Redis 是用 C 语言写的, 但是 Redis 并没有使用 C 的字符串表示, 而是自己构建了一种 &lt;strong&gt;简单动态字符串&lt;/strong&gt;（Simple Dynamic String）相比于 C 的原生字符串, Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据, 并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）, 除此之外, Redis 的 SDS API 是安全的, 不会造成&lt;strong&gt;缓冲区溢出&lt;/strong&gt;:&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-redis--仅仅是缓存吗&#34;&gt;1. Redis  仅仅是缓存吗&lt;/h2&gt;
&lt;p&gt;Redis 最广为人知的用途是&lt;strong&gt;缓存&lt;/strong&gt;, 它通过内存存储提供超高的读写性能, 常用于减轻数据库压力:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存热点数据&lt;/li&gt;
&lt;li&gt;会话存储&lt;/li&gt;
&lt;li&gt;页面缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但 Redis 的功能远不止缓存：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据结构存储：支持字符串、列表、集合、哈希等，类似一个内存数据库&lt;/li&gt;
&lt;li&gt;消息队列：通过 Pub/Sub 或 List 实现轻量级消息传递&lt;/li&gt;
&lt;li&gt;分布式锁：在分布式系统中用于同步&lt;/li&gt;
&lt;li&gt;高可用与分布式：通过主从复制、哨兵模式、集群模式支持分布式架构&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-string&#34;&gt;2. String&lt;/h2&gt;
&lt;h3 id=&#34;21-常见操作&#34;&gt;2.1. 常见操作&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SET user:001 &amp;#34;Alice&amp;#34;
SET user:001 &amp;#39;{&amp;#34;name&amp;#34;: &amp;#34;Alice&amp;#34;, &amp;#34;age&amp;#34;: 25}&amp;#39;
SET counter 10
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;user:001&lt;/code&gt; 和 &lt;code&gt;counter&lt;/code&gt; 是 Key, 后面的 字符串 &lt;code&gt;&amp;quot;Alice&amp;quot;&lt;/code&gt;, &lt;code&gt;{&amp;quot;name&amp;quot;: &amp;quot;Alice&amp;quot;, &amp;quot;age&amp;quot;: 25}&lt;/code&gt;, 还有数字 &lt;code&gt;10&lt;/code&gt; 是 Value, Redis 中的 String 有点像哈希表, 但不是&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;GET user:001 &lt;span style=&#34;color:#75715e&#34;&gt;# 获取 key user:001 值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;INCR counter &lt;span style=&#34;color:#75715e&#34;&gt;# 自增1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;DECR counter &lt;span style=&#34;color:#75715e&#34;&gt;# 自减1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;INCRBY counter &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# 自增5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;虽然 Redis 是用 C 语言写的, 但是 Redis 并没有使用 C 的字符串表示, 而是自己构建了一种 &lt;strong&gt;简单动态字符串&lt;/strong&gt;（Simple Dynamic String）相比于 C 的原生字符串, Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据, 并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）, 除此之外, Redis 的 SDS API 是安全的, 不会造成&lt;strong&gt;缓冲区溢出&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Buffer Overflow&lt;/strong&gt; 是一种常见的程序错误, 通常发生在程序试图向一个固定大小的内存缓冲区写入超出其容量的数据时导致的数据覆盖相邻内存，导致程序行为异常或崩溃, 在 C 语言中，字符串操作尤其容易引发缓冲区溢出, 因为 C 的原生字符串（以空字符 &lt;code&gt;\0&lt;/code&gt; 结尾的字符数组）不自带长度信息, 操作时需要程序员手动确保不会越界&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;22-一些拓展&#34;&gt;2.2. 一些拓展&lt;/h3&gt;
&lt;p&gt;String 是一种二进制安全的数据类型, 可以用来存储任何类型的数据比如字符串、数字、序列化后的对象（如 JSON、Protobuf 等）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;严格来说, String 本身并不直接存储“类型”, 而是存储数据的字节表示, 在编程中, “类型”（data type）指的是数据的种类以及与之相关的操作规则, 每种“类型”都有自己的&lt;strong&gt;语义&lt;/strong&gt;（含义）和&lt;strong&gt;操作方式&lt;/strong&gt;, 这些是由编程语言或程序逻辑定义的, 当我们说 String 存储数据时, String 本身并不知道或关心数据的“类型”, 它只是一个&lt;strong&gt;字节序列&lt;/strong&gt;（byte sequence）的容器, 换句话说, String 存储的是数据的&lt;strong&gt;二进制表示&lt;/strong&gt;, 而不是数据的高级语义或类型信息:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;字节表示&lt;/strong&gt;：任何数据（无论是整数、浮点数、文本、图片还是对象）在计算机底层都是以二进制形式（0 和 1 的序列）存储的, 这些二进制数据可以看作一串字节（每个字节是 8 位）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;String 的角色&lt;/strong&gt;：在二进制安全的 String 实现中（例如 Redis 或 PHP 的字符串）, String 只是把这些字节原封不动地保存下来, 它不关心这些字节是表示一个整数、一个图片，还是一个序列化后的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举个例子:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整数 42 的二进制表示可能是 00101010（取决于编码方式，比如 32 位整数）&lt;/li&gt;
&lt;li&gt;文本 &amp;ldquo;hello&amp;rdquo; 的 UTF-8 编码可能是字节序列 01101000 01100101 01101100 01101100 01101111&lt;/li&gt;
&lt;li&gt;一个序列化后的 JSON 对象 &lt;code&gt;{&amp;quot;name&amp;quot;: &amp;quot;Alice&amp;quot;}&lt;/code&gt; 也是一串字节，可能看起来像 7b226e616d65223a2022416c696365227d（十六进制表示）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当你把这些数据存进 Redis String 时, String 只负责保存这些字节的顺序和内容,, 它不会记录“这是个整数”或“这是个 JSON 对象”这样的类型信息, Redis String 作为二进制安全的数据类型, 负责存储数据, 但数据的&lt;strong&gt;语义&lt;/strong&gt;（如整数、浮点数、对象）需要由程序逻辑解析, 例如, 一个序列化后的 JSON 对象存储在 String 中, 程序需要调用 JSON 解析器来还原对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;在某些编程语言或系统中（例如 Redis、PHP等），String 被称为&lt;strong&gt;二进制安全&lt;/strong&gt;（binary-safe）的数据类型，意思是它可以安全地存储和处理任意的二进制数据，而不会因为数据中包含特定的字符（如空字符 &lt;code&gt;\0&lt;/code&gt;）或其他控制字符而导致数据被截断或错误解析, 并非所有语言或系统的 String 都是二进制安全的, 例如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 C 中，字符串通常不是二进制安全的（因为以 &lt;code&gt;\0&lt;/code&gt; 结尾）&lt;/li&gt;
&lt;li&gt;在 Java 中, String 是基于 Unicode 的, 主要用于文本, 处理二进制数据更常用 &lt;code&gt;byte[]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;3-set&#34;&gt;3. Set&lt;/h2&gt;
&lt;p&gt;Set 只能存储字符串, 且字符串不能重复:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[&amp;#34;123&amp;#34;, &amp;#34;456&amp;#34;, &amp;#34;Jack&amp;#34;, &amp;#34;Alice&amp;#34;, ...]
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;注意 Redis String 是一个数据结构, 不是一个值的类型, Redis 中 Set 只能用来存储 String 类型的值, 这里的 String 指的只是单纯的字符串, 而不是前面的数据结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;4-list&#34;&gt;4. List&lt;/h2&gt;
&lt;p&gt;Redis 中的 List 其实就是链表数据结构的实现, 很多语言都内置了链表的实现, 但是 C 语言并没有实现链表, 因此 Redis 实现了自己的链表, Redis 的 List 的实现是一个 双向链表,&lt;/p&gt;
&lt;p&gt;&lt;code&gt;List&lt;/code&gt; 可以用来做消息队列, 只是功能过于简单且存在很多缺陷, 不建议这样做, 相对来说, Redis 5.0 新增加的一个数据结构 &lt;code&gt;Stream&lt;/code&gt; 更适合做消息队列一些, 只是功能依然非常简陋, 和专业的消息队列相比, 还是有很多欠缺的地方比如消息丢失和堆积问题不好解决&lt;/p&gt;
&lt;h2 id=&#34;5-hash&#34;&gt;5. Hash&lt;/h2&gt;
&lt;p&gt;大部分编程语言都提供了 哈希（&lt;code&gt;hash&lt;/code&gt;）类型, 它们的叫法可能是 哈希、字典, 在 &lt;code&gt;Redis&lt;/code&gt; 中, 哈希类型 是指键值本身又是一个 键值对结构:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;HMSET user:1001 name &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Alice&amp;#34;&lt;/span&gt; age &lt;span style=&#34;color:#ae81ff&#34;&gt;25&lt;/span&gt; city &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Beijing&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;这里 user:1001 是 Redis 的键（key）&lt;/li&gt;
&lt;li&gt;这个键对应的值是一个哈希，包含多个键值对：name: &amp;ldquo;Alice&amp;rdquo;，age: 25，city: &amp;ldquo;Beijing&amp;rdquo;&lt;/li&gt;
&lt;li&gt;在这个哈希里，name、age、city 是 field，&amp;ldquo;Alice&amp;rdquo;、25、Beijing 是对应的值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类似下面这种:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;key: user:1001
value: { name: &amp;#34;Alice&amp;#34;, age: 25, city: &amp;#34;Beijing&amp;#34; }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你可以用命令单独访问某个 field 的值，比如:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;HGET user:1001 name
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看出 Redis 中的 哈希表 和 普通键值对不同:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;key: username
value: &amp;#34;Alice&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Redis 是一个高效的键值数据库, 为了保证性能和一致性, 它要求所有存储的数据在底层都以字符串的形式保存, 因此:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Field&lt;/strong&gt;：哈希的字段（比如上面的 name、age、city）必须是字符串类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Value&lt;/strong&gt;：每个字段对应的值（比如 &amp;ldquo;Alice&amp;rdquo;、25、Beijing）也必须是字符串&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;HMSET user:1001 friends [&amp;#34;Bob&amp;#34;, &amp;#34;Charlie&amp;#34;]  # 错误！
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那如果我们想存用户的信息, 而用户又存在这样的数组字段, 应该怎么办呢?&lt;/p&gt;
&lt;p&gt;答案是把整个用户信息（比如 name、age、city、friends 等）&lt;strong&gt;序列化&lt;/strong&gt;为一个 JSON 字符串, 直接存到 Redis 的 String 类型的一个键里, 每次读写时, 客户端负责解析和序列化 JSON&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Alice&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;age&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;25&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;city&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Beijing&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;friends&amp;#34;&lt;/span&gt;: [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Bob&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Charlie&amp;#34;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;用 Redis 哈希存储：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 用 SET 命令存储 JSON 字符串&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SET user:&lt;span style=&#34;color:#ae81ff&#34;&gt;1001&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Alice&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;age&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;:25,&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;city&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Beijing&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;friends&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;:[&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Bob&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Charlie&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;]}&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 获取 JSON 字符串&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;GET user:&lt;span style=&#34;color:#ae81ff&#34;&gt;1001&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 返回: &amp;#34;{\&amp;#34;name\&amp;#34;:\&amp;#34;Alice\&amp;#34;,\&amp;#34;age\&amp;#34;:25,\&amp;#34;city\&amp;#34;:\&amp;#34;Beijing\&amp;#34;,\&amp;#34;friends\&amp;#34;:[\&amp;#34;Bob\&amp;#34;,\&amp;#34;Charlie\&amp;#34;]}&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; json
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;json_str &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; redis_client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user:1001&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;user_info &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; json&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;loads(json_str)  &lt;span style=&#34;color:#75715e&#34;&gt;# 转为字典&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# user_info = {&amp;#34;name&amp;#34;: &amp;#34;Alice&amp;#34;, &amp;#34;age&amp;#34;: 25, &amp;#34;city&amp;#34;: &amp;#34;Beijing&amp;#34;, &amp;#34;friends&amp;#34;: [&amp;#34;Bob&amp;#34;, &amp;#34;Charlie&amp;#34;]}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 要更新某个字段（比如加朋友或改 city），需要, 读取整个 JSON, 在客户端修改, 序列化后写回&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 添加新朋友&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;user_info[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;friends&amp;#34;&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Alice&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;redis_client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;set(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user:1001&amp;#34;&lt;/span&gt;, json&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;dumps(user_info))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 或者改城市&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;user_info[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;city&amp;#34;&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Shanghai&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;redis_client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;set(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user:1001&amp;#34;&lt;/span&gt;, json&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;dumps(user_info))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;虽然这种方式直接存整个 JSON 对象, 看着很容易理解, 但缺点也很明显&lt;strong&gt;更新效率低&lt;/strong&gt;：每次修改（即使只改 name 或加一个朋友）, 都要：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;读整个 JSON（GET）&lt;/li&gt;
&lt;li&gt;客户端解析&lt;/li&gt;
&lt;li&gt;修改后序列化&lt;/li&gt;
&lt;li&gt;写回整个 JSON（SET）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这对频繁更新的场景效率较低, 那有没有更好的办法?&lt;/p&gt;
&lt;p&gt;用 Redis 哈希存储基本信息（name、age、city 等）作为单独的字段, 把复杂结构（比如 friends 列表）序列化为 JSON 字符串存到一个字段, 这样结合了哈希的结构化和 JSON 的灵活性:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 存储用户信息
HMSET user:1001 name &amp;#34;Alice&amp;#34; age &amp;#34;25&amp;#34; city &amp;#34;Beijing&amp;#34; friends &amp;#34;[\&amp;#34;Bob\&amp;#34;, \&amp;#34;Charlie\&amp;#34;]&amp;#34;

# 获取所有字段
HGETALL user:1001
# 返回: {&amp;#34;name&amp;#34;: &amp;#34;Alice&amp;#34;, &amp;#34;age&amp;#34;: &amp;#34;25&amp;#34;, &amp;#34;city&amp;#34;: &amp;#34;Beijing&amp;#34;, &amp;#34;friends&amp;#34;: &amp;#34;[\&amp;#34;Bob\&amp;#34;, \&amp;#34;Charlie\&amp;#34;]&amp;#34;}
&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; json
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;user_info &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; redis_client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;hgetall(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user:1001&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;friends &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; json&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;loads(user_info[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;friends&amp;#34;&lt;/span&gt;])  &lt;span style=&#34;color:#75715e&#34;&gt;# 转为列表 [&amp;#34;Bob&amp;#34;, &amp;#34;Charlie&amp;#34;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 更新基本信息, 直接修改某个字段&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;HSET user:&lt;span style=&#34;color:#ae81ff&#34;&gt;1001&lt;/span&gt; city &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Shanghai&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 更新朋友列表&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 客户端先读取，修改，再写回&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;friends&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Alice&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;redis_client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;hset(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user:1001&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;friends&amp;#34;&lt;/span&gt;, json&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;dumps(friends))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;基本字段（name、city）可直接修改，效率高&lt;/li&gt;
&lt;li&gt;friends 列表用 JSON 存储，灵活支持列表或其他复杂结构&lt;/li&gt;
&lt;li&gt;所有信息在一个键（user:1001）下&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>MySQL 事务 数据库锁 悲观锁 乐观锁</title>
      <link>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/001-%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Mon, 17 Feb 2025 20:39:22 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/001-%E4%BA%8B%E5%8A%A1/</guid>
      <description>&lt;h2 id=&#34;1-脏读-脏写-幻读---事务隔离级别&#34;&gt;1. 脏读 脏写 幻读 - 事务隔离级别&lt;/h2&gt;
&lt;h3 id=&#34;11-脏读---事务隔离级别较低&#34;&gt;1.1. 脏读 - 事务隔离级别较低&lt;/h3&gt;
&lt;p&gt;脏读是指一个事务读取到了另一个事务尚未提交的数据。若后者发生回滚，则前者读取的数据实际上并不存在。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;事务 A 修改了一条记录，但尚未提交&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务 B 读取这条记录，看到 A 的修改&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果 A 后续回滚，那么 B 读到了不存在的数据，这就是脏读问题。&lt;/p&gt;
&lt;p&gt;根本原因在于事务隔离级别较低，&lt;strong&gt;允许一个事务读取另一个事务未提交的修改数据&lt;/strong&gt;，缺少对数据一致性的保证。&lt;/p&gt;
&lt;h3 id=&#34;12-脏写&#34;&gt;1.2. 脏写&lt;/h3&gt;
&lt;p&gt;脏写指的是：事务 B 在事务 A 尚未提交的更新基础上又进行了更新并提交。如果随后事务 A 回滚，但 B 已经基于 A 的“未提交更新”写入了数据库，就会导致数据库中出现了一份基于“从未真正生效的数据”所写进去的值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果 B 的更新逻辑要判断某个字段是否满足条件（例如库存是否 &amp;gt; 0 才扣减），而这个字段恰恰是由 A 更新的未提交数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;B 基于 A 未提交的数据做了扣减并提交，后来 A 回滚导致库存根本没增加（或者没变化），最终 B 却“凭空”把库存扣了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些例子都说明了：脏写本质上是写操作基于了一份并不存在（或不确定会不会存在）的中间状态，进而可能对数据一致性和业务逻辑造成破坏, 这就是为什么数据库禁止脏写的原因。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在多数主流数据库(例如 MySQL InnoDB)的默认配置下，这种情况通常不会发生，因为对同一行记录的并发写操作自动会被加 x锁序列化：只有前一个写操作提交或回滚后，后一个事务才能对这行数据进行新的写。因此，脏写往往只在极其宽松/非常低的隔离级别（或人为关闭了某些并发控制）下，才可能被“模拟”或“测试”出来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;13-不可重复读-和-幻读&#34;&gt;1.3. 不可重复读 和 幻读&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;不可重复读&lt;/strong&gt; 发生在同一行数据被更新，导致同一查询多次执行返回不同的具体数值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;幻读&lt;/strong&gt; 则发生在范围查询中，其他事务在该范围内插入或删除数据，导致结果集的记录数发生变化&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;14-四种隔离级别&#34;&gt;1.4. 四种隔离级别&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;SQL&lt;/code&gt;标准中设立了4种隔离级别, 用来解决上面的读一致性问题, 不同的隔离级别可以解决不同的读一致性问题:&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-脏读-脏写-幻读---事务隔离级别&#34;&gt;1. 脏读 脏写 幻读 - 事务隔离级别&lt;/h2&gt;
&lt;h3 id=&#34;11-脏读---事务隔离级别较低&#34;&gt;1.1. 脏读 - 事务隔离级别较低&lt;/h3&gt;
&lt;p&gt;脏读是指一个事务读取到了另一个事务尚未提交的数据。若后者发生回滚，则前者读取的数据实际上并不存在。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;事务 A 修改了一条记录，但尚未提交&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务 B 读取这条记录，看到 A 的修改&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果 A 后续回滚，那么 B 读到了不存在的数据，这就是脏读问题。&lt;/p&gt;
&lt;p&gt;根本原因在于事务隔离级别较低，&lt;strong&gt;允许一个事务读取另一个事务未提交的修改数据&lt;/strong&gt;，缺少对数据一致性的保证。&lt;/p&gt;
&lt;h3 id=&#34;12-脏写&#34;&gt;1.2. 脏写&lt;/h3&gt;
&lt;p&gt;脏写指的是：事务 B 在事务 A 尚未提交的更新基础上又进行了更新并提交。如果随后事务 A 回滚，但 B 已经基于 A 的“未提交更新”写入了数据库，就会导致数据库中出现了一份基于“从未真正生效的数据”所写进去的值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果 B 的更新逻辑要判断某个字段是否满足条件（例如库存是否 &amp;gt; 0 才扣减），而这个字段恰恰是由 A 更新的未提交数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;B 基于 A 未提交的数据做了扣减并提交，后来 A 回滚导致库存根本没增加（或者没变化），最终 B 却“凭空”把库存扣了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些例子都说明了：脏写本质上是写操作基于了一份并不存在（或不确定会不会存在）的中间状态，进而可能对数据一致性和业务逻辑造成破坏, 这就是为什么数据库禁止脏写的原因。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在多数主流数据库(例如 MySQL InnoDB)的默认配置下，这种情况通常不会发生，因为对同一行记录的并发写操作自动会被加 x锁序列化：只有前一个写操作提交或回滚后，后一个事务才能对这行数据进行新的写。因此，脏写往往只在极其宽松/非常低的隔离级别（或人为关闭了某些并发控制）下，才可能被“模拟”或“测试”出来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;13-不可重复读-和-幻读&#34;&gt;1.3. 不可重复读 和 幻读&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;不可重复读&lt;/strong&gt; 发生在同一行数据被更新，导致同一查询多次执行返回不同的具体数值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;幻读&lt;/strong&gt; 则发生在范围查询中，其他事务在该范围内插入或删除数据，导致结果集的记录数发生变化&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;14-四种隔离级别&#34;&gt;1.4. 四种隔离级别&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;SQL&lt;/code&gt;标准中设立了4种隔离级别, 用来解决上面的读一致性问题, 不同的隔离级别可以解决不同的读一致性问题:&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;隔离级别 (Isolation Level)&lt;/th&gt;
          &lt;th&gt;脏读 (Dirty Read)&lt;/th&gt;
          &lt;th&gt;不可重复读 (Non-repeatable Read)&lt;/th&gt;
          &lt;th&gt;幻读 (Phantom Read)&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;未提交读 (READ UNCOMMITTED)&lt;/td&gt;
          &lt;td&gt;可能 (Yes)&lt;/td&gt;
          &lt;td&gt;可能 (Yes)&lt;/td&gt;
          &lt;td&gt;可能 (Yes)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;已提交读 (READ COMMITTED)&lt;/td&gt;
          &lt;td&gt;不可能 (No)&lt;/td&gt;
          &lt;td&gt;可能 (Yes)&lt;/td&gt;
          &lt;td&gt;可能 (Yes)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;可重复读 (REPEATABLE READ)&lt;/td&gt;
          &lt;td&gt;不可能 (No)&lt;/td&gt;
          &lt;td&gt;不可能 (No)&lt;/td&gt;
          &lt;td&gt;可能 (Yes)（对 InnoDB 不可能）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;串行化 (SERIALIZABLE)&lt;/td&gt;
          &lt;td&gt;不可能 (No)&lt;/td&gt;
          &lt;td&gt;不可能 (No)&lt;/td&gt;
          &lt;td&gt;不可能 (No)&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;脏写的问题严重, 数据库设计上通过删改操作默认加 x锁, 实现脏写在任何隔离级别都会避免&lt;/p&gt;
&lt;p&gt;&lt;code&gt;InnoDB&lt;/code&gt;支持四个隔离级别（和&lt;code&gt;SQL&lt;/code&gt;标准定义的基本一致）。隔离级别越高，事务的并发度就越低。唯一的区别就在于，&lt;code&gt;InnoDB&lt;/code&gt; 在&lt;code&gt;可重复读（REPEATABLE READ）&lt;/code&gt;的级别就解决了幻读的问题。这也是&lt;code&gt;InnoDB&lt;/code&gt;使用&lt;code&gt;可重复读&lt;/code&gt; 作为事务默认隔离级别的原因。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-脏读-脏写-幻读如何被解决的&#34;&gt;2. 脏读 脏写 幻读如何被解决的&lt;/h2&gt;
&lt;h3 id=&#34;21-脏读-脏写&#34;&gt;2.1. 脏读 脏写&lt;/h3&gt;
&lt;p&gt;上面提到, 数据库有四种隔离级别, 用来解决 脏读, 脏写, 不可重复读, 幻读等问题, 现在我们简单叙述一下各自的概念:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;脏读: 一个事务读取到了另一个事务尚未提交的数据, 若未提交的数据发生回滚&amp;hellip;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务隔离级别较低, 允许一个事务读取另一个事务未提交的修改数据所导致&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;脏写: 事务 B 在事务 A 尚未提交的更新基础上又进行了更新并提交&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;脏写的问题严重, 数据库设计上通过删改操作默认加 x锁, 实现脏写在任何隔离级别都会避免&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;幻读: 发生在范围查询中，其他事务在该范围内插入或删除数据，导致结果集的记录数发生变化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不可重复读: 发生在同一行数据被更新, 导致同一查询多次执行返回不同的具体数值&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中脏写在隔离级别下都被消除了, 方法是任何写操作都需要先获得 x 锁, 然后就剩脏读, 幻读, 不可重复读这三个问题,&lt;/p&gt;
&lt;p&gt;InnoDB 在第三级别 &lt;code&gt;可重复读（REPEATABLE READ）&lt;/code&gt; 就解决了所有的问题, 前两个级别分别是 &lt;code&gt;未提交读&lt;/code&gt;, &lt;code&gt;已提交读&lt;/code&gt;, 根据名字就可以看出, &lt;code&gt;未提交读&lt;/code&gt;就是允许修改的数据还没提交就允许其他事务读取, 这显然会造成脏读, &lt;code&gt;未提交读&lt;/code&gt;也是最低级别的事务隔离, 第二级别就是&lt;code&gt;已提交读&lt;/code&gt;, 显然该级别解决了脏读问题, 但是还不够, 此时还有幻读和不可重复读的问题没有解决,&lt;/p&gt;
&lt;h3 id=&#34;22-不可重复读&#34;&gt;2.2. 不可重复读&lt;/h3&gt;
&lt;p&gt;不可重复读指的是在同一个事务中，多次读取同一数据时，由于其他事务的修改并提交，导致读取结果不一致:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;事务 A：在一个事务中需要两次读取 id = 1 的余额&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务 B：在事务 A 执行两次读取期间修改并提交数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要解决“不可重复读”问题, 需要将事务隔离级别提升到 &lt;code&gt;可重复读&lt;/code&gt; 或更高的 &lt;code&gt;序列化&lt;/code&gt; 级别, 这两个级别实行默认一致性读 MVCC 来避免“不可重复读“问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;可重复读&lt;/code&gt;隔离级别下, 读取数据操作&lt;strong&gt;默认使用&lt;/strong&gt;的是一致性读, 即通过 MVCC 机制读取数据的快照, 注意默认不是加锁读取&lt;/li&gt;
&lt;li&gt;当然也可以使用 &lt;code&gt;Select ... LOCK IN SHARE MODE&lt;/code&gt; 为某行添加共享s锁, 直到当前事务结束, 这样也可以防止读取的时候数据被其他事务修改,&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;x锁和 s锁是互斥的, 也就是说 当事务 A 获得某行记录的 s锁后, 其他事务想要修改该行记录, 在尝试获取 x 锁的阶段就会阻塞&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务 A：在一个事务中需要两次读取 id = 1 的余额&lt;/li&gt;
&lt;li&gt;事务 B：在事务 A 执行期间修改并提交数据&lt;/li&gt;
&lt;li&gt;隔离级别：设置为“可重复读”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;执行过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;事务 A 开始&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行 SELECT balance FROM account WHERE id = 1;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结果：balance = 100&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据库记录事务 A 的时间点（通过 MVCC）&lt;strong&gt;或&lt;/strong&gt;对 id = 1 的行加共享锁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务 B 开始&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行 UPDATE account SET balance = 200 WHERE id = 1;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1 如果使用锁：事务 B 被阻塞，直到事务 A 结束&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2 如果使用 MVCC：事务 B 可以提交，更新 balance = 200，但事务 A 仍读取旧版本（快照）数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务 A 再次读取&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再次执行 SELECT balance FROM account WHERE id = 1;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结果：balance = 100（无论事务 B 是否提交，事务 A 读取的是一致的旧版本数据）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务 A 结束&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务 A 提交或回滚后，锁（如果有）释放，或快照失效&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后续事务读取到的可能是 balance = 200&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结果：事务 A 在整个过程中两次读取的结果都是 100, 避免了不可重复读, 但现在仍存在“幻读” 问题&lt;/p&gt;
&lt;h3 id=&#34;23-幻读&#34;&gt;2.3. 幻读&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;可重复读&lt;/code&gt; 解决了“不可重复读”, 但没有解决“幻读”问题, 幻读是指事务读取一个范围的数据时, 另一个事务插入或删除行, 导致再次读取范围时结果不一致 例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务 A：SELECT * FROM account WHERE balance &amp;gt; 50;（返回 1 行）&lt;/li&gt;
&lt;li&gt;事务 B：INSERT INTO account (id, balance) VALUES (2, 60); 并提交&lt;/li&gt;
&lt;li&gt;事务 A 再次执行相同查询，可能返回 2 行（幻读）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面我们说的是数据库上的定义, MySQL 的 InnoDB 引擎在 &lt;code&gt;可重复读&lt;/code&gt; 级别下, 通过 多版本并发控制 MVCC 和 Next-Key 锁, 在一定程度上解决了幻读问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“幻读”是指一个事务在多次读取某个范围的数据时, 由于另一个事务插入或删除了数据并提交, 导致前后两次读取的结果集不一致（多了或少了行）, 它与“不可重复读”的区别在于, &lt;strong&gt;幻读涉及范围查询的结果集变化&lt;/strong&gt;, 而&lt;strong&gt;不可重复读针对单行数据的修改&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;情况 1：事务 A 使用快照读（普通 SELECT）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事务 A 执行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;START&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TRANSACTION&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; users &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; age &lt;span style=&#34;color:#66d9ef&#34;&gt;BETWEEN&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;40&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;-- 快照读
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结果：id=1, age=20 和 id=3, age=30&lt;/p&gt;
&lt;p&gt;机制：MVCC 创建一致性读视图，事务 A 只看到开始时的快照，不加锁&lt;/p&gt;
&lt;p&gt;事务 B 插入数据, 执行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;START&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TRANSACTION&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;INSERT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INTO&lt;/span&gt; users (id, age) &lt;span style=&#34;color:#66d9ef&#34;&gt;VALUES&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;25&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;COMMIT&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结果：插入成功，表数据变为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;id | age
1  | 20
2  | 25
3  | 30
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;事务 A 再次查询, 执行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; users &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; age &lt;span style=&#34;color:#66d9ef&#34;&gt;BETWEEN&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;40&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;-- 快照读
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结果：仍是 id=1, age=20 和 id=3, age=30&lt;/p&gt;
&lt;p&gt;原因：MVCC 保证快照一致性，不受事务 B 影响，幻读被避免&lt;/p&gt;
&lt;p&gt;结论：快照读通过 MVCC 避免幻读，但不加锁，事务 B 可以插入&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;情况 2：事务 A 从一开始使用 Next-Key 锁（当前读）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事务 A 开始并使用当前读&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;START&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TRANSACTION&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; users &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; age &lt;span style=&#34;color:#66d9ef&#34;&gt;BETWEEN&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;40&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FOR&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;-- 当前读
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结果：id=1, age=20 和 id=3, age=30&lt;/p&gt;
&lt;p&gt;机制：Next-Key 锁触发，锁定 age 在 10 到 40 的范围：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;记录锁：age=20 和 age=30&lt;/li&gt;
&lt;li&gt;间隙锁：(负无穷, 20)、(20, 30)、(30, 正无穷)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事务 B 尝试插入&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;INSERT INTO users (id, age) VALUES (2, 25);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果：被阻塞，因为 age=25 落在间隙 (20, 30) 中，而该间隙已被锁定。&lt;/p&gt;
&lt;p&gt;事务 A 再次查询&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SELECT * FROM users WHERE age BETWEEN 10 AND 40 FOR UPDATE; -- 当前读
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果：仍是 id=1, age=20 和 id=3, age=30&lt;/p&gt;
&lt;p&gt;原因：事务 B 的插入被阻止，数据未改变&lt;/p&gt;
&lt;p&gt;事务 A 提交&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;COMMIT;&lt;/li&gt;
&lt;li&gt;事务 B 解除阻塞，插入成功&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结论：事务 A 从一开始使用 Next-Key 锁，完全避免了幻读，因为事务 B 无法在事务 A 执行期间插入新记录&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;情况 3：事务 A 在第二次查询时使用当前读&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事务 A 开始 执行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;START&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TRANSACTION&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; users &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; age &lt;span style=&#34;color:#66d9ef&#34;&gt;BETWEEN&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;40&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;-- 快照读
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结果：id=1, age=20 和 id=3, age=30&lt;/p&gt;
&lt;p&gt;事务 B 插入数据执行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;INSERT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INTO&lt;/span&gt; users (id, age) &lt;span style=&#34;color:#66d9ef&#34;&gt;VALUES&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;25&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;COMMIT&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;事务 A 再次查询（当前读）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; users &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; age &lt;span style=&#34;color:#66d9ef&#34;&gt;BETWEEN&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;40&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FOR&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;-- 当前读
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结果：id=1, age=20、id=2, age=25 和 id=3, age=30&lt;/p&gt;
&lt;p&gt;机制：当前读读取最新提交的数据，看到事务 B 的插入。Next-Key 锁在此触发，但因插入已完成，无法阻止已存在的数据被读取&lt;/p&gt;
&lt;p&gt;结论：当前读会看到新数据，可能出现逻辑上的幻读（与第一次快照读不一致）&lt;/p&gt;
&lt;h2 id=&#34;3-事务&#34;&gt;3. 事务&lt;/h2&gt;
&lt;h3 id=&#34;31-事务的概念&#34;&gt;3.1. 事务的概念&lt;/h3&gt;
&lt;p&gt;事务是一组要么全部成功，要么全部失败的数据库操作，保证数据的一致性。&lt;/p&gt;
&lt;p&gt;假设你要从 A 账户转 100 元到 B 账户，这个过程涉及两个操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从 A 账户扣 100 元&lt;/li&gt;
&lt;li&gt;给 B 账户加 100 元&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果第一步执行了，但第二步失败了，就会导致 A 的钱少了，但 B 没收到钱，这导致了数据一致性问题。事务可以防止这种情况。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;START TRANSACTION;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 从 A 账户扣 100 元
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; accounts &lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; balance &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; balance &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;A&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 给 B 账户加 100 元
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; accounts &lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; balance &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; balance &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;B&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;COMMIT;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果在执行过程中出现错误（比如 B 账户不存在），可以执行回滚，撤销已经执行的操作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;拓展:&lt;/strong&gt; 在 MySQL（InnoDB 存储引擎）中，单个 DML 语句（INSERT, UPDATE, DELETE）本身就是一个事务，如果 &lt;code&gt;AUTOCOMMIT&lt;/code&gt; 处于默认开启状态，它会自动提交，不需要手动 &lt;code&gt;COMMIT&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在数据修改操作（Update、Delete、Insert）中, MySQL InnoDB 会&lt;strong&gt;自动&lt;/strong&gt;对受影响的行加上 x 锁, 事务提交的时候(语句执行完成), x锁会被自动释放。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;后端开发:&lt;/strong&gt; 在 Spring Data JPA 中，事务管理是由 Spring 的事务管理器（通常是 &lt;code&gt;@Transactional&lt;/code&gt; 注解）来控制的，自动回滚行为也由 Spring 决定。Spring 默认会在遇到 &lt;strong&gt;运行时异常（RuntimeException 及其子类）&lt;/strong&gt; 或 &lt;strong&gt;错误（Error）&lt;/strong&gt; 时自动回滚事务。&lt;/p&gt;
&lt;p&gt;如果在事务方法内部捕获了异常，并没有将异常抛出到事务管理器，那么 Spring 不会感知到异常，从而事务不会自动回滚。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Transactional&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;updateSomeData&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 一些数据库操作&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 可能抛出异常&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt; (Exception e) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 捕获异常后不重新抛出，事务将按正常流程提交&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;32-事务不是导致错误的原因而是处理错误的机制&#34;&gt;3.2. 事务不是导致错误的原因，而是处理错误的机制&lt;/h3&gt;
&lt;p&gt;连接类错误, 语法错误, 系统资源相关错误, 数据完整性和约束错误, 事务和锁相关错误, 前几种没什么好说的, 看一下最后两种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;违反完整性约束的错误: 数据库自身的机制, 比如：主键重复、外键不存在、唯一约束冲突、&lt;code&gt;CHECK&lt;/code&gt; 约束失败等&lt;/li&gt;
&lt;li&gt;事务和锁相关错误: 在事务操作中遇到死锁或锁等待等问题
&lt;ul&gt;
&lt;li&gt;两个或多个事务在等待对方持有的资源而形成循环依赖，导致系统检测到死锁。&lt;/li&gt;
&lt;li&gt;事务等待获取资源的时间超出了设定的超时时间，可能需要检查当前事务的锁竞争情况&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;事务不是导致错误的原因，而是处理错误的机制:&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;strong&gt;情况&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;数据库是否报错？&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;事务是否回滚？&lt;/strong&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;主键冲突&lt;/td&gt;
          &lt;td&gt;✅ 报错&lt;/td&gt;
          &lt;td&gt;✅ 回滚（事务开启时）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;外键约束失败&lt;/td&gt;
          &lt;td&gt;✅ 报错&lt;/td&gt;
          &lt;td&gt;✅ 回滚（事务开启时）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;唯一约束失败&lt;/td&gt;
          &lt;td&gt;✅ 报错&lt;/td&gt;
          &lt;td&gt;✅ 回滚（事务开启时）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;业务逻辑错误（如负余额）&lt;/td&gt;
          &lt;td&gt;✅ 报错&lt;/td&gt;
          &lt;td&gt;✅ 回滚（事务开启时）&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ol&gt;
&lt;li&gt;没开启事务时, 每条 SQL 都是独立提交的, 报错不会回滚之前的操作&lt;/li&gt;
&lt;li&gt;事务不会主动报错，报错的原因是 SQL 语句违反数据库的完整性约束&lt;/li&gt;
&lt;li&gt;事务的作用是确保错误发生时，数据不会进入不一致的状态, 事务只是处理数据库错误的工具, 并不是开启事务就万事大吉了&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;33-事务的特性&#34;&gt;3.3. 事务的特性&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;原子性（Atomicity）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务是一个不可分割的最小操作单元，要么全部执行成功，要么全部回滚&lt;/li&gt;
&lt;li&gt;以转账场景为例，一个账户的余额减少，另一个账户的余额增加，这两个操作一定是同时成功或者同时失败的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;一致性（Consistency）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务执行前后，数据库必须保持一致性状态，即不会违反数据库的完整性约束&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;隔离性（Isolation）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并发事务互不影响，一个事务未提交前，其他事务无法看到其变化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;持久性（Durability）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务提交后，其修改的数据会被永久保存，即使系统崩溃也不会丢失&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;一致性并不是事务本身的固有属性, 而更像是一种外在要求,&lt;/strong&gt; 不难发现其他三个都是实打实的特征, 唯独一致性, 无法理解, 这里的一致性更像是一种外在要求, 而不是事务本身的固有的属性, 即是一种需要依赖业务层逻辑来实现的状态,&lt;/p&gt;
&lt;p&gt;举个不恰当的例子, 我们说一个苹果, 苹果是圆的, 苹果可以为我们提供维生素C, 这都是苹果的特征, 可是你却说, 苹果也有生吃性, 苹果必须生吃才能最大化的提供营养价值, WTF? 生不生吃苹果取决于个人啊, 这怎么能是苹果的特性呢?&lt;/p&gt;
&lt;p&gt;同理, 数据库是不是保持一致性, 这取决于业务逻辑啊, 比如需要结合锁来实现, 什么悲观锁, 乐观锁, 这怎么能是事务的特性呢?&lt;/p&gt;
&lt;h2 id=&#34;4-数据一致性问题&#34;&gt;4. 数据一致性问题&lt;/h2&gt;
&lt;h3 id=&#34;41-直接修改操作---隐式-x-锁&#34;&gt;4.1. 直接修改操作 - 隐式 x 锁&lt;/h3&gt;
&lt;p&gt;比如常见的转账例子多个人给同一个账户转 100 块钱,  系统可能会有下面的命令:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; account &lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; balance &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; balance &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; account_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;002&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;高并发状态下, A事务读取到此时账户余额为 100, B事务 也读取到账户余额为 100,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A 事务: 余额 = 100 + 100 = 200,&lt;/li&gt;
&lt;li&gt;B 事务:  余额 = 100 + 100 = 200&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后账户余额仅为 200 而不是 300, 导致数据一致性问题, 因为 InnoDB 会在执行 UPDATE 时对目标行加上排它锁（X 锁）, 从而确保这些操作是串行化的,&lt;/p&gt;
&lt;p&gt;好像是告诉事务, 你想更新 &lt;code&gt;account_id = 002&lt;/code&gt; 的数据? 行, 但请先获得这行数据的 X 锁, 所以不可能会有两个事务同时对同一行执行 UPDATE 操作, 也就是说使用单条 UPDATE 语句时, 不会出现多个事务都获取到相同 balance 的情况, 因为数据修改操作都是串行化的,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在数据修改操作（Update、Delete、Insert）中, 事务会先尝试获得受影响行的 X 锁, 若得到, 才能进行更新, 否则只能等待, 不要忘了单个语句, 也默认属于一个事务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;42-检查--修改操作----显式-x锁-悲观锁-或乐观锁&#34;&gt;4.2. 检查 + 修改操作 -  显式 x锁 (悲观锁) 或乐观锁&lt;/h3&gt;
&lt;p&gt;这种属于多个事务中基于过时数据进行判断后再写入更新的场景, 读取数据与更新操作之间缺乏必要的锁机制保护, 导致多个事务基于同一份数据进行判断并更新, 从而引发数据不一致,&lt;/p&gt;
&lt;p&gt;上面的例子过于简化了, 实际系统肯定不会直接给账户加钱, 还有很多考虑, 比如检查收账人是否存在, 检查转账人的余额是不是足够, 然后进行扣款,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤 1：同时读取余额&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务 A 和事务 B 同时对转账人账户执行查询操作，读取到余额都为 100 元&lt;/li&gt;
&lt;li&gt;此时，如果没有加锁（如 &lt;code&gt;FOR UPDATE&lt;/code&gt;），两个事务都基于相同的旧数据做判断&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;步骤 2：判断余额充足&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务 A 判断：100 元 &amp;gt;= 转账金额 80 元，认为余额足够&lt;/li&gt;
&lt;li&gt;事务 B 同样判断：100 元 &amp;gt;= 转账金额 60 元，也认为余额足够&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;步骤 3：分别执行扣款&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务 A 扣款 80 元，更新余额为 20 元&lt;/li&gt;
&lt;li&gt;事务 B 扣款 80 元，同样在自己的事务中基于最初读取到的 100 元执行更新，更新余额为 40 元&lt;/li&gt;
&lt;li&gt;最终两个事务都成功提交，导致余额可能是40, 也可能是20, 也可能是100 - 80 - 60 = -40, 导致余额出现问题（负数或不一致）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解决办法1: 悲观锁&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;BEGIN;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; balance &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; accounts &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FOR&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;-- 加锁
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 判断余额是否充足, 通过业务代码实现, SQL 无法实现逻辑判断
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; accounts &lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; balance &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; balance &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;COMMIT;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样可以确保在一个事务完成之前，其他事务必须等待，避免同时读取同一份数据进行判断。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决办法2: 乐观锁&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;BEGIN;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; balance, version &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; accounts &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 判断余额是否充足, 通过业务代码实现, SQL 无法实现逻辑判断
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; accounts &lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; balance &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; balance &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;, version &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; version &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; version &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 判断 UPDATE 是否成功, 否则重试或抛出异常返回给客户端执行失败, 通过业务代码实现
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;COMMIT;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;43-多表操作---事务原子性&#34;&gt;4.3. 多表操作 - 事务原子性&lt;/h3&gt;
&lt;p&gt;除此之外还要确保转账人的账户 -100, 收款人的账户 +100, 不能出现后者操作失败了, 导致收款人账户余额没变, 转账人账户的钱却少了 100, 这也是属于数据不一致,&lt;/p&gt;
&lt;p&gt;这种很简单, 把更新两张表的语句放到同一个事务里就行了, 因为可以利用事务的回滚保证, 若有一个操作失败, 则同时都失败,&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>数据库表设计 悲观锁/乐观锁 Redis 高并发场景实践</title>
      <link>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/006-%E9%AB%98%E5%B9%B6%E5%8F%91%E7%82%B9%E8%B5%9E/</link>
      <pubDate>Mon, 17 Feb 2025 19:20:35 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/006-%E9%AB%98%E5%B9%B6%E5%8F%91%E7%82%B9%E8%B5%9E/</guid>
      <description>&lt;h2 id=&#34;1-典型设计&#34;&gt;1. 典型设计&lt;/h2&gt;
&lt;p&gt;一个帖子系统, 用户可以发帖, 点赞帖子, 给帖子发表评论, 点赞评论, 回复评论&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 用户表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;users&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AUTO_INCREMENT&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    username &lt;span style=&#34;color:#66d9ef&#34;&gt;VARCHAR&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户名&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    email &lt;span style=&#34;color:#66d9ef&#34;&gt;VARCHAR&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;邮箱&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    password_hash &lt;span style=&#34;color:#66d9ef&#34;&gt;VARCHAR&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;255&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;密码哈希&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    created_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;创建时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    updated_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;更新时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;UNIQUE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_username&lt;/span&gt; (username),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;UNIQUE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_email&lt;/span&gt; (email)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户表&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 帖子表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;posts&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AUTO_INCREMENT&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;帖子ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    user_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;作者ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    title &lt;span style=&#34;color:#66d9ef&#34;&gt;VARCHAR&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;标题&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    content &lt;span style=&#34;color:#66d9ef&#34;&gt;TEXT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;内容&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    likes_count &lt;span style=&#34;color:#66d9ef&#34;&gt;INT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;点赞数&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    comments_count &lt;span style=&#34;color:#66d9ef&#34;&gt;INT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论数&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    status &lt;span style=&#34;color:#66d9ef&#34;&gt;TINYINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;状态:1-正常,2-已删除&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    created_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;创建时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    updated_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;更新时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    version &lt;span style=&#34;color:#66d9ef&#34;&gt;INT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;乐观锁版本号&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_user_id&lt;/span&gt; (user_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户ID索引,用于查询用户的帖子列表&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_created_at&lt;/span&gt; (created_at) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;创建时间索引,用于按时间排序&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;帖子表&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 帖子点赞表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;post_likes&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AUTO_INCREMENT&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;点赞ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    post_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;帖子ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    user_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    created_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;创建时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;UNIQUE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_post_user&lt;/span&gt; (post_id, user_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;帖子用户联合唯一索引,防止重复点赞&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_user_id&lt;/span&gt; (user_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户ID索引,用于查询用户的点赞列表&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;帖子点赞表&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 评论表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;comments&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AUTO_INCREMENT&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    post_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;帖子ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    user_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论者ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    parent_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;父评论ID,回复评论时使用&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    content &lt;span style=&#34;color:#66d9ef&#34;&gt;TEXT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论内容&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    likes_count &lt;span style=&#34;color:#66d9ef&#34;&gt;INT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;点赞数&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    replies_count &lt;span style=&#34;color:#66d9ef&#34;&gt;INT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;回复数&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    status &lt;span style=&#34;color:#66d9ef&#34;&gt;TINYINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;状态:1-正常,2-已删除&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    created_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;创建时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    updated_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;更新时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    version &lt;span style=&#34;color:#66d9ef&#34;&gt;INT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;乐观锁版本号&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_post_id&lt;/span&gt; (post_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;帖子ID索引,用于查询帖子的评论列表&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_user_id&lt;/span&gt; (user_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户ID索引,用于查询用户的评论列表&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_parent_id&lt;/span&gt; (parent_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;父评论ID索引,用于查询评论的回复列表&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论表&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 评论点赞表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;comment_likes&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AUTO_INCREMENT&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;点赞ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    comment_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    user_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    created_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;创建时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;UNIQUE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_comment_user&lt;/span&gt; (comment_id, user_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论用户联合唯一索引,防止重复点赞&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_user_id&lt;/span&gt; (user_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户ID索引,用于查询用户的点赞列表&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论点赞表&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;2-帖子中应该放点赞数和回复数吗&#34;&gt;2. 帖子中应该放点赞数和回复数吗&lt;/h2&gt;
&lt;h3 id=&#34;21-数据一致性问题---事务&#34;&gt;2.1. 数据一致性问题 - 事务&lt;/h3&gt;
&lt;p&gt;优点是读取性能好, 减少数据库压力 , 显示帖子列表时无需连表统计, 缺点是会有&lt;strong&gt;写入一致性问题和并发问题&lt;/strong&gt;, 假设用户点赞一个帖子，我们需要做两件事：&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-典型设计&#34;&gt;1. 典型设计&lt;/h2&gt;
&lt;p&gt;一个帖子系统, 用户可以发帖, 点赞帖子, 给帖子发表评论, 点赞评论, 回复评论&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 用户表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;users&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AUTO_INCREMENT&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    username &lt;span style=&#34;color:#66d9ef&#34;&gt;VARCHAR&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户名&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    email &lt;span style=&#34;color:#66d9ef&#34;&gt;VARCHAR&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;邮箱&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    password_hash &lt;span style=&#34;color:#66d9ef&#34;&gt;VARCHAR&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;255&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;密码哈希&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    created_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;创建时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    updated_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;更新时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;UNIQUE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_username&lt;/span&gt; (username),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;UNIQUE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_email&lt;/span&gt; (email)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户表&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 帖子表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;posts&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AUTO_INCREMENT&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;帖子ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    user_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;作者ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    title &lt;span style=&#34;color:#66d9ef&#34;&gt;VARCHAR&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;标题&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    content &lt;span style=&#34;color:#66d9ef&#34;&gt;TEXT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;内容&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    likes_count &lt;span style=&#34;color:#66d9ef&#34;&gt;INT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;点赞数&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    comments_count &lt;span style=&#34;color:#66d9ef&#34;&gt;INT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论数&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    status &lt;span style=&#34;color:#66d9ef&#34;&gt;TINYINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;状态:1-正常,2-已删除&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    created_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;创建时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    updated_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;更新时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    version &lt;span style=&#34;color:#66d9ef&#34;&gt;INT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;乐观锁版本号&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_user_id&lt;/span&gt; (user_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户ID索引,用于查询用户的帖子列表&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_created_at&lt;/span&gt; (created_at) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;创建时间索引,用于按时间排序&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;帖子表&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 帖子点赞表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;post_likes&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AUTO_INCREMENT&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;点赞ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    post_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;帖子ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    user_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    created_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;创建时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;UNIQUE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_post_user&lt;/span&gt; (post_id, user_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;帖子用户联合唯一索引,防止重复点赞&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_user_id&lt;/span&gt; (user_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户ID索引,用于查询用户的点赞列表&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;帖子点赞表&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 评论表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;comments&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AUTO_INCREMENT&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    post_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;帖子ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    user_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论者ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    parent_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;父评论ID,回复评论时使用&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    content &lt;span style=&#34;color:#66d9ef&#34;&gt;TEXT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论内容&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    likes_count &lt;span style=&#34;color:#66d9ef&#34;&gt;INT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;点赞数&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    replies_count &lt;span style=&#34;color:#66d9ef&#34;&gt;INT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;回复数&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    status &lt;span style=&#34;color:#66d9ef&#34;&gt;TINYINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;状态:1-正常,2-已删除&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    created_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;创建时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    updated_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;更新时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    version &lt;span style=&#34;color:#66d9ef&#34;&gt;INT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;乐观锁版本号&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_post_id&lt;/span&gt; (post_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;帖子ID索引,用于查询帖子的评论列表&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_user_id&lt;/span&gt; (user_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户ID索引,用于查询用户的评论列表&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_parent_id&lt;/span&gt; (parent_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;父评论ID索引,用于查询评论的回复列表&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论表&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 评论点赞表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;comment_likes&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AUTO_INCREMENT&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;点赞ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    comment_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    user_id &lt;span style=&#34;color:#66d9ef&#34;&gt;BIGINT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户ID&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    created_at &lt;span style=&#34;color:#66d9ef&#34;&gt;TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;创建时间&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;UNIQUE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_comment_user&lt;/span&gt; (comment_id, user_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论用户联合唯一索引,防止重复点赞&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;idx_user_id&lt;/span&gt; (user_id) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;用户ID索引,用于查询用户的点赞列表&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;) COMMENT &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;评论点赞表&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;2-帖子中应该放点赞数和回复数吗&#34;&gt;2. 帖子中应该放点赞数和回复数吗&lt;/h2&gt;
&lt;h3 id=&#34;21-数据一致性问题---事务&#34;&gt;2.1. 数据一致性问题 - 事务&lt;/h3&gt;
&lt;p&gt;优点是读取性能好, 减少数据库压力 , 显示帖子列表时无需连表统计, 缺点是会有&lt;strong&gt;写入一致性问题和并发问题&lt;/strong&gt;, 假设用户点赞一个帖子，我们需要做两件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 post_likes 表插入一条点赞记录&lt;/li&gt;
&lt;li&gt;在 posts 表把这个帖子的 likes_count 加1&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 第一步：插入点赞记录成功
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;INSERT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INTO&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;post_likes&lt;/span&gt; (post_id, user_id) &lt;span style=&#34;color:#66d9ef&#34;&gt;VALUES&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 第二步：更新帖子点赞数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 假设在这时候数据库突然崩溃了或者网络中断了
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; posts &lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; likes_count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; likes_count &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这就导致了数据不一致: post_likes 表显示用户点赞了, 但是 posts 表的点赞数没有增加, 我们可以通过加入事务来解决:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;BEGIN&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;INSERT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INTO&lt;/span&gt; post_likes (post_id, user_id) &lt;span style=&#34;color:#66d9ef&#34;&gt;VALUES&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; posts &lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; likes_count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; likes_count &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;COMMIT&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过使用事务, 若 &lt;code&gt;BEGIN ... COMMIT&lt;/code&gt; 中的一个语句执行失败, 之前所有的操作都不会成功, 这就解决了数据一致性问题&lt;/p&gt;
&lt;h3 id=&#34;22-并发问题---x锁&#34;&gt;2.2. 并发问题 - X锁&lt;/h3&gt;
&lt;p&gt;下面先说一下一个常见的&lt;strong&gt;误解&lt;/strong&gt;, 假如帖子当前有100个赞，两个用户 A 和 B 同时点赞:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 用户A的操作
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; posts &lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; likes_count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; likes_count &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 用户B的操作(同时进行, 则都会读取到 likes_count = 100)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; posts &lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; likes_count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; likes_count &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;有人会想到可能会出现下面问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A读取到 likes_count = 100, B读取到 likes_count = 100&lt;/li&gt;
&lt;li&gt;A更新 likes_count = 101, B 更新 likes_count = 101&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最终结果是 likes_count = 101，但实际上应该是102, 其实并不会出现这个问题, 这里需要指出两个关于事务和锁事实:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 MySQL 中，默认情况下 &lt;code&gt;autocommit&lt;/code&gt; 是开启的（即 &lt;code&gt;autocommit=1&lt;/code&gt;）。在这个模式下，每条单独的 SQL 语句 (增删改, &lt;strong&gt;除了查&lt;/strong&gt;) 都会被当作一个独立的事务来执行。&lt;code&gt;SELECT&lt;/code&gt; 语句通常不涉及事务（除非是 &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt; 这种需要锁的语句）&lt;/li&gt;
&lt;li&gt;在数据修改操作（Update、Delete、Insert）中, InnoDB 会&lt;strong&gt;自动&lt;/strong&gt;对受影响的行加上行级的&lt;strong&gt;排它锁&lt;/strong&gt;（X 锁）&lt;/li&gt;
&lt;li&gt;锁只会在事务 commit 或者 rollback 的时候自动被释放, 这也是为什么锁必须配合事务使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据第二条事实, 我们知道当执行 &lt;code&gt;UPDATE posts SET likes_count = likes_count + 1 WHERE id = 1;&lt;/code&gt; 时, MySQL 会自动为 id=1 的行加上一个 x 锁, 意味着在这个锁没有被释放前, 其它任何事务都不可以修改这行数据, 因为想要修改某行数据必须要获得这行数据的 x 锁 (MySQL 默认行为), 而这行数据的 x锁还没被释放,&lt;/p&gt;
&lt;p&gt;下面使用如下表格展示用户A和用户B并发执行更新时的操作流程, 假设初始状态：&lt;code&gt;posts&lt;/code&gt; 表中 id=1 的记录 &lt;code&gt;likes_count=100&lt;/code&gt;:&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;时间 (T)&lt;/th&gt;
          &lt;th&gt;用户A的操作&lt;/th&gt;
          &lt;th&gt;用户B的操作&lt;/th&gt;
          &lt;th&gt;备注说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;T₀&lt;/td&gt;
          &lt;td&gt;——&lt;/td&gt;
          &lt;td&gt;——&lt;/td&gt;
          &lt;td&gt;初始状态：点赞数 100&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T₁&lt;/td&gt;
          &lt;td&gt;执行 &lt;code&gt;UPDATE ...&lt;/code&gt; 加排他锁并将值由 100 更新为 101&lt;/td&gt;
          &lt;td&gt;——&lt;/td&gt;
          &lt;td&gt;用户A自动获得行锁，其他事务无法修改该行&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T₂&lt;/td&gt;
          &lt;td&gt;——（等待提交或后续操作）&lt;/td&gt;
          &lt;td&gt;尝试执行相同 &lt;code&gt;UPDATE&lt;/code&gt; 语句但因行被锁，进入等待状态&lt;/td&gt;
          &lt;td&gt;用户B操作被阻塞，等待用户A释放锁&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T₃&lt;/td&gt;
          &lt;td&gt;提交事务，释放锁&lt;/td&gt;
          &lt;td&gt;——&lt;/td&gt;
          &lt;td&gt;用户A提交后，行更新为 101，释放了锁&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T₄&lt;/td&gt;
          &lt;td&gt;——&lt;/td&gt;
          &lt;td&gt;获得锁后执行 &lt;code&gt;UPDATE ...&lt;/code&gt; 将值由 101 更新为 102&lt;/td&gt;
          &lt;td&gt;用户B操作获得锁，基于最新数据进行更新&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T₅&lt;/td&gt;
          &lt;td&gt;——&lt;/td&gt;
          &lt;td&gt;提交事务&lt;/td&gt;
          &lt;td&gt;最终结果：点赞数102（累加 2）&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可以看出, 并不需要手动加x锁, 只需要使用事务保证操作的原子性就好了, 因为UPDATE 会自动获得 x 锁, 不必担心并发问题, 如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;BEGIN;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;-- 插入点赞记录
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;INSERT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INTO&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;post_likes&lt;/span&gt; (post_id, user_id) &lt;span style=&#34;color:#66d9ef&#34;&gt;VALUES&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;-- 更新点赞数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; posts &lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; likes_count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; likes_count &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;COMMIT;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;至于防止用户重复点赞, 我们可以在 &lt;code&gt;(post_id, user_id)&lt;/code&gt; 上建立索引, 若相同数据插入, &lt;code&gt;INSERT INTO post_likes (post_id, user_id) VALUES (1, 1);&lt;/code&gt; 必然失败, 导致业务逻辑抛出异常, 下面的更新操作也不会发生, 然后我们捕获异常, 告诉用户点赞重复即可,&lt;/p&gt;
&lt;h3 id=&#34;23-事务--悲观锁&#34;&gt;2.3. 事务 + 悲观锁&lt;/h3&gt;
&lt;p&gt;既然每条修改语句都会先尝试获取排它锁, 然后才能修改数据, 为什么还会有并发问题呢? 上面的情况很简单, 所以没有问题, 我们来考虑一个复杂一些的问题,&lt;/p&gt;
&lt;p&gt;假设有一个库存系统，需要先判断库存是否充足，再扣减库存。如果不使用显式加锁，可能会出现多个事务同时读取相同库存数量，然后都判断库存足够，导致库存扣减错误。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;时间 (T)&lt;/th&gt;
          &lt;th&gt;用户A的操作&lt;/th&gt;
          &lt;th&gt;用户B的操作&lt;/th&gt;
          &lt;th&gt;备注说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;T₀&lt;/td&gt;
          &lt;td&gt;——&lt;/td&gt;
          &lt;td&gt;——&lt;/td&gt;
          &lt;td&gt;初始状态：库存 &lt;code&gt;stock = 10&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T₁&lt;/td&gt;
          &lt;td&gt;查询库存,  stock = 10&lt;/td&gt;
          &lt;td&gt;——&lt;/td&gt;
          &lt;td&gt;用户A读取库存，未加锁（普通 SELECT）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T₂&lt;/td&gt;
          &lt;td&gt;——&lt;/td&gt;
          &lt;td&gt;查询库存,  &lt;code&gt;stock = 10&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;用户B也读取库存，双方看到的都是相同的初始库存&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T₃&lt;/td&gt;
          &lt;td&gt;库存足够10 ≥ 8, 加 X 锁, 更新库存 10 - 8 = 2,&lt;/td&gt;
          &lt;td&gt;——&lt;/td&gt;
          &lt;td&gt;用户A更新时加锁，库存实际变为 2&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T₄&lt;/td&gt;
          &lt;td&gt;——&lt;/td&gt;
          &lt;td&gt;库存足够10 ≥ 6, 尝试更新库存数据, 无法获取 x锁, 尝试更新失败&lt;/td&gt;
          &lt;td&gt;用户B的 UPDATE 操作因被 A 的锁阻塞，等待 A 提交&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T₅&lt;/td&gt;
          &lt;td&gt;提交事务，释放锁&lt;/td&gt;
          &lt;td&gt;——&lt;/td&gt;
          &lt;td&gt;用户A提交后，锁释放，此时数据库中库存为 2&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T₆&lt;/td&gt;
          &lt;td&gt;——&lt;/td&gt;
          &lt;td&gt;获得x锁后执行 UPDATE 操作 10 - 6 = 4,&lt;/td&gt;
          &lt;td&gt;用户B执行更新时，虽然其早先读取到库存为 10，但更新操作是基于当前实际库存（2）进行扣减，即 2 - 6 = -4&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T₇&lt;/td&gt;
          &lt;td&gt;——&lt;/td&gt;
          &lt;td&gt;提交事务&lt;/td&gt;
          &lt;td&gt;最终库存变为 -4，出现库存不足但仍被扣减的问题&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这种问题通常需要使用悲观锁（例如 &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt;）, 即使用显式加锁可以解决这个问题：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 开启事务保证多个操作的原子性(数据一致性)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;BEGIN&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;-- 手工显式加x锁，防止其他事务在判断和扣减期间修改库存
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; stock &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; products &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; product_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FOR&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;-- 根据读取的库存进行判断
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;IF&lt;/span&gt; (stock &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;THEN&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; products &lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; stock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; stock &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; product_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;END&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;IF&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;COMMIT&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里我们在事务开始前显式添加了 x锁, 这意味着若其它事务想修改 &lt;code&gt;product_id = 100&lt;/code&gt; 这行数据, &lt;strong&gt;必须先拿到这一行的 x锁&lt;/strong&gt;, 而此时若事务 A 已经显式拿到了  &lt;code&gt;product_id = 100&lt;/code&gt; 这一行数据的 x锁, 意味着事务 A 不结束, 该锁永远不会被释放, 也就是其它事务永远不可能拿到这行数据的x锁, 也就无法执行下面的流程 (比如: 查询编号为100的商品的剩余, 更新该行数据),&lt;/p&gt;
&lt;p&gt;注意这里添加事务是为了保留显式添加的锁直到整个事务结束,&lt;/p&gt;
&lt;p&gt;可以看出, 使用悲观锁（通过 &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt; 显示加 X 锁）的主要目的就是在执行更新前，确保读取到的数据是最新且不会被其他并发事务修改，从而&lt;strong&gt;保证基于该数据做出的判断是可靠的&lt;/strong&gt;。如果判断通过，再执行更新操作，而这整个过程都在同一个事务内执行，确保了原子性和隔离性，避免数据竞争和不一致的问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;小贴士&lt;/strong&gt;:  &lt;strong&gt;&lt;code&gt;X锁&lt;/code&gt; 的加锁方式有两种&lt;/strong&gt;，第一种是自动加锁，在对数据进行&lt;strong&gt;增删改&lt;/strong&gt;的时候，都会默认加上一个&lt;code&gt;X锁&lt;/code&gt;。还有一种是手工加锁，我们用一个&lt;code&gt;FOR UPDATE&lt;/code&gt;给一行数据加上一个&lt;code&gt;X锁&lt;/code&gt;, &lt;code&gt;X锁&lt;/code&gt;在同一时刻只能被一个事务持有, 其它事务想获得, 必须等待&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;最常见的数据一致性问题就是多步骤其中一个步骤失败引起的, 比如假设你在银行 A 账户有 1000 元，你想转账 200 元到银行 B 账户, 正常情况下 从 A 账户扣除 200 元（余额变成 800）, 向 B 账户增加 200 元（余额变成 1200）, 假设在步骤 1 之后（A 账户变成 800），系统崩溃或网络异常，导致步骤 2 没有执行, 这就导致 A 账户已经减少了 200 元（800），但 B 账户仍然是 1000, 这也是数据一致性问题, 这种数据一致性问题我们可以添加事务 &lt;strong&gt;利用事务的原子性&lt;/strong&gt;来解决,&lt;/p&gt;
&lt;p&gt;数据一致性问题分为好多种, 比如上面用户A, B同时点赞, 导致点赞数丢失的问题, 比如多个人给一个账户转 100 块钱,  A事务读取到此时账户余额为 100, B事务 也读取到账户余额为 100, 所以 A: 余额= 100 + 100 = 200, B事务 也是这样, 最后账户余额仅为 200 而不是 300, 导致数据一致性问题, 这种数据一致性问题可以&lt;strong&gt;通过 x 锁解决&lt;/strong&gt;, 当然 MySQL 数据库默认加上了 x 锁, 我们不必担心&lt;/p&gt;
&lt;p&gt;还有一种是需要判断再进行其他增减操作的, 比如高并发防止&lt;strong&gt;库存超卖&lt;/strong&gt;, 我们需要先判断库存是否有剩余, 再进行扣减, 这个时候就有了两个操作 判断 + 扣除, 这个时候就需要使用悲观锁直接锁定或者使用乐观锁, 需要通过锁机制来确保“判断+扣减”作为一个整体原子操作执行, 通过一个版本号标识数据的状态, 在更新时检查版本是否一致, 如果一致, 说明数据未被其他线程修改, 可以安全更新；如果不一致，说明有并发修改，需要重试或失败处理。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; quantity, &lt;span style=&#34;color:#66d9ef&#34;&gt;version&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; stock &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; product_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1001&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; stock 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; quantity &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; quantity &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;version&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;version&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; product_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1001&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;version&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;3-帖子表放点赞数-高并发点赞-redis--kafka&#34;&gt;3. 帖子表放点赞数 高并发点赞 Redis + Kafka&lt;/h2&gt;
&lt;p&gt;首先看一下易错的实现:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Transactional&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;likePost&lt;/span&gt;(Long postId, Long userId) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String likesUsersKey &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;post:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; postId &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:likes_users&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String likesCountKey &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;post:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; postId &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:likes_count&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 1. 检查是否已点赞, 检查和更新操作分离&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (Boolean.&lt;span style=&#34;color:#a6e22e&#34;&gt;TRUE&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;equals&lt;/span&gt;(redisTemplate.&lt;span style=&#34;color:#a6e22e&#34;&gt;opsForSet&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;isMember&lt;/span&gt;(likesUsersKey, userId))) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 2. Redis 操作：添加用户 ID 到点赞集合 &amp;amp; 计数+1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    redisTemplate.&lt;span style=&#34;color:#a6e22e&#34;&gt;opsForSet&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(likesUsersKey, userId);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    redisTemplate.&lt;span style=&#34;color:#a6e22e&#34;&gt;opsForValue&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;increment&lt;/span&gt;(likesCountKey, 1);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 3. 发送 Kafka 事件 (type=like)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String event &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;like,&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; postId &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; userId;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    kafkaTemplate.&lt;span style=&#34;color:#a6e22e&#34;&gt;send&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;like-topic&amp;#34;&lt;/span&gt;, event);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;初学者可能会认为Redis 服务是一个单线程进程, 所以即使一个用户同时进行两次点赞, 也不会出现数据不一致问题, 因为在:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;redisTemplate.&lt;span style=&#34;color:#a6e22e&#34;&gt;opsForSet&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(likesUsersKey, userId);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这一步就会失败(Set 集合天然唯一性), 自增1也不可能执行, 首先这么理解是不对的, &lt;code&gt;opsForSet().add(...);&lt;/code&gt; 底层调用的是 Redis 的 SADD 命令, 如果添加的成员已经存在于集合中, Redis 不会抛出异常，而是简单地&lt;strong&gt;忽略&lt;/strong&gt;该操作, 所以下面的代码(自增1)会继续执行, 那这就可能导致数据不一致问题:&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;步骤&lt;/th&gt;
          &lt;th&gt;线程A操作&lt;/th&gt;
          &lt;th&gt;线程B操作&lt;/th&gt;
          &lt;th&gt;Redis 中的实际情况&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;isMember(likes_users, 888)&lt;/code&gt; 返回 false&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;likes_users = {}&lt;/code&gt;, &lt;code&gt;likes_count = 0&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;isMember(likes_users, 888)&lt;/code&gt; 返回 false&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;likes_users = {}&lt;/code&gt;, &lt;code&gt;likes_count = 0&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;SADD(likes_users, 888)&lt;/code&gt;，返回 1&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;likes_users = {888}&lt;/code&gt;, &lt;code&gt;likes_count = 0&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;increment(likes_count)&lt;/code&gt;，加 1&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;likes_users = {888}&lt;/code&gt;, &lt;code&gt;likes_count = 1&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;SADD(likes_users, 888)&lt;/code&gt;，返回 0&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;likes_users = {888}&lt;/code&gt;, &lt;code&gt;likes_count = 1&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;6&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;increment(likes_count)&lt;/code&gt;，又加 1&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;likes_users = {888}&lt;/code&gt;, &lt;code&gt;likes_count = 2&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;从最终结果看, Set 中只有一个用户 (888), 但 &lt;code&gt;likes_count&lt;/code&gt; 变成了 2, 这就是「点赞数比实际多」的不一致情况, 要解决这个问题可以利用 Redis 命令本身返回值并在代码中加以判断:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;likePost&lt;/span&gt;(Long postId, Long userId) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String likesUsersKey &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;post:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; postId &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:likes_users&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String likesCountKey &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;post:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; postId &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:likes_count&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// sAddRet 要么是 1（成功加入，不在集合中），要么是 0（已存在，没加入）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Long sAddRet &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; redisTemplate.&lt;span style=&#34;color:#a6e22e&#34;&gt;opsForSet&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(likesUsersKey, userId);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (sAddRet &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; sAddRet &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; 0) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 只有在成功新加了用户的时候才执行加1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        redisTemplate.&lt;span style=&#34;color:#a6e22e&#34;&gt;opsForValue&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;increment&lt;/span&gt;(likesCountKey, 1);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 同时再发Kafka事件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        String event &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;like,&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; postId &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; userId;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        kafkaTemplate.&lt;span style=&#34;color:#a6e22e&#34;&gt;send&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;like-topic&amp;#34;&lt;/span&gt;, event);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样只有在成功加入到集合的时候, 才进行加1操作, 所以解决了上面的问题, 这样虽然可以解决, Redis 遇到多个操作如 检查 + 更新 这种场景的时候, 还是应该考虑&lt;strong&gt;利用分布式锁或者Lua脚本保证操作原子性&lt;/strong&gt;来解决问题,&lt;/p&gt;
&lt;p&gt;除此之外, 可以注意到上面的代码我们省略了 &lt;code&gt;isMember&lt;/code&gt; 判断, 因为我们的实现依赖 &lt;code&gt;SADD&lt;/code&gt; 的返回值来判定是否是第一次点赞,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring 的 &lt;code&gt;@Transactional&lt;/code&gt; 注解默认只对使用了关系型数据库（如 JPA / JDBC）的事务生效, 对于 RedisTemplate 的操作，除非你做了额外的配置（例如启用 Redis 事务支持，或使用了 Lua 脚本实现原子性操作），否则 Redis 并不会因为 Spring 事务回滚而自动回滚, 换句话说，一般情况下，Redis 操作默认是「非事务性」的，Spring 事务并不会对它生效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;4-高并发防止库存超卖&#34;&gt;4. 高并发防止库存超卖&lt;/h2&gt;
&lt;h3 id=&#34;41-redis--lua-脚本&#34;&gt;4.1. Redis + Lua 脚本&lt;/h3&gt;
&lt;p&gt;除了悲观锁和乐观锁, 还可以使用 Redis 来解决这个问题, 首先可能会想到的是利用 Redis 单线程特性, 伪代码如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;deductStock&lt;/span&gt;(String productId, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; amount) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;stock:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; productId;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 1. 检查库存&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Integer stock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; redis.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(key);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (stock &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; stock &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; amount) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 库存不足&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 2. 原子扣减&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Integer newStock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; redis.&lt;span style=&#34;color:#a6e22e&#34;&gt;decrBy&lt;/span&gt;(key, amount);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (newStock &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 0) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 库存不足，手动回滚&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        redis.&lt;span style=&#34;color:#a6e22e&#34;&gt;incrBy&lt;/span&gt;(key, amount);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 扣减成功&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;假设初始库存为 5, 两个线程 T1 和 T2 同时尝试扣减 3 个库存:&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;时间步&lt;/th&gt;
          &lt;th&gt;线程 T1&lt;/th&gt;
          &lt;th&gt;线程 T2&lt;/th&gt;
          &lt;th&gt;Redis 库存&lt;/th&gt;
          &lt;th&gt;备注&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;T1&lt;/td&gt;
          &lt;td&gt;GET 返回 5，检查 5 &amp;gt;= 3&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;T1 检查通过&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T2&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;GET 返回 5，检查 5 &amp;gt;= 3&lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;T2 检查通过&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T3&lt;/td&gt;
          &lt;td&gt;DECRBY 3，返回 2&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;T1 扣减成功，newStock = 2&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T4&lt;/td&gt;
          &lt;td&gt;检查 newStock = 2 &amp;gt;= 0，不回滚&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;T1 完成，库存合法&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T5&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;DECRBY 3，返回 -1&lt;/td&gt;
          &lt;td&gt;-1&lt;/td&gt;
          &lt;td&gt;T2 扣减，newStock = -1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;T6&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;检查 newStock = -1 &amp;lt; 0，回滚 3&lt;/td&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;T2 回滚，库存恢复到 2&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;库存最终值：2（T1 扣了 3，T2 扣了又回滚）, 似乎问题解决了, 但实际上这只是表面现象, 问题依然存在:&lt;/p&gt;
&lt;p&gt;虽然 &lt;code&gt;decrBy&lt;/code&gt; 本身是原子的, 但前面的检查（&lt;code&gt;get&lt;/code&gt; 和判断库存是否足够）与扣减之间不是一个原子操作, 当 &lt;code&gt;decrBy&lt;/code&gt; 执行后，如果结果小于 0，则会调用 &lt;code&gt;redis.incrBy&lt;/code&gt; 补偿库存，并返回扣减失败。这样虽然能保证最终库存不会维持在负值，但&lt;strong&gt;在短时间内可能出现库存负值的状态&lt;/strong&gt;，而且多个并发请求可能都进行补偿操作:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这会导致性能问题, 大量线程尝试扣减, 最终只有少数成功, 其他回滚, 浪费资源&lt;/li&gt;
&lt;li&gt;严重的情况是由于网络延迟等原因导致补偿操作不成功, 从而引起实际上的超卖问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以你看, 即使 Redis 是单线程, 所有发送到 Redis 服务器的指令都是一个个串行执行, 依然可能会出现并发问题,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;改进建议&lt;/strong&gt; 为了解决上述问题, 可以使用 Lua 脚本将库存检查和扣减操作封装成一个原子操作, 确保整个过程在 Redis 内部一次性执行, 从而消除检查与扣减之间的时间窗口, 例如, 可以使用如下 Lua 脚本来实现:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;local&lt;/span&gt; stock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; tonumber(redis.call(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;get&amp;#39;&lt;/span&gt;, KEYS[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; stock &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; stock &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; tonumber(ARGV[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]) &lt;span style=&#34;color:#66d9ef&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; redis.call(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;decrby&amp;#39;&lt;/span&gt;, KEYS[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;], ARGV[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;伪代码:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;deductStock&lt;/span&gt;(String productId, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; amount) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;stock:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; productId;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String luaScript &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;local stock = tonumber(redis.call(&amp;#39;GET&amp;#39;, KEYS[1]))\n&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                       &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;local amount = tonumber(ARGV[1])\n&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                       &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;if stock == nil then return -1 end\n&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                       &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;if stock &amp;lt; amount then return -2 end\n&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                       &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;local newStock = stock - amount\n&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                       &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;redis.call(&amp;#39;SET&amp;#39;, KEYS[1], newStock)\n&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                       &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;return newStock&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Lua 脚本在 Redis 内部执行, 效率极高&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Long result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; redis.&lt;span style=&#34;color:#a6e22e&#34;&gt;eval&lt;/span&gt;(luaScript, Collections.&lt;span style=&#34;color:#a6e22e&#34;&gt;singletonList&lt;/span&gt;(key), Collections.&lt;span style=&#34;color:#a6e22e&#34;&gt;singletonList&lt;/span&gt;(String.&lt;span style=&#34;color:#a6e22e&#34;&gt;valueOf&lt;/span&gt;(amount)));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; 0; &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;gt;= 0 表示扣减成功&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt; 虽然这个方案通过补偿操作在逻辑上试图防止超卖，但由于库存检查与扣减操作之间不是原子性的，仍然存在在高并发场景下出现短暂负库存（即“超卖”）的风险, 使用 Lua 脚本或分布式锁来保证整个扣减过程的原子性是更为稳妥的方案&lt;/p&gt;
&lt;h3 id=&#34;42-分布式锁&#34;&gt;4.2. 分布式锁&lt;/h3&gt;
&lt;p&gt;在方案二（Lua 脚本）中, 我们将“检查库存”和“扣减库存”封装成一个原子操作, &lt;strong&gt;完全在 Redis 内部执行&lt;/strong&gt;, 效率很高, 如果业务逻辑复杂, 例如扣减库存后需要异步更新数据库, 可以用 Redis 分布式锁来控制并发&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取锁： 使用 SETNX（Set if Not Exists）加锁：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SET lock:1001 1 EX 10 NX  # 设置锁，10秒过期
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;扣减库存： 获取锁后，检查并扣减库存：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;GET stock:1001
DECRBY stock:1001 2
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;释放锁： 操作完成后删除锁&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;DEL lock:1001
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;伪代码:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;deductStock&lt;/span&gt;(String productId, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; amount) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String lockKey &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;lock:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; productId;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String stockKey &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;stock:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; productId;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 获取分布式锁&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; locked &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; redis.&lt;span style=&#34;color:#a6e22e&#34;&gt;setNX&lt;/span&gt;(lockKey, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, 10);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;locked) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 获取锁失败, 被其他线程占用&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 检查库存&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Integer stock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; redis.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(stockKey);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (stock &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; stock &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; amount) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 扣减库存&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Integer newStock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; redis.&lt;span style=&#34;color:#a6e22e&#34;&gt;decrBy&lt;/span&gt;(stockKey, amount);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (newStock &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 0) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            redis.&lt;span style=&#34;color:#a6e22e&#34;&gt;incrBy&lt;/span&gt;(stockKey, amount); &lt;span style=&#34;color:#75715e&#34;&gt;// 回滚&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 异步更新数据库&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        asyncExecutor.&lt;span style=&#34;color:#a6e22e&#34;&gt;submit&lt;/span&gt;(() &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                updateDatabase(productId, amount);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            } &lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt; (Exception e) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 数据库更新失败，回滚 Redis&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                redis.&lt;span style=&#34;color:#a6e22e&#34;&gt;incrBy&lt;/span&gt;(stockKey, amount);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                log.&lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Database update failed, rolled back stock&amp;#34;&lt;/span&gt;, e);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#66d9ef&#34;&gt;finally&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        redis.&lt;span style=&#34;color:#a6e22e&#34;&gt;del&lt;/span&gt;(lockKey); &lt;span style=&#34;color:#75715e&#34;&gt;// 释放锁&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;43-总结&#34;&gt;4.3. 总结&lt;/h3&gt;
&lt;p&gt;Lua 脚本适用场景: 业务逻辑简单，只涉及 Redis 数据操作, Lua 脚本只能操作 Redis 的数据, 无法直接与外部系统（如数据库、消息队列）交互, 分布式锁适用场景: 库存扣减后需要与外部系统（如数据库）保持一致性&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Java 基础八股文</title>
      <link>https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/002-nuggets-java-basic/</link>
      <pubDate>Sat, 15 Feb 2025 10:30:20 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/002-nuggets-java-basic/</guid>
      <description>&lt;h2 id=&#34;1-访问控制修饰符&#34;&gt;1. 访问控制修饰符&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;访问修饰符&lt;/th&gt;
          &lt;th&gt;同一个类&lt;/th&gt;
          &lt;th&gt;同一个包&lt;/th&gt;
          &lt;th&gt;子类（不同包）&lt;/th&gt;
          &lt;th&gt;其他包&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;private&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;✅&lt;/td&gt;
          &lt;td&gt;❌&lt;/td&gt;
          &lt;td&gt;❌&lt;/td&gt;
          &lt;td&gt;❌&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;default&lt;/strong&gt;（无修饰符）&lt;/td&gt;
          &lt;td&gt;✅&lt;/td&gt;
          &lt;td&gt;✅&lt;/td&gt;
          &lt;td&gt;❌&lt;/td&gt;
          &lt;td&gt;❌&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;protected&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;✅&lt;/td&gt;
          &lt;td&gt;✅&lt;/td&gt;
          &lt;td&gt;✅&lt;/td&gt;
          &lt;td&gt;❌&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;public&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;✅&lt;/td&gt;
          &lt;td&gt;✅&lt;/td&gt;
          &lt;td&gt;✅&lt;/td&gt;
          &lt;td&gt;✅&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;2-java-类的生命周期&#34;&gt;2. Java 类的生命周期&lt;/h2&gt;
&lt;h3 id=&#34;21-基本概念&#34;&gt;2.1. 基本概念&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;类的生命周期包括: 加载 &amp;ndash;&amp;gt; 验证 &amp;ndash;&amp;gt; 准备 &amp;ndash;&amp;gt; 解析 &amp;ndash;&amp;gt; 初始化 &amp;ndash;&amp;gt; 使用 &amp;ndash;&amp;gt; 卸载&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;类只会被加载一次&lt;/strong&gt;, 即使 &lt;code&gt;new&lt;/code&gt; 了多个对象, 也不会重复加载,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类的加载是个连续的过程, 加载完就会进入验证, 准备等阶段&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类的初始化 vs 对象的初始化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类初始化是 JVM 处理静态变量和静态代码块的过程, 发生在类的生命周期中, 类的初始化只执行一次（类第一次被加载时）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对象初始化是创建对象并赋值实例变量的过程, 发生在实例化阶段（&lt;code&gt;new&lt;/code&gt; 关键字）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JVM 不会在程序启动时一次性加载所有类, 而是按需加载, 触发类加载的条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建类的实例（&lt;code&gt;new&lt;/code&gt; 操作）&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-访问控制修饰符&#34;&gt;1. 访问控制修饰符&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;访问修饰符&lt;/th&gt;
          &lt;th&gt;同一个类&lt;/th&gt;
          &lt;th&gt;同一个包&lt;/th&gt;
          &lt;th&gt;子类（不同包）&lt;/th&gt;
          &lt;th&gt;其他包&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;private&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;✅&lt;/td&gt;
          &lt;td&gt;❌&lt;/td&gt;
          &lt;td&gt;❌&lt;/td&gt;
          &lt;td&gt;❌&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;default&lt;/strong&gt;（无修饰符）&lt;/td&gt;
          &lt;td&gt;✅&lt;/td&gt;
          &lt;td&gt;✅&lt;/td&gt;
          &lt;td&gt;❌&lt;/td&gt;
          &lt;td&gt;❌&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;protected&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;✅&lt;/td&gt;
          &lt;td&gt;✅&lt;/td&gt;
          &lt;td&gt;✅&lt;/td&gt;
          &lt;td&gt;❌&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;public&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;✅&lt;/td&gt;
          &lt;td&gt;✅&lt;/td&gt;
          &lt;td&gt;✅&lt;/td&gt;
          &lt;td&gt;✅&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;2-java-类的生命周期&#34;&gt;2. Java 类的生命周期&lt;/h2&gt;
&lt;h3 id=&#34;21-基本概念&#34;&gt;2.1. 基本概念&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;类的生命周期包括: 加载 &amp;ndash;&amp;gt; 验证 &amp;ndash;&amp;gt; 准备 &amp;ndash;&amp;gt; 解析 &amp;ndash;&amp;gt; 初始化 &amp;ndash;&amp;gt; 使用 &amp;ndash;&amp;gt; 卸载&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;类只会被加载一次&lt;/strong&gt;, 即使 &lt;code&gt;new&lt;/code&gt; 了多个对象, 也不会重复加载,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类的加载是个连续的过程, 加载完就会进入验证, 准备等阶段&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类的初始化 vs 对象的初始化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类初始化是 JVM 处理静态变量和静态代码块的过程, 发生在类的生命周期中, 类的初始化只执行一次（类第一次被加载时）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对象初始化是创建对象并赋值实例变量的过程, 发生在实例化阶段（&lt;code&gt;new&lt;/code&gt; 关键字）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JVM 不会在程序启动时一次性加载所有类, 而是按需加载, 触发类加载的条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建类的实例（&lt;code&gt;new&lt;/code&gt; 操作）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问类的静态成员（静态变量、静态方法 类级别）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;调用 Class.forName(&amp;ldquo;类名&amp;rdquo;) 反射加载: &lt;code&gt;Class.forName()&lt;/code&gt; 直接强制 JVM 加载并初始化该类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子类初始化时，父类会先被初始化&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;引用类的静态常量（&lt;code&gt;static final&lt;/code&gt;）：不会触发类的加载, 因为 &lt;code&gt;static final&lt;/code&gt; 常量在编译时已确定, 编译器会直接替换值&lt;/p&gt;
&lt;h3 id=&#34;22-过程&#34;&gt;2.2. 过程&lt;/h3&gt;
&lt;h4 id=&#34;221-加载&#34;&gt;2.2.1. 加载&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;JVM 通过类的全限定名找到 &lt;code&gt;.class&lt;/code&gt; 文件，并读取字节码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 &lt;code&gt;java.lang.Class&lt;/code&gt; 对象（这只是一个描述类的对象，而不是类的实例！）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;222-验证&#34;&gt;2.2.2. 验证&lt;/h4&gt;
&lt;h4 id=&#34;223-准备&#34;&gt;2.2.3. 准备&lt;/h4&gt;
&lt;p&gt;为类的静态变量（&lt;code&gt;static&lt;/code&gt; 变量）分配内存，并赋默认值（不会执行具体的赋值操作）, 这里的 &amp;ldquo;默认值&amp;rdquo; 不是程序员写的值，而是 JVM 规定的默认初值&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Test&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 10;  &lt;span style=&#34;color:#75715e&#34;&gt;// 在 &amp;#34;准备&amp;#34; 阶段 a = 0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 20; &lt;span style=&#34;color:#75715e&#34;&gt;// b 是编译期常量，直接在 class 文件常量池中存储&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;224-解析-动态链接&#34;&gt;2.2.4. 解析 动态链接&lt;/h4&gt;
&lt;p&gt;在 Java 中，类、方法、变量等在 &lt;code&gt;.class&lt;/code&gt; 文件中以符号引用的形式&lt;strong&gt;存储在常量池&lt;/strong&gt;中。当 JVM 运行到 解析阶段 时，JVM 会&lt;strong&gt;根据符号引用找到实际的内存地址&lt;/strong&gt;，并替换掉符号引用。&lt;/p&gt;
&lt;p&gt;符号引用 是 &lt;code&gt;.class&lt;/code&gt; 文件中使用的逻辑地址，用于表示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;类和接口（如 &lt;code&gt;&amp;quot;java/lang/String&amp;quot;&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;字段（静态变量、实例变量）（如 &lt;code&gt;java/lang/System.out&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;方法（实例方法、静态方法）（如 &lt;code&gt;java/lang/String.length()&lt;/code&gt;）&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;String s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 &lt;code&gt;.class&lt;/code&gt; 文件的常量池中：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#1 = Class              #2 // java/lang/String
#2 = Utf8               java/lang/String
#3 = Methodref          #1.#4 // String.length()I
#4 = NameAndType        #5:#6 // length:()I
#5 = Utf8               length
#6 = Utf8               ()I
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里的 &lt;code&gt;#3 = Methodref&lt;/code&gt; 代表 &lt;code&gt;&amp;quot;java/lang/String.length()&amp;quot;&lt;/code&gt; 方法的符号引用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么要用符号引用，而不是一开始就存储内存地址？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一开始就存储内存地址, 就意味着 &lt;strong&gt;编译时&lt;/strong&gt;（而非运行时）就已经确定了一些关键的信息,&lt;/p&gt;
&lt;p&gt;函数、变量地址已经确定, 无法加载动态库（DLL、so）, 不同操作系统的 &lt;code&gt;syscall&lt;/code&gt; 地址不同也会导致兼容性问题。&lt;/p&gt;
&lt;p&gt;那 Java 还怎么实现跨平台呢? 就连 C, 大部分时候都是采用动态链接, 即一些标准库函数在编译后也只是符号连接, 在执行的时候动态链接阶段才会把符号引用换成内存地址,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C 语言的静态编译：地址是否确定？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 C 语言的静态编译 过程中，编译器和链接器（linker）会对程序进行地址分配，但这些地址是 相对地址（Relative Address），并不是 物理地址（Physical Address）。具体来说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编译阶段（Compilation）
&lt;ul&gt;
&lt;li&gt;C 源代码（&lt;code&gt;.c&lt;/code&gt;）转换成 目标文件（&lt;code&gt;.o&lt;/code&gt; 或 &lt;code&gt;.obj&lt;/code&gt;），此时变量和函数的地址是 符号引用（Symbolic Reference），还没有实际地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;链接阶段（Linking）
&lt;ul&gt;
&lt;li&gt;静态编译 时，链接器（Linker）会分配相对地址，并替换符号引用。&lt;/li&gt;
&lt;li&gt;可执行文件（&lt;code&gt;.exe&lt;/code&gt; / ELF）中的地址是 虚拟地址（Virtual Address），而非物理地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;加载（Loading）
&lt;ul&gt;
&lt;li&gt;操作系统（OS） 在运行 C 语言程序时，会使用 内存管理单元（MMU） 将虚拟地址映射到 实际物理地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以若程序编译后直接存储物理地址, 是不现实的, 除非一个机器只运行特定的一个程序,&lt;/p&gt;
&lt;h2 id=&#34;3-java-基本类型和包装类型的区别&#34;&gt;3. Java 基本类型和包装类型的区别&lt;/h2&gt;
&lt;p&gt;包装类型 (也叫引用类型) 就是把基础值包装成一个类然后添加一些常用工具方法, 基础类型就是最基本的, 告诉编译器分配多大内存空间&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：&lt;strong&gt;基本数据类型存放在栈中是一个常见的误区！&lt;/strong&gt; 基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆/方法区/元空间中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;4-自动装箱与拆箱&#34;&gt;4. 自动装箱与拆箱&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;装箱&lt;/strong&gt;：将基本类型用它们对应的引用类型包装起来；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;拆箱&lt;/strong&gt;：将包装类型转换为基本数据类型；调用包装类型对象的 &lt;code&gt;valueOf()&lt;/code&gt;方法&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Integer i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 10;  &lt;span style=&#34;color:#75715e&#34;&gt;//装箱&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i;   &lt;span style=&#34;color:#75715e&#34;&gt;//拆箱&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;5-泛型&#34;&gt;5. 泛型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;泛型类（需要显式声明）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Box&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; T value;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Box&lt;/span&gt;(T value) { &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; value; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 使用时必须写 &amp;lt;Integer&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Integer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; box &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;(123);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;泛型方法（自动推断）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;print&lt;/span&gt;(T value) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(value);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(123);      &lt;span style=&#34;color:#75715e&#34;&gt;// 自动推断 T = Integer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello&amp;#34;&lt;/span&gt;);  &lt;span style=&#34;color:#75715e&#34;&gt;// 自动推断 T = String&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的函数声明也可以改写为:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; T &lt;span style=&#34;color:#a6e22e&#34;&gt;print&lt;/span&gt;(T value) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(value);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;意思是, 函数 print 接受的参数值类型为 T, 返回值类型也是 T,&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;String str &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello, Generics!&amp;#34;&lt;/span&gt;);  &lt;span style=&#34;color:#75715e&#34;&gt;// 传入 String&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Integer num &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; print(100);                &lt;span style=&#34;color:#75715e&#34;&gt;// 传入 Integer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Double decimal &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; print(99.&lt;span style=&#34;color:#a6e22e&#34;&gt;99&lt;/span&gt;);           &lt;span style=&#34;color:#75715e&#34;&gt;// 传入 Double&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;泛型方法可以定义多个类型参数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 泛型方法可以定义多个类型参数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T, U&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;showPair&lt;/span&gt;(T first, U second) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;First: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; first &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;, Second: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; second);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;showPair(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Age&amp;#34;&lt;/span&gt;, 25);     &lt;span style=&#34;color:#75715e&#34;&gt;// String 和 Integer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;showPair(3.&lt;span style=&#34;color:#a6e22e&#34;&gt;14&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;);    &lt;span style=&#34;color:#75715e&#34;&gt;// Double 和 Boolean&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;showPair(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;A&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Apple&amp;#34;&lt;/span&gt;);  &lt;span style=&#34;color:#75715e&#34;&gt;// Character 和 String&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 输出&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;First: Age, Second: 25
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;First: 3.&lt;span style=&#34;color:#a6e22e&#34;&gt;14&lt;/span&gt;, Second: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;First: A, Second: Apple
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;6-lambda-表达式&#34;&gt;6. Lambda 表达式&lt;/h2&gt;
&lt;p&gt;把一个字符串转成整数，正常情况下可能要写一个完整的函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Converter&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;convert&lt;/span&gt;(String s);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MyConverter&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;implements&lt;/span&gt; Converter {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;convert&lt;/span&gt;(String s) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; Integer.&lt;span style=&#34;color:#a6e22e&#34;&gt;parseInt&lt;/span&gt;(s);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但用 Lambda 表达式，可以简化为一行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Converter converter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (s) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; Integer.&lt;span style=&#34;color:#a6e22e&#34;&gt;parseInt&lt;/span&gt;(s);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;为什么 &lt;code&gt;(s) -&amp;gt; Integer.parseInt(s)&lt;/code&gt; 可以赋值给 &lt;code&gt;Converter&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;Converter 是一个接口，里面有一个方法叫 convert, 任何实现这个接口的东西，都必须实现这个方法, Lambda 表达式 &lt;code&gt;(s) -&amp;gt; Integer.parseInt(s)&lt;/code&gt; 正好匹配 Converter 接口里 convert 方法的签名, 因为这个 Lambda 表达式完全符合 Converter 接口的要求，Java 允许把它直接赋值给 Converter 类型的变量。换句话说，&lt;code&gt;(s) -&amp;gt; Integer.parseInt(s)&lt;/code&gt; 就像是一个临时的、匿名的 Converter 实现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;7-函数式接口&#34;&gt;7. 函数式接口&lt;/h2&gt;
&lt;p&gt;Java 中有两种接口,  普通接口 和 函数式接口, 普通接口用于定义&lt;strong&gt;一组&lt;/strong&gt;相关的行为规范, 通常用于面向对象编程中的抽象和多态, 通过 implements 关键字由类显式实现, 函数式接口专为函数式编程设计, 表示&lt;strong&gt;单一&lt;/strong&gt;功能的抽象, 通常通过 Lambda 表达式、方法引用或匿名内部类实现, 不需要显式定义一个完整的类&lt;/p&gt;
&lt;p&gt;假设我们定义一个简单的函数式接口 Calculator，用于表示两个数的计算操作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@FunctionalInterface&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 可选注解，确保接口只有一个抽象方法&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Calculator&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;calculate&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用 Lambda 表达式实现:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Calculator addition &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (a, b) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;加法结果: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; addition.&lt;span style=&#34;color:#a6e22e&#34;&gt;calculate&lt;/span&gt;(5, 3)); &lt;span style=&#34;color:#75715e&#34;&gt;// 输出: 加法结果: 8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用方法引用实现:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Main&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Calculator addition &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Main::add;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;加法结果: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; addition.&lt;span style=&#34;color:#a6e22e&#34;&gt;calculate&lt;/span&gt;(5, 3)); &lt;span style=&#34;color:#75715e&#34;&gt;// 输出: 加法结果: 8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用匿名内部类实现:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Main&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 使用匿名内部类实现减法&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Calculator subtraction &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Calculator() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;@Override&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;calculate&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; b;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;减法结果: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; subtraction.&lt;span style=&#34;color:#a6e22e&#34;&gt;calculate&lt;/span&gt;(5, 3)); &lt;span style=&#34;color:#75715e&#34;&gt;// 输出: 减法结果: 2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Java 8 提供了一些常用的内置函数式接口，主要在 &lt;code&gt;java.util.function&lt;/code&gt; 包中：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;函数式接口&lt;/th&gt;
          &lt;th&gt;抽象方法&lt;/th&gt;
          &lt;th&gt;作用&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;Consumer&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;void accept(T t)&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;只接收参数，没有返回值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;Supplier&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;T get()&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;不接收参数，返回一个值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;Function&amp;lt;T, R&amp;gt;&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;R apply(T t)&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;接收一个参数，返回一个结果&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;Predicate&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;boolean test(T t)&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;进行条件判断，返回 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;Function&amp;lt;T, R&amp;gt;&lt;/code&gt; 也是函数式接口, 并不是什么高级的东西, 只不过添加了泛型, 定义如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@FunctionalInterface&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Function&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T, R&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 唯一抽象方法&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    R &lt;span style=&#34;color:#a6e22e&#34;&gt;apply&lt;/span&gt;(T t);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 默认方法：函数组合&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;V&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; Function&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;V, R&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;compose&lt;/span&gt;(Function&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;?&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;super&lt;/span&gt; V, &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; before) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Objects.&lt;span style=&#34;color:#a6e22e&#34;&gt;requireNonNull&lt;/span&gt;(before);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (V v) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; apply(before.&lt;span style=&#34;color:#a6e22e&#34;&gt;apply&lt;/span&gt;(v));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到 &lt;code&gt;Function&amp;lt;T, R&amp;gt;&lt;/code&gt; 只有一个抽象方法 &lt;code&gt;R apply(T t)&lt;/code&gt;, 也就是说实现了这个方法的 lambda 或者其他类, 都算是实现了该接口, 比如:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Function&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Double, Double&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; addTax &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; price &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; price &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; 1.&lt;span style=&#34;color:#a6e22e&#34;&gt;13&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 加13%的税&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; priceWithTax &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; addTax.&lt;span style=&#34;color:#a6e22e&#34;&gt;apply&lt;/span&gt;(discountedPrice);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;折扣后加税价: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; priceWithTax); &lt;span style=&#34;color:#75715e&#34;&gt;// 输出: 90.4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;泛型在 java 中有三种情况可以用: 类, 接口, 方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;8-方法引用&#34;&gt;8. 方法引用&lt;/h2&gt;
&lt;p&gt;当你的 Lambda 表达式只是调用一个&lt;strong&gt;已经存在的方法&lt;/strong&gt;时，可以用方法引用来代替，简单来说，方法引用是 Lambda 表达式的“快捷方式”&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;类名::静态方法
对象名::实例方法
类名::实例方法（特殊情况）
类名::new（构造方法引用）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;类名::静态方法&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 使用 Lambda 表达式&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Function&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String, Integer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; lambdaFunc &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; Integer.&lt;span style=&#34;color:#a6e22e&#34;&gt;parseInt&lt;/span&gt;(s);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 使用方法引用, 类名::静态方法&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Function&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String, Integer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; methodRefFunc &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Integer::parseInt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 测试&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(lambdaFunc.&lt;span style=&#34;color:#a6e22e&#34;&gt;apply&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;100&amp;#34;&lt;/span&gt;)); &lt;span style=&#34;color:#75715e&#34;&gt;// 输出 100&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(methodRefFunc.&lt;span style=&#34;color:#a6e22e&#34;&gt;apply&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;200&amp;#34;&lt;/span&gt;)); &lt;span style=&#34;color:#75715e&#34;&gt;// 输出 200&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对象名::实例方法&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;String str &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 使用 Lambda 表达式&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Runnable lambda &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; () &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(str.&lt;span style=&#34;color:#a6e22e&#34;&gt;toUpperCase&lt;/span&gt;());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 使用方法引用, 对象名::实例方法&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Runnable methodRef &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; str::toUpperCase;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 执行&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;lambda.&lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;(); &lt;span style=&#34;color:#75715e&#34;&gt;// 输出 HELLO&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;methodRef.&lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;(); &lt;span style=&#34;color:#75715e&#34;&gt;// 输出 HELLO&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;9-项目中哪里用到了泛型&#34;&gt;9. 项目中哪里用到了泛型?&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;PageDTO&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; List&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; content;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; pageNumber;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; totalElements;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; hasNext;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;PageConverter&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T, DTO&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; PageDTO&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;DTO&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;convertToPageDTO&lt;/span&gt;(Page&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; entityPage, Function&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T, DTO&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; converter) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        List&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;DTO&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; dtoList &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; entityPage.&lt;span style=&#34;color:#a6e22e&#34;&gt;getContent&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;stream&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                .&lt;span style=&#34;color:#a6e22e&#34;&gt;map&lt;/span&gt;(converter)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                .&lt;span style=&#34;color:#a6e22e&#34;&gt;collect&lt;/span&gt;(Collectors.&lt;span style=&#34;color:#a6e22e&#34;&gt;toList&lt;/span&gt;());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        PageDTO&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;DTO&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; pageDTO &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; PageDTO&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        pageDTO.&lt;span style=&#34;color:#a6e22e&#34;&gt;setContent&lt;/span&gt;(dtoList);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        pageDTO.&lt;span style=&#34;color:#a6e22e&#34;&gt;setPageNumber&lt;/span&gt;(entityPage.&lt;span style=&#34;color:#a6e22e&#34;&gt;getNumber&lt;/span&gt;());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        pageDTO.&lt;span style=&#34;color:#a6e22e&#34;&gt;setTotalElements&lt;/span&gt;(entityPage.&lt;span style=&#34;color:#a6e22e&#34;&gt;getTotalElements&lt;/span&gt;());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        pageDTO.&lt;span style=&#34;color:#a6e22e&#34;&gt;setHasNext&lt;/span&gt;(entityPage.&lt;span style=&#34;color:#a6e22e&#34;&gt;hasNext&lt;/span&gt;());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; pageDTO;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; PageDTO&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;PostDTO&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getUserPosts&lt;/span&gt;(Long userId, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; page, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; size) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 按创建时间降序排序，获取分页对象&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Pageable pageable &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; PageRequest.&lt;span style=&#34;color:#a6e22e&#34;&gt;of&lt;/span&gt;(page, size, Sort.&lt;span style=&#34;color:#a6e22e&#34;&gt;by&lt;/span&gt;(Sort.&lt;span style=&#34;color:#a6e22e&#34;&gt;Direction&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;DESC&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;createdAt&amp;#34;&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 查询该用户发布的帖子&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Page&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Post&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; postPage &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; postRepository.&lt;span style=&#34;color:#a6e22e&#34;&gt;findByUserIdAndStatus&lt;/span&gt;(userId, 1, pageable);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 查询该用户点赞过的帖子 ID&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    List&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Long&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; likedPostIds &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; postLikeRepository.&lt;span style=&#34;color:#a6e22e&#34;&gt;findPostIdsByUserId&lt;/span&gt;(userId);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; pageConverter.&lt;span style=&#34;color:#a6e22e&#34;&gt;convertToPageDTO&lt;/span&gt;(postPage,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            post &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; convertToDTO(post, likedPostIds.&lt;span style=&#34;color:#a6e22e&#34;&gt;contains&lt;/span&gt;(post.&lt;span style=&#34;color:#a6e22e&#34;&gt;getId&lt;/span&gt;())));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这段代码的作用是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从 &lt;code&gt;entityPage&lt;/code&gt; 中获取当前页的实体列表（&lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;converter&lt;/code&gt; 函数将每个实体 &lt;code&gt;T&lt;/code&gt; 转换为对应的 &lt;code&gt;DTO&lt;/code&gt; 对象&lt;/li&gt;
&lt;li&gt;将转换后的结果收集到一个新的 &lt;code&gt;List&amp;lt;DTO&amp;gt;&lt;/code&gt; 中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt; 是 &lt;code&gt;User&lt;/code&gt;（实体类），有字段 &lt;code&gt;id&lt;/code&gt; 和 &lt;code&gt;name&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DTO&lt;/code&gt; 是 &lt;code&gt;UserDTO&lt;/code&gt;（数据传输对象），有字段 &lt;code&gt;userId&lt;/code&gt; 和 &lt;code&gt;fullName&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;converter&lt;/code&gt; 定义为：&lt;code&gt;user -&amp;gt; new UserDTO(user.getId(), user.getName())&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果 &lt;code&gt;entityPage.getContent()&lt;/code&gt; 返回 &lt;code&gt;[User(1, &amp;quot;Alice&amp;quot;), User(2, &amp;quot;Bob&amp;quot;)]&lt;/code&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;stream()&lt;/code&gt; 创建一个流：&lt;code&gt;[User(1, &amp;quot;Alice&amp;quot;), User(2, &amp;quot;Bob&amp;quot;)]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;map(converter)&lt;/code&gt; 转换为：&lt;code&gt;[UserDTO(1, &amp;quot;Alice&amp;quot;), UserDTO(2, &amp;quot;Bob&amp;quot;)]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;collect(Collectors.toList())&lt;/code&gt; 得到：&lt;code&gt;List&amp;lt;UserDTO&amp;gt;&lt;/code&gt;，包含 &lt;code&gt;[UserDTO(1, &amp;quot;Alice&amp;quot;), UserDTO(2, &amp;quot;Bob&amp;quot;)]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最终，&lt;code&gt;dtoList&lt;/code&gt; 是一个包含转换后 &lt;code&gt;UserDTO&lt;/code&gt; 对象的列表&lt;/p&gt;
&lt;h2 id=&#34;10-反射&#34;&gt;10. 反射&lt;/h2&gt;
</content>
    </item>
    
    <item>
      <title>国内面试 OJ 平台调试</title>
      <link>https://blog.jiyi27.com/posts/interview/%E7%AE%97%E6%B3%95/004-oj%E5%B9%B3%E5%8F%B0%E7%89%9B%E5%AE%A2%E7%BD%91/</link>
      <pubDate>Fri, 14 Feb 2025 22:21:39 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E7%AE%97%E6%B3%95/004-oj%E5%B9%B3%E5%8F%B0%E7%89%9B%E5%AE%A2%E7%BD%91/</guid>
      <description>&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; sys
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# split() 默认会去掉换行符和多余的空格&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sys&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;stdin&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;read()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, len(data), &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(int(data[i]) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; int(data[i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      <content>&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; sys
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# split() 默认会去掉换行符和多余的空格&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sys&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;stdin&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;read()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, len(data), &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(int(data[i]) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; int(data[i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
    </item>
    
    <item>
      <title>算法题 链表系列</title>
      <link>https://blog.jiyi27.com/posts/interview/%E7%AE%97%E6%B3%95/003-link-algorithm/</link>
      <pubDate>Tue, 11 Feb 2025 10:50:52 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E7%AE%97%E6%B3%95/003-link-algorithm/</guid>
      <description>&lt;h2 id=&#34;1-dummy-head&#34;&gt;1. Dummy Head&lt;/h2&gt;
&lt;p&gt;链表 A B C, 我们若想移除 B, 需要 A.next = B.next, 所以当头部节点也有可能被移除的时候, 我们就需要一个 dummy 节点: D A B C, 从而实现 D.next = A.next 进而删除 A 节点,&lt;/p&gt;
&lt;p&gt;除此之外, 我们并不能直接移动 dummy 节点, 因为我们要记住 头部节点的位置, 用于函数返回, 不管这个头部 是 A, B 或者 C,&lt;/p&gt;
&lt;p&gt;我们要再使用一个节点 current, 通过 current = current.next 来遍历整个链表, 这样不管最后怎么变, dummy.next 都是最后形成的链表的第一个节点,&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ListNode&lt;/span&gt;(object):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; __init__(self, val&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, next&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;val &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; val
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; next
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;removeElements&lt;/span&gt;(self, head, val):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 用于记住头部节点&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    dummy &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ListNode(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, head)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    current &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dummy
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; current&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; current&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;val &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; val:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            current&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; current&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            current &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; current&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; dummy&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;2-交叉点&#34;&gt;2. 交叉点&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getIntersectionNode&lt;/span&gt;(self, headA: ListNode, headB: ListNode) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; ListNode:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ta, tb &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; headA, headB
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; ta &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; tb:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ta &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ta&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ta &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; headB
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        tb &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; tb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; tb &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; headA
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; tb
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;ta = ta.next if ta else headB&lt;/code&gt; 并不会报错, 即使 &lt;code&gt;ta&lt;/code&gt; 为 None, 因为这语句先执行 &lt;code&gt;if ta&lt;/code&gt;, 所以不会出现, None 不存在 next 属性的异常,&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-dummy-head&#34;&gt;1. Dummy Head&lt;/h2&gt;
&lt;p&gt;链表 A B C, 我们若想移除 B, 需要 A.next = B.next, 所以当头部节点也有可能被移除的时候, 我们就需要一个 dummy 节点: D A B C, 从而实现 D.next = A.next 进而删除 A 节点,&lt;/p&gt;
&lt;p&gt;除此之外, 我们并不能直接移动 dummy 节点, 因为我们要记住 头部节点的位置, 用于函数返回, 不管这个头部 是 A, B 或者 C,&lt;/p&gt;
&lt;p&gt;我们要再使用一个节点 current, 通过 current = current.next 来遍历整个链表, 这样不管最后怎么变, dummy.next 都是最后形成的链表的第一个节点,&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ListNode&lt;/span&gt;(object):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; __init__(self, val&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, next&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;val &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; val
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; next
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;removeElements&lt;/span&gt;(self, head, val):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 用于记住头部节点&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    dummy &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ListNode(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, head)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    current &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dummy
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; current&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; current&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;val &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; val:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            current&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; current&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            current &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; current&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; dummy&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;2-交叉点&#34;&gt;2. 交叉点&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getIntersectionNode&lt;/span&gt;(self, headA: ListNode, headB: ListNode) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; ListNode:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ta, tb &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; headA, headB
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; ta &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; tb:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ta &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ta&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ta &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; headB
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        tb &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; tb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; tb &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; headA
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; tb
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;ta = ta.next if ta else headB&lt;/code&gt; 并不会报错, 即使 &lt;code&gt;ta&lt;/code&gt; 为 None, 因为这语句先执行 &lt;code&gt;if ta&lt;/code&gt;, 所以不会出现, None 不存在 next 属性的异常,&lt;/p&gt;
&lt;h2 id=&#34;3-实现链表&#34;&gt;3. 实现链表&lt;/h2&gt;
&lt;p&gt;在做涉及到 index 和 size 相关的问题时, 一定要考虑清楚,  index 是从 0 开始 还是从 1 开始, 这很重要, 它告诉了我们 index 是不是 可以等于 size, 还是 size = index + 1&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; __init__(self, val&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, next&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;val &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; val
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; next
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MyLinkedList&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; __init__(self):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;head &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;size &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(self, index):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;size:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cur &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;head
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(index):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            cur &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cur&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; cur&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;val
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;addAtHead&lt;/span&gt;(self, val):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# self.head 只是一个 reference, 指向在堆上的对象, &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# 只有有引用指向对象, 对象就不会被清理&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# 这也是为什么我们可以这么操作&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        node &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Node(val, self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;head)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;head &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;size &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;# 更新长度&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;addAtTail&lt;/span&gt;(self, val):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# 链表相关的题, 每当访问某个节点的 next, &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# 就要想一下, 该节点有没有可能为空&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;head:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;head &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Node(val)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            cur &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;head
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; cur&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                cur &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cur&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            cur&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Node(val)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;size &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;# 更新长度&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;addAtIndex&lt;/span&gt;(self, index, val):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;size:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;# 超出范围，直接返回&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;addAtHead(val)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        dummy &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Node(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;head)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cur &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dummy
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(index):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            cur &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cur&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        node &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Node(val, cur&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cur&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;head &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dummy&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;size &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;# 更新长度&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;deleteAtIndex&lt;/span&gt;(self, index):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;size:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;# 超出范围，直接返回&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        dummy &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Node(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;head)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cur &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dummy
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(index):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            cur &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cur&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cur&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cur&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;head &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dummy&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;size &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;# 更新长度&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;用到了 prev 和 head, 即每次交换都是 prev 和 head 往下移动, 前者代表虚拟节点, 后者代表要交换的第一个,&lt;/p&gt;
&lt;p&gt;first 和 second 则代表两个要交换的节点, 这样 prev first second 三个配合交换, 交换之后, prev 往下移动, head 往下移动, 继续重复&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;swapPairs&lt;/span&gt;(self, head):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; head:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; head&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; head
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    dummy &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ListNode(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    dummy&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; head
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    prev &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dummy
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; head &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; head&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        first &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; head
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        second &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; head&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        prev&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; second
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        first&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; second&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        second&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; first
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        prev &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; first
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        head &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; first&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; dummy&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
    </item>
    
    <item>
      <title>算法题 数组系列</title>
      <link>https://blog.jiyi27.com/posts/interview/%E7%AE%97%E6%B3%95/002-array-algorithm/</link>
      <pubDate>Sun, 02 Feb 2025 15:28:52 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E7%AE%97%E6%B3%95/002-array-algorithm/</guid>
      <description>&lt;h2 id=&#34;1-列表常用操作&#34;&gt;1. 列表常用操作&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 844. Backspace String Compare&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;backspaceCompare&lt;/span&gt;(s, t):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    s_arr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    t_arr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; ch &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; s:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ch &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;#&amp;#39;&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            s_arr&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(ch) &lt;span style=&#34;color:#75715e&#34;&gt;# 列表可以直接 append&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;elif&lt;/span&gt; s_arr:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            s_arr&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pop() &lt;span style=&#34;color:#75715e&#34;&gt;# pop 之前要检查是否为空&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; ch &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; t:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ch &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;#&amp;#39;&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            t_arr&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(ch)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;elif&lt;/span&gt; t_arr:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            t_arr&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pop()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; t_arr &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; s_arr &lt;span style=&#34;color:#75715e&#34;&gt;# 直接比较列表即里面的字符是否顺序全部相同&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 977. Squares of a Sorted Array&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sortedSquares&lt;/span&gt;(self, nums: List[int]) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; List[int]:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; len(nums)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; n  &lt;span style=&#34;color:#75715e&#34;&gt;# 初始化 方便 index 访问&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    start, end &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 非常聪明的遍历方法, 不用重新倒序处理数组了&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; abs(nums[start]) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; abs(nums[end]):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            ans[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums[start] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; nums[start]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            start &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            ans[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums[end] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; nums[end]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            end &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ans
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; matrix &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; n &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(m)]  &lt;span style=&#34;color:#75715e&#34;&gt;# 初始化 n×m 矩阵&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 切片 反转整个字符串, 切片和操作不会改变原字符串, &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 它们会返回一个新字符串, 因为字符串 immutable&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;abcdefg&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(s[::&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;])  &lt;span style=&#34;color:#75715e&#34;&gt;# &amp;#34;gfedcba&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;abcdefg&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(s[::&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;])  &lt;span style=&#34;color:#75715e&#34;&gt;# &amp;#34;geca&amp;#34;  -&amp;gt; 每隔2个字符倒序取&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;abcdefg&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(s[:&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;])   &lt;span style=&#34;color:#75715e&#34;&gt;# &amp;#34;abcd&amp;#34;  -&amp;gt; 取前4个字符&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(s[&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;:])   &lt;span style=&#34;color:#75715e&#34;&gt;# &amp;#34;efg&amp;#34;   -&amp;gt; 从索引4开始取到结尾&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;abcdefg&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;k &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s[k:] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; s[:k]  &lt;span style=&#34;color:#75715e&#34;&gt;# 交换前 k 个字符和剩余部分&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(result)  &lt;span style=&#34;color:#75715e&#34;&gt;# &amp;#34;defgabc&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 541. 反转字符串 II&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;reverseStr&lt;/span&gt;(self, s: str, k: int) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; str:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; list(s)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, len(s), k &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        s[i: i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; k] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s[i: i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; k][::&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]  &lt;span style=&#34;color:#75715e&#34;&gt;# 创建该切片的反转副本&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;join(s)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;2-滑动窗口暴力遍历---209-长度最小的子数组&#34;&gt;2. 滑动窗口+暴力遍历 - 209 长度最小的子数组&lt;/h2&gt;
&lt;p&gt;注意子数组的意思是从一个数组任意截取连续的一段子数组, 不是从里面任取数字然后组合, 子序列也是这个概念,&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-列表常用操作&#34;&gt;1. 列表常用操作&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 844. Backspace String Compare&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;backspaceCompare&lt;/span&gt;(s, t):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    s_arr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    t_arr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; ch &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; s:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ch &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;#&amp;#39;&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            s_arr&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(ch) &lt;span style=&#34;color:#75715e&#34;&gt;# 列表可以直接 append&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;elif&lt;/span&gt; s_arr:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            s_arr&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pop() &lt;span style=&#34;color:#75715e&#34;&gt;# pop 之前要检查是否为空&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; ch &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; t:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ch &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;#&amp;#39;&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            t_arr&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(ch)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;elif&lt;/span&gt; t_arr:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            t_arr&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pop()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; t_arr &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; s_arr &lt;span style=&#34;color:#75715e&#34;&gt;# 直接比较列表即里面的字符是否顺序全部相同&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 977. Squares of a Sorted Array&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sortedSquares&lt;/span&gt;(self, nums: List[int]) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; List[int]:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; len(nums)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; n  &lt;span style=&#34;color:#75715e&#34;&gt;# 初始化 方便 index 访问&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    start, end &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 非常聪明的遍历方法, 不用重新倒序处理数组了&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; abs(nums[start]) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; abs(nums[end]):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            ans[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums[start] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; nums[start]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            start &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            ans[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums[end] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; nums[end]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            end &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ans
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; matrix &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; n &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(m)]  &lt;span style=&#34;color:#75715e&#34;&gt;# 初始化 n×m 矩阵&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 切片 反转整个字符串, 切片和操作不会改变原字符串, &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 它们会返回一个新字符串, 因为字符串 immutable&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;abcdefg&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(s[::&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;])  &lt;span style=&#34;color:#75715e&#34;&gt;# &amp;#34;gfedcba&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;abcdefg&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(s[::&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;])  &lt;span style=&#34;color:#75715e&#34;&gt;# &amp;#34;geca&amp;#34;  -&amp;gt; 每隔2个字符倒序取&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;abcdefg&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(s[:&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;])   &lt;span style=&#34;color:#75715e&#34;&gt;# &amp;#34;abcd&amp;#34;  -&amp;gt; 取前4个字符&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(s[&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;:])   &lt;span style=&#34;color:#75715e&#34;&gt;# &amp;#34;efg&amp;#34;   -&amp;gt; 从索引4开始取到结尾&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;abcdefg&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;k &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s[k:] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; s[:k]  &lt;span style=&#34;color:#75715e&#34;&gt;# 交换前 k 个字符和剩余部分&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(result)  &lt;span style=&#34;color:#75715e&#34;&gt;# &amp;#34;defgabc&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 541. 反转字符串 II&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;reverseStr&lt;/span&gt;(self, s: str, k: int) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; str:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; list(s)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, len(s), k &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        s[i: i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; k] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s[i: i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; k][::&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]  &lt;span style=&#34;color:#75715e&#34;&gt;# 创建该切片的反转副本&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;join(s)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;2-滑动窗口暴力遍历---209-长度最小的子数组&#34;&gt;2. 滑动窗口+暴力遍历 - 209 长度最小的子数组&lt;/h2&gt;
&lt;p&gt;注意子数组的意思是从一个数组任意截取连续的一段子数组, 不是从里面任取数字然后组合, 子序列也是这个概念,&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;minSubArrayLen&lt;/span&gt;(s: int, nums: List[int]) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; int:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# float(&amp;#39;-inf&amp;#39;) 负无穷大&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; float(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;inf&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sum_val &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sub_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(nums)):  &lt;span style=&#34;color:#75715e&#34;&gt;# 设置子序列起点为 i&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sum_val &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(i, len(nums)):  &lt;span style=&#34;color:#75715e&#34;&gt;# 注意第二层循环从 i 开始&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            sum_val &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; nums[j]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sum_val &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; s:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                sub_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; min(result, sub_length)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;# 一旦符合条件就 break&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; result &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; float(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;inf&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; result
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;minSubArrayLen&lt;/span&gt;(target, nums):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    min_len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; float(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;inf&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(nums)):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sum &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; nums[j]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; target:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            min_len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; min(j &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, min_len) &lt;span style=&#34;color:#75715e&#34;&gt;# 注意 j - i + 1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            sum &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; nums[i]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            i &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# python 不支持 i++, 精髓动态更新初始位置, 不断收缩窗口&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; min_len &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; min_len &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; float(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;inf&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# 常用语法&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;3-字典的使用---904-fruit-into-baskets&#34;&gt;3. 字典的使用 - 904. Fruit Into Baskets&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Find the longest continuous sub array that has exactly 2 distinct elements.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;找出下面代码的错误:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;totalFruit&lt;/span&gt;(self, fruits):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    max_len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    basket &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Counter()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(fruits)):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; len(basket) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            basket[fruits[j]] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            max_len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(max_len, j &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            j &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        i &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;del&lt;/span&gt; basket[fruits[i]]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; max_len
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;while 循环应当是用来收缩窗口的 (改变初始位置 &lt;code&gt;i&lt;/code&gt;),&lt;/strong&gt; 如果用来扩大窗口, 会导致 &lt;code&gt;j&lt;/code&gt; 不仅在 &lt;code&gt;for&lt;/code&gt; 循环里被迭代，还在 &lt;code&gt;while&lt;/code&gt; 里手动增加了 &lt;code&gt;j&lt;/code&gt;，这会导致以下问题：无限循环或 IndexError&lt;/li&gt;
&lt;li&gt;直接 &lt;code&gt;del basket[fruits[i]]&lt;/code&gt; 并不对, 想象我们的窗口是 [2, 3, 2, 2] 完整的数组是 [2, 3, 2, 2, 5], 此时篮子里的水果种类为 2, 所以我们让 &lt;code&gt;j&lt;/code&gt; 往右移动继续扩大, 我们的滑动窗口变为 [2, 3, 2, 2, 5] , 此时篮子里有 3 类水果, 因此缩小窗口, 移动 &lt;code&gt;i&lt;/code&gt;, 此时窗口为 [3, 2, 2, 5] , 若此时直接执行 &lt;code&gt;del basket[fruits[i]]&lt;/code&gt;, 也就是把类别 2 的水果全部倒出, 就不合理, 因为我们有 3 个类别 2 的水果, 我们要做的应该是让 basket[2] - 1, 即丢掉一个种类为 2 的水果, 只有当 basket[2] = 0 的时候才可以删除 种类为 2 的水果&lt;/li&gt;
&lt;li&gt;然后我们继续让 i 往右移动, 刚好种类为 3 的水果就一个, 我们直接丢掉, 然后删除, 这样 篮子里就剩两个种类为 2 的元素, 此时滑动窗口为 [2, 2, 5]&lt;/li&gt;
&lt;li&gt;此时篮子里的水果种类为 2, 因此 这也是为什么, 我们需要 while 循环, 一直让 i 往右移动, 缩小窗口, 直到 篮子里的水果种类大于 2 为 false 的时候, 窗口右侧 j 才能继续移动&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用 &lt;code&gt;Counter()&lt;/code&gt; 会造成不必要的开销, 在进行 &lt;code&gt;basket[fruits[i]] -= 1&lt;/code&gt; 这种操作的时候, 会执行一些检查, 并不是直接操作, 所以我们换为 defaultdict 速度更快一些:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;totalFruit&lt;/span&gt;(self, fruits):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;# 滑动窗口的左边界&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    max_len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;# 记录最大长度&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    basket &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {}  &lt;span style=&#34;color:#75715e&#34;&gt;# 记录当前窗口内的水果种类和数量&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(fruits)):  &lt;span style=&#34;color:#75715e&#34;&gt;# 遍历水果数组，j 是右指针&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        basket[fruits[j]] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; basket&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(fruits[j], &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;# 统计当前窗口内的水果数量&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# 如果窗口内的水果种类超过 2 种，移动左指针 i 缩小窗口&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; len(basket) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            basket[fruits[i]] &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;# 减少左边水果的个数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; basket[fruits[i]] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:  &lt;span style=&#34;color:#75715e&#34;&gt;# 如果某种水果数量变为 0，则从字典中删除&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;del&lt;/span&gt; basket[fruits[i]]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            i &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;# 左指针右移，缩小窗口&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# 记录当前窗口的最大长度&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        max_len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(max_len, j &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; max_len
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;虽然这题也是找连续子数组长度, 都使用双指针解决问题, 但与 209 长度最小的子数组 还是不同, 不同的地方是判断条件, 也就是收放窗口的条件, 之前的那道题的条件是判断 sum 总和和target的大小关系, 若 sum 更大, 则可以持续缩放窗口(while 循环条件), 而这道题的判断条件是数组中元素种类, 而且根据题意, 我们不可以简单的直接删除一个元素, 而是元素个数为0的时候才可以删除, 因此我们不仅需要元素种类, 而且需要知道该种类对应的元素个数, 因此只能使用哈希表, 不能使用比如 Set 这种一维数组,&lt;/p&gt;
&lt;h2 id=&#34;4-循环嵌套-58-length-of-last-word&#34;&gt;4. 循环嵌套 58 Length of Last Word&lt;/h2&gt;
&lt;p&gt;找出下面代码的逻辑问题, 最开始的解决思路, len 记录单词的长度, 每次遇到空格就会跳出 while 循环, 然后更新重新计算新的单词的长度,&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lengthOfLastWord&lt;/span&gt;(self, s):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(s)):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; s[i] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len(s):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            len &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            i &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; len
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关于 len 的重置有问题, 没有考虑最后有空格的情况, 比如 &lt;code&gt;&amp;quot;Hello World  &amp;quot;&lt;/code&gt;, 我们期望 5，实际输出是 0, 因为遍历完最后一个单词跳出 while 后, i 仍没越界, 此时重新进入 for 循环, len 又被重置为零, 可是后面的都是空格, 也不会进入 while 循环, len 一直为 0,&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lengthOfLastWord&lt;/span&gt;(self, s):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# len 是个函数, 命名重复&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(s)):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;# 这个重置会导致问题, 没有考虑最后有空格的情况&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# i &amp;lt; len(s) 这个检查并不安全, 应该先检查是否越界&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; s[i] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len(s):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            len &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            i &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# 最严重的问题在这, &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; len
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;i&lt;/code&gt; 在 while 循环中被改变了（&lt;code&gt;i += 1&lt;/code&gt;），但是这个 &lt;code&gt;i&lt;/code&gt; 也是 for 循环的控制变量。这会导致：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比如当 for 循环 i = 0 时&lt;/li&gt;
&lt;li&gt;while 循环增加 i 到 5&lt;/li&gt;
&lt;li&gt;但 for 循环下一轮会让 i = 1，&lt;strong&gt;又重新从头开始数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以&lt;strong&gt;永远不要在两个地方修改循环变量&lt;/strong&gt;, 正确的写法如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lengthOfLastWord&lt;/span&gt;(self, s):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;strip() &lt;span style=&#34;color:#75715e&#34;&gt;# 截取空格&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(s)):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; s[i] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            length &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; length
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但是这还不够高效, 可以直接从后面倒序遍历, 遇到空格就跳出:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lengthOfLastWord&lt;/span&gt;(self, s):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;strip()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 又一次出现了这个聪明的遍历方式&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(s) &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; s[i] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            length &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; length
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;5-代码输入输出调试&#34;&gt;5. 代码输入输出调试&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://kamacoder.com/problempage.php?pid=1070&#34;&gt;https://kamacoder.com/problempage.php?pid=1070&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; sys
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  	input &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sys&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;stdin&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;read &lt;span style=&#34;color:#75715e&#34;&gt;# 读取&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; input()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split()  &lt;span style=&#34;color:#75715e&#34;&gt;# 读取并拆分输入 (空白字符拆分&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    index &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(data[index])  &lt;span style=&#34;color:#75715e&#34;&gt;# 读取数组大小, 不要忘了 data 是字符数组&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    index &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    nums &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(n):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        nums&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(int(data[index &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; i]))  &lt;span style=&#34;color:#75715e&#34;&gt;# 读取数组的数值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    index &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; n  &lt;span style=&#34;color:#75715e&#34;&gt;# 读取完 nums 后移动 index&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 构建前缀和数组&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sums &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; n &lt;span style=&#34;color:#75715e&#34;&gt;# 初始化 不要忘了&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sums[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, n):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sums[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sums[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; nums[i]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len(data):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(data[index]) &lt;span style=&#34;color:#75715e&#34;&gt;# 转换为整数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(data[index &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        index &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;# 移动到下一个查询&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            result&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(sums[right])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            result&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(sums[right] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; sums[left &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; result:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        print(res)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; __name__ &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;__main__&amp;#34;&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    main()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;6-二维数组&#34;&gt;6. 二维数组&lt;/h2&gt;
&lt;p&gt;开发商购买土地: &lt;a href=&#34;https://kamacoder.com/problempage.php?pid=1044&#34;&gt;https://kamacoder.com/problempage.php?pid=1044&lt;/a&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;3 3
1 2 3
2 1 3
1 2 3
&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; sys
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    input &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sys&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;stdin&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;read 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; input()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    index &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(data[index])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(data[index &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    index &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    nums &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(n):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        row &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(m):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            num &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(data[index])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            row&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(num)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            index &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            sum &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; num
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        nums&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(row)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    horizontal &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; n
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(n):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(m):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            horizontal[i] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; nums[i][j]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vertical &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; m
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(m):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(n):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            vertical[j] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; nums[i][j]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; float(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;inf&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    horizontalCut &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(n):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        horizontalCut &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; horizontal[i]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# horizontalCut - (sum - horizontalCut) = 两个区域的差 取绝对值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; min(result, abs(sum &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; horizontalCut))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    verticalCut &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(m):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        verticalCut &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; vertical[j]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; min(result, abs(sum &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; verticalCut))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(result)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; __name__ &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;__main__&amp;#34;&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    main()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt;(object):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;generateMatrix&lt;/span&gt;(self, n):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        :type n: int
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        :rtype: List[List[int]]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        top &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        bottom &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        square &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; n
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; n &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(n)]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        num &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; num &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; square:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# 从左到右填充&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; col &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(left, right &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                result[top][col] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; num
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                num &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            top &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# 从上到下填充&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; row &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(top, bottom &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                result[row][right] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; num
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                num &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            right &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# 从右到左填充&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; top &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; bottom:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; col &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(right, left &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    result[bottom][col] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; num
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    num &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                bottom &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# 从下到上填充&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; right:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; row &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(bottom, top &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    result[row][left] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; num
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    num &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                left &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们的遍历范围在 &lt;strong&gt;左闭右闭&lt;/strong&gt;（即 &lt;code&gt;[left, right]&lt;/code&gt; 或 &lt;code&gt;[top, bottom]&lt;/code&gt;），也就是说，遍历时包括起点 &lt;code&gt;start&lt;/code&gt; 和终点 &lt;code&gt;end&lt;/code&gt;。这就是为什么我们在 &lt;code&gt;range()&lt;/code&gt; 里要 &lt;code&gt;+1&lt;/code&gt; 或 &lt;code&gt;-1&lt;/code&gt; 来确保终点被包含。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从右到左填充&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这一部分填充的是 &lt;strong&gt;当前最底部的行&lt;/strong&gt; (&lt;code&gt;bottom&lt;/code&gt; 行)。&lt;/li&gt;
&lt;li&gt;但此时，&lt;code&gt;top&lt;/code&gt; 已经向下移动了一格 (&lt;code&gt;top += 1&lt;/code&gt;)，所以需要 &lt;strong&gt;额外判断 &lt;code&gt;top &amp;lt;= bottom&lt;/code&gt;&lt;/strong&gt;，确保当前 &lt;code&gt;bottom&lt;/code&gt; 这行仍然 &lt;strong&gt;未被填充过&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;top &amp;gt; bottom&lt;/code&gt;，说明 &lt;code&gt;bottom&lt;/code&gt; 这一行已经被上面的填充覆盖了，不需要执行这一步。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;从下到上填充&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这一部分填充的是 &lt;strong&gt;当前最左侧的列&lt;/strong&gt; (&lt;code&gt;left&lt;/code&gt; 列)。&lt;/li&gt;
&lt;li&gt;但此时，&lt;code&gt;right&lt;/code&gt; 已经向左移动了一格 (&lt;code&gt;right -= 1&lt;/code&gt;)，所以需要 &lt;strong&gt;额外判断 &lt;code&gt;left &amp;lt;= right&lt;/code&gt;&lt;/strong&gt;，确保当前 &lt;code&gt;left&lt;/code&gt; 这列仍然 &lt;strong&gt;未被填充过&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;left &amp;gt; right&lt;/code&gt;，说明 &lt;code&gt;left&lt;/code&gt; 这一列已经被右边的填充覆盖了，不需要执行这一步。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在进入循环时，&lt;code&gt;top &amp;lt;= bottom&lt;/code&gt; 和 &lt;code&gt;left &amp;lt;= right&lt;/code&gt; 一定成立，因为矩阵初始是完整的，所以不需要额外判断。&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>算法题 动态规划 01 背包</title>
      <link>https://blog.jiyi27.com/posts/interview/%E7%AE%97%E6%B3%95/001-dp-algorithm/</link>
      <pubDate>Sat, 25 Jan 2025 16:55:20 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E7%AE%97%E6%B3%95/001-dp-algorithm/</guid>
      <description>&lt;p&gt;递推公式:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// dp[i][j] 表示从下标为 [0-i] 的物品里任意取, 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 放进容量为 j 的背包, 价值总和的最大值是 dp[i][j]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;dp[i][j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(dp[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;][j], dp[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;][j &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; weight[i]] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; value[i]);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;max(..., ...)&lt;/code&gt; 表示两种情况, 要么不选当前物品 &lt;code&gt;i&lt;/code&gt; 放入背包, 要么选&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;若不把当前物品 &lt;code&gt;i&lt;/code&gt; 放入背包, 背包的总价值为第  &lt;code&gt;i-1&lt;/code&gt;  个物品时, 背包的状态, 即被包容量为 &lt;code&gt;j&lt;/code&gt;, 从 &lt;code&gt;0 ~ i-1&lt;/code&gt; 任选放入, 价值为  &lt;code&gt;dp[i - 1][j]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选的话背包的总价值为 物品 &lt;code&gt;i&lt;/code&gt; 的价值 加上 背包减去 物品 &lt;code&gt;i&lt;/code&gt; 的重量后, 在第  &lt;code&gt;i-1&lt;/code&gt;  个物品的状态, 即 &lt;code&gt;dp[i - 1][j - weight[i]] + value[i]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为可以把 &lt;code&gt;dp[i - 1]&lt;/code&gt; 那一层拷贝到 &lt;code&gt;dp[i]&lt;/code&gt; 上, 表达式完全可以是：&lt;/p&gt;</description>
      <content>&lt;p&gt;递推公式:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// dp[i][j] 表示从下标为 [0-i] 的物品里任意取, 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 放进容量为 j 的背包, 价值总和的最大值是 dp[i][j]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;dp[i][j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(dp[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;][j], dp[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;][j &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; weight[i]] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; value[i]);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;max(..., ...)&lt;/code&gt; 表示两种情况, 要么不选当前物品 &lt;code&gt;i&lt;/code&gt; 放入背包, 要么选&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;若不把当前物品 &lt;code&gt;i&lt;/code&gt; 放入背包, 背包的总价值为第  &lt;code&gt;i-1&lt;/code&gt;  个物品时, 背包的状态, 即被包容量为 &lt;code&gt;j&lt;/code&gt;, 从 &lt;code&gt;0 ~ i-1&lt;/code&gt; 任选放入, 价值为  &lt;code&gt;dp[i - 1][j]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选的话背包的总价值为 物品 &lt;code&gt;i&lt;/code&gt; 的价值 加上 背包减去 物品 &lt;code&gt;i&lt;/code&gt; 的重量后, 在第  &lt;code&gt;i-1&lt;/code&gt;  个物品的状态, 即 &lt;code&gt;dp[i - 1][j - weight[i]] + value[i]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为可以把 &lt;code&gt;dp[i - 1]&lt;/code&gt; 那一层拷贝到 &lt;code&gt;dp[i]&lt;/code&gt; 上, 表达式完全可以是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;dp[i][j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(dp[i][j], dp[i][j &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; weight[i]] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; value[i]);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;即计算物品 i 的情况时, 不用再去看上一层(物品)的情况, 看当前就行了, 所以直接就可以把 &lt;code&gt;[i]&lt;/code&gt; 去掉, 得到:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;dp[j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(dp[j], dp[j &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; weight[i]] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; value[i]);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dp[j]&lt;/code&gt;: 相当于二维 &lt;code&gt;dp&lt;/code&gt; 数组中的 &lt;code&gt;dp[i-1][j]&lt;/code&gt;，即不放物品 &lt;code&gt;i&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[j - weight[i]] + value[i]&lt;/code&gt;: 就是放物品 &lt;code&gt;i&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后代码可以得到:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; weight.size(); i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) { &lt;span style=&#34;color:#75715e&#34;&gt;// 遍历物品
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bagWeight; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; weight[i]; j&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;) { &lt;span style=&#34;color:#75715e&#34;&gt;// 遍历背包容量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        dp[j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(dp[j], dp[j &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; weight[i]] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; value[i]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;即对于每个物品, 我们都要从背包的最大容量开始到容量等于物品 &lt;code&gt;i&lt;/code&gt; 的重量结束, 尝试去放物品 &lt;code&gt;i&lt;/code&gt;, 比如我们有 3 个物品, 价值为 &lt;code&gt;[10, 20, 50]&lt;/code&gt;, 重量为 &lt;code&gt;[4, 2, 6]&lt;/code&gt;, 背包容量为 6, 此时我们从第一个物品开始尝试:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果背包容量为 6 , 第一个物品放还是不放, 看哪个情况背包总价值大,  显然放入, 价值变大, 因为刚开始为 &lt;code&gt;dp[6] = 0&lt;/code&gt;, 所以我们得到 &lt;code&gt;dp[6] = dp[2] + value[0] = 0 + 10 = 10&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后我们尝试如果背包容量为 5 , 第一个物品放还是不放, 类似第一种情况, 我们得到: &lt;code&gt;dp[5] = dp[1] + value[0] = 0 + 10 = 10&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与上面相同, 如果背包容量为 4, 背包总价值也是 10, 之后我们就不尝试了, 因为 如果背包容量小于 4, 根本放不进去第一个物品, 所以默认此时以及之后的总价值为 0,&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后我们尝试第二个物品, 对于第二个物品, 同样从背包容量为 6 开始尝试:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果背包容量为 6, 第二个物品放还是不放, 比较这两种情况下背包的总价值, 此时，放入第二个物品后, &lt;code&gt;dp[6] = dp[4] + value[1] = 10 + 20 = 30&lt;/code&gt;, 总价值变大了, 所以我们更新 &lt;code&gt;dp[6] = 30&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;接着尝试背包容量为 5，同样比较放入或不放入的情况。放入第二个物品后，&lt;code&gt;dp[5] = dp[3] + value[1] = 0 + 20 = 20&lt;/code&gt;，而之前 &lt;code&gt;dp[5] = 10&lt;/code&gt;，因此更新 &lt;code&gt;dp[5] = 20&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;以此类推, 背包容量为 2 时，放入第二个物品后，&lt;code&gt;dp[2] = dp[0] + value[1] = 0 + 20 = 20&lt;/code&gt;，更新 &lt;code&gt;dp[2] = 20&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;背包容量小于 2 时无法放入第二个物品，因此对应的 &lt;code&gt;dp&lt;/code&gt; 值不变&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，我们尝试第三个物品：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果背包容量为 6, 第三个物品放还是不放, 放入第三个物品后，&lt;code&gt;dp[6] = dp[0] + value[2] = 0 + 50 = 50&lt;/code&gt;，而之前 &lt;code&gt;dp[6] = 30&lt;/code&gt;，因此更新 &lt;code&gt;dp[6] = 50&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;背包容量为 5 或更小的情况时，第三个物品的重量（6）已经超过当前容量，无法放入，因此对应的 &lt;code&gt;dp&lt;/code&gt; 值保持不变&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里我们选择&lt;strong&gt;倒序遍历是为了避免同一个物品被放入两次&lt;/strong&gt;, 还以上面例子为例, 我们&lt;strong&gt;尝试放第一个物品&lt;/strong&gt;,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;刚开始我们假设背包容量为 0, 1, 2, 3 此时不能放下第一个物品, 因此 &lt;code&gt;dp[0~3] = 0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果 背包容量为 1, 此时也不能发下第一个物品, 然后被包容量为 2, 3, 都是相同情况, 所以 &lt;code&gt;dp[0~4] = 0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果背包容量为 4, 此时可以放下第一个物品, 放还是不放呢, 比较 &lt;code&gt;dp[4]&lt;/code&gt; 和 &lt;code&gt;dp[4 - weight[0]] + value[0]&lt;/code&gt;, 显然要放, 因为  &lt;code&gt;dp[4]&lt;/code&gt; 现在还为 0, 所以 我们选择 &lt;code&gt;dp[4] = dp[4 - weight[0]] + value[0] = dp[0] + value[0] = 10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此时 &lt;code&gt;dp[0~6]&lt;/code&gt; 的值为: &lt;code&gt;0, 0, 0, 0, 10, 10, 10&lt;/code&gt;, 这都没什么问题, 接下来我们来&lt;strong&gt;尝试放第二个物品&lt;/strong&gt;,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;刚开始背包容量为 0, 1, 放不下, 所以我们从背包容量为 2 开始&lt;/li&gt;
&lt;li&gt;如果背包容量为 2，比较 &lt;code&gt;dp[2]&lt;/code&gt; 和 &lt;code&gt;dp[2 - weight[1]] + value[1]&lt;/code&gt;，即 &lt;code&gt;dp[2]&lt;/code&gt; 和 &lt;code&gt;dp[0] + value[1]&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;我们遍历第一个物品的时候, &lt;code&gt;dp[0~3] = 0&lt;/code&gt;, 所以此时 &lt;code&gt;dp[2]=0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;若我们选择放入 &lt;code&gt;dp[2]&lt;/code&gt;,  放入后 &lt;code&gt;dp[2] = dp[0] + value[1] = 0 + 20 = 20&lt;/code&gt;，更新 &lt;code&gt;dp[2] = 20&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果背包容量为 3，与上面相同, 此时我们判断放还是不放第二个物品
&lt;ul&gt;
&lt;li&gt;不放第二个物品, &lt;code&gt;dp[3] = dp[3] = 0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;放第二个物品，&lt;code&gt;dp[3] = dp[3 - weight[1]] + value[1] = dp[1] + value[1] = 0 + 20 = 20&lt;/code&gt;，更新 &lt;code&gt;dp[3] = 20&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意此时  &lt;code&gt;dp[0~6]&lt;/code&gt; 的值为: &lt;code&gt;0, 0, 20, 20, 10, 10, 10&lt;/code&gt;,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果背包容量为 4
&lt;ul&gt;
&lt;li&gt;不放第二个物品, &lt;code&gt;dp[4] = 10&lt;/code&gt;, 我们遍历第一个物品时, 更新了这个值,&lt;/li&gt;
&lt;li&gt;放第二个物品，&lt;code&gt;dp[4] = dp[4 - weight[1]] + value[1] = dp[2] + value[1] = 20 + 20 = 40&lt;/code&gt;。由于之前的 &lt;code&gt;dp[4] = 10&lt;/code&gt;，我们选择更新 &lt;code&gt;dp[4] = 40&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有没有发现, 此时 我们把 第二个物品 放入了两次, 因为 &lt;code&gt;dp[2] = 20&lt;/code&gt; 的值就是这轮循环(&lt;strong&gt;尝试放第二个物品&lt;/strong&gt;)中前面通过放入 第二个物品得来的, 现在只是容量变大了, 我们又放一次第二个物品, 即 &lt;code&gt;value[1]&lt;/code&gt; 和 &lt;code&gt;dp[2]&lt;/code&gt; 相加, 这不就是重复了吗,&lt;/p&gt;
&lt;p&gt;或者说我们的算法的本质后面的状态又是根据前面的状态推断出来的, 也就是公式  &lt;code&gt;dp[j] = dp[j - weight[i]] + value[i])&lt;/code&gt; 的问题, 因为 &lt;code&gt;j - weight[i]&lt;/code&gt; 一定比 &lt;code&gt;j&lt;/code&gt; 小 嘛,&lt;/p&gt;
&lt;p&gt;此时我们还按背包容量从小到大遍历, 那对于同一个物品, 后面就有可能遇到 背包已经放了 这个物品的 状态, 此时再和物品 value 相加, 就重复了, 所以我们要从后往前, 这样, 可以保证&lt;strong&gt;前面的状态肯定没有放过当前物品&lt;/strong&gt;, 注意这里前面的状态指的是, 背包的容量比较小的状态,&lt;/p&gt;
&lt;p&gt;比如对于容量为 4 来说,  0, 1, 2, 3, 就是前面的状态, 所以对于同一个物品, 当我们从背包容量 4 遍历到背包容量 0 使用我们的递推公式来分别计算背包容量为 4, 3, 2, 1, 0 时的价值, &lt;code&gt;dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);&lt;/code&gt;, 肯定不会遇到, 已经放了当前物品已经被放过的状态, 因为 &lt;code&gt;dp[j] = dp[j - weight[i]] + value[i])&lt;/code&gt; 中, &lt;code&gt;j - weight[i]&lt;/code&gt; 一定比 &lt;code&gt;j&lt;/code&gt; 小,&lt;/p&gt;
&lt;p&gt;了解更多: &lt;a href=&#34;https://www.zhihu.com/question/23995189/answer/613096905&#34;&gt;https://www.zhihu.com/question/23995189/answer/613096905&lt;/a&gt;&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>后端八股文</title>
      <link>https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/003-nuggets-backend/</link>
      <pubDate>Wed, 22 Jan 2025 15:30:20 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/003-nuggets-backend/</guid>
      <description>&lt;h2 id=&#34;1-sessions-状态管理&#34;&gt;1. Sessions 状态管理&lt;/h2&gt;
&lt;p&gt;JWT由三部分组成, Header, Payload, Signature, JWT 的 Header 和 Payload 部分是经过 Base64 URL 编码的, 本质上是“明文”的, 不适合在Payload中存储敏感信息, 只有Signature部分是经过加密的, 用于验证数据的完整性. 了解更多: &lt;a href=&#34;https://jwt.io/&#34;&gt;https://jwt.io/&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JWTs provide a means of maintaining session state on the client instead of doing it on the server.&lt;/p&gt;
&lt;p&gt;With server-side sessions, you will either have to &lt;strong&gt;store the session identifier in a database&lt;/strong&gt;, or else &lt;strong&gt;keep it in memory&lt;/strong&gt; and make sure that the client always hits the same server.&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-sessions-状态管理&#34;&gt;1. Sessions 状态管理&lt;/h2&gt;
&lt;p&gt;JWT由三部分组成, Header, Payload, Signature, JWT 的 Header 和 Payload 部分是经过 Base64 URL 编码的, 本质上是“明文”的, 不适合在Payload中存储敏感信息, 只有Signature部分是经过加密的, 用于验证数据的完整性. 了解更多: &lt;a href=&#34;https://jwt.io/&#34;&gt;https://jwt.io/&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JWTs provide a means of maintaining session state on the client instead of doing it on the server.&lt;/p&gt;
&lt;p&gt;With server-side sessions, you will either have to &lt;strong&gt;store the session identifier in a database&lt;/strong&gt;, or else &lt;strong&gt;keep it in memory&lt;/strong&gt; and make sure that the client always hits the same server.&lt;/p&gt;
&lt;p&gt;Moving the session to the client means that you remove the dependency on a server-side session, but it imposes its own set of challenges.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Storing the token securely. (禁止 客户端 JS 代码访问 token, 可以把 token 放到 cookie 中, 然后设置该 cookie 为 HTTP only)&lt;/li&gt;
&lt;li&gt;Transporting it securely. (后端设置 cookie, 只允许通过 HTTPS 传输)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;[Stackoverflow][https://stackoverflow.com/a/45214431/16317008]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-ab-压测-大部分请求失败&#34;&gt;2. AB 压测 大部分请求失败&lt;/h2&gt;
&lt;p&gt;有时候测试会遇到大部分请求都显示失败, 可是实际服务端却是执行成功了,  可能一个原因是 &lt;code&gt;ab&lt;/code&gt; 运行负载测试时，它默认会检查所有响应的长度是否一致。如果服务器返回的响应长度不一致，&lt;code&gt;ab&lt;/code&gt; 会报错，认为测试结果不可靠。&lt;code&gt;-l&lt;/code&gt; 选项允许 &lt;code&gt;ab&lt;/code&gt; 忽略这些长度变化。&lt;a href=&#34;https://stackoverflow.com/a/28435814/16317008&#34;&gt;了解更多&lt;/a&gt;&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>QPS TPS PV 等概念</title>
      <link>https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/001-qps-pv/</link>
      <pubDate>Tue, 21 Jan 2025 18:20:10 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E5%90%8E%E7%AB%AF/001-qps-pv/</guid>
      <description>&lt;p&gt;&lt;strong&gt;PV（Page View，页面浏览量）：&lt;/strong&gt; 指的是页面被浏览的总次数。用户每次打开一个页面，就算作一次 PV。同一个用户多次访问同一页面，PV 也会累加。PV 是衡量网站流量的重要指标，但它不能反映实际访问的用户数量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;QPS（Query Per Second，每秒查询数）：&lt;/strong&gt; 指的是系统每秒能够处理的请求数量。QPS 是衡量系统吞吐能力的重要指标。比如说某 API 支持 200 QPS，就是说这个接口可以做到每秒查寻 200 次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TPS（Transactions Per Second，每秒事务数）&lt;/strong&gt;: TPS 指的是每秒钟系统能够处理的事务数量, 一个事务通常包含多个操作, 例如一次完整的订单提交、一次银行转账等, 在一些简单的系统中，一个请求就是一个事务，此时 QPS 和 TPS 相等。但在复杂的系统中，一个事务可能包含多次查询，此时 TPS 通常小于 QPS.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并发数：&lt;/strong&gt; 指的是系统同时能够处理的请求数量, 假设一个系统的 QPS 是 1000, 平均每个请求的处理时间是 100 毫秒, 那么这个系统的并发数大约为 1000 * 0.1 = 100 (1 s 处理 1000 个请求, 那 0.1 秒可以处理 100 个)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;想象一个水龙头（请求入口），水流速度是每秒 1000 毫升（QPS）。水流到一个水管（系统），水管的长度决定了水在里面停留的时间，假设水在水管中需要 0.1 秒才能流出（平均处理时间）。&lt;/p&gt;
&lt;p&gt;那么在任何时刻，水管中都存有多少水呢？答案是 1000 毫升/秒 * 0.1 秒 = 100 毫升。这 100 毫升水就相当于并发数。&lt;/p&gt;</description>
      <content>&lt;p&gt;&lt;strong&gt;PV（Page View，页面浏览量）：&lt;/strong&gt; 指的是页面被浏览的总次数。用户每次打开一个页面，就算作一次 PV。同一个用户多次访问同一页面，PV 也会累加。PV 是衡量网站流量的重要指标，但它不能反映实际访问的用户数量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;QPS（Query Per Second，每秒查询数）：&lt;/strong&gt; 指的是系统每秒能够处理的请求数量。QPS 是衡量系统吞吐能力的重要指标。比如说某 API 支持 200 QPS，就是说这个接口可以做到每秒查寻 200 次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TPS（Transactions Per Second，每秒事务数）&lt;/strong&gt;: TPS 指的是每秒钟系统能够处理的事务数量, 一个事务通常包含多个操作, 例如一次完整的订单提交、一次银行转账等, 在一些简单的系统中，一个请求就是一个事务，此时 QPS 和 TPS 相等。但在复杂的系统中，一个事务可能包含多次查询，此时 TPS 通常小于 QPS.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并发数：&lt;/strong&gt; 指的是系统同时能够处理的请求数量, 假设一个系统的 QPS 是 1000, 平均每个请求的处理时间是 100 毫秒, 那么这个系统的并发数大约为 1000 * 0.1 = 100 (1 s 处理 1000 个请求, 那 0.1 秒可以处理 100 个)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;想象一个水龙头（请求入口），水流速度是每秒 1000 毫升（QPS）。水流到一个水管（系统），水管的长度决定了水在里面停留的时间，假设水在水管中需要 0.1 秒才能流出（平均处理时间）。&lt;/p&gt;
&lt;p&gt;那么在任何时刻，水管中都存有多少水呢？答案是 1000 毫升/秒 * 0.1 秒 = 100 毫升。这 100 毫升水就相当于并发数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;可以通过 PV 来估算网站的峰值 QPS, 根据 28 定理, 80%的请求发生在20%的时间内:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;峰值 QPS ≈ (总 PV 数 * 80%) / (每天秒数 * 20%)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;假设一个网站每天的 PV 是 100 万，那么它的峰值 QPS 大约为 (1000000 * 0.8) / (86400 * 0.2) ≈ 46。这意味着&lt;strong&gt;在访问高峰期(20%的时间)&lt;/strong&gt;，网站需要每秒处理约 46 个请求,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我说下我目前接触下来比较合理的 QPS 范围：带了数据库的服务一般写性能在 5k 以下，读性能一般在 10k 以下，能到 10k 以上的话，那很可能是在数据库前面加了层缓存。&lt;/p&gt;
&lt;p&gt;比如候选人上来就说服务单实例 API 读写性能都有上万 QPS, 那我可以大概猜到这&lt;strong&gt;应该&lt;/strong&gt;是个纯 cpu+内存的 API 链路。但如果候选人还说这里面没做缓存且有数据库调用，那我可能会追问这里头用的是哪款数据库，底层是什么&lt;a href=&#34;https://zhida.zhihu.com/search?content_id=239847572&amp;amp;content_type=Article&amp;amp;match_order=1&amp;amp;q=%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e&amp;amp;zhida_source=entity&#34;&gt;存储引擎&lt;/a&gt;？&lt;/p&gt;
&lt;p&gt;此段摘自: &lt;a href=&#34;https://zhuanlan.zhihu.com/p/682728083&#34;&gt;https://zhuanlan.zhihu.com/p/682728083&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意我们可以通过一个网站的 PV 来估算它需要的 QPS, 一般网站都是一百以内的 QPS, 因为 100 QPS 就意味着  216万 PV 了, 反推：总 PV 数 = (峰值 QPS * 每天秒数 * 20%) / 80%&lt;/p&gt;
&lt;p&gt;但是这只是估算一天 20% 时间的 QPS, 实际比这复杂, 比如淘宝那种, 某个时间点, 很多人冲进直播间买东西, 这就不能通过上面的方式来计算网站需要的 QPS 了, 这个时候就要看我们服务器最多可以支持多大 QPS, 和网站每天峰值 QPS 估算不是一个场景了,&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;上面我们已经提到: &lt;code&gt;并发数 = QPS / RT(响应时间)&lt;/code&gt;, 因此: &lt;code&gt;QPS = 并发数 * RT&lt;/code&gt;, 这是不是说, 并发数越高, 我们的 QPS 就会越高呢, 从公式可以看出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在平均响应时间不变的情况下，并发数越高，QPS越高&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果并发数不变，平均响应时间越短，QPS越高&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可是不要忽略: &lt;strong&gt;并发数和平均响应时间是相互影响的&lt;/strong&gt;, 在并发数设置过大时, API 同时要处理很多请求, 我们知道每个请求, 服务器都会开启一个新的线程或者协程, 用线程的时候一般都会用线程池, 因为频繁创建删除线程也是有代价的, 另外线程池可以用来控制线程总数: 并发度.&lt;/p&gt;
&lt;p&gt;不要忘了, 线程是有时间片的, 并不是说我们开启 1000 个线程, 就真的是 1000 个线程在同时运行, 所以当并发 HTTP 请求增加时, 就会导致大量线程在 READY 队列等待 CPU, 每个线程分配到的CPU时间片减少, 这个时候就会导致大量的上下文切换, 也就是线程实际干活的时间越来越短, 时间都浪费在了上下文切换上,&lt;/p&gt;
&lt;p&gt;所以并发数过大时，API 同时要处理很多请求，会频繁切换上下文，而真正用于处理请求的时间变少，请求响应时间也会变长, 反而使得 QPS 会降低, 一般 API 会有一个合适的并发数，在该并发数下，API 的 QPS 可以达到最大，但该并发数不一定是最佳并发数，还要参考该并发数下的平均请求响应时间。&lt;/p&gt;
&lt;p&gt;比如下面这个API压测数据，并发50至并发300的QPS都是220左右，但是并发2000的平均请求响应时间是60ms，平均QPS下降到33，那么我们可以理解为并发2000下API处于不可用状态了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pub-2a6758f3b2d64ef5bb71ba1601101d35.r2.dev/blogs/2025/01/8dbc603d578987e024070cdad7b84227.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;来源: &lt;a href=&#34;https://zhuanlan.zhihu.com/p/609348456&#34;&gt;https://zhuanlan.zhihu.com/p/609348456&lt;/a&gt;&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>敏捷开发(Scrum) 和 瀑布开发 以及 Jira 工具</title>
      <link>https://blog.jiyi27.com/posts/interview/%E5%85%B6%E5%AE%83/001-jira-scrum/</link>
      <pubDate>Wed, 19 Jun 2024 18:12:21 +0000</pubDate>
      
      <guid>https://blog.jiyi27.com/posts/interview/%E5%85%B6%E5%AE%83/001-jira-scrum/</guid>
      <description>&lt;h2 id=&#34;1-敏捷开发-vs-scrum&#34;&gt;1. 敏捷开发 vs Scrum&lt;/h2&gt;
&lt;p&gt;敏捷开发是一种 软件开发理念，强调：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发周期短，频繁交付小版本。&lt;/li&gt;
&lt;li&gt;需求可以随时调整，而不是一开始就确定所有需求&lt;/li&gt;
&lt;li&gt;强调团队沟通，减少文档负担&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;敏捷开发的理念来自 《敏捷宣言（Agile Manifesto）》：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;个体和互动 &amp;gt; 过程和工具&lt;/li&gt;
&lt;li&gt;可工作的软件 &amp;gt; 详尽的文档&lt;/li&gt;
&lt;li&gt;客户合作 &amp;gt; 合同谈判&lt;/li&gt;
&lt;li&gt;响应变化 &amp;gt; 遵循计划&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;strong&gt;对比项&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;敏捷开发（Agile）&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;Scrum（Scrum 只是 Agile 的一种）&lt;/strong&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;概念&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;一种理念/开发方法论&lt;/td&gt;
          &lt;td&gt;一种具体的敏捷开发框架&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;灵活性&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;可以灵活选择方法&lt;/td&gt;
          &lt;td&gt;需要遵循固定规则（角色、事件、Sprint）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;开发周期&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;持续迭代&lt;/td&gt;
          &lt;td&gt;Sprint（一般 1-4 周）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;任务管理&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;任何任务管理方式&lt;/td&gt;
          &lt;td&gt;通过 Product Backlog、Sprint Backlog&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;团队结构&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;没有固定角色&lt;/td&gt;
          &lt;td&gt;必须有 Scrum Master、Product Owner、开发团队&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;2-scrum-实际例子-小型web应用开发团队&#34;&gt;2. Scrum 实际例子 小型Web应用开发团队&lt;/h2&gt;
&lt;h3 id=&#34;21-团队组成&#34;&gt;2.1. 团队组成&lt;/h3&gt;
&lt;p&gt;假设有一个小团队正在开发一个在线电商网站，团队成员包括产品负责人(Product Owner/PO)、Scrum Master、开发、测试和设计人员。&lt;/p&gt;
&lt;h3 id=&#34;22-产品-backlog&#34;&gt;2.2. 产品 Backlog&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;产品负责人(PO)&lt;/strong&gt; 根据市场调研、用户反馈和竞争对手分析，将用户需求转化为用户故事，记录在产品 Backlog 中。比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户故事1：作为一个顾客，我希望在网站上能够搜索商品，以便快速找到我需要的产品&lt;/li&gt;
&lt;li&gt;用户故事2：作为一个顾客，我希望能够在购物车中添加和删除商品，以便管理我的购物清单。&lt;/li&gt;
&lt;li&gt;用户故事3：作为一个管理员，我希望能够管理商品库存，以便保证网站商品信息的准确性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些用户故事通常会包括详细的描述、验收标准以及大致的业务价值和优先级。产品 Backlog 不仅包含新功能，还可能包含优化现有功能、技术债务和缺陷修复等工作项。&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;1-敏捷开发-vs-scrum&#34;&gt;1. 敏捷开发 vs Scrum&lt;/h2&gt;
&lt;p&gt;敏捷开发是一种 软件开发理念，强调：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发周期短，频繁交付小版本。&lt;/li&gt;
&lt;li&gt;需求可以随时调整，而不是一开始就确定所有需求&lt;/li&gt;
&lt;li&gt;强调团队沟通，减少文档负担&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;敏捷开发的理念来自 《敏捷宣言（Agile Manifesto）》：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;个体和互动 &amp;gt; 过程和工具&lt;/li&gt;
&lt;li&gt;可工作的软件 &amp;gt; 详尽的文档&lt;/li&gt;
&lt;li&gt;客户合作 &amp;gt; 合同谈判&lt;/li&gt;
&lt;li&gt;响应变化 &amp;gt; 遵循计划&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;strong&gt;对比项&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;敏捷开发（Agile）&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;Scrum（Scrum 只是 Agile 的一种）&lt;/strong&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;概念&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;一种理念/开发方法论&lt;/td&gt;
          &lt;td&gt;一种具体的敏捷开发框架&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;灵活性&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;可以灵活选择方法&lt;/td&gt;
          &lt;td&gt;需要遵循固定规则（角色、事件、Sprint）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;开发周期&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;持续迭代&lt;/td&gt;
          &lt;td&gt;Sprint（一般 1-4 周）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;任务管理&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;任何任务管理方式&lt;/td&gt;
          &lt;td&gt;通过 Product Backlog、Sprint Backlog&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;团队结构&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;没有固定角色&lt;/td&gt;
          &lt;td&gt;必须有 Scrum Master、Product Owner、开发团队&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;2-scrum-实际例子-小型web应用开发团队&#34;&gt;2. Scrum 实际例子 小型Web应用开发团队&lt;/h2&gt;
&lt;h3 id=&#34;21-团队组成&#34;&gt;2.1. 团队组成&lt;/h3&gt;
&lt;p&gt;假设有一个小团队正在开发一个在线电商网站，团队成员包括产品负责人(Product Owner/PO)、Scrum Master、开发、测试和设计人员。&lt;/p&gt;
&lt;h3 id=&#34;22-产品-backlog&#34;&gt;2.2. 产品 Backlog&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;产品负责人(PO)&lt;/strong&gt; 根据市场调研、用户反馈和竞争对手分析，将用户需求转化为用户故事，记录在产品 Backlog 中。比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户故事1：作为一个顾客，我希望在网站上能够搜索商品，以便快速找到我需要的产品&lt;/li&gt;
&lt;li&gt;用户故事2：作为一个顾客，我希望能够在购物车中添加和删除商品，以便管理我的购物清单。&lt;/li&gt;
&lt;li&gt;用户故事3：作为一个管理员，我希望能够管理商品库存，以便保证网站商品信息的准确性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些用户故事通常会包括详细的描述、验收标准以及大致的业务价值和优先级。产品 Backlog 不仅包含新功能，还可能包含优化现有功能、技术债务和缺陷修复等工作项。&lt;/p&gt;
&lt;h3 id=&#34;23-sprint-backlog&#34;&gt;2.3. Sprint Backlog&lt;/h3&gt;
&lt;p&gt;当团队准备进入一个两周的 Sprint 时，他们会召开 Sprint 规划会议。会议流程可能如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;选择任务&lt;/strong&gt;：产品负责人和开发团队一起从产品 Backlog 中挑选出优先级最高且在两周内能够完成的用户故事，比如选择了“用户故事1”和“用户故事2”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拆分任务&lt;/strong&gt;：对于“用户故事1”，团队将其拆分为具体任务，例如：
&lt;ul&gt;
&lt;li&gt;任务1：设计搜索框界面&lt;/li&gt;
&lt;li&gt;任务2：实现前端搜索逻辑&lt;/li&gt;
&lt;li&gt;任务3：后端实现搜索接口&lt;/li&gt;
&lt;li&gt;任务4：整合测试并修复可能的缺陷&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;任务分配与估算&lt;/strong&gt;：虽然 Scrum 鼓励团队自组织，任务分配通常是通过讨论达成共识。例如，开发A负责任务2和任务3，开发B负责任务4，而设计师则负责任务1。每个任务还会进行时间或复杂度估算，帮助团队了解工作量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更新 Sprint Backlog&lt;/strong&gt;：这些拆分后的任务就构成了 Sprint Backlog。团队在 Sprint 执行过程中，会在看板或任务管理工具上更新每个任务的状态（例如“待处理”、“进行中”、“已完成”）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;24-持续管理与反馈&#34;&gt;2.4. 持续管理与反馈&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;动态调整&lt;/strong&gt;：在 Sprint 过程中，如果发现某个任务比预期耗时多，团队会讨论如何调整后续任务；如果某个任务提前完成，团队成员可以从产品 Backlog 中获取额外的小任务，保持持续高效的工作状态&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;每日站会&lt;/strong&gt;：每天站会中，团队成员会报告自己当前 Sprint Backlog 中任务的进展、遇到的障碍以及下一步计划，确保大家对整个 Sprint 的进展有清晰认识&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-项目经理-产品经理&#34;&gt;3. 项目经理 产品经理&lt;/h2&gt;
&lt;h3 id=&#34;31-产品经理product-manager-pm&#34;&gt;3.1. 产品经理（Product Manager, PM）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;主要职责&lt;/strong&gt;：研究市场和用户需求&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;负责确定这个健身 App 应该有哪些核心功能（比如步数记录、饮食管理、训练计划等）&lt;/li&gt;
&lt;li&gt;研究市场，分析竞争对手的 App，看看别人都做了什么&lt;/li&gt;
&lt;li&gt;与用户沟通，了解用户需求，比如有些用户可能希望有一个“教练指导”功能，而有些用户想要个性化饮食建议&lt;/li&gt;
&lt;li&gt;向公司高层汇报产品方向，确保产品符合公司业务目标（比如希望通过这个 App 吸引更多用户订阅高级功能）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;PM 的日常工作例子：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;与甲方沟通:&lt;/strong&gt; 讨论他们的需求、期望的功能，以及目标用户是谁&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;与开发团队沟通&lt;/strong&gt;：告诉团队最优先要做的是“智能饮食推荐”，并解释为什么这个功能很重要。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;与设计师合作&lt;/strong&gt;：讨论 App 界面应该怎么设计，才能让用户觉得好用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;向公司老板汇报&lt;/strong&gt;：说明为什么这个 App 有市场机会，争取更多资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-项目经理project-manager-pm&#34;&gt;3.2. 项目经理（Project Manager, PM）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;主要职责&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保产品开发过程顺利进行，确保开发团队按时完成任务&lt;/li&gt;
&lt;li&gt;制定项目计划，比如这个 App 需要 3 个月开发完，前 1 个月做后端架构，接下来 2 个月开发前端功能&lt;/li&gt;
&lt;li&gt;协调团队资源，确保开发人员、测试人员、UI 设计师都能顺利完成工作&lt;/li&gt;
&lt;li&gt;监控项目进度，发现某个功能开发遇到困难时，及时协调解决问题（比如服务器崩了，联系运维团队修复）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;项目经理的日常工作例子&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;制定开发时间表&lt;/strong&gt;：确定 1 月份完成步数记录功能，2 月份完成饮食管理功能，3 月份上线测试。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;处理紧急情况&lt;/strong&gt;：本来计划 3 月 1 号上线，但因为 App 存在严重 Bug，项目经理决定推迟一周发布。&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
  </channel>
</rss>
